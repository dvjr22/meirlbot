{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/diff-sequence.js","filenameRelative":"/bundle/programs/server/packages/diff-sequence.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/diff-sequence.js.map","sourceFileName":"/bundle/programs/server/packages/diff-sequence.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"diff-sequence"},"ignored":false,"code":"(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var _ = Package.underscore._;\n  var EJSON = Package.ejson.EJSON;\n\n  /* Package-scope variables */\n  var DiffSequence;\n\n  (function () {\n\n    /////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                 //\n    // packages/diff-sequence/diff.js                                                  //\n    //                                                                                 //\n    /////////////////////////////////////////////////////////////////////////////////////\n    //\n    DiffSequence = {};\n\n    // ordered: bool.\n    // old_results and new_results: collections of documents.\n    //    if ordered, they are arrays.\n    //    if unordered, they are IdMaps\n    DiffSequence.diffQueryChanges = function (ordered, oldResults, newResults, observer, options) {\n      if (ordered) DiffSequence.diffQueryOrderedChanges(oldResults, newResults, observer, options);else DiffSequence.diffQueryUnorderedChanges(oldResults, newResults, observer, options);\n    };\n\n    DiffSequence.diffQueryUnorderedChanges = function (oldResults, newResults, observer, options) {\n      options = options || {};\n      var projectionFn = options.projectionFn || EJSON.clone;\n\n      if (observer.movedBefore) {\n        throw new Error(\"_diffQueryUnordered called with a movedBefore observer!\");\n      }\n\n      newResults.forEach(function (newDoc, id) {\n        var oldDoc = oldResults.get(id);\n        if (oldDoc) {\n          if (observer.changed && !EJSON.equals(oldDoc, newDoc)) {\n            var projectedNew = projectionFn(newDoc);\n            var projectedOld = projectionFn(oldDoc);\n            var changedFields = DiffSequence.makeChangedFields(projectedNew, projectedOld);\n            if (!_.isEmpty(changedFields)) {\n              observer.changed(id, changedFields);\n            }\n          }\n        } else if (observer.added) {\n          var fields = projectionFn(newDoc);\n          delete fields._id;\n          observer.added(newDoc._id, fields);\n        }\n      });\n\n      if (observer.removed) {\n        oldResults.forEach(function (oldDoc, id) {\n          if (!newResults.has(id)) observer.removed(id);\n        });\n      }\n    };\n\n    DiffSequence.diffQueryOrderedChanges = function (old_results, new_results, observer, options) {\n      options = options || {};\n      var projectionFn = options.projectionFn || EJSON.clone;\n\n      var new_presence_of_id = {};\n      _.each(new_results, function (doc) {\n        if (new_presence_of_id[doc._id]) Meteor._debug(\"Duplicate _id in new_results\");\n        new_presence_of_id[doc._id] = true;\n      });\n\n      var old_index_of_id = {};\n      _.each(old_results, function (doc, i) {\n        if (doc._id in old_index_of_id) Meteor._debug(\"Duplicate _id in old_results\");\n        old_index_of_id[doc._id] = i;\n      });\n\n      // ALGORITHM:\n      //\n      // To determine which docs should be considered \"moved\" (and which\n      // merely change position because of other docs moving) we run\n      // a \"longest common subsequence\" (LCS) algorithm.  The LCS of the\n      // old doc IDs and the new doc IDs gives the docs that should NOT be\n      // considered moved.\n\n      // To actually call the appropriate callbacks to get from the old state to the\n      // new state:\n\n      // First, we call removed() on all the items that only appear in the old\n      // state.\n\n      // Then, once we have the items that should not move, we walk through the new\n      // results array group-by-group, where a \"group\" is a set of items that have\n      // moved, anchored on the end by an item that should not move.  One by one, we\n      // move each of those elements into place \"before\" the anchoring end-of-group\n      // item, and fire changed events on them if necessary.  Then we fire a changed\n      // event on the anchor, and move on to the next group.  There is always at\n      // least one group; the last group is anchored by a virtual \"null\" id at the\n      // end.\n\n      // Asymptotically: O(N k) where k is number of ops, or potentially\n      // O(N log N) if inner loop of LCS were made to be binary search.\n\n      //////// LCS (longest common sequence, with respect to _id)\n      // (see Wikipedia article on Longest Increasing Subsequence,\n      // where the LIS is taken of the sequence of old indices of the\n      // docs in new_results)\n      //\n      // unmoved: the output of the algorithm; members of the LCS,\n      // in the form of indices into new_results\n      var unmoved = [];\n      // max_seq_len: length of LCS found so far\n      var max_seq_len = 0;\n      // seq_ends[i]: the index into new_results of the last doc in a\n      // common subsequence of length of i+1 <= max_seq_len\n      var N = new_results.length;\n      var seq_ends = new Array(N);\n      // ptrs:  the common subsequence ending with new_results[n] extends\n      // a common subsequence ending with new_results[ptr[n]], unless\n      // ptr[n] is -1.\n      var ptrs = new Array(N);\n      // virtual sequence of old indices of new results\n      var old_idx_seq = function old_idx_seq(i_new) {\n        return old_index_of_id[new_results[i_new]._id];\n      };\n      // for each item in new_results, use it to extend a common subsequence\n      // of length j <= max_seq_len\n      for (var i = 0; i < N; i++) {\n        if (old_index_of_id[new_results[i]._id] !== undefined) {\n          var j = max_seq_len;\n          // this inner loop would traditionally be a binary search,\n          // but scanning backwards we will likely find a subseq to extend\n          // pretty soon, bounded for example by the total number of ops.\n          // If this were to be changed to a binary search, we'd still want\n          // to scan backwards a bit as an optimization.\n          while (j > 0) {\n            if (old_idx_seq(seq_ends[j - 1]) < old_idx_seq(i)) break;\n            j--;\n          }\n\n          ptrs[i] = j === 0 ? -1 : seq_ends[j - 1];\n          seq_ends[j] = i;\n          if (j + 1 > max_seq_len) max_seq_len = j + 1;\n        }\n      }\n\n      // pull out the LCS/LIS into unmoved\n      var idx = max_seq_len === 0 ? -1 : seq_ends[max_seq_len - 1];\n      while (idx >= 0) {\n        unmoved.push(idx);\n        idx = ptrs[idx];\n      }\n      // the unmoved item list is built backwards, so fix that\n      unmoved.reverse();\n\n      // the last group is always anchored by the end of the result list, which is\n      // an id of \"null\"\n      unmoved.push(new_results.length);\n\n      _.each(old_results, function (doc) {\n        if (!new_presence_of_id[doc._id]) observer.removed && observer.removed(doc._id);\n      });\n      // for each group of things in the new_results that is anchored by an unmoved\n      // element, iterate through the things before it.\n      var startOfGroup = 0;\n      _.each(unmoved, function (endOfGroup) {\n        var groupId = new_results[endOfGroup] ? new_results[endOfGroup]._id : null;\n        var oldDoc, newDoc, fields, projectedNew, projectedOld;\n        for (var i = startOfGroup; i < endOfGroup; i++) {\n          newDoc = new_results[i];\n          if (!_.has(old_index_of_id, newDoc._id)) {\n            fields = projectionFn(newDoc);\n            delete fields._id;\n            observer.addedBefore && observer.addedBefore(newDoc._id, fields, groupId);\n            observer.added && observer.added(newDoc._id, fields);\n          } else {\n            // moved\n            oldDoc = old_results[old_index_of_id[newDoc._id]];\n            projectedNew = projectionFn(newDoc);\n            projectedOld = projectionFn(oldDoc);\n            fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);\n            if (!_.isEmpty(fields)) {\n              observer.changed && observer.changed(newDoc._id, fields);\n            }\n            observer.movedBefore && observer.movedBefore(newDoc._id, groupId);\n          }\n        }\n        if (groupId) {\n          newDoc = new_results[endOfGroup];\n          oldDoc = old_results[old_index_of_id[newDoc._id]];\n          projectedNew = projectionFn(newDoc);\n          projectedOld = projectionFn(oldDoc);\n          fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);\n          if (!_.isEmpty(fields)) {\n            observer.changed && observer.changed(newDoc._id, fields);\n          }\n        }\n        startOfGroup = endOfGroup + 1;\n      });\n    };\n\n    // General helper for diff-ing two objects.\n    // callbacks is an object like so:\n    // { leftOnly: function (key, leftValue) {...},\n    //   rightOnly: function (key, rightValue) {...},\n    //   both: function (key, leftValue, rightValue) {...},\n    // }\n    DiffSequence.diffObjects = function (left, right, callbacks) {\n      _.each(left, function (leftValue, key) {\n        if (_.has(right, key)) callbacks.both && callbacks.both(key, leftValue, right[key]);else callbacks.leftOnly && callbacks.leftOnly(key, leftValue);\n      });\n      if (callbacks.rightOnly) {\n        _.each(right, function (rightValue, key) {\n          if (!_.has(left, key)) callbacks.rightOnly(key, rightValue);\n        });\n      }\n    };\n\n    DiffSequence.makeChangedFields = function (newDoc, oldDoc) {\n      var fields = {};\n      DiffSequence.diffObjects(oldDoc, newDoc, {\n        leftOnly: function leftOnly(key, value) {\n          fields[key] = undefined;\n        },\n        rightOnly: function rightOnly(key, value) {\n          fields[key] = value;\n        },\n        both: function both(key, leftValue, rightValue) {\n          if (!EJSON.equals(leftValue, rightValue)) fields[key] = rightValue;\n        }\n      });\n      return fields;\n    };\n\n    DiffSequence.applyChanges = function (doc, changeFields) {\n      _.each(changeFields, function (value, key) {\n        if (value === undefined) delete doc[key];else doc[key] = value;\n      });\n    };\n\n    /////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package['diff-sequence'] = {}, {\n    DiffSequence: DiffSequence\n  });\n})();\n\n//# sourceMappingURL=diff-sequence.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/diff-sequence.js"],"names":[],"mappings":"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","file":"/bundle/programs/server/packages/diff-sequence.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar EJSON = Package.ejson.EJSON;\n\n/* Package-scope variables */\nvar DiffSequence;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////\n//                                                                                 //\n// packages/diff-sequence/diff.js                                                  //\n//                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////\n                                                                                   //\nDiffSequence = {};\n\n// ordered: bool.\n// old_results and new_results: collections of documents.\n//    if ordered, they are arrays.\n//    if unordered, they are IdMaps\nDiffSequence.diffQueryChanges = function (ordered, oldResults, newResults,\n                                              observer, options) {\n  if (ordered)\n    DiffSequence.diffQueryOrderedChanges(\n      oldResults, newResults, observer, options);\n  else\n    DiffSequence.diffQueryUnorderedChanges(\n      oldResults, newResults, observer, options);\n};\n\nDiffSequence.diffQueryUnorderedChanges = function (oldResults, newResults,\n                                                       observer, options) {\n  options = options || {};\n  var projectionFn = options.projectionFn || EJSON.clone;\n\n  if (observer.movedBefore) {\n    throw new Error(\"_diffQueryUnordered called with a movedBefore observer!\");\n  }\n\n  newResults.forEach(function (newDoc, id) {\n    var oldDoc = oldResults.get(id);\n    if (oldDoc) {\n      if (observer.changed && !EJSON.equals(oldDoc, newDoc)) {\n        var projectedNew = projectionFn(newDoc);\n        var projectedOld = projectionFn(oldDoc);\n        var changedFields =\n              DiffSequence.makeChangedFields(projectedNew, projectedOld);\n        if (! _.isEmpty(changedFields)) {\n          observer.changed(id, changedFields);\n        }\n      }\n    } else if (observer.added) {\n      var fields = projectionFn(newDoc);\n      delete fields._id;\n      observer.added(newDoc._id, fields);\n    }\n  });\n\n  if (observer.removed) {\n    oldResults.forEach(function (oldDoc, id) {\n      if (!newResults.has(id))\n        observer.removed(id);\n    });\n  }\n};\n\n\nDiffSequence.diffQueryOrderedChanges = function (old_results, new_results,\n                                                     observer, options) {\n  options = options || {};\n  var projectionFn = options.projectionFn || EJSON.clone;\n\n  var new_presence_of_id = {};\n  _.each(new_results, function (doc) {\n    if (new_presence_of_id[doc._id])\n      Meteor._debug(\"Duplicate _id in new_results\");\n    new_presence_of_id[doc._id] = true;\n  });\n\n  var old_index_of_id = {};\n  _.each(old_results, function (doc, i) {\n    if (doc._id in old_index_of_id)\n      Meteor._debug(\"Duplicate _id in old_results\");\n    old_index_of_id[doc._id] = i;\n  });\n\n  // ALGORITHM:\n  //\n  // To determine which docs should be considered \"moved\" (and which\n  // merely change position because of other docs moving) we run\n  // a \"longest common subsequence\" (LCS) algorithm.  The LCS of the\n  // old doc IDs and the new doc IDs gives the docs that should NOT be\n  // considered moved.\n\n  // To actually call the appropriate callbacks to get from the old state to the\n  // new state:\n\n  // First, we call removed() on all the items that only appear in the old\n  // state.\n\n  // Then, once we have the items that should not move, we walk through the new\n  // results array group-by-group, where a \"group\" is a set of items that have\n  // moved, anchored on the end by an item that should not move.  One by one, we\n  // move each of those elements into place \"before\" the anchoring end-of-group\n  // item, and fire changed events on them if necessary.  Then we fire a changed\n  // event on the anchor, and move on to the next group.  There is always at\n  // least one group; the last group is anchored by a virtual \"null\" id at the\n  // end.\n\n  // Asymptotically: O(N k) where k is number of ops, or potentially\n  // O(N log N) if inner loop of LCS were made to be binary search.\n\n\n  //////// LCS (longest common sequence, with respect to _id)\n  // (see Wikipedia article on Longest Increasing Subsequence,\n  // where the LIS is taken of the sequence of old indices of the\n  // docs in new_results)\n  //\n  // unmoved: the output of the algorithm; members of the LCS,\n  // in the form of indices into new_results\n  var unmoved = [];\n  // max_seq_len: length of LCS found so far\n  var max_seq_len = 0;\n  // seq_ends[i]: the index into new_results of the last doc in a\n  // common subsequence of length of i+1 <= max_seq_len\n  var N = new_results.length;\n  var seq_ends = new Array(N);\n  // ptrs:  the common subsequence ending with new_results[n] extends\n  // a common subsequence ending with new_results[ptr[n]], unless\n  // ptr[n] is -1.\n  var ptrs = new Array(N);\n  // virtual sequence of old indices of new results\n  var old_idx_seq = function(i_new) {\n    return old_index_of_id[new_results[i_new]._id];\n  };\n  // for each item in new_results, use it to extend a common subsequence\n  // of length j <= max_seq_len\n  for(var i=0; i<N; i++) {\n    if (old_index_of_id[new_results[i]._id] !== undefined) {\n      var j = max_seq_len;\n      // this inner loop would traditionally be a binary search,\n      // but scanning backwards we will likely find a subseq to extend\n      // pretty soon, bounded for example by the total number of ops.\n      // If this were to be changed to a binary search, we'd still want\n      // to scan backwards a bit as an optimization.\n      while (j > 0) {\n        if (old_idx_seq(seq_ends[j-1]) < old_idx_seq(i))\n          break;\n        j--;\n      }\n\n      ptrs[i] = (j === 0 ? -1 : seq_ends[j-1]);\n      seq_ends[j] = i;\n      if (j+1 > max_seq_len)\n        max_seq_len = j+1;\n    }\n  }\n\n  // pull out the LCS/LIS into unmoved\n  var idx = (max_seq_len === 0 ? -1 : seq_ends[max_seq_len-1]);\n  while (idx >= 0) {\n    unmoved.push(idx);\n    idx = ptrs[idx];\n  }\n  // the unmoved item list is built backwards, so fix that\n  unmoved.reverse();\n\n  // the last group is always anchored by the end of the result list, which is\n  // an id of \"null\"\n  unmoved.push(new_results.length);\n\n  _.each(old_results, function (doc) {\n    if (!new_presence_of_id[doc._id])\n      observer.removed && observer.removed(doc._id);\n  });\n  // for each group of things in the new_results that is anchored by an unmoved\n  // element, iterate through the things before it.\n  var startOfGroup = 0;\n  _.each(unmoved, function (endOfGroup) {\n    var groupId = new_results[endOfGroup] ? new_results[endOfGroup]._id : null;\n    var oldDoc, newDoc, fields, projectedNew, projectedOld;\n    for (var i = startOfGroup; i < endOfGroup; i++) {\n      newDoc = new_results[i];\n      if (!_.has(old_index_of_id, newDoc._id)) {\n        fields = projectionFn(newDoc);\n        delete fields._id;\n        observer.addedBefore && observer.addedBefore(newDoc._id, fields, groupId);\n        observer.added && observer.added(newDoc._id, fields);\n      } else {\n        // moved\n        oldDoc = old_results[old_index_of_id[newDoc._id]];\n        projectedNew = projectionFn(newDoc);\n        projectedOld = projectionFn(oldDoc);\n        fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);\n        if (!_.isEmpty(fields)) {\n          observer.changed && observer.changed(newDoc._id, fields);\n        }\n        observer.movedBefore && observer.movedBefore(newDoc._id, groupId);\n      }\n    }\n    if (groupId) {\n      newDoc = new_results[endOfGroup];\n      oldDoc = old_results[old_index_of_id[newDoc._id]];\n      projectedNew = projectionFn(newDoc);\n      projectedOld = projectionFn(oldDoc);\n      fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);\n      if (!_.isEmpty(fields)) {\n        observer.changed && observer.changed(newDoc._id, fields);\n      }\n    }\n    startOfGroup = endOfGroup+1;\n  });\n\n\n};\n\n\n// General helper for diff-ing two objects.\n// callbacks is an object like so:\n// { leftOnly: function (key, leftValue) {...},\n//   rightOnly: function (key, rightValue) {...},\n//   both: function (key, leftValue, rightValue) {...},\n// }\nDiffSequence.diffObjects = function (left, right, callbacks) {\n  _.each(left, function (leftValue, key) {\n    if (_.has(right, key))\n      callbacks.both && callbacks.both(key, leftValue, right[key]);\n    else\n      callbacks.leftOnly && callbacks.leftOnly(key, leftValue);\n  });\n  if (callbacks.rightOnly) {\n    _.each(right, function(rightValue, key) {\n      if (!_.has(left, key))\n        callbacks.rightOnly(key, rightValue);\n    });\n  }\n};\n\n\nDiffSequence.makeChangedFields = function (newDoc, oldDoc) {\n  var fields = {};\n  DiffSequence.diffObjects(oldDoc, newDoc, {\n    leftOnly: function (key, value) {\n      fields[key] = undefined;\n    },\n    rightOnly: function (key, value) {\n      fields[key] = value;\n    },\n    both: function (key, leftValue, rightValue) {\n      if (!EJSON.equals(leftValue, rightValue))\n        fields[key] = rightValue;\n    }\n  });\n  return fields;\n};\n\nDiffSequence.applyChanges = function (doc, changeFields) {\n  _.each(changeFields, function (value, key) {\n    if (value === undefined)\n      delete doc[key];\n    else\n      doc[key] = value;\n  });\n};\n\n\n/////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['diff-sequence'] = {}, {\n  DiffSequence: DiffSequence\n});\n\n})();\n\n//# sourceMappingURL=diff-sequence.js.map\n"]},"hash":"b61ebe479cf940a4e48644695084049e23a0638f"}

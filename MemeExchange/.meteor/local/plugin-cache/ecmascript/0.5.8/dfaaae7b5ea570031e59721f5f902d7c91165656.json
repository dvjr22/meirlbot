{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/npm-rebuild.js","filenameRelative":"/bundle/programs/server/npm-rebuild.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/npm-rebuild.js.map","sourceFileName":"/bundle/programs/server/npm-rebuild.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"npm-rebuild"},"ignored":false,"code":"// If a developer wants to go to the trouble of building on exactly the\n// same architecture as the production machine, then it should be possible\n// to skip running `npm rebuild`.\nif (process.env.METEOR_SKIP_NPM_REBUILD) {\n  process.exit(0);\n}\n\nvar path = require(\"path\");\nvar spawn = require(\"child_process\").spawn;\nvar rebuildArgs = require(\"./npm-rebuild-args.js\").get();\n\ntry {\n  // This JSON file gets written in meteor/tools/isobuild/bundler.js.\n  var rebuilds = require(\"./npm-rebuilds.json\");\n} catch (e) {\n  if (e.code !== \"MODULE_NOT_FOUND\") {\n    throw e;\n  }\n\n  // If npm-rebuilds.json was not written, assume there is nothing that\n  // needs to be rebuilt.\n  process.exit(0);\n}\n\n// Make sure the npm finds this exact version of node in its $PATH.\nvar PATH = path.dirname(process.execPath) + \":\" + process.env.PATH;\nvar env = Object.create(process.env, {\n  PATH: { value: PATH }\n});\n\nfunction rebuild(i) {\n  var dir = rebuilds && rebuilds[i];\n\n  if (!dir) {\n    // Print Node/V8/etc. versions for diagnostic purposes.\n    spawn(\"npm\", [\"version\", \"--json\"], {\n      stdio: \"inherit\",\n      env: env\n    });\n\n    return;\n  }\n\n  spawn(\"npm\", rebuildArgs, {\n    cwd: path.join(__dirname, dir),\n    stdio: \"inherit\",\n    env: env\n  }).on(\"exit\", function (code) {\n    if (code !== 0) {\n      process.exit(code);\n    } else {\n      rebuild(i + 1);\n    }\n  });\n}\n\nrebuild(0);","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/npm-rebuild.js"],"names":[],"mappings":";;;AAGA,IAAI,QAAQ,GAAR,CAAY,uBAAhB,EAAyC;AACvC,UAAQ,IAAR,CAAa,CAAb;AACD;;AAED,IAAI,OAAO,QAAQ,MAAR,CAAX;AACA,IAAI,QAAQ,QAAQ,eAAR,EAAyB,KAArC;AACA,IAAI,cAAc,QAAQ,uBAAR,EAAiC,GAAjC,EAAlB;;AAEA,IAAI;;AAEF,MAAI,WAAW,QAAQ,qBAAR,CAAf;AACD,CAHD,CAGE,OAAO,CAAP,EAAU;AACV,MAAI,EAAE,IAAF,KAAW,kBAAf,EAAmC;AACjC,UAAM,CAAN;AACD;;;;AAID,UAAQ,IAAR,CAAa,CAAb;AACD;;;AAGD,IAAI,OAAO,KAAK,OAAL,CAAa,QAAQ,QAArB,IAAiC,GAAjC,GAAuC,QAAQ,GAAR,CAAY,IAA9D;AACA,IAAI,MAAM,OAAO,MAAP,CAAc,QAAQ,GAAtB,EAA2B;AACnC,QAAM,EAAE,OAAO,IAAT;AAD6B,CAA3B,CAAV;;AAIA,SAAS,OAAT,CAAiB,CAAjB,EAAoB;AAClB,MAAI,MAAM,YAAY,SAAS,CAAT,CAAtB;;AAEA,MAAI,CAAE,GAAN,EAAW;;AAET,UAAM,KAAN,EAAa,CAAC,SAAD,EAAY,QAAZ,CAAb,EAAoC;AAClC,aAAO,SAD2B;AAElC,WAAK;AAF6B,KAApC;;AAKA;AACD;;AAED,QAAM,KAAN,EAAa,WAAb,EAA0B;AACxB,SAAK,KAAK,IAAL,CAAU,SAAV,EAAqB,GAArB,CADmB;AAExB,WAAO,SAFiB;AAGxB,SAAK;AAHmB,GAA1B,EAIG,EAJH,CAIM,MAJN,EAIc,UAAU,IAAV,EAAgB;AAC5B,QAAI,SAAS,CAAb,EAAgB;AACd,cAAQ,IAAR,CAAa,IAAb;AACD,KAFD,MAEO;AACL,cAAQ,IAAI,CAAZ;AACD;AACF,GAVD;AAWD;;AAED,QAAQ,CAAR","file":"/bundle/programs/server/npm-rebuild.js.map","sourcesContent":["// If a developer wants to go to the trouble of building on exactly the\n// same architecture as the production machine, then it should be possible\n// to skip running `npm rebuild`.\nif (process.env.METEOR_SKIP_NPM_REBUILD) {\n  process.exit(0);\n}\n\nvar path = require(\"path\");\nvar spawn = require(\"child_process\").spawn;\nvar rebuildArgs = require(\"./npm-rebuild-args.js\").get();\n\ntry {\n  // This JSON file gets written in meteor/tools/isobuild/bundler.js.\n  var rebuilds = require(\"./npm-rebuilds.json\");\n} catch (e) {\n  if (e.code !== \"MODULE_NOT_FOUND\") {\n    throw e;\n  }\n\n  // If npm-rebuilds.json was not written, assume there is nothing that\n  // needs to be rebuilt.\n  process.exit(0);\n}\n\n// Make sure the npm finds this exact version of node in its $PATH.\nvar PATH = path.dirname(process.execPath) + \":\" + process.env.PATH;\nvar env = Object.create(process.env, {\n  PATH: { value: PATH }\n});\n\nfunction rebuild(i) {\n  var dir = rebuilds && rebuilds[i];\n\n  if (! dir) {\n    // Print Node/V8/etc. versions for diagnostic purposes.\n    spawn(\"npm\", [\"version\", \"--json\"], {\n      stdio: \"inherit\",\n      env: env\n    });\n\n    return;\n  }\n\n  spawn(\"npm\", rebuildArgs, {\n    cwd: path.join(__dirname, dir),\n    stdio: \"inherit\",\n    env: env\n  }).on(\"exit\", function (code) {\n    if (code !== 0) {\n      process.exit(code);\n    } else {\n      rebuild(i + 1);\n    }\n  });\n}\n\nrebuild(0);\n"]},"hash":"dfaaae7b5ea570031e59721f5f902d7c91165656"}

{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/ordered-dict.js","filenameRelative":"/bundle/programs/server/packages/ordered-dict.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/ordered-dict.js.map","sourceFileName":"/bundle/programs/server/packages/ordered-dict.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"ordered-dict"},"ignored":false,"code":"(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var _ = Package.underscore._;\n\n  /* Package-scope variables */\n  var OrderedDict;\n\n  (function () {\n\n    ///////////////////////////////////////////////////////////////////////////////////\n    //                                                                               //\n    // packages/ordered-dict/ordered_dict.js                                         //\n    //                                                                               //\n    ///////////////////////////////////////////////////////////////////////////////////\n    //\n    // This file defines an ordered dictionary abstraction that is useful for\n    // maintaining a dataset backed by observeChanges.  It supports ordering items\n    // by specifying the item they now come before.\n\n    // The implementation is a dictionary that contains nodes of a doubly-linked\n    // list as its values.\n\n    // constructs a new element struct\n    // next and prev are whole elements, not keys.\n    var element = function element(key, value, next, prev) {\n      return {\n        key: key,\n        value: value,\n        next: next,\n        prev: prev\n      };\n    };\n    OrderedDict = function OrderedDict() /* ... */{\n      var self = this;\n      self._dict = {};\n      self._first = null;\n      self._last = null;\n      self._size = 0;\n      var args = _.toArray(arguments);\n      self._stringify = function (x) {\n        return x;\n      };\n      if (typeof args[0] === 'function') self._stringify = args.shift();\n      _.each(args, function (kv) {\n        self.putBefore(kv[0], kv[1], null);\n      });\n    };\n\n    _.extend(OrderedDict.prototype, {\n      // the \"prefix keys with a space\" thing comes from here\n      // https://github.com/documentcloud/underscore/issues/376#issuecomment-2815649\n      _k: function _k(key) {\n        return \" \" + this._stringify(key);\n      },\n\n      empty: function empty() {\n        var self = this;\n        return !self._first;\n      },\n      size: function size() {\n        var self = this;\n        return self._size;\n      },\n      _linkEltIn: function _linkEltIn(elt) {\n        var self = this;\n        if (!elt.next) {\n          elt.prev = self._last;\n          if (self._last) self._last.next = elt;\n          self._last = elt;\n        } else {\n          elt.prev = elt.next.prev;\n          elt.next.prev = elt;\n          if (elt.prev) elt.prev.next = elt;\n        }\n        if (self._first === null || self._first === elt.next) self._first = elt;\n      },\n      _linkEltOut: function _linkEltOut(elt) {\n        var self = this;\n        if (elt.next) elt.next.prev = elt.prev;\n        if (elt.prev) elt.prev.next = elt.next;\n        if (elt === self._last) self._last = elt.prev;\n        if (elt === self._first) self._first = elt.next;\n      },\n      putBefore: function putBefore(key, item, before) {\n        var self = this;\n        if (self._dict[self._k(key)]) throw new Error(\"Item \" + key + \" already present in OrderedDict\");\n        var elt = before ? element(key, item, self._dict[self._k(before)]) : element(key, item, null);\n        if (elt.next === undefined) throw new Error(\"could not find item to put this one before\");\n        self._linkEltIn(elt);\n        self._dict[self._k(key)] = elt;\n        self._size++;\n      },\n      append: function append(key, item) {\n        var self = this;\n        self.putBefore(key, item, null);\n      },\n      remove: function remove(key) {\n        var self = this;\n        var elt = self._dict[self._k(key)];\n        if (elt === undefined) throw new Error(\"Item \" + key + \" not present in OrderedDict\");\n        self._linkEltOut(elt);\n        self._size--;\n        delete self._dict[self._k(key)];\n        return elt.value;\n      },\n      get: function get(key) {\n        var self = this;\n        if (self.has(key)) return self._dict[self._k(key)].value;\n        return undefined;\n      },\n      has: function has(key) {\n        var self = this;\n        return _.has(self._dict, self._k(key));\n      },\n      // Iterate through the items in this dictionary in order, calling\n      // iter(value, key, index) on each one.\n\n      // Stops whenever iter returns OrderedDict.BREAK, or after the last element.\n      forEach: function forEach(iter) {\n        var self = this;\n        var i = 0;\n        var elt = self._first;\n        while (elt !== null) {\n          var b = iter(elt.value, elt.key, i);\n          if (b === OrderedDict.BREAK) return;\n          elt = elt.next;\n          i++;\n        }\n      },\n      first: function first() {\n        var self = this;\n        if (self.empty()) return undefined;\n        return self._first.key;\n      },\n      firstValue: function firstValue() {\n        var self = this;\n        if (self.empty()) return undefined;\n        return self._first.value;\n      },\n      last: function last() {\n        var self = this;\n        if (self.empty()) return undefined;\n        return self._last.key;\n      },\n      lastValue: function lastValue() {\n        var self = this;\n        if (self.empty()) return undefined;\n        return self._last.value;\n      },\n      prev: function prev(key) {\n        var self = this;\n        if (self.has(key)) {\n          var elt = self._dict[self._k(key)];\n          if (elt.prev) return elt.prev.key;\n        }\n        return null;\n      },\n      next: function next(key) {\n        var self = this;\n        if (self.has(key)) {\n          var elt = self._dict[self._k(key)];\n          if (elt.next) return elt.next.key;\n        }\n        return null;\n      },\n      moveBefore: function moveBefore(key, before) {\n        var self = this;\n        var elt = self._dict[self._k(key)];\n        var eltBefore = before ? self._dict[self._k(before)] : null;\n        if (elt === undefined) throw new Error(\"Item to move is not present\");\n        if (eltBefore === undefined) {\n          throw new Error(\"Could not find element to move this one before\");\n        }\n        if (eltBefore === elt.next) // no moving necessary\n          return;\n        // remove from its old place\n        self._linkEltOut(elt);\n        // patch into its new place\n        elt.next = eltBefore;\n        self._linkEltIn(elt);\n      },\n      // Linear, sadly.\n      indexOf: function indexOf(key) {\n        var self = this;\n        var ret = null;\n        self.forEach(function (v, k, i) {\n          if (self._k(k) === self._k(key)) {\n            ret = i;\n            return OrderedDict.BREAK;\n          }\n          return undefined;\n        });\n        return ret;\n      },\n      _checkRep: function _checkRep() {\n        var self = this;\n        _.each(self._dict, function (k, v) {\n          if (v.next === v) throw new Error(\"Next is a loop\");\n          if (v.prev === v) throw new Error(\"Prev is a loop\");\n        });\n      }\n\n    });\n    OrderedDict.BREAK = { \"break\": true };\n\n    ///////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package['ordered-dict'] = {}, {\n    OrderedDict: OrderedDict\n  });\n})();\n\n//# sourceMappingURL=ordered-dict.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/ordered-dict.js"],"names":[],"mappings":"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","file":"/bundle/programs/server/packages/ordered-dict.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\n\n/* Package-scope variables */\nvar OrderedDict;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////\n//                                                                               //\n// packages/ordered-dict/ordered_dict.js                                         //\n//                                                                               //\n///////////////////////////////////////////////////////////////////////////////////\n                                                                                 //\n// This file defines an ordered dictionary abstraction that is useful for\n// maintaining a dataset backed by observeChanges.  It supports ordering items\n// by specifying the item they now come before.\n\n// The implementation is a dictionary that contains nodes of a doubly-linked\n// list as its values.\n\n// constructs a new element struct\n// next and prev are whole elements, not keys.\nvar element = function (key, value, next, prev) {\n  return {\n    key: key,\n    value: value,\n    next: next,\n    prev: prev\n  };\n};\nOrderedDict = function (/* ... */) {\n  var self = this;\n  self._dict = {};\n  self._first = null;\n  self._last = null;\n  self._size = 0;\n  var args = _.toArray(arguments);\n  self._stringify = function (x) { return x; };\n  if (typeof args[0] === 'function')\n    self._stringify = args.shift();\n  _.each(args, function (kv) {\n    self.putBefore(kv[0], kv[1], null);\n  });\n};\n\n_.extend(OrderedDict.prototype, {\n  // the \"prefix keys with a space\" thing comes from here\n  // https://github.com/documentcloud/underscore/issues/376#issuecomment-2815649\n  _k: function (key) { return \" \" + this._stringify(key); },\n\n  empty: function () {\n    var self = this;\n    return !self._first;\n  },\n  size: function () {\n    var self = this;\n    return self._size;\n  },\n  _linkEltIn: function (elt) {\n    var self = this;\n    if (!elt.next) {\n      elt.prev = self._last;\n      if (self._last)\n        self._last.next = elt;\n      self._last = elt;\n    } else {\n      elt.prev = elt.next.prev;\n      elt.next.prev = elt;\n      if (elt.prev)\n        elt.prev.next = elt;\n    }\n    if (self._first === null || self._first === elt.next)\n      self._first = elt;\n  },\n  _linkEltOut: function (elt) {\n    var self = this;\n    if (elt.next)\n      elt.next.prev = elt.prev;\n    if (elt.prev)\n      elt.prev.next = elt.next;\n    if (elt === self._last)\n      self._last = elt.prev;\n    if (elt === self._first)\n      self._first = elt.next;\n  },\n  putBefore: function (key, item, before) {\n    var self = this;\n    if (self._dict[self._k(key)])\n      throw new Error(\"Item \" + key + \" already present in OrderedDict\");\n    var elt = before ?\n          element(key, item, self._dict[self._k(before)]) :\n          element(key, item, null);\n    if (elt.next === undefined)\n      throw new Error(\"could not find item to put this one before\");\n    self._linkEltIn(elt);\n    self._dict[self._k(key)] = elt;\n    self._size++;\n  },\n  append: function (key, item) {\n    var self = this;\n    self.putBefore(key, item, null);\n  },\n  remove: function (key) {\n    var self = this;\n    var elt = self._dict[self._k(key)];\n    if (elt === undefined)\n      throw new Error(\"Item \" + key + \" not present in OrderedDict\");\n    self._linkEltOut(elt);\n    self._size--;\n    delete self._dict[self._k(key)];\n    return elt.value;\n  },\n  get: function (key) {\n    var self = this;\n    if (self.has(key))\n        return self._dict[self._k(key)].value;\n    return undefined;\n  },\n  has: function (key) {\n    var self = this;\n    return _.has(self._dict, self._k(key));\n  },\n  // Iterate through the items in this dictionary in order, calling\n  // iter(value, key, index) on each one.\n\n  // Stops whenever iter returns OrderedDict.BREAK, or after the last element.\n  forEach: function (iter) {\n    var self = this;\n    var i = 0;\n    var elt = self._first;\n    while (elt !== null) {\n      var b = iter(elt.value, elt.key, i);\n      if (b === OrderedDict.BREAK)\n        return;\n      elt = elt.next;\n      i++;\n    }\n  },\n  first: function () {\n    var self = this;\n    if (self.empty())\n      return undefined;\n    return self._first.key;\n  },\n  firstValue: function () {\n    var self = this;\n    if (self.empty())\n      return undefined;\n    return self._first.value;\n  },\n  last: function () {\n    var self = this;\n    if (self.empty())\n      return undefined;\n    return self._last.key;\n  },\n  lastValue: function () {\n    var self = this;\n    if (self.empty())\n      return undefined;\n    return self._last.value;\n  },\n  prev: function (key) {\n    var self = this;\n    if (self.has(key)) {\n      var elt = self._dict[self._k(key)];\n      if (elt.prev)\n        return elt.prev.key;\n    }\n    return null;\n  },\n  next: function (key) {\n    var self = this;\n    if (self.has(key)) {\n      var elt = self._dict[self._k(key)];\n      if (elt.next)\n        return elt.next.key;\n    }\n    return null;\n  },\n  moveBefore: function (key, before) {\n    var self = this;\n    var elt = self._dict[self._k(key)];\n    var eltBefore = before ? self._dict[self._k(before)] : null;\n    if (elt === undefined)\n      throw new Error(\"Item to move is not present\");\n    if (eltBefore === undefined) {\n      throw new Error(\"Could not find element to move this one before\");\n    }\n    if (eltBefore === elt.next) // no moving necessary\n      return;\n    // remove from its old place\n    self._linkEltOut(elt);\n    // patch into its new place\n    elt.next = eltBefore;\n    self._linkEltIn(elt);\n  },\n  // Linear, sadly.\n  indexOf: function (key) {\n    var self = this;\n    var ret = null;\n    self.forEach(function (v, k, i) {\n      if (self._k(k) === self._k(key)) {\n        ret = i;\n        return OrderedDict.BREAK;\n      }\n      return undefined;\n    });\n    return ret;\n  },\n  _checkRep: function () {\n    var self = this;\n    _.each(self._dict, function (k, v) {\n      if (v.next === v)\n        throw new Error(\"Next is a loop\");\n      if (v.prev === v)\n        throw new Error(\"Prev is a loop\");\n    });\n  }\n\n});\nOrderedDict.BREAK = {\"break\": true};\n\n///////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['ordered-dict'] = {}, {\n  OrderedDict: OrderedDict\n});\n\n})();\n\n//# sourceMappingURL=ordered-dict.js.map\n"]},"hash":"924dc7aba0c2a887a257197bf3829fc52df21f50"}

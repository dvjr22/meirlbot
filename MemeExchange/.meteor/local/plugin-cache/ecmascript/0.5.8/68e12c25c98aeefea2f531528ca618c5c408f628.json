{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/mongo.js","filenameRelative":"/bundle/programs/server/packages/mongo.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/mongo.js.map","sourceFileName":"/bundle/programs/server/packages/mongo.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"mongo"},"ignored":false,"code":"(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var NpmModuleMongodb = Package['npm-mongo'].NpmModuleMongodb;\n  var NpmModuleMongodbVersion = Package['npm-mongo'].NpmModuleMongodbVersion;\n  var AllowDeny = Package['allow-deny'].AllowDeny;\n  var Random = Package.random.Random;\n  var EJSON = Package.ejson.EJSON;\n  var _ = Package.underscore._;\n  var LocalCollection = Package.minimongo.LocalCollection;\n  var Minimongo = Package.minimongo.Minimongo;\n  var DDP = Package['ddp-client'].DDP;\n  var DDPServer = Package['ddp-server'].DDPServer;\n  var Tracker = Package.tracker.Tracker;\n  var Deps = Package.tracker.Deps;\n  var DiffSequence = Package['diff-sequence'].DiffSequence;\n  var MongoID = Package['mongo-id'].MongoID;\n  var check = Package.check.check;\n  var Match = Package.check.Match;\n  var ECMAScript = Package.ecmascript.ECMAScript;\n  var MaxHeap = Package['binary-heap'].MaxHeap;\n  var MinHeap = Package['binary-heap'].MinHeap;\n  var MinMaxHeap = Package['binary-heap'].MinMaxHeap;\n  var Hook = Package['callback-hook'].Hook;\n  var meteorInstall = Package.modules.meteorInstall;\n  var Buffer = Package.modules.Buffer;\n  var process = Package.modules.process;\n  var _Symbol = Package['ecmascript-runtime'].Symbol;\n  var Map = Package['ecmascript-runtime'].Map;\n  var Set = Package['ecmascript-runtime'].Set;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n\n  /* Package-scope variables */\n  var MongoInternals, MongoTest, MongoConnection, mongoResult, CursorDescription, Cursor, listenAll, forEachTrigger, OPLOG_COLLECTION, idForOp, OplogHandle, ObserveMultiplexer, ObserveHandle, DocFetcher, PollingObserveDriver, OplogObserveDriver, LocalCollectionDriver, Mongo;\n\n  var require = meteorInstall({ \"node_modules\": { \"meteor\": { \"mongo\": { \"mongo_driver.js\": [\"babel-runtime/helpers/typeof\", function (require, exports, module) {\n\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/mongo/mongo_driver.js                                                                                     //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            var _typeof;module['import']('babel-runtime/helpers/typeof', { \"default\": function _default(v) {\n                _typeof = v;\n              } }); //\n            /**                                                                                                                   //\n             * Provide a synchronous Collection API using fibers, backed by                                                       //\n             * MongoDB.  This is only for use on the server, and mostly identical                                                 //\n             * to the client API.                                                                                                 //\n             *                                                                                                                    //\n             * NOTE: the public API methods must be run within a fiber. If you call                                               //\n             * these outside of a fiber they will explode!                                                                        //\n             */ //\n            //\n            var path = Npm.require('path'); // 10\n            var MongoDB = NpmModuleMongodb; // 11\n            var Fiber = Npm.require('fibers'); // 12\n            var Future = Npm.require(path.join('fibers', 'future')); // 13\n            //\n            MongoInternals = {}; // 15\n            MongoTest = {}; // 16\n            //\n            MongoInternals.NpmModules = { // 18\n              mongodb: { // 19\n                version: NpmModuleMongodbVersion, // 20\n                module: MongoDB // 21\n              } // 19\n            }; // 18\n            //\n            // Older version of what is now available via                                                                         //\n            // MongoInternals.NpmModules.mongodb.module.  It was never documented, but                                            //\n            // people do use it.                                                                                                  //\n            // XXX COMPAT WITH 1.0.3.2                                                                                            //\n            MongoInternals.NpmModule = MongoDB; // 29\n            //\n            // This is used to add or remove EJSON from the beginning of everything nested                                        //\n            // inside an EJSON custom type. It should only be called on pure JSON!                                                //\n            var replaceNames = function replaceNames(filter, thing) {\n              // 33\n              if ((typeof thing === 'undefined' ? 'undefined' : _typeof(thing)) === \"object\") {\n                // 34\n                if (_.isArray(thing)) {\n                  // 35\n                  return _.map(thing, _.bind(replaceNames, null, filter)); // 36\n                } // 37\n                var ret = {}; // 38\n                _.each(thing, function (value, key) {\n                  // 39\n                  ret[filter(key)] = replaceNames(filter, value); // 40\n                }); // 41\n                return ret; // 42\n              } // 43\n              return thing; // 44\n            }; // 45\n            //\n            // Ensure that EJSON.clone keeps a Timestamp as a Timestamp (instead of just                                          //\n            // doing a structural clone).                                                                                         //\n            // XXX how ok is this? what if there are multiple copies of MongoDB loaded?                                           //\n            MongoDB.Timestamp.prototype.clone = function () {\n              // 50\n              // Timestamps should be immutable.                                                                                  //\n              return this; // 52\n            }; // 53\n            //\n            var makeMongoLegal = function makeMongoLegal(name) {\n              // 55\n              return \"EJSON\" + name; // 55\n            }; // 55\n            var unmakeMongoLegal = function unmakeMongoLegal(name) {\n              // 56\n              return name.substr(5); // 56\n            }; // 56\n            //\n            var replaceMongoAtomWithMeteor = function replaceMongoAtomWithMeteor(document) {\n              // 58\n              if (document instanceof MongoDB.Binary) {\n                // 59\n                var buffer = document.value(true); // 60\n                return new Uint8Array(buffer); // 61\n              } // 62\n              if (document instanceof MongoDB.ObjectID) {\n                // 63\n                return new Mongo.ObjectID(document.toHexString()); // 64\n              } // 65\n              if (document[\"EJSON$type\"] && document[\"EJSON$value\"] && _.size(document) === 2) {\n                // 66\n                return EJSON.fromJSONValue(replaceNames(unmakeMongoLegal, document)); // 68\n              } // 69\n              if (document instanceof MongoDB.Timestamp) {\n                // 70\n                // For now, the Meteor representation of a Mongo timestamp type (not a date!                                      //\n                // this is a weird internal thing used in the oplog!) is the same as the                                          //\n                // Mongo representation. We need to do this explicitly or else we would do a                                      //\n                // structural clone and lose the prototype.                                                                       //\n                return document; // 75\n              } // 76\n              return undefined; // 77\n            }; // 78\n            //\n            var replaceMeteorAtomWithMongo = function replaceMeteorAtomWithMongo(document) {\n              // 80\n              if (EJSON.isBinary(document)) {\n                // 81\n                // This does more copies than we'd like, but is necessary because                                                 //\n                // MongoDB.BSON only looks like it takes a Uint8Array (and doesn't actually                                       //\n                // serialize it correctly).                                                                                       //\n                return new MongoDB.Binary(new Buffer(document)); // 85\n              } // 86\n              if (document instanceof Mongo.ObjectID) {\n                // 87\n                return new MongoDB.ObjectID(document.toHexString()); // 88\n              } // 89\n              if (document instanceof MongoDB.Timestamp) {\n                // 90\n                // For now, the Meteor representation of a Mongo timestamp type (not a date!                                      //\n                // this is a weird internal thing used in the oplog!) is the same as the                                          //\n                // Mongo representation. We need to do this explicitly or else we would do a                                      //\n                // structural clone and lose the prototype.                                                                       //\n                return document; // 95\n              } // 96\n              if (EJSON._isCustomType(document)) {\n                // 97\n                return replaceNames(makeMongoLegal, EJSON.toJSONValue(document)); // 98\n              } // 99\n              // It is not ordinarily possible to stick dollar-sign keys into mongo                                               //\n              // so we don't bother checking for things that need escaping at this time.                                          //\n              return undefined; // 102\n            }; // 103\n            //\n            var replaceTypes = function replaceTypes(document, atomTransformer) {\n              // 105\n              if ((typeof document === 'undefined' ? 'undefined' : _typeof(document)) !== 'object' || document === null) return document;\n              //\n              var replacedTopLevelAtom = atomTransformer(document); // 109\n              if (replacedTopLevelAtom !== undefined) return replacedTopLevelAtom; // 110\n              //\n              var ret = document; // 113\n              _.each(document, function (val, key) {\n                // 114\n                var valReplaced = replaceTypes(val, atomTransformer); // 115\n                if (val !== valReplaced) {\n                  // 116\n                  // Lazy clone. Shallow copy.                                                                                    //\n                  if (ret === document) ret = _.clone(document); // 118\n                  ret[key] = valReplaced; // 120\n                } // 121\n              }); // 122\n              return ret; // 123\n            }; // 124\n            //\n            MongoConnection = function MongoConnection(url, options) {\n              // 127\n              var self = this; // 128\n              options = options || {}; // 129\n              self._observeMultiplexers = {}; // 130\n              self._onFailoverHook = new Hook(); // 131\n              //\n              var mongoOptions = _.extend({ db: { safe: true }, server: {}, replSet: {} }, Mongo._connectionOptions); // 133\n              //\n              // Set autoReconnect to true, unless passed on the URL. Why someone                                                 //\n              // would want to set autoReconnect to false, I'm not really sure, but                                               //\n              // keeping this for backwards compatibility for now.                                                                //\n              if (!/[\\?&]auto_?[rR]econnect=/.test(url)) {\n                // 139\n                mongoOptions.server.auto_reconnect = true; // 140\n              } // 141\n              //\n              // Disable the native parser by default, unless specifically enabled                                                //\n              // in the mongo URL.                                                                                                //\n              // - The native driver can cause errors which normally would be                                                     //\n              //   thrown, caught, and handled into segfaults that take down the                                                  //\n              //   whole app.                                                                                                     //\n              // - Binary modules don't yet work when you bundle and move the bundle                                              //\n              //   to a different platform (aka deploy)                                                                           //\n              // We should revisit this after binary npm module support lands.                                                    //\n              if (!/[\\?&]native_?[pP]arser=/.test(url)) {\n                // 151\n                mongoOptions.db.native_parser = false; // 152\n              } // 153\n              //\n              // Internally the oplog connections specify their own poolSize                                                      //\n              // which we don't want to overwrite with any user defined value                                                     //\n              if (_.has(options, 'poolSize')) {\n                // 157\n                // If we just set this for \"server\", replSet will override it. If we just                                         //\n                // set it for replSet, it will be ignored if we're not using a replSet.                                           //\n                mongoOptions.server.poolSize = options.poolSize; // 160\n                mongoOptions.replSet.poolSize = options.poolSize; // 161\n              } // 162\n              //\n              self.db = null; // 164\n              // We keep track of the ReplSet's primary, so that we can trigger hooks when                                        //\n              // it changes.  The Node driver's joined callback seems to fire way too                                             //\n              // often, which is why we need to track it ourselves.                                                               //\n              self._primary = null; // 168\n              self._oplogHandle = null; // 169\n              self._docFetcher = null; // 170\n              //\n              var connectFuture = new Future(); // 173\n              MongoDB.connect(url, mongoOptions, Meteor.bindEnvironment(function (err, db) {\n                // 174\n                if (err) {\n                  // 179\n                  throw err; // 180\n                } // 181\n                //\n                // First, figure out what the current primary is, if any.                                                         //\n                if (db.serverConfig.isMasterDoc) {\n                  // 184\n                  self._primary = db.serverConfig.isMasterDoc.primary; // 185\n                } // 186\n                //\n                db.serverConfig.on('joined', Meteor.bindEnvironment(function (kind, doc) {\n                  // 188\n                  if (kind === 'primary') {\n                    // 190\n                    if (doc.primary !== self._primary) {\n                      // 191\n                      self._primary = doc.primary; // 192\n                      self._onFailoverHook.each(function (callback) {\n                        // 193\n                        callback(); // 194\n                        return true; // 195\n                      }); // 196\n                    } // 197\n                  } else if (doc.me === self._primary) {\n                      // 198\n                      // The thing we thought was primary is now something other than                                               //\n                      // primary.  Forget that we thought it was primary.  (This means                                              //\n                      // that if a server stops being primary and then starts being                                                 //\n                      // primary again without another server becoming primary in the                                               //\n                      // middle, we'll correctly count it as a failover.)                                                           //\n                      self._primary = null; // 204\n                    } // 205\n                })); // 206\n                //\n                // Allow the constructor to return.                                                                               //\n                connectFuture['return'](db); // 209\n              }, connectFuture.resolver() // onException                                                                          // 210\n              )); // 177\n              //\n              // Wait for the connection to be successful; throws on failure.                                                     //\n              self.db = connectFuture.wait(); // 216\n              //\n              if (options.oplogUrl && !Package['disable-oplog']) {\n                // 218\n                self._oplogHandle = new OplogHandle(options.oplogUrl, self.db.databaseName); // 219\n                self._docFetcher = new DocFetcher(self); // 220\n              } // 221\n            }; // 222\n            //\n            MongoConnection.prototype.close = function () {\n              // 224\n              var self = this; // 225\n              //\n              if (!self.db) throw Error(\"close called before Connection created?\"); // 227\n              //\n              // XXX probably untested                                                                                            //\n              var oplogHandle = self._oplogHandle; // 231\n              self._oplogHandle = null; // 232\n              if (oplogHandle) oplogHandle.stop(); // 233\n              //\n              // Use Future.wrap so that errors get thrown. This happens to                                                       //\n              // work even outside a fiber since the 'close' method is not                                                        //\n              // actually asynchronous.                                                                                           //\n              Future.wrap(_.bind(self.db.close, self.db))(true).wait(); // 239\n            }; // 240\n            //\n            // Returns the Mongo Collection object; may yield.                                                                    //\n            MongoConnection.prototype.rawCollection = function (collectionName) {\n              // 243\n              var self = this; // 244\n              //\n              if (!self.db) throw Error(\"rawCollection called before Connection created?\"); // 246\n              //\n              var future = new Future(); // 249\n              self.db.collection(collectionName, future.resolver()); // 250\n              return future.wait(); // 251\n            }; // 252\n            //\n            MongoConnection.prototype._createCappedCollection = function (collectionName, byteSize, maxDocuments) {\n              // 254\n              var self = this; // 256\n              //\n              if (!self.db) throw Error(\"_createCappedCollection called before Connection created?\"); // 258\n              //\n              var future = new Future(); // 261\n              self.db.createCollection(collectionName, { capped: true, size: byteSize, max: maxDocuments }, future.resolver()); // 262\n              future.wait(); // 266\n            }; // 267\n            //\n            // This should be called synchronously with a write, to create a                                                      //\n            // transaction on the current write fence, if any. After we can read                                                  //\n            // the write, and after observers have been notified (or at least,                                                    //\n            // after the observer notifiers have added themselves to the write                                                    //\n            // fence), you should call 'committed()' on the object returned.                                                      //\n            MongoConnection.prototype._maybeBeginWrite = function () {\n              // 274\n              var self = this; // 275\n              var fence = DDPServer._CurrentWriteFence.get(); // 276\n              if (fence) return fence.beginWrite();else return { committed: function committed() {} }; // 277\n            }; // 281\n            //\n            // Internal interface: adds a callback which is called when the Mongo primary                                         //\n            // changes. Returns a stop handle.                                                                                    //\n            MongoConnection.prototype._onFailover = function (callback) {\n              // 285\n              return this._onFailoverHook.register(callback); // 286\n            }; // 287\n            //\n            //////////// Public API //////////                                                                                    //\n            //\n            // The write methods block until the database has confirmed the write (it may                                         //\n            // not be replicated or stable on disk, but one server has confirmed it) if no                                        //\n            // callback is provided. If a callback is provided, then they call the callback                                       //\n            // when the write is confirmed. They return nothing on success, and raise an                                          //\n            // exception on failure.                                                                                              //\n            //                                                                                                                    //\n            // After making a write (with insert, update, remove), observers are                                                  //\n            // notified asynchronously. If you want to receive a callback once all                                                //\n            // of the observer notifications have landed for your write, do the                                                   //\n            // writes inside a write fence (set DDPServer._CurrentWriteFence to a new                                             //\n            // _WriteFence, and then set a callback on the write fence.)                                                          //\n            //                                                                                                                    //\n            // Since our execution environment is single-threaded, this is                                                        //\n            // well-defined -- a write \"has been made\" if it's returned, and an                                                   //\n            // observer \"has been notified\" if its callback has returned.                                                         //\n            //\n            var writeCallback = function writeCallback(write, refresh, callback) {\n              // 308\n              return function (err, result) {\n                // 309\n                if (!err) {\n                  // 310\n                  // XXX We don't have to run this on error, right?                                                               //\n                  try {\n                    // 312\n                    refresh(); // 313\n                  } catch (refreshErr) {\n                    // 314\n                    if (callback) {\n                      // 315\n                      callback(refreshErr); // 316\n                      return; // 317\n                    } else {\n                        // 318\n                        throw refreshErr; // 319\n                      } // 320\n                  } // 321\n                } // 322\n                write.committed(); // 323\n                if (callback) callback(err, result);else if (err) throw err; // 324\n              }; // 328\n            }; // 329\n            //\n            var bindEnvironmentForWrite = function bindEnvironmentForWrite(callback) {\n              // 331\n              return Meteor.bindEnvironment(callback, \"Mongo write\"); // 332\n            }; // 333\n            //\n            MongoConnection.prototype._insert = function (collection_name, document, callback) {\n              // 335\n              var self = this; // 337\n              //\n              var sendError = function sendError(e) {\n                // 339\n                if (callback) return callback(e); // 340\n                throw e; // 342\n              }; // 343\n              //\n              if (collection_name === \"___meteor_failure_test_collection\") {\n                // 345\n                var e = new Error(\"Failure test\"); // 346\n                e.expected = true; // 347\n                sendError(e); // 348\n                return; // 349\n              } // 350\n              //\n              if (!(LocalCollection._isPlainObject(document) && !EJSON._isCustomType(document))) {\n                // 352\n                sendError(new Error(\"Only plain objects may be inserted into MongoDB\")); // 354\n                return; // 356\n              } // 357\n              //\n              var write = self._maybeBeginWrite(); // 359\n              var refresh = function refresh() {\n                // 360\n                Meteor.refresh({ collection: collection_name, id: document._id }); // 361\n              }; // 362\n              callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback)); // 363\n              try {\n                // 364\n                var collection = self.rawCollection(collection_name); // 365\n                collection.insert(replaceTypes(document, replaceMeteorAtomWithMongo), { safe: true }, callback); // 366\n              } catch (e) {\n                // 368\n                write.committed(); // 369\n                throw e; // 370\n              } // 371\n            }; // 372\n            //\n            // Cause queries that may be affected by the selector to poll in this write                                           //\n            // fence.                                                                                                             //\n            MongoConnection.prototype._refresh = function (collectionName, selector) {\n              // 376\n              var self = this; // 377\n              var refreshKey = { collection: collectionName }; // 378\n              // If we know which documents we're removing, don't poll queries that are                                           //\n              // specific to other documents. (Note that multiple notifications here should                                       //\n              // not cause multiple polls, since all our listener is doing is enqueueing a                                        //\n              // poll.)                                                                                                           //\n              var specificIds = LocalCollection._idsMatchedBySelector(selector); // 383\n              if (specificIds) {\n                // 384\n                _.each(specificIds, function (id) {\n                  // 385\n                  Meteor.refresh(_.extend({ id: id }, refreshKey)); // 386\n                }); // 387\n              } else {\n                  // 388\n                  Meteor.refresh(refreshKey); // 389\n                } // 390\n            }; // 391\n            //\n            MongoConnection.prototype._remove = function (collection_name, selector, callback) {\n              // 393\n              var self = this; // 395\n              //\n              if (collection_name === \"___meteor_failure_test_collection\") {\n                // 397\n                var e = new Error(\"Failure test\"); // 398\n                e.expected = true; // 399\n                if (callback) return callback(e);else throw e; // 400\n              } // 404\n              //\n              var write = self._maybeBeginWrite(); // 406\n              var refresh = function refresh() {\n                // 407\n                self._refresh(collection_name, selector); // 408\n              }; // 409\n              callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback)); // 410\n              //\n              try {\n                // 412\n                var collection = self.rawCollection(collection_name); // 413\n                var wrappedCallback = function wrappedCallback(err, driverResult) {\n                  // 414\n                  callback(err, transformResult(driverResult).numberAffected); // 415\n                }; // 416\n                collection.remove(replaceTypes(selector, replaceMeteorAtomWithMongo), { safe: true }, wrappedCallback); // 417\n              } catch (e) {\n                // 419\n                write.committed(); // 420\n                throw e; // 421\n              } // 422\n            }; // 423\n            //\n            MongoConnection.prototype._dropCollection = function (collectionName, cb) {\n              // 425\n              var self = this; // 426\n              //\n              var write = self._maybeBeginWrite(); // 428\n              var refresh = function refresh() {\n                // 429\n                Meteor.refresh({ collection: collectionName, id: null, // 430\n                  dropCollection: true }); // 431\n              }; // 432\n              cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb)); // 433\n              //\n              try {\n                // 435\n                var collection = self.rawCollection(collectionName); // 436\n                collection.drop(cb); // 437\n              } catch (e) {\n                // 438\n                write.committed(); // 439\n                throw e; // 440\n              } // 441\n            }; // 442\n            //\n            // For testing only.  Slightly better than `c.rawDatabase().dropDatabase()`                                           //\n            // because it lets the test's fence wait for it to be complete.                                                       //\n            MongoConnection.prototype._dropDatabase = function (cb) {\n              // 446\n              var self = this; // 447\n              //\n              var write = self._maybeBeginWrite(); // 449\n              var refresh = function refresh() {\n                // 450\n                Meteor.refresh({ dropDatabase: true }); // 451\n              }; // 452\n              cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb)); // 453\n              //\n              try {\n                // 455\n                self.db.dropDatabase(cb); // 456\n              } catch (e) {\n                // 457\n                write.committed(); // 458\n                throw e; // 459\n              } // 460\n            }; // 461\n            //\n            MongoConnection.prototype._update = function (collection_name, selector, mod, options, callback) {\n              // 463\n              var self = this; // 465\n              //\n              if (!callback && options instanceof Function) {\n                // 467\n                callback = options; // 468\n                options = null; // 469\n              } // 470\n              //\n              if (collection_name === \"___meteor_failure_test_collection\") {\n                // 472\n                var e = new Error(\"Failure test\"); // 473\n                e.expected = true; // 474\n                if (callback) return callback(e);else throw e; // 475\n              } // 479\n              //\n              // explicit safety check. null and undefined can crash the mongo                                                    //\n              // driver. Although the node driver and minimongo do 'support'                                                      //\n              // non-object modifier in that they don't crash, they are not                                                       //\n              // meaningful operations and do not do anything. Defensively throw an                                               //\n              // error here.                                                                                                      //\n              if (!mod || (typeof mod === 'undefined' ? 'undefined' : _typeof(mod)) !== 'object') throw new Error(\"Invalid modifier. Modifier must be an object.\");\n              //\n              if (!(LocalCollection._isPlainObject(mod) && !EJSON._isCustomType(mod))) {\n                // 489\n                throw new Error(\"Only plain objects may be used as replacement\" + \" documents in MongoDB\"); // 491\n                return; // 494\n              } // 495\n              //\n              if (!options) options = {}; // 497\n              //\n              var write = self._maybeBeginWrite(); // 499\n              var refresh = function refresh() {\n                // 500\n                self._refresh(collection_name, selector); // 501\n              }; // 502\n              callback = writeCallback(write, refresh, callback); // 503\n              try {\n                // 504\n                var collection = self.rawCollection(collection_name); // 505\n                var mongoOpts = { safe: true }; // 506\n                // explictly enumerate options that minimongo supports                                                            //\n                if (options.upsert) mongoOpts.upsert = true; // 508\n                if (options.multi) mongoOpts.multi = true; // 509\n                // Lets you get a more more full result from MongoDB. Use with caution:                                           //\n                // might not work with C.upsert (as opposed to C.update({upsert:true}) or                                         //\n                // with simulated upsert.                                                                                         //\n                if (options.fullResult) mongoOpts.fullResult = true; // 513\n                //\n                var mongoSelector = replaceTypes(selector, replaceMeteorAtomWithMongo); // 515\n                var mongoMod = replaceTypes(mod, replaceMeteorAtomWithMongo); // 516\n                //\n                var isModify = isModificationMod(mongoMod); // 518\n                var knownId = selector._id || mod._id; // 519\n                //\n                if (options._forbidReplace && !isModify) {\n                  // 521\n                  var e = new Error(\"Invalid modifier. Replacements are forbidden.\"); // 522\n                  if (callback) {\n                    // 523\n                    return callback(e); // 524\n                  } else {\n                      // 525\n                      throw e; // 526\n                    } // 527\n                } // 528\n                //\n                if (options.upsert && !knownId && options.insertedId) {\n                  // 530\n                  // XXX If we know we're using Mongo 2.6 (and this isn't a replacement)                                          //\n                  //     we should be able to just use $setOnInsert instead of this                                               //\n                  //     simulated upsert thing. (We can't use $setOnInsert with                                                  //\n                  //     replacements because there's nowhere to write it, and $setOnInsert                                       //\n                  //     can't set _id on Mongo 2.4.)                                                                             //\n                  //                                                                                                              //\n                  //     Also, in the future we could do a real upsert for the mongo id                                           //\n                  //     generation case, if the the node mongo driver gives us back the id                                       //\n                  //     of the upserted doc (which our current version does not).                                                //\n                  //                                                                                                              //\n                  //     For more context, see                                                                                    //\n                  //     https://github.com/meteor/meteor/issues/2278#issuecomment-64252706                                       //\n                  simulateUpsertWithInsertedId(collection, mongoSelector, mongoMod, isModify, options, // 543\n                  // This callback does not need to be bindEnvironment'ed because                                                 //\n                  // simulateUpsertWithInsertedId() wraps it and then passes it through                                           //\n                  // bindEnvironmentForWrite.                                                                                     //\n                  function (err, result) {\n                    // 549\n                    // If we got here via a upsert() call, then options._returnObject will                                        //\n                    // be set and we should return the whole object. Otherwise, we should                                         //\n                    // just return the number of affected docs to match the mongo API.                                            //\n                    if (result && !options._returnObject) callback(err, result.numberAffected);else callback(err, result); // 553\n                  }); // 557\n                } else {\n                    // 559\n                    collection.update(mongoSelector, mongoMod, mongoOpts, bindEnvironmentForWrite(function (err, result) {\n                      // 560\n                      if (!err) {\n                        // 563\n                        var meteorResult = transformResult(result); // 564\n                        if (meteorResult && options._returnObject) {\n                          // 565\n                          // If this was an upsert() call, and we ended up                                                          //\n                          // inserting a new doc and we know its id, then                                                           //\n                          // return that id as well.                                                                                //\n                          //\n                          if (options.upsert && meteorResult.insertedId && knownId) {\n                            // 570\n                            meteorResult.insertedId = knownId; // 571\n                          } // 572\n                          callback(err, meteorResult); // 573\n                        } else {\n                            // 574\n                            callback(err, meteorResult.numberAffected); // 575\n                          } // 576\n                      } else {\n                          // 577\n                          callback(err); // 578\n                        } // 579\n                    })); // 580\n                  } // 581\n              } catch (e) {\n                // 582\n                write.committed(); // 583\n                throw e; // 584\n              } // 585\n            }; // 586\n            //\n            var isModificationMod = function isModificationMod(mod) {\n              // 588\n              var isReplace = false; // 589\n              var isModify = false; // 590\n              for (var k in mod) {\n                // 591\n                if (k.substr(0, 1) === '$') {\n                  // 592\n                  isModify = true; // 593\n                } else {\n                    // 594\n                    isReplace = true; // 595\n                  } // 596\n              } // 597\n              if (isModify && isReplace) {\n                // 598\n                throw new Error(\"Update parameter cannot have both modifier and non-modifier fields.\"); // 599\n              } // 601\n              return isModify; // 602\n            }; // 603\n            //\n            var transformResult = function transformResult(driverResult) {\n              // 605\n              var meteorResult = { numberAffected: 0 }; // 606\n              if (driverResult) {\n                // 607\n                mongoResult = driverResult.result; // 608\n                //\n                // On updates with upsert:true, the inserted values come as a list of                                             //\n                // upserted values -- even with options.multi, when the upsert does insert,                                       //\n                // it only inserts one element.                                                                                   //\n                if (mongoResult.upserted) {\n                  // 613\n                  meteorResult.numberAffected += mongoResult.upserted.length; // 614\n                  //\n                  if (mongoResult.upserted.length == 1) {\n                    // 616\n                    meteorResult.insertedId = mongoResult.upserted[0]._id; // 617\n                  } // 618\n                } else {\n                    // 619\n                    meteorResult.numberAffected = mongoResult.n; // 620\n                  } // 621\n              } // 622\n              //\n              return meteorResult; // 624\n            }; // 625\n            //\n            var NUM_OPTIMISTIC_TRIES = 3; // 628\n            //\n            // exposed for testing                                                                                                //\n            MongoConnection._isCannotChangeIdError = function (err) {\n              // 631\n              // First check for what this error looked like in Mongo 2.4.  Either of these                                       //\n              // checks should work, but just to be safe...                                                                       //\n              if (err.code === 13596) return true; // 634\n              if (err.errmsg.indexOf(\"cannot change _id of a document\") === 0) return true; // 636\n              //\n              // Now look for what it looks like in Mongo 2.6.  We don't use the error code                                       //\n              // here, because the error code we observed it producing (16837) appears to be                                      //\n              // a far more generic error code based on examining the source.                                                     //\n              if (err.errmsg.indexOf(\"The _id field cannot be changed\") === 0) return true; // 642\n              //\n              return false; // 645\n            }; // 646\n            //\n            var simulateUpsertWithInsertedId = function simulateUpsertWithInsertedId(collection, selector, mod, isModify, options, callback) {\n              // STRATEGY:  First try doing a plain update.  If it affected 0 documents,                                          //\n              // then without affecting the database, we know we should probably do an                                            //\n              // insert.  We then do a *conditional* insert that will fail in the case                                            //\n              // of a race condition.  This conditional insert is actually an                                                     //\n              // upsert-replace with an _id, which will never successfully update an                                              //\n              // existing document.  If this upsert fails with an error saying it                                                 //\n              // couldn't change an existing _id, then we know an intervening write has                                           //\n              // caused the query to match something.  We go back to step one and repeat.                                         //\n              // Like all \"optimistic write\" schemes, we rely on the fact that it's                                               //\n              // unlikely our writes will continue to be interfered with under normal                                             //\n              // circumstances (though sufficiently heavy contention with writers                                                 //\n              // disagreeing on the existence of an object will cause writes to fail                                              //\n              // in theory).                                                                                                      //\n              //\n              var newDoc; // 664\n              // Run this code up front so that it fails fast if someone uses                                                     //\n              // a Mongo update operator we don't support.                                                                        //\n              if (isModify) {\n                // 667\n                // We've already run replaceTypes/replaceMeteorAtomWithMongo on                                                   //\n                // selector and mod.  We assume it doesn't matter, as far as                                                      //\n                // the behavior of modifiers is concerned, whether `_modify`                                                      //\n                // is run on EJSON or on mongo-converted EJSON.                                                                   //\n                var selectorDoc = LocalCollection._removeDollarOperators(selector); // 672\n                //\n                newDoc = selectorDoc; // 674\n                //\n                // Convert dotted keys into objects. (Resolves issue #4522).                                                      //\n                _.each(newDoc, function (value, key) {\n                  // 677\n                  var trail = key.split(\".\"); // 678\n                  //\n                  if (trail.length > 1) {\n                    // 680\n                    //Key is dotted. Convert it into an object.                                                                   //\n                    delete newDoc[key]; // 682\n                    //\n                    var obj = newDoc,\n                        // 684\n                    leaf = trail.pop(); // 684\n                    //\n                    // XXX It is not quite certain what should be done if there are clashing                                      //\n                    // keys on the trail of the dotted key. For now we will just override it                                      //\n                    // It wouldn't be a very sane query in the first place, but should look                                       //\n                    // up what mongo does in this case.                                                                           //\n                    //\n                    while (key = trail.shift()) {\n                      // 692\n                      if (_typeof(obj[key]) !== \"object\") {\n                        // 693\n                        obj[key] = {}; // 694\n                      } // 695\n                      //\n                      obj = obj[key]; // 697\n                    } // 698\n                    //\n                    obj[leaf] = value; // 700\n                  } // 701\n                }); // 702\n                //\n                LocalCollection._modify(newDoc, mod, { isInsert: true }); // 704\n              } else {\n                  // 705\n                  newDoc = mod; // 706\n                } // 707\n              //\n              var insertedId = options.insertedId; // must exist                                                                  // 709\n              var mongoOptsForUpdate = { // 710\n                safe: true, // 711\n                multi: options.multi // 712\n              }; // 710\n              var mongoOptsForInsert = { // 714\n                safe: true, // 715\n                upsert: true // 716\n              }; // 714\n              //\n              var tries = NUM_OPTIMISTIC_TRIES; // 719\n              //\n              var doUpdate = function doUpdate() {\n                // 721\n                tries--; // 722\n                if (!tries) {\n                  // 723\n                  callback(new Error(\"Upsert failed after \" + NUM_OPTIMISTIC_TRIES + \" tries.\")); // 724\n                } else {\n                    // 725\n                    collection.update(selector, mod, mongoOptsForUpdate, bindEnvironmentForWrite(function (err, result) {\n                      // 726\n                      if (err) {\n                        // 728\n                        callback(err); // 729\n                      } else if (result && result.result.n != 0) {\n                          // 730\n                          callback(null, { // 731\n                            numberAffected: result.result.n // 732\n                          }); // 731\n                        } else {\n                            // 734\n                            doConditionalInsert(); // 735\n                          } // 736\n                    })); // 737\n                  } // 738\n              }; // 739\n              //\n              var doConditionalInsert = function doConditionalInsert() {\n                // 741\n                var replacementWithId = _.extend(replaceTypes({ _id: insertedId }, replaceMeteorAtomWithMongo), newDoc); // 742\n                collection.update(selector, replacementWithId, mongoOptsForInsert, bindEnvironmentForWrite(function (err, result) {\n                  if (err) {\n                    // 747\n                    // figure out if this is a                                                                                    //\n                    // \"cannot change _id of document\" error, and                                                                 //\n                    // if so, try doUpdate() again, up to 3 times.                                                                //\n                    if (MongoConnection._isCannotChangeIdError(err)) {\n                      // 751\n                      doUpdate(); // 752\n                    } else {\n                        // 753\n                        callback(err); // 754\n                      } // 755\n                  } else {\n                      // 756\n                      callback(null, { // 757\n                        numberAffected: result.result.upserted.length, // 758\n                        insertedId: insertedId // 759\n                      }); // 757\n                    } // 761\n                })); // 762\n              }; // 763\n              //\n              doUpdate(); // 765\n            }; // 766\n            //\n            _.each([\"insert\", \"update\", \"remove\", \"dropCollection\", \"dropDatabase\"], function (method) {\n              // 768\n              MongoConnection.prototype[method] = function () /* arguments */{\n                // 769\n                var self = this; // 770\n                return Meteor.wrapAsync(self[\"_\" + method]).apply(self, arguments); // 771\n              }; // 772\n            }); // 773\n            //\n            // XXX MongoConnection.upsert() does not return the id of the inserted document                                       //\n            // unless you set it explicitly in the selector or modifier (as a replacement                                         //\n            // doc).                                                                                                              //\n            MongoConnection.prototype.upsert = function (collectionName, selector, mod, options, callback) {\n              // 778\n              var self = this; // 780\n              if (typeof options === \"function\" && !callback) {\n                // 781\n                callback = options; // 782\n                options = {}; // 783\n              } // 784\n              //\n              return self.update(collectionName, selector, mod, _.extend({}, options, { // 786\n                upsert: true, // 788\n                _returnObject: true // 789\n              }), callback); // 787\n            }; // 791\n            //\n            MongoConnection.prototype.find = function (collectionName, selector, options) {\n              // 793\n              var self = this; // 794\n              //\n              if (arguments.length === 1) selector = {}; // 796\n              //\n              return new Cursor(self, new CursorDescription(collectionName, selector, options)); // 799\n            }; // 801\n            //\n            MongoConnection.prototype.findOne = function (collection_name, selector, options) {\n              // 803\n              var self = this; // 805\n              if (arguments.length === 1) selector = {}; // 806\n              //\n              options = options || {}; // 809\n              options.limit = 1; // 810\n              return self.find(collection_name, selector, options).fetch()[0]; // 811\n            }; // 812\n            //\n            // We'll actually design an index API later. For now, we just pass through to                                         //\n            // Mongo's, but make it synchronous.                                                                                  //\n            MongoConnection.prototype._ensureIndex = function (collectionName, index, options) {\n              // 816\n              var self = this; // 818\n              //\n              // We expect this function to be called at startup, not from within a method,                                       //\n              // so we don't interact with the write fence.                                                                       //\n              var collection = self.rawCollection(collectionName); // 822\n              var future = new Future(); // 823\n              var indexName = collection.ensureIndex(index, options, future.resolver()); // 824\n              future.wait(); // 825\n            }; // 826\n            MongoConnection.prototype._dropIndex = function (collectionName, index) {\n              // 827\n              var self = this; // 828\n              //\n              // This function is only used by test code, not within a method, so we don't                                        //\n              // interact with the write fence.                                                                                   //\n              var collection = self.rawCollection(collectionName); // 832\n              var future = new Future(); // 833\n              var indexName = collection.dropIndex(index, future.resolver()); // 834\n              future.wait(); // 835\n            }; // 836\n            //\n            // CURSORS                                                                                                            //\n            //\n            // There are several classes which relate to cursors:                                                                 //\n            //                                                                                                                    //\n            // CursorDescription represents the arguments used to construct a cursor:                                             //\n            // collectionName, selector, and (find) options.  Because it is used as a key                                         //\n            // for cursor de-dup, everything in it should either be JSON-stringifiable or                                         //\n            // not affect observeChanges output (eg, options.transform functions are not                                          //\n            // stringifiable but do not affect observeChanges).                                                                   //\n            //                                                                                                                    //\n            // SynchronousCursor is a wrapper around a MongoDB cursor                                                             //\n            // which includes fully-synchronous versions of forEach, etc.                                                         //\n            //                                                                                                                    //\n            // Cursor is the cursor object returned from find(), which implements the                                             //\n            // documented Mongo.Collection cursor API.  It wraps a CursorDescription and a                                        //\n            // SynchronousCursor (lazily: it doesn't contact Mongo until you call a method                                        //\n            // like fetch or forEach on it).                                                                                      //\n            //                                                                                                                    //\n            // ObserveHandle is the \"observe handle\" returned from observeChanges. It has a                                       //\n            // reference to an ObserveMultiplexer.                                                                                //\n            //                                                                                                                    //\n            // ObserveMultiplexer allows multiple identical ObserveHandles to be driven by a                                      //\n            // single observe driver.                                                                                             //\n            //                                                                                                                    //\n            // There are two \"observe drivers\" which drive ObserveMultiplexers:                                                   //\n            //   - PollingObserveDriver caches the results of a query and reruns it when                                          //\n            //     necessary.                                                                                                     //\n            //   - OplogObserveDriver follows the Mongo operation log to directly observe                                         //\n            //     database changes.                                                                                              //\n            // Both implementations follow the same simple interface: when you create them,                                       //\n            // they start sending observeChanges callbacks (and a ready() invocation) to                                          //\n            // their ObserveMultiplexer, and you stop them by calling their stop() method.                                        //\n            //\n            CursorDescription = function CursorDescription(collectionName, selector, options) {\n              // 871\n              var self = this; // 872\n              self.collectionName = collectionName; // 873\n              self.selector = Mongo.Collection._rewriteSelector(selector); // 874\n              self.options = options || {}; // 875\n            }; // 876\n            //\n            Cursor = function Cursor(mongo, cursorDescription) {\n              // 878\n              var self = this; // 879\n              //\n              self._mongo = mongo; // 881\n              self._cursorDescription = cursorDescription; // 882\n              self._synchronousCursor = null; // 883\n            }; // 884\n            //\n            _.each(['forEach', 'map', 'fetch', 'count'], function (method) {\n              // 886\n              Cursor.prototype[method] = function () {\n                // 887\n                var self = this; // 888\n                //\n                // You can only observe a tailable cursor.                                                                        //\n                if (self._cursorDescription.options.tailable) throw new Error(\"Cannot call \" + method + \" on a tailable cursor\");\n                //\n                if (!self._synchronousCursor) {\n                  // 894\n                  self._synchronousCursor = self._mongo._createSynchronousCursor(self._cursorDescription, { // 895\n                    // Make sure that the \"self\" argument to forEach/map callbacks is the                                         //\n                    // Cursor, not the SynchronousCursor.                                                                         //\n                    selfForIteration: self, // 899\n                    useTransform: true // 900\n                  }); // 896\n                } // 902\n                //\n                return self._synchronousCursor[method].apply(self._synchronousCursor, arguments); // 904\n              }; // 906\n            }); // 907\n            //\n            // Since we don't actually have a \"nextObject\" interface, there's really no                                           //\n            // reason to have a \"rewind\" interface.  All it did was make multiple calls                                           //\n            // to fetch/map/forEach return nothing the second time.                                                               //\n            // XXX COMPAT WITH 0.8.1                                                                                              //\n            Cursor.prototype.rewind = function () {}; // 913\n            //\n            Cursor.prototype.getTransform = function () {\n              // 916\n              return this._cursorDescription.options.transform; // 917\n            }; // 918\n            //\n            // When you call Meteor.publish() with a function that returns a Cursor, we need                                      //\n            // to transmute it into the equivalent subscription.  This is the function that                                       //\n            // does that.                                                                                                         //\n            //\n            Cursor.prototype._publishCursor = function (sub) {\n              // 924\n              var self = this; // 925\n              var collection = self._cursorDescription.collectionName; // 926\n              return Mongo.Collection._publishCursor(self, sub, collection); // 927\n            }; // 928\n            //\n            // Used to guarantee that publish functions return at most one cursor per                                             //\n            // collection. Private, because we might later have cursors that include                                              //\n            // documents from multiple collections somehow.                                                                       //\n            Cursor.prototype._getCollectionName = function () {\n              // 933\n              var self = this; // 934\n              return self._cursorDescription.collectionName; // 935\n            }; // 936\n            //\n            Cursor.prototype.observe = function (callbacks) {\n              // 938\n              var self = this; // 939\n              return LocalCollection._observeFromObserveChanges(self, callbacks); // 940\n            }; // 941\n            //\n            Cursor.prototype.observeChanges = function (callbacks) {\n              // 943\n              var self = this; // 944\n              var ordered = LocalCollection._observeChangesCallbacksAreOrdered(callbacks); // 945\n              return self._mongo._observeChanges(self._cursorDescription, ordered, callbacks); // 946\n            }; // 948\n            //\n            MongoConnection.prototype._createSynchronousCursor = function (cursorDescription, options) {\n              // 950\n              var self = this; // 952\n              options = _.pick(options || {}, 'selfForIteration', 'useTransform'); // 953\n              //\n              var collection = self.rawCollection(cursorDescription.collectionName); // 955\n              var cursorOptions = cursorDescription.options; // 956\n              var mongoOptions = { // 957\n                sort: cursorOptions.sort, // 958\n                limit: cursorOptions.limit, // 959\n                skip: cursorOptions.skip // 960\n              }; // 957\n              //\n              // Do we want a tailable cursor (which only works on capped collections)?                                           //\n              if (cursorOptions.tailable) {\n                // 964\n                // We want a tailable cursor...                                                                                   //\n                mongoOptions.tailable = true; // 966\n                // ... and for the server to wait a bit if any getMore has no data (rather                                        //\n                // than making us put the relevant sleeps in the client)...                                                       //\n                mongoOptions.awaitdata = true; // 969\n                // ... and to keep querying the server indefinitely rather than just 5 times                                      //\n                // if there's no more data.                                                                                       //\n                mongoOptions.numberOfRetries = -1; // 972\n                // And if this is on the oplog collection and the cursor specifies a 'ts',                                        //\n                // then set the undocumented oplog replay flag, which does a special scan to                                      //\n                // find the first document (instead of creating an index on ts). This is a                                        //\n                // very hard-coded Mongo flag which only works on the oplog collection and                                        //\n                // only works with the ts field.                                                                                  //\n                if (cursorDescription.collectionName === OPLOG_COLLECTION && cursorDescription.selector.ts) {\n                  // 978\n                  mongoOptions.oplogReplay = true; // 980\n                } // 981\n              } // 982\n              //\n              var dbCursor = collection.find(replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo), cursorOptions.fields, mongoOptions);\n              //\n              return new SynchronousCursor(dbCursor, cursorDescription, options); // 988\n            }; // 989\n            //\n            var SynchronousCursor = function SynchronousCursor(dbCursor, cursorDescription, options) {\n              // 991\n              var self = this; // 992\n              options = _.pick(options || {}, 'selfForIteration', 'useTransform'); // 993\n              //\n              self._dbCursor = dbCursor; // 995\n              self._cursorDescription = cursorDescription; // 996\n              // The \"self\" argument passed to forEach/map callbacks. If we're wrapped                                            //\n              // inside a user-visible Cursor, we want to provide the outer cursor!                                               //\n              self._selfForIteration = options.selfForIteration || self; // 999\n              if (options.useTransform && cursorDescription.options.transform) {\n                // 1000\n                self._transform = LocalCollection.wrapTransform(cursorDescription.options.transform); // 1001\n              } else {\n                  // 1003\n                  self._transform = null; // 1004\n                } // 1005\n              //\n              // Need to specify that the callback is the first argument to nextObject,                                           //\n              // since otherwise when we try to call it with no args the driver will                                              //\n              // interpret \"undefined\" first arg as an options hash and crash.                                                    //\n              self._synchronousNextObject = Future.wrap(dbCursor.nextObject.bind(dbCursor), 0); // 1010\n              self._synchronousCount = Future.wrap(dbCursor.count.bind(dbCursor)); // 1012\n              self._visitedIds = new LocalCollection._IdMap(); // 1013\n            }; // 1014\n            //\n            _.extend(SynchronousCursor.prototype, { // 1016\n              _nextObject: function _nextObject() {\n                // 1017\n                var self = this; // 1018\n                //\n                while (true) {\n                  // 1020\n                  var doc = self._synchronousNextObject().wait(); // 1021\n                  //\n                  if (!doc) return null; // 1023\n                  doc = replaceTypes(doc, replaceMongoAtomWithMeteor); // 1024\n                  //\n                  if (!self._cursorDescription.options.tailable && _.has(doc, '_id')) {\n                    // 1026\n                    // Did Mongo give us duplicate documents in the same cursor? If so,                                           //\n                    // ignore this one. (Do this before the transform, since transform might                                      //\n                    // return some unrelated value.) We don't do this for tailable cursors,                                       //\n                    // because we want to maintain O(1) memory usage. And if there isn't _id                                      //\n                    // for some reason (maybe it's the oplog), then we don't do this either.                                      //\n                    // (Be careful to do this for falsey but existing _id, though.)                                               //\n                    if (self._visitedIds.has(doc._id)) continue; // 1033\n                    self._visitedIds.set(doc._id, true); // 1034\n                  } // 1035\n                  //\n                  if (self._transform) doc = self._transform(doc); // 1037\n                  //\n                  return doc; // 1040\n                } // 1041\n              }, // 1042\n              //\n              forEach: function forEach(callback, thisArg) {\n                // 1044\n                var self = this; // 1045\n                //\n                // Get back to the beginning.                                                                                     //\n                self._rewind(); // 1048\n                //\n                // We implement the loop ourself instead of using self._dbCursor.each,                                            //\n                // because \"each\" will call its callback outside of a fiber which makes it                                        //\n                // much more complex to make this function synchronous.                                                           //\n                var index = 0; // 1053\n                while (true) {\n                  // 1054\n                  var doc = self._nextObject(); // 1055\n                  if (!doc) return; // 1056\n                  callback.call(thisArg, doc, index++, self._selfForIteration); // 1057\n                } // 1058\n              }, // 1059\n              //\n              // XXX Allow overlapping callback executions if callback yields.                                                    //\n              map: function map(callback, thisArg) {\n                // 1062\n                var self = this; // 1063\n                var res = []; // 1064\n                self.forEach(function (doc, index) {\n                  // 1065\n                  res.push(callback.call(thisArg, doc, index, self._selfForIteration)); // 1066\n                }); // 1067\n                return res; // 1068\n              }, // 1069\n              //\n              _rewind: function _rewind() {\n                // 1071\n                var self = this; // 1072\n                //\n                // known to be synchronous                                                                                        //\n                self._dbCursor.rewind(); // 1075\n                //\n                self._visitedIds = new LocalCollection._IdMap(); // 1077\n              }, // 1078\n              //\n              // Mostly usable for tailable cursors.                                                                              //\n              close: function close() {\n                // 1081\n                var self = this; // 1082\n                //\n                self._dbCursor.close(); // 1084\n              }, // 1085\n              //\n              fetch: function fetch() {\n                // 1087\n                var self = this; // 1088\n                return self.map(_.identity); // 1089\n              }, // 1090\n              //\n              count: function count(applySkipLimit) {\n                // 1092\n                var self = this; // 1093\n                return self._synchronousCount(applySkipLimit).wait(); // 1094\n              }, // 1095\n              //\n              // This method is NOT wrapped in Cursor.                                                                            //\n              getRawObjects: function getRawObjects(ordered) {\n                // 1098\n                var self = this; // 1099\n                if (ordered) {\n                  // 1100\n                  return self.fetch(); // 1101\n                } else {\n                    // 1102\n                    var results = new LocalCollection._IdMap(); // 1103\n                    self.forEach(function (doc) {\n                      // 1104\n                      results.set(doc._id, doc); // 1105\n                    }); // 1106\n                    return results; // 1107\n                  } // 1108\n              } // 1109\n            }); // 1016\n            //\n            MongoConnection.prototype.tail = function (cursorDescription, docCallback) {\n              // 1112\n              var self = this; // 1113\n              if (!cursorDescription.options.tailable) throw new Error(\"Can only tail a tailable cursor\"); // 1114\n              //\n              var cursor = self._createSynchronousCursor(cursorDescription); // 1117\n              //\n              var stopped = false; // 1119\n              var lastTS = undefined; // 1120\n              var loop = function loop() {\n                // 1121\n                while (true) {\n                  // 1122\n                  if (stopped) return; // 1123\n                  try {\n                    // 1125\n                    var doc = cursor._nextObject(); // 1126\n                  } catch (err) {\n                    // 1127\n                    // There's no good way to figure out if this was actually an error                                            //\n                    // from Mongo. Ah well. But either way, we need to retry the cursor                                           //\n                    // (unless the failure was because the observe got stopped).                                                  //\n                    doc = null; // 1131\n                  } // 1132\n                  // Since cursor._nextObject can yield, we need to check again to see if                                         //\n                  // we've been stopped before calling the callback.                                                              //\n                  if (stopped) return; // 1135\n                  if (doc) {\n                    // 1137\n                    // If a tailable cursor contains a \"ts\" field, use it to recreate the                                         //\n                    // cursor on error. (\"ts\" is a standard that Mongo uses internally for                                        //\n                    // the oplog, and there's a special flag that lets you do binary search                                       //\n                    // on it instead of needing to use an index.)                                                                 //\n                    lastTS = doc.ts; // 1142\n                    docCallback(doc); // 1143\n                  } else {\n                      // 1144\n                      var newSelector = _.clone(cursorDescription.selector); // 1145\n                      if (lastTS) {\n                        // 1146\n                        newSelector.ts = { $gt: lastTS }; // 1147\n                      } // 1148\n                      cursor = self._createSynchronousCursor(new CursorDescription(cursorDescription.collectionName, newSelector, cursorDescription.options));\n                      // Mongo failover takes many seconds.  Retry in a bit.  (Without this                                         //\n                      // setTimeout, we peg the CPU at 100% and never notice the actual                                             //\n                      // failover.                                                                                                  //\n                      Meteor.setTimeout(loop, 100); // 1156\n                      break; // 1157\n                    } // 1158\n                } // 1159\n              }; // 1160\n              //\n              Meteor.defer(loop); // 1162\n              //\n              return { // 1164\n                stop: function stop() {\n                  // 1165\n                  stopped = true; // 1166\n                  cursor.close(); // 1167\n                } // 1168\n              }; // 1164\n            }; // 1170\n            //\n            MongoConnection.prototype._observeChanges = function (cursorDescription, ordered, callbacks) {\n              // 1172\n              var self = this; // 1174\n              //\n              if (cursorDescription.options.tailable) {\n                // 1176\n                return self._observeChangesTailable(cursorDescription, ordered, callbacks); // 1177\n              } // 1178\n              //\n              // You may not filter out _id when observing changes, because the id is a core                                      //\n              // part of the observeChanges API.                                                                                  //\n              if (cursorDescription.options.fields && (cursorDescription.options.fields._id === 0 || cursorDescription.options.fields._id === false)) {\n                throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\"); // 1185\n              } // 1186\n              //\n              var observeKey = JSON.stringify(_.extend({ ordered: ordered }, cursorDescription)); // 1188\n              //\n              var multiplexer, observeDriver; // 1191\n              var firstHandle = false; // 1192\n              //\n              // Find a matching ObserveMultiplexer, or create a new one. This next block is                                      //\n              // guaranteed to not yield (and it doesn't call anything that can observe a                                         //\n              // new query), so no other calls to this function can interleave with it.                                           //\n              Meteor._noYieldsAllowed(function () {\n                // 1197\n                if (_.has(self._observeMultiplexers, observeKey)) {\n                  // 1198\n                  multiplexer = self._observeMultiplexers[observeKey]; // 1199\n                } else {\n                    // 1200\n                    firstHandle = true; // 1201\n                    // Create a new ObserveMultiplexer.                                                                             //\n                    multiplexer = new ObserveMultiplexer({ // 1203\n                      ordered: ordered, // 1204\n                      onStop: function onStop() {\n                        // 1205\n                        delete self._observeMultiplexers[observeKey]; // 1206\n                        observeDriver.stop(); // 1207\n                      } // 1208\n                    }); // 1203\n                    self._observeMultiplexers[observeKey] = multiplexer; // 1210\n                  } // 1211\n              }); // 1212\n              //\n              var observeHandle = new ObserveHandle(multiplexer, callbacks); // 1214\n              //\n              if (firstHandle) {\n                // 1216\n                var matcher, sorter; // 1217\n                var canUseOplog = _.all([function () {\n                  // 1218\n                  // At a bare minimum, using the oplog requires us to have an oplog, to                                          //\n                  // want unordered callbacks, and to not want a callback on the polls                                            //\n                  // that won't happen.                                                                                           //\n                  return self._oplogHandle && !ordered && !callbacks._testOnlyPollCallback; // 1223\n                }, function () {\n                  // 1225\n                  // We need to be able to compile the selector. Fall back to polling for                                         //\n                  // some newfangled $selector that minimongo doesn't support yet.                                                //\n                  try {\n                    // 1228\n                    matcher = new Minimongo.Matcher(cursorDescription.selector); // 1229\n                    return true; // 1230\n                  } catch (e) {\n                    // 1231\n                    // XXX make all compilation errors MinimongoError or something                                                //\n                    //     so that this doesn't ignore unrelated exceptions                                                       //\n                    return false; // 1234\n                  } // 1235\n                }, function () {\n                  // 1236\n                  // ... and the selector itself needs to support oplog.                                                          //\n                  return OplogObserveDriver.cursorSupported(cursorDescription, matcher); // 1238\n                }, function () {\n                  // 1239\n                  // And we need to be able to compile the sort, if any.  eg, can't be                                            //\n                  // {$natural: 1}.                                                                                               //\n                  if (!cursorDescription.options.sort) return true; // 1242\n                  try {\n                    // 1244\n                    sorter = new Minimongo.Sorter(cursorDescription.options.sort, { matcher: matcher }); // 1245\n                    return true; // 1247\n                  } catch (e) {\n                    // 1248\n                    // XXX make all compilation errors MinimongoError or something                                                //\n                    //     so that this doesn't ignore unrelated exceptions                                                       //\n                    return false; // 1251\n                  } // 1252\n                }], function (f) {\n                  // 1253\n                  return f(); // 1253\n                }); // invoke each function                                                                                       // 1253\n                //\n                var driverClass = canUseOplog ? OplogObserveDriver : PollingObserveDriver; // 1255\n                observeDriver = new driverClass({ // 1256\n                  cursorDescription: cursorDescription, // 1257\n                  mongoHandle: self, // 1258\n                  multiplexer: multiplexer, // 1259\n                  ordered: ordered, // 1260\n                  matcher: matcher, // ignored by polling                                                                         // 1261\n                  sorter: sorter, // ignored by polling                                                                           // 1262\n                  _testOnlyPollCallback: callbacks._testOnlyPollCallback // 1263\n                }); // 1256\n                //\n                // This field is only set for use in tests.                                                                       //\n                multiplexer._observeDriver = observeDriver; // 1267\n              } // 1268\n              //\n              // Blocks until the initial adds have been sent.                                                                    //\n              multiplexer.addHandleAndSendInitialAdds(observeHandle); // 1271\n              //\n              return observeHandle; // 1273\n            }; // 1274\n            //\n            // Listen for the invalidation messages that will trigger us to poll the                                              //\n            // database for changes. If this selector specifies specific IDs, specify them                                        //\n            // here, so that updates to different specific IDs don't cause us to poll.                                            //\n            // listenCallback is the same kind of (notification, complete) callback passed                                        //\n            // to InvalidationCrossbar.listen.                                                                                    //\n            //\n            listenAll = function listenAll(cursorDescription, listenCallback) {\n              // 1282\n              var listeners = []; // 1283\n              forEachTrigger(cursorDescription, function (trigger) {\n                // 1284\n                listeners.push(DDPServer._InvalidationCrossbar.listen(trigger, listenCallback)); // 1285\n              }); // 1287\n              //\n              return { // 1289\n                stop: function stop() {\n                  // 1290\n                  _.each(listeners, function (listener) {\n                    // 1291\n                    listener.stop(); // 1292\n                  }); // 1293\n                } // 1294\n              }; // 1289\n            }; // 1296\n            //\n            forEachTrigger = function forEachTrigger(cursorDescription, triggerCallback) {\n              // 1298\n              var key = { collection: cursorDescription.collectionName }; // 1299\n              var specificIds = LocalCollection._idsMatchedBySelector(cursorDescription.selector); // 1300\n              if (specificIds) {\n                // 1302\n                _.each(specificIds, function (id) {\n                  // 1303\n                  triggerCallback(_.extend({ id: id }, key)); // 1304\n                }); // 1305\n                triggerCallback(_.extend({ dropCollection: true, id: null }, key)); // 1306\n              } else {\n                  // 1307\n                  triggerCallback(key); // 1308\n                } // 1309\n              // Everyone cares about the database being dropped.                                                                 //\n              triggerCallback({ dropDatabase: true }); // 1311\n            }; // 1312\n            //\n            // observeChanges for tailable cursors on capped collections.                                                         //\n            //                                                                                                                    //\n            // Some differences from normal cursors:                                                                              //\n            //   - Will never produce anything other than 'added' or 'addedBefore'. If you                                        //\n            //     do update a document that has already been produced, this will not notice                                      //\n            //     it.                                                                                                            //\n            //   - If you disconnect and reconnect from Mongo, it will essentially restart                                        //\n            //     the query, which will lead to duplicate results. This is pretty bad,                                           //\n            //     but if you include a field called 'ts' which is inserted as                                                    //\n            //     new MongoInternals.MongoTimestamp(0, 0) (which is initialized to the                                           //\n            //     current Mongo-style timestamp), we'll be able to find the place to                                             //\n            //     restart properly. (This field is specifically understood by Mongo with an                                      //\n            //     optimization which allows it to find the right place to start without                                          //\n            //     an index on ts. It's how the oplog works.)                                                                     //\n            //   - No callbacks are triggered synchronously with the call (there's no                                             //\n            //     differentiation between \"initial data\" and \"later changes\"; everything                                         //\n            //     that matches the query gets sent asynchronously).                                                              //\n            //   - De-duplication is not implemented.                                                                             //\n            //   - Does not yet interact with the write fence. Probably, this should work by                                      //\n            //     ignoring removes (which don't work on capped collections) and updates                                          //\n            //     (which don't affect tailable cursors), and just keeping track of the ID                                        //\n            //     of the inserted object, and closing the write fence once you get to that                                       //\n            //     ID (or timestamp?).  This doesn't work well if the document doesn't match                                      //\n            //     the query, though.  On the other hand, the write fence can close                                               //\n            //     immediately if it does not match the query. So if we trust minimongo                                           //\n            //     enough to accurately evaluate the query against the write fence, we                                            //\n            //     should be able to do this...  Of course, minimongo doesn't even support                                        //\n            //     Mongo Timestamps yet.                                                                                          //\n            MongoConnection.prototype._observeChangesTailable = function (cursorDescription, ordered, callbacks) {\n              // 1342\n              var self = this; // 1344\n              //\n              // Tailable cursors only ever call added/addedBefore callbacks, so it's an                                          //\n              // error if you didn't provide them.                                                                                //\n              if (ordered && !callbacks.addedBefore || !ordered && !callbacks.added) {\n                // 1348\n                throw new Error(\"Can't observe an \" + (ordered ? \"ordered\" : \"unordered\") + \" tailable cursor without a \" + (ordered ? \"addedBefore\" : \"added\") + \" callback\");\n              } // 1353\n              //\n              return self.tail(cursorDescription, function (doc) {\n                // 1355\n                var id = doc._id; // 1356\n                delete doc._id; // 1357\n                // The ts is an implementation detail. Hide it.                                                                   //\n                delete doc.ts; // 1359\n                if (ordered) {\n                  // 1360\n                  callbacks.addedBefore(id, doc, null); // 1361\n                } else {\n                    // 1362\n                    callbacks.added(id, doc); // 1363\n                  } // 1364\n              }); // 1365\n            }; // 1366\n            //\n            // XXX We probably need to find a better way to expose this. Right now                                                //\n            // it's only used by tests, but in fact you need it in normal                                                         //\n            // operation to interact with capped collections.                                                                     //\n            MongoInternals.MongoTimestamp = MongoDB.Timestamp; // 1371\n            //\n            MongoInternals.Connection = MongoConnection; // 1373\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }], \"oplog_tailing.js\": function oplog_tailingJs(require) {\n\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/mongo/oplog_tailing.js                                                                                    //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            var Future = Npm.require('fibers/future'); // 1\n            //\n            OPLOG_COLLECTION = 'oplog.rs'; // 3\n            //\n            var TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000; // 5\n            //\n            var showTS = function showTS(ts) {\n              // 7\n              return \"Timestamp(\" + ts.getHighBits() + \", \" + ts.getLowBits() + \")\"; // 8\n            }; // 9\n            //\n            idForOp = function idForOp(op) {\n              // 11\n              if (op.op === 'd') return op.o._id;else if (op.op === 'i') return op.o._id;else if (op.op === 'u') return op.o2._id;else if (op.op === 'c') throw Error(\"Operator 'c' doesn't supply an object with id: \" + EJSON.stringify(op));else throw Error(\"Unknown op: \" + EJSON.stringify(op));\n            }; // 23\n            //\n            OplogHandle = function OplogHandle(oplogUrl, dbName) {\n              // 25\n              var self = this; // 26\n              self._oplogUrl = oplogUrl; // 27\n              self._dbName = dbName; // 28\n              //\n              self._oplogLastEntryConnection = null; // 30\n              self._oplogTailConnection = null; // 31\n              self._stopped = false; // 32\n              self._tailHandle = null; // 33\n              self._readyFuture = new Future(); // 34\n              self._crossbar = new DDPServer._Crossbar({ // 35\n                factPackage: \"mongo-livedata\", factName: \"oplog-watchers\" // 36\n              }); // 35\n              self._baseOplogSelector = { // 38\n                ns: new RegExp('^' + Meteor._escapeRegExp(self._dbName) + '\\\\.'), // 39\n                $or: [{ op: { $in: ['i', 'u', 'd'] } }, // 40\n                // drop collection                                                                                                //\n                { op: 'c', 'o.drop': { $exists: true } }, { op: 'c', 'o.dropDatabase': 1 }] // 43\n              }; // 38\n              //\n              // Data structures to support waitUntilCaughtUp(). Each oplog entry has a                                           //\n              // MongoTimestamp object on it (which is not the same as a Date --- it's a                                          //\n              // combination of time and an incrementing counter; see                                                             //\n              // http://docs.mongodb.org/manual/reference/bson-types/#timestamps).                                                //\n              //                                                                                                                  //\n              // _catchingUpFutures is an array of {ts: MongoTimestamp, future: Future}                                           //\n              // objects, sorted by ascending timestamp. _lastProcessedTS is the                                                  //\n              // MongoTimestamp of the last oplog entry we've processed.                                                          //\n              //                                                                                                                  //\n              // Each time we call waitUntilCaughtUp, we take a peek at the final oplog                                           //\n              // entry in the db.  If we've already processed it (ie, it is not greater than                                      //\n              // _lastProcessedTS), waitUntilCaughtUp immediately returns. Otherwise,                                             //\n              // waitUntilCaughtUp makes a new Future and inserts it along with the final                                         //\n              // timestamp entry that it read, into _catchingUpFutures. waitUntilCaughtUp                                         //\n              // then waits on that future, which is resolved once _lastProcessedTS is                                            //\n              // incremented to be past its timestamp by the worker fiber.                                                        //\n              //                                                                                                                  //\n              // XXX use a priority queue or something else that's faster than an array                                           //\n              self._catchingUpFutures = []; // 66\n              self._lastProcessedTS = null; // 67\n              //\n              self._onSkippedEntriesHook = new Hook({ // 69\n                debugPrintExceptions: \"onSkippedEntries callback\" // 70\n              }); // 69\n              //\n              self._entryQueue = new Meteor._DoubleEndedQueue(); // 73\n              self._workerActive = false; // 74\n              //\n              self._startTailing(); // 76\n            }; // 77\n            //\n            _.extend(OplogHandle.prototype, { // 79\n              stop: function stop() {\n                // 80\n                var self = this; // 81\n                if (self._stopped) return; // 82\n                self._stopped = true; // 84\n                if (self._tailHandle) self._tailHandle.stop(); // 85\n                // XXX should close connections too                                                                               //\n              }, // 88\n              onOplogEntry: function onOplogEntry(trigger, callback) {\n                // 89\n                var self = this; // 90\n                if (self._stopped) throw new Error(\"Called onOplogEntry on stopped handle!\"); // 91\n                //\n                // Calling onOplogEntry requires us to wait for the tailing to be ready.                                          //\n                self._readyFuture.wait(); // 95\n                //\n                var originalCallback = callback; // 97\n                callback = Meteor.bindEnvironment(function (notification) {\n                  // 98\n                  // XXX can we avoid this clone by making oplog.js careful?                                                      //\n                  originalCallback(EJSON.clone(notification)); // 100\n                }, function (err) {\n                  // 101\n                  Meteor._debug(\"Error in oplog callback\", err.stack); // 102\n                }); // 103\n                var listenHandle = self._crossbar.listen(trigger, callback); // 104\n                return { // 105\n                  stop: function stop() {\n                    // 106\n                    listenHandle.stop(); // 107\n                  } // 108\n                }; // 105\n              }, // 110\n              // Register a callback to be invoked any time we skip oplog entries (eg,                                            //\n              // because we are too far behind).                                                                                  //\n              onSkippedEntries: function onSkippedEntries(callback) {\n                // 113\n                var self = this; // 114\n                if (self._stopped) throw new Error(\"Called onSkippedEntries on stopped handle!\"); // 115\n                return self._onSkippedEntriesHook.register(callback); // 117\n              }, // 118\n              // Calls `callback` once the oplog has been processed up to a point that is                                         //\n              // roughly \"now\": specifically, once we've processed all ops that are                                               //\n              // currently visible.                                                                                               //\n              // XXX become convinced that this is actually safe even if oplogConnection                                          //\n              // is some kind of pool                                                                                             //\n              waitUntilCaughtUp: function waitUntilCaughtUp() {\n                // 124\n                var self = this; // 125\n                if (self._stopped) throw new Error(\"Called waitUntilCaughtUp on stopped handle!\"); // 126\n                //\n                // Calling waitUntilCaughtUp requries us to wait for the oplog connection to                                      //\n                // be ready.                                                                                                      //\n                self._readyFuture.wait(); // 131\n                //\n                while (!self._stopped) {\n                  // 133\n                  // We need to make the selector at least as restrictive as the actual                                           //\n                  // tailing selector (ie, we need to specify the DB name) or else we might                                       //\n                  // find a TS that won't show up in the actual tail stream.                                                      //\n                  try {\n                    // 137\n                    var lastEntry = self._oplogLastEntryConnection.findOne(OPLOG_COLLECTION, self._baseOplogSelector, { fields: { ts: 1 }, sort: { $natural: -1 } });\n                    break; // 141\n                  } catch (e) {\n                    // 142\n                    // During failover (eg) if we get an exception we should log and retry                                        //\n                    // instead of crashing.                                                                                       //\n                    Meteor._debug(\"Got exception while reading last entry: \" + e); // 145\n                    Meteor._sleepForMs(100); // 146\n                  } // 147\n                } // 148\n                //\n                if (self._stopped) return; // 150\n                //\n                if (!lastEntry) {\n                  // 153\n                  // Really, nothing in the oplog? Well, we've processed everything.                                              //\n                  return; // 155\n                } // 156\n                //\n                var ts = lastEntry.ts; // 158\n                if (!ts) throw Error(\"oplog entry without ts: \" + EJSON.stringify(lastEntry)); // 159\n                //\n                if (self._lastProcessedTS && ts.lessThanOrEqual(self._lastProcessedTS)) {\n                  // 162\n                  // We've already caught up to here.                                                                             //\n                  return; // 164\n                } // 165\n                //\n                // Insert the future into our list. Almost always, this will be at the end,                                       //\n                // but it's conceivable that if we fail over from one primary to another,                                         //\n                // the oplog entries we see will go backwards.                                                                    //\n                var insertAfter = self._catchingUpFutures.length; // 171\n                while (insertAfter - 1 > 0 && self._catchingUpFutures[insertAfter - 1].ts.greaterThan(ts)) {\n                  // 172\n                  insertAfter--; // 174\n                } // 175\n                var f = new Future(); // 176\n                self._catchingUpFutures.splice(insertAfter, 0, { ts: ts, future: f }); // 177\n                f.wait(); // 178\n              }, // 179\n              _startTailing: function _startTailing() {\n                // 180\n                var self = this; // 181\n                // First, make sure that we're talking to the local database.                                                     //\n                var mongodbUri = Npm.require('mongodb-uri'); // 183\n                if (mongodbUri.parse(self._oplogUrl).database !== 'local') {\n                  // 184\n                  throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" + \"a Mongo replica set\"); // 185\n                } // 187\n                //\n                // We make two separate connections to Mongo. The Node Mongo driver                                               //\n                // implements a naive round-robin connection pool: each \"connection\" is a                                         //\n                // pool of several (5 by default) TCP connections, and each request is                                            //\n                // rotated through the pools. Tailable cursor queries block on the server                                         //\n                // until there is some data to return (or until a few seconds have                                                //\n                // passed). So if the connection pool used for tailing cursors is the same                                        //\n                // pool used for other queries, the other queries will be delayed by seconds                                      //\n                // 1/5 of the time.                                                                                               //\n                //                                                                                                                //\n                // The tail connection will only ever be running a single tail command, so                                        //\n                // it only needs to make one underlying TCP connection.                                                           //\n                self._oplogTailConnection = new MongoConnection(self._oplogUrl, { poolSize: 1 }); // 200\n                // XXX better docs, but: it's to get monotonic results                                                            //\n                // XXX is it safe to say \"if there's an in flight query, just use its                                             //\n                //     results\"? I don't think so but should consider that                                                        //\n                self._oplogLastEntryConnection = new MongoConnection(self._oplogUrl, { poolSize: 1 }); // 205\n                //\n                // Now, make sure that there actually is a repl set here. If not, oplog                                           //\n                // tailing won't ever find anything!                                                                              //\n                // More on the isMasterDoc                                                                                        //\n                // https://docs.mongodb.com/manual/reference/command/isMaster/                                                    //\n                var f = new Future(); // 212\n                self._oplogLastEntryConnection.db.admin().command({ ismaster: 1 }, f.resolver()); // 213\n                var isMasterDoc = f.wait(); // 215\n                //\n                if (!(isMasterDoc && isMasterDoc.setName)) {\n                  // 217\n                  throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" + \"a Mongo replica set\"); // 218\n                } // 220\n                //\n                // Find the last oplog entry.                                                                                     //\n                var lastOplogEntry = self._oplogLastEntryConnection.findOne(OPLOG_COLLECTION, {}, { sort: { $natural: -1 }, fields: { ts: 1 } });\n                //\n                var oplogSelector = _.clone(self._baseOplogSelector); // 226\n                if (lastOplogEntry) {\n                  // 227\n                  // Start after the last entry that currently exists.                                                            //\n                  oplogSelector.ts = { $gt: lastOplogEntry.ts }; // 229\n                  // If there are any calls to callWhenProcessedLatest before any other                                           //\n                  // oplog entries show up, allow callWhenProcessedLatest to call its                                             //\n                  // callback immediately.                                                                                        //\n                  self._lastProcessedTS = lastOplogEntry.ts; // 233\n                } // 234\n                //\n                var cursorDescription = new CursorDescription(OPLOG_COLLECTION, oplogSelector, { tailable: true }); // 236\n                //\n                self._tailHandle = self._oplogTailConnection.tail(cursorDescription, function (doc) {\n                  // 239\n                  self._entryQueue.push(doc); // 241\n                  self._maybeStartWorker(); // 242\n                }); // 243\n                self._readyFuture['return'](); // 245\n              }, // 246\n              //\n              _maybeStartWorker: function _maybeStartWorker() {\n                // 248\n                var self = this; // 249\n                if (self._workerActive) return; // 250\n                self._workerActive = true; // 252\n                Meteor.defer(function () {\n                  // 253\n                  try {\n                    // 254\n                    while (!self._stopped && !self._entryQueue.isEmpty()) {\n                      // 255\n                      // Are we too far behind? Just tell our observers that they need to                                         //\n                      // repoll, and drop our queue.                                                                              //\n                      if (self._entryQueue.length > TOO_FAR_BEHIND) {\n                        // 258\n                        var lastEntry = self._entryQueue.pop(); // 259\n                        self._entryQueue.clear(); // 260\n                        //\n                        self._onSkippedEntriesHook.each(function (callback) {\n                          // 262\n                          callback(); // 263\n                          return true; // 264\n                        }); // 265\n                        //\n                        // Free any waitUntilCaughtUp() calls that were waiting for us to                                         //\n                        // pass something that we just skipped.                                                                   //\n                        self._setLastProcessedTS(lastEntry.ts); // 269\n                        continue; // 270\n                      } // 271\n                      //\n                      var doc = self._entryQueue.shift(); // 273\n                      //\n                      if (!(doc.ns && doc.ns.length > self._dbName.length + 1 && doc.ns.substr(0, self._dbName.length + 1) === self._dbName + '.')) {\n                        throw new Error(\"Unexpected ns\"); // 278\n                      } // 279\n                      //\n                      var trigger = { collection: doc.ns.substr(self._dbName.length + 1), // 281\n                        dropCollection: false, // 282\n                        dropDatabase: false, // 283\n                        op: doc }; // 284\n                      //\n                      // Is it a special command and the collection name is hidden somewhere                                      //\n                      // in operator?                                                                                             //\n                      if (trigger.collection === \"$cmd\") {\n                        // 288\n                        if (doc.o.dropDatabase) {\n                          // 289\n                          delete trigger.collection; // 290\n                          trigger.dropDatabase = true; // 291\n                        } else if (_.has(doc.o, 'drop')) {\n                            // 292\n                            trigger.collection = doc.o.drop; // 293\n                            trigger.dropCollection = true; // 294\n                            trigger.id = null; // 295\n                          } else {\n                              // 296\n                              throw Error(\"Unknown command \" + JSON.stringify(doc)); // 297\n                            } // 298\n                      } else {\n                          // 299\n                          // All other ops have an id.                                                                              //\n                          trigger.id = idForOp(doc); // 301\n                        } // 302\n                      //\n                      self._crossbar.fire(trigger); // 304\n                      //\n                      // Now that we've processed this operation, process pending                                                 //\n                      // sequencers.                                                                                              //\n                      if (!doc.ts) throw Error(\"oplog entry without ts: \" + EJSON.stringify(doc)); // 308\n                      self._setLastProcessedTS(doc.ts); // 310\n                    } // 311\n                  } finally {\n                    // 312\n                    self._workerActive = false; // 313\n                  } // 314\n                }); // 315\n              }, // 316\n              _setLastProcessedTS: function _setLastProcessedTS(ts) {\n                // 317\n                var self = this; // 318\n                self._lastProcessedTS = ts; // 319\n                while (!_.isEmpty(self._catchingUpFutures) && self._catchingUpFutures[0].ts.lessThanOrEqual(self._lastProcessedTS)) {\n                  var sequencer = self._catchingUpFutures.shift(); // 323\n                  sequencer.future['return'](); // 324\n                } // 325\n              }, // 326\n              //\n              //Methods used on tests to dinamically change TOO_FAR_BEHIND                                                        //\n              _defineTooFarBehind: function _defineTooFarBehind(value) {\n                // 329\n                TOO_FAR_BEHIND = value; // 330\n              }, // 331\n              _resetTooFarBehind: function _resetTooFarBehind() {\n                // 332\n                TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000; // 333\n              } // 334\n            }); // 79\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }, \"observe_multiplex.js\": function observe_multiplexJs(require) {\n\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/mongo/observe_multiplex.js                                                                                //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            var Future = Npm.require('fibers/future'); // 1\n            //\n            ObserveMultiplexer = function ObserveMultiplexer(options) {\n              // 3\n              var self = this; // 4\n              //\n              if (!options || !_.has(options, 'ordered')) throw Error(\"must specified ordered\"); // 6\n              //\n              Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-multiplexers\", 1); // 9\n              //\n              self._ordered = options.ordered; // 12\n              self._onStop = options.onStop || function () {}; // 13\n              self._queue = new Meteor._SynchronousQueue(); // 14\n              self._handles = {}; // 15\n              self._readyFuture = new Future(); // 16\n              self._cache = new LocalCollection._CachingChangeObserver({ // 17\n                ordered: options.ordered }); // 18\n              // Number of addHandleAndSendInitialAdds tasks scheduled but not yet                                                //\n              // running. removeHandle uses this to know if it's time to call the onStop                                          //\n              // callback.                                                                                                        //\n              self._addHandleTasksScheduledButNotPerformed = 0; // 22\n              //\n              _.each(self.callbackNames(), function (callbackName) {\n                // 24\n                self[callbackName] = function () /* ... */{\n                  // 25\n                  self._applyCallback(callbackName, _.toArray(arguments)); // 26\n                }; // 27\n              }); // 28\n            }; // 29\n            //\n            _.extend(ObserveMultiplexer.prototype, { // 31\n              addHandleAndSendInitialAdds: function addHandleAndSendInitialAdds(handle) {\n                // 32\n                var self = this; // 33\n                //\n                // Check this before calling runTask (even though runTask does the same                                           //\n                // check) so that we don't leak an ObserveMultiplexer on error by                                                 //\n                // incrementing _addHandleTasksScheduledButNotPerformed and never                                                 //\n                // decrementing it.                                                                                               //\n                if (!self._queue.safeToRunTask()) throw new Error(\"Can't call observeChanges from an observe callback on the same query\");\n                ++self._addHandleTasksScheduledButNotPerformed; // 42\n                //\n                Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-handles\", 1); // 44\n                //\n                self._queue.runTask(function () {\n                  // 47\n                  self._handles[handle._id] = handle; // 48\n                  // Send out whatever adds we have so far (whether or not we the                                                 //\n                  // multiplexer is ready).                                                                                       //\n                  self._sendAdds(handle); // 51\n                  --self._addHandleTasksScheduledButNotPerformed; // 52\n                }); // 53\n                // *outside* the task, since otherwise we'd deadlock                                                              //\n                self._readyFuture.wait(); // 55\n              }, // 56\n              //\n              // Remove an observe handle. If it was the last observe handle, call the                                            //\n              // onStop callback; you cannot add any more observe handles after this.                                             //\n              //                                                                                                                  //\n              // This is not synchronized with polls and handle additions: this means that                                        //\n              // you can safely call it from within an observe callback, but it also means                                        //\n              // that we have to be careful when we iterate over _handles.                                                        //\n              removeHandle: function removeHandle(id) {\n                // 64\n                var self = this; // 65\n                //\n                // This should not be possible: you can only call removeHandle by having                                          //\n                // access to the ObserveHandle, which isn't returned to user code until the                                       //\n                // multiplex is ready.                                                                                            //\n                if (!self._ready()) throw new Error(\"Can't remove handles until the multiplex is ready\"); // 70\n                //\n                delete self._handles[id]; // 73\n                //\n                Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-handles\", -1); // 75\n                //\n                if (_.isEmpty(self._handles) && self._addHandleTasksScheduledButNotPerformed === 0) {\n                  // 78\n                  self._stop(); // 80\n                } // 81\n              }, // 82\n              _stop: function _stop(options) {\n                // 83\n                var self = this; // 84\n                options = options || {}; // 85\n                //\n                // It shouldn't be possible for us to stop when all our handles still                                             //\n                // haven't been returned from observeChanges!                                                                     //\n                if (!self._ready() && !options.fromQueryError) throw Error(\"surprising _stop: not ready\"); // 89\n                //\n                // Call stop callback (which kills the underlying process which sends us                                          //\n                // callbacks and removes us from the connection's dictionary).                                                    //\n                self._onStop(); // 94\n                Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-multiplexers\", -1); // 95\n                //\n                // Cause future addHandleAndSendInitialAdds calls to throw (but the onStop                                        //\n                // callback should make our connection forget about us).                                                          //\n                self._handles = null; // 100\n              }, // 101\n              //\n              // Allows all addHandleAndSendInitialAdds calls to return, once all preceding                                       //\n              // adds have been processed. Does not block.                                                                        //\n              ready: function ready() {\n                // 105\n                var self = this; // 106\n                self._queue.queueTask(function () {\n                  // 107\n                  if (self._ready()) throw Error(\"can't make ObserveMultiplex ready twice!\"); // 108\n                  self._readyFuture['return'](); // 110\n                }); // 111\n              }, // 112\n              //\n              // If trying to execute the query results in an error, call this. This is                                           //\n              // intended for permanent errors, not transient network errors that could be                                        //\n              // fixed. It should only be called before ready(), because if you called ready                                      //\n              // that meant that you managed to run the query once. It will stop this                                             //\n              // ObserveMultiplex and cause addHandleAndSendInitialAdds calls (and thus                                           //\n              // observeChanges calls) to throw the error.                                                                        //\n              queryError: function queryError(err) {\n                // 120\n                var self = this; // 121\n                self._queue.runTask(function () {\n                  // 122\n                  if (self._ready()) throw Error(\"can't claim query has an error after it worked!\"); // 123\n                  self._stop({ fromQueryError: true }); // 125\n                  self._readyFuture['throw'](err); // 126\n                }); // 127\n              }, // 128\n              //\n              // Calls \"cb\" once the effects of all \"ready\", \"addHandleAndSendInitialAdds\"                                        //\n              // and observe callbacks which came before this call have been propagated to                                        //\n              // all handles. \"ready\" must have already been called on this multiplexer.                                          //\n              onFlush: function onFlush(cb) {\n                // 133\n                var self = this; // 134\n                self._queue.queueTask(function () {\n                  // 135\n                  if (!self._ready()) throw Error(\"only call onFlush on a multiplexer that will be ready\"); // 136\n                  cb(); // 138\n                }); // 139\n              }, // 140\n              callbackNames: function callbackNames() {\n                // 141\n                var self = this; // 142\n                if (self._ordered) return [\"addedBefore\", \"changed\", \"movedBefore\", \"removed\"];else return [\"added\", \"changed\", \"removed\"];\n              }, // 147\n              _ready: function _ready() {\n                // 148\n                return this._readyFuture.isResolved(); // 149\n              }, // 150\n              _applyCallback: function _applyCallback(callbackName, args) {\n                // 151\n                var self = this; // 152\n                self._queue.queueTask(function () {\n                  // 153\n                  // If we stopped in the meantime, do nothing.                                                                   //\n                  if (!self._handles) return; // 155\n                  //\n                  // First, apply the change to the cache.                                                                        //\n                  // XXX We could make applyChange callbacks promise not to hang on to any                                        //\n                  // state from their arguments (assuming that their supplied callbacks                                           //\n                  // don't) and skip this clone. Currently 'changed' hangs on to state                                            //\n                  // though.                                                                                                      //\n                  self._cache.applyChange[callbackName].apply(null, EJSON.clone(args)); // 163\n                  //\n                  // If we haven't finished the initial adds, then we should only be getting                                      //\n                  // adds.                                                                                                        //\n                  if (!self._ready() && callbackName !== 'added' && callbackName !== 'addedBefore') {\n                    // 167\n                    throw new Error(\"Got \" + callbackName + \" during initial adds\"); // 169\n                  } // 170\n                  //\n                  // Now multiplex the callbacks out to all observe handles. It's OK if                                           //\n                  // these calls yield; since we're inside a task, no other use of our queue                                      //\n                  // can continue until these are done. (But we do have to be careful to not                                      //\n                  // use a handle that got removed, because removeHandle does not use the                                         //\n                  // queue; thus, we iterate over an array of keys that we control.)                                              //\n                  _.each(_.keys(self._handles), function (handleId) {\n                    // 177\n                    var handle = self._handles && self._handles[handleId]; // 178\n                    if (!handle) return; // 179\n                    var callback = handle['_' + callbackName]; // 181\n                    // clone arguments so that callbacks can mutate their arguments                                               //\n                    callback && callback.apply(null, EJSON.clone(args)); // 183\n                  }); // 184\n                }); // 185\n              }, // 186\n              //\n              // Sends initial adds to a handle. It should only be called from within a task                                      //\n              // (the task that is processing the addHandleAndSendInitialAdds call). It                                           //\n              // synchronously invokes the handle's added or addedBefore; there's no need to                                      //\n              // flush the queue afterwards to ensure that the callbacks get out.                                                 //\n              _sendAdds: function _sendAdds(handle) {\n                // 192\n                var self = this; // 193\n                if (self._queue.safeToRunTask()) throw Error(\"_sendAdds may only be called from within a task!\"); // 194\n                var add = self._ordered ? handle._addedBefore : handle._added; // 196\n                if (!add) return; // 197\n                // note: docs may be an _IdMap or an OrderedDict                                                                  //\n                self._cache.docs.forEach(function (doc, id) {\n                  // 200\n                  if (!_.has(self._handles, handle._id)) throw Error(\"handle got removed before sending initial adds!\"); // 201\n                  var fields = EJSON.clone(doc); // 203\n                  delete fields._id; // 204\n                  if (self._ordered) add(id, fields, null); // we're going in order, so add at end                                // 205\n                  else add(id, fields); // 205\n                }); // 209\n              } // 210\n            }); // 31\n            //\n            var nextObserveHandleId = 1; // 214\n            ObserveHandle = function ObserveHandle(multiplexer, callbacks) {\n              // 215\n              var self = this; // 216\n              // The end user is only supposed to call stop().  The other fields are                                              //\n              // accessible to the multiplexer, though.                                                                           //\n              self._multiplexer = multiplexer; // 219\n              _.each(multiplexer.callbackNames(), function (name) {\n                // 220\n                if (callbacks[name]) {\n                  // 221\n                  self['_' + name] = callbacks[name]; // 222\n                } else if (name === \"addedBefore\" && callbacks.added) {\n                    // 223\n                    // Special case: if you specify \"added\" and \"movedBefore\", you get an                                           //\n                    // ordered observe where for some reason you don't get ordering data on                                         //\n                    // the adds.  I dunno, we wrote tests for it, there must have been a                                            //\n                    // reason.                                                                                                      //\n                    self._addedBefore = function (id, fields, before) {\n                      // 228\n                      callbacks.added(id, fields); // 229\n                    }; // 230\n                  } // 231\n              }); // 232\n              self._stopped = false; // 233\n              self._id = nextObserveHandleId++; // 234\n            }; // 235\n            ObserveHandle.prototype.stop = function () {\n              // 236\n              var self = this; // 237\n              if (self._stopped) return; // 238\n              self._stopped = true; // 240\n              self._multiplexer.removeHandle(self._id); // 241\n            }; // 242\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }, \"doc_fetcher.js\": function doc_fetcherJs(require) {\n\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/mongo/doc_fetcher.js                                                                                      //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            var Fiber = Npm.require('fibers'); // 1\n            var Future = Npm.require('fibers/future'); // 2\n            //\n            DocFetcher = function DocFetcher(mongoConnection) {\n              // 4\n              var self = this; // 5\n              self._mongoConnection = mongoConnection; // 6\n              // Map from cache key -> [callback]                                                                                 //\n              self._callbacksForCacheKey = {}; // 8\n            }; // 9\n            //\n            _.extend(DocFetcher.prototype, { // 11\n              // Fetches document \"id\" from collectionName, returning it or null if not                                           //\n              // found.                                                                                                           //\n              //                                                                                                                  //\n              // If you make multiple calls to fetch() with the same cacheKey (a string),                                         //\n              // DocFetcher may assume that they all return the same document. (It does                                           //\n              // not check to see if collectionName/id match.)                                                                    //\n              //                                                                                                                  //\n              // You may assume that callback is never called synchronously (and in fact                                          //\n              // OplogObserveDriver does so).                                                                                     //\n              fetch: function fetch(collectionName, id, cacheKey, callback) {\n                // 21\n                var self = this; // 22\n                //\n                check(collectionName, String); // 24\n                // id is some sort of scalar                                                                                      //\n                check(cacheKey, String); // 26\n                //\n                // If there's already an in-progress fetch for this cache key, yield until                                        //\n                // it's done and return whatever it returns.                                                                      //\n                if (_.has(self._callbacksForCacheKey, cacheKey)) {\n                  // 30\n                  self._callbacksForCacheKey[cacheKey].push(callback); // 31\n                  return; // 32\n                } // 33\n                //\n                var callbacks = self._callbacksForCacheKey[cacheKey] = [callback]; // 35\n                //\n                Fiber(function () {\n                  // 37\n                  try {\n                    // 38\n                    var doc = self._mongoConnection.findOne(collectionName, { _id: id }) || null; // 39\n                    // Return doc to all relevant callbacks. Note that this array can                                             //\n                    // continue to grow during callback excecution.                                                               //\n                    while (!_.isEmpty(callbacks)) {\n                      // 43\n                      // Clone the document so that the various calls to fetch don't return                                       //\n                      // objects that are intertwingled with each other. Clone before                                             //\n                      // popping the future, so that if clone throws, the error gets passed                                       //\n                      // to the next callback.                                                                                    //\n                      var clonedDoc = EJSON.clone(doc); // 48\n                      callbacks.pop()(null, clonedDoc); // 49\n                    } // 50\n                  } catch (e) {\n                    // 51\n                    while (!_.isEmpty(callbacks)) {\n                      // 52\n                      callbacks.pop()(e); // 53\n                    } // 54\n                  } finally {\n                    // 55\n                    // XXX consider keeping the doc around for a period of time before                                            //\n                    // removing from the cache                                                                                    //\n                    delete self._callbacksForCacheKey[cacheKey]; // 58\n                  } // 59\n                }).run(); // 60\n              } // 61\n            }); // 11\n            //\n            MongoTest.DocFetcher = DocFetcher; // 64\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }, \"polling_observe_driver.js\": function polling_observe_driverJs() {\n\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/mongo/polling_observe_driver.js                                                                           //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            PollingObserveDriver = function PollingObserveDriver(options) {\n              // 1\n              var self = this; // 2\n              //\n              self._cursorDescription = options.cursorDescription; // 4\n              self._mongoHandle = options.mongoHandle; // 5\n              self._ordered = options.ordered; // 6\n              self._multiplexer = options.multiplexer; // 7\n              self._stopCallbacks = []; // 8\n              self._stopped = false; // 9\n              //\n              self._synchronousCursor = self._mongoHandle._createSynchronousCursor(self._cursorDescription); // 11\n              //\n              // previous results snapshot.  on each poll cycle, diffs against                                                    //\n              // results drives the callbacks.                                                                                    //\n              self._results = null; // 16\n              //\n              // The number of _pollMongo calls that have been added to self._taskQueue but                                       //\n              // have not started running. Used to make sure we never schedule more than one                                      //\n              // _pollMongo (other than possibly the one that is currently running). It's                                         //\n              // also used by _suspendPolling to pretend there's a poll scheduled. Usually,                                       //\n              // it's either 0 (for \"no polls scheduled other than maybe one currently                                            //\n              // running\") or 1 (for \"a poll scheduled that isn't running yet\"), but it can                                       //\n              // also be 2 if incremented by _suspendPolling.                                                                     //\n              self._pollsScheduledButNotStarted = 0; // 25\n              self._pendingWrites = []; // people to notify when polling completes                                                // 26\n              //\n              // Make sure to create a separately throttled function for each                                                     //\n              // PollingObserveDriver object.                                                                                     //\n              self._ensurePollIsScheduled = _.throttle(self._unthrottledEnsurePollIsScheduled, self._cursorDescription.options.pollingThrottleMs || 50 /* ms */);\n              //\n              // XXX figure out if we still need a queue                                                                          //\n              self._taskQueue = new Meteor._SynchronousQueue(); // 35\n              //\n              var listenersHandle = listenAll(self._cursorDescription, function (notification) {\n                // 37\n                // When someone does a transaction that might affect us, schedule a poll                                          //\n                // of the database. If that transaction happens inside of a write fence,                                          //\n                // block the fence until we've polled and notified observers.                                                     //\n                var fence = DDPServer._CurrentWriteFence.get(); // 42\n                if (fence) self._pendingWrites.push(fence.beginWrite()); // 43\n                // Ensure a poll is scheduled... but if we already know that one is,                                              //\n                // don't hit the throttled _ensurePollIsScheduled function (which might                                           //\n                // lead to us calling it unnecessarily in <pollingThrottleMs> ms).                                                //\n                if (self._pollsScheduledButNotStarted === 0) self._ensurePollIsScheduled(); // 48\n              }); // 50\n              self._stopCallbacks.push(function () {\n                // 52\n                listenersHandle.stop(); // 52\n              }); // 52\n              //\n              // every once and a while, poll even if we don't think we're dirty, for                                             //\n              // eventual consistency with database writes from outside the Meteor                                                //\n              // universe.                                                                                                        //\n              //                                                                                                                  //\n              // For testing, there's an undocumented callback argument to observeChanges                                         //\n              // which disables time-based polling and gets called at the beginning of each                                       //\n              // poll.                                                                                                            //\n              if (options._testOnlyPollCallback) {\n                // 61\n                self._testOnlyPollCallback = options._testOnlyPollCallback; // 62\n              } else {\n                  // 63\n                  var pollingInterval = self._cursorDescription.options.pollingIntervalMs || self._cursorDescription.options._pollingInterval || // COMPAT with 1.2\n                  10 * 1000; // 67\n                  var intervalHandle = Meteor.setInterval(_.bind(self._ensurePollIsScheduled, self), pollingInterval); // 68\n                  self._stopCallbacks.push(function () {\n                    // 70\n                    Meteor.clearInterval(intervalHandle); // 71\n                  }); // 72\n                } // 73\n              //\n              // Make sure we actually poll soon!                                                                                 //\n              self._unthrottledEnsurePollIsScheduled(); // 76\n              //\n              Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-polling\", 1); // 78\n            }; // 80\n            //\n            _.extend(PollingObserveDriver.prototype, { // 82\n              // This is always called through _.throttle (except once at startup).                                               //\n              _unthrottledEnsurePollIsScheduled: function _unthrottledEnsurePollIsScheduled() {\n                // 84\n                var self = this; // 85\n                if (self._pollsScheduledButNotStarted > 0) return; // 86\n                ++self._pollsScheduledButNotStarted; // 88\n                self._taskQueue.queueTask(function () {\n                  // 89\n                  self._pollMongo(); // 90\n                }); // 91\n              }, // 92\n              //\n              // test-only interface for controlling polling.                                                                     //\n              //                                                                                                                  //\n              // _suspendPolling blocks until any currently running and scheduled polls are                                       //\n              // done, and prevents any further polls from being scheduled. (new                                                  //\n              // ObserveHandles can be added and receive their initial added callbacks,                                           //\n              // though.)                                                                                                         //\n              //                                                                                                                  //\n              // _resumePolling immediately polls, and allows further polls to occur.                                             //\n              _suspendPolling: function _suspendPolling() {\n                // 102\n                var self = this; // 103\n                // Pretend that there's another poll scheduled (which will prevent                                                //\n                // _ensurePollIsScheduled from queueing any more polls).                                                          //\n                ++self._pollsScheduledButNotStarted; // 106\n                // Now block until all currently running or scheduled polls are done.                                             //\n                self._taskQueue.runTask(function () {}); // 108\n                //\n                // Confirm that there is only one \"poll\" (the fake one we're pretending to                                        //\n                // have) scheduled.                                                                                               //\n                if (self._pollsScheduledButNotStarted !== 1) throw new Error(\"_pollsScheduledButNotStarted is \" + self._pollsScheduledButNotStarted);\n              }, // 115\n              _resumePolling: function _resumePolling() {\n                // 116\n                var self = this; // 117\n                // We should be in the same state as in the end of _suspendPolling.                                               //\n                if (self._pollsScheduledButNotStarted !== 1) throw new Error(\"_pollsScheduledButNotStarted is \" + self._pollsScheduledButNotStarted);\n                // Run a poll synchronously (which will counteract the                                                            //\n                // ++_pollsScheduledButNotStarted from _suspendPolling).                                                          //\n                self._taskQueue.runTask(function () {\n                  // 124\n                  self._pollMongo(); // 125\n                }); // 126\n              }, // 127\n              //\n              _pollMongo: function _pollMongo() {\n                // 129\n                var self = this; // 130\n                --self._pollsScheduledButNotStarted; // 131\n                //\n                if (self._stopped) return; // 133\n                //\n                var first = false; // 136\n                var oldResults = self._results; // 137\n                if (!oldResults) {\n                  // 138\n                  first = true; // 139\n                  // XXX maybe use OrderedDict instead?                                                                           //\n                  oldResults = self._ordered ? [] : new LocalCollection._IdMap(); // 141\n                } // 142\n                //\n                self._testOnlyPollCallback && self._testOnlyPollCallback(); // 144\n                //\n                // Save the list of pending writes which this round will commit.                                                  //\n                var writesForCycle = self._pendingWrites; // 147\n                self._pendingWrites = []; // 148\n                //\n                // Get the new query results. (This yields.)                                                                      //\n                try {\n                  // 151\n                  var newResults = self._synchronousCursor.getRawObjects(self._ordered); // 152\n                } catch (e) {\n                  // 153\n                  if (first && typeof e.code === 'number') {\n                    // 154\n                    // This is an error document sent to us by mongod, not a connection                                           //\n                    // error generated by the client. And we've never seen this query work                                        //\n                    // successfully. Probably it's a bad selector or something, so we should                                      //\n                    // NOT retry. Instead, we should halt the observe (which ends up calling                                      //\n                    // `stop` on us).                                                                                             //\n                    self._multiplexer.queryError(new Error(\"Exception while polling query \" + JSON.stringify(self._cursorDescription) + \": \" + e.message));\n                    return; // 164\n                  } // 165\n                  //\n                  // getRawObjects can throw if we're having trouble talking to the                                               //\n                  // database.  That's fine --- we will repoll later anyway. But we should                                        //\n                  // make sure not to lose track of this cycle's writes.                                                          //\n                  // (It also can throw if there's just something invalid about this query;                                       //\n                  // unfortunately the ObserveDriver API doesn't provide a good way to                                            //\n                  // \"cancel\" the observe from the inside in this case.                                                           //\n                  Array.prototype.push.apply(self._pendingWrites, writesForCycle); // 173\n                  Meteor._debug(\"Exception while polling query \" + JSON.stringify(self._cursorDescription) + \": \" + e.stack); // 174\n                  return; // 176\n                } // 177\n                //\n                // Run diffs.                                                                                                     //\n                if (!self._stopped) {\n                  // 180\n                  LocalCollection._diffQueryChanges(self._ordered, oldResults, newResults, self._multiplexer); // 181\n                } // 183\n                //\n                // Signals the multiplexer to allow all observeChanges calls that share this                                      //\n                // multiplexer to return. (This happens asynchronously, via the                                                   //\n                // multiplexer's queue.)                                                                                          //\n                if (first) self._multiplexer.ready(); // 188\n                //\n                // Replace self._results atomically.  (This assignment is what makes `first`                                      //\n                // stay through on the next cycle, so we've waited until after we've                                              //\n                // committed to ready-ing the multiplexer.)                                                                       //\n                self._results = newResults; // 194\n                //\n                // Once the ObserveMultiplexer has processed everything we've done in this                                        //\n                // round, mark all the writes which existed before this call as                                                   //\n                // commmitted. (If new writes have shown up in the meantime, there'll                                             //\n                // already be another _pollMongo task scheduled.)                                                                 //\n                self._multiplexer.onFlush(function () {\n                  // 200\n                  _.each(writesForCycle, function (w) {\n                    // 201\n                    w.committed(); // 202\n                  }); // 203\n                }); // 204\n              }, // 205\n              //\n              stop: function stop() {\n                // 207\n                var self = this; // 208\n                self._stopped = true; // 209\n                _.each(self._stopCallbacks, function (c) {\n                  // 210\n                  c(); // 210\n                }); // 210\n                // Release any write fences that are waiting on us.                                                               //\n                _.each(self._pendingWrites, function (w) {\n                  // 212\n                  w.committed(); // 213\n                }); // 214\n                Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-polling\", -1); // 215\n              } // 217\n            }); // 82\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }, \"oplog_observe_driver.js\": function oplog_observe_driverJs(require) {\n\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/mongo/oplog_observe_driver.js                                                                             //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            var Fiber = Npm.require('fibers'); // 1\n            var Future = Npm.require('fibers/future'); // 2\n            //\n            var PHASE = { // 4\n              QUERYING: \"QUERYING\", // 5\n              FETCHING: \"FETCHING\", // 6\n              STEADY: \"STEADY\" // 7\n            }; // 4\n            //\n            // Exception thrown by _needToPollQuery which unrolls the stack up to the                                             //\n            // enclosing call to finishIfNeedToPollQuery.                                                                         //\n            var SwitchedToQuery = function SwitchedToQuery() {}; // 12\n            var finishIfNeedToPollQuery = function finishIfNeedToPollQuery(f) {\n              // 13\n              return function () {\n                // 14\n                try {\n                  // 15\n                  f.apply(this, arguments); // 16\n                } catch (e) {\n                  // 17\n                  if (!(e instanceof SwitchedToQuery)) throw e; // 18\n                } // 20\n              }; // 21\n            }; // 22\n            //\n            var currentId = 0; // 24\n            //\n            // OplogObserveDriver is an alternative to PollingObserveDriver which follows                                         //\n            // the Mongo operation log instead of just re-polling the query. It obeys the                                         //\n            // same simple interface: constructing it starts sending observeChanges                                               //\n            // callbacks (and a ready() invocation) to the ObserveMultiplexer, and you stop                                       //\n            // it by calling the stop() method.                                                                                   //\n            OplogObserveDriver = function OplogObserveDriver(options) {\n              // 31\n              var self = this; // 32\n              self._usesOplog = true; // tests look at this                                                                       // 33\n              //\n              self._id = currentId; // 35\n              currentId++; // 36\n              //\n              self._cursorDescription = options.cursorDescription; // 38\n              self._mongoHandle = options.mongoHandle; // 39\n              self._multiplexer = options.multiplexer; // 40\n              //\n              if (options.ordered) {\n                // 42\n                throw Error(\"OplogObserveDriver only supports unordered observeChanges\"); // 43\n              } // 44\n              //\n              var sorter = options.sorter; // 46\n              // We don't support $near and other geo-queries so it's OK to initialize the                                        //\n              // comparator only once in the constructor.                                                                         //\n              var comparator = sorter && sorter.getComparator(); // 49\n              //\n              if (options.cursorDescription.options.limit) {\n                // 51\n                // There are several properties ordered driver implements:                                                        //\n                // - _limit is a positive number                                                                                  //\n                // - _comparator is a function-comparator by which the query is ordered                                           //\n                // - _unpublishedBuffer is non-null Min/Max Heap,                                                                 //\n                //                      the empty buffer in STEADY phase implies that the                                         //\n                //                      everything that matches the queries selector fits                                         //\n                //                      into published set.                                                                       //\n                // - _published - Min Heap (also implements IdMap methods)                                                        //\n                //\n                var heapOptions = { IdMap: LocalCollection._IdMap }; // 61\n                self._limit = self._cursorDescription.options.limit; // 62\n                self._comparator = comparator; // 63\n                self._sorter = sorter; // 64\n                self._unpublishedBuffer = new MinMaxHeap(comparator, heapOptions); // 65\n                // We need something that can find Max value in addition to IdMap interface                                       //\n                self._published = new MaxHeap(comparator, heapOptions); // 67\n              } else {\n                  // 68\n                  self._limit = 0; // 69\n                  self._comparator = null; // 70\n                  self._sorter = null; // 71\n                  self._unpublishedBuffer = null; // 72\n                  self._published = new LocalCollection._IdMap(); // 73\n                } // 74\n              //\n              // Indicates if it is safe to insert a new document at the end of the buffer                                        //\n              // for this query. i.e. it is known that there are no documents matching the                                        //\n              // selector those are not in published or buffer.                                                                   //\n              self._safeAppendToBuffer = false; // 79\n              //\n              self._stopped = false; // 81\n              self._stopHandles = []; // 82\n              //\n              Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-oplog\", 1); // 84\n              //\n              self._registerPhaseChange(PHASE.QUERYING); // 87\n              //\n              var selector = self._cursorDescription.selector; // 89\n              self._matcher = options.matcher; // 90\n              var projection = self._cursorDescription.options.fields || {}; // 91\n              self._projectionFn = LocalCollection._compileProjection(projection); // 92\n              // Projection function, result of combining important fields for selector and                                       //\n              // existing fields projection                                                                                       //\n              self._sharedProjection = self._matcher.combineIntoProjection(projection); // 95\n              if (sorter) self._sharedProjection = sorter.combineIntoProjection(self._sharedProjection); // 96\n              self._sharedProjectionFn = LocalCollection._compileProjection(self._sharedProjection); // 98\n              //\n              self._needToFetch = new LocalCollection._IdMap(); // 101\n              self._currentlyFetching = null; // 102\n              self._fetchGeneration = 0; // 103\n              //\n              self._requeryWhenDoneThisQuery = false; // 105\n              self._writesToCommitWhenWeReachSteady = []; // 106\n              //\n              // If the oplog handle tells us that it skipped some entries (because it got                                        //\n              // behind, say), re-poll.                                                                                           //\n              self._stopHandles.push(self._mongoHandle._oplogHandle.onSkippedEntries(finishIfNeedToPollQuery(function () {\n                // 110\n                self._needToPollQuery(); // 112\n              }))); // 113\n              //\n              forEachTrigger(self._cursorDescription, function (trigger) {\n                // 116\n                self._stopHandles.push(self._mongoHandle._oplogHandle.onOplogEntry(trigger, function (notification) {\n                  // 117\n                  Meteor._noYieldsAllowed(finishIfNeedToPollQuery(function () {\n                    // 119\n                    var op = notification.op; // 120\n                    if (notification.dropCollection || notification.dropDatabase) {\n                      // 121\n                      // Note: this call is not allowed to block on anything (especially                                          //\n                      // on waiting for oplog entries to catch up) because that will block                                        //\n                      // onOplogEntry!                                                                                            //\n                      self._needToPollQuery(); // 125\n                    } else {\n                        // 126\n                        // All other operators should be handled depending on phase                                                 //\n                        if (self._phase === PHASE.QUERYING) self._handleOplogEntryQuerying(op);else self._handleOplogEntrySteadyOrFetching(op);\n                      } // 132\n                  })); // 133\n                })); // 134\n              }); // 136\n              //\n              // XXX ordering w.r.t. everything else?                                                                             //\n              self._stopHandles.push(listenAll(self._cursorDescription, function (notification) {\n                // 139\n                // If we're not in a pre-fire write fence, we don't have to do anything.                                          //\n                var fence = DDPServer._CurrentWriteFence.get(); // 142\n                if (!fence || fence.fired) return; // 143\n                //\n                if (fence._oplogObserveDrivers) {\n                  // 146\n                  fence._oplogObserveDrivers[self._id] = self; // 147\n                  return; // 148\n                } // 149\n                //\n                fence._oplogObserveDrivers = {}; // 151\n                fence._oplogObserveDrivers[self._id] = self; // 152\n                //\n                fence.onBeforeFire(function () {\n                  // 154\n                  var drivers = fence._oplogObserveDrivers; // 155\n                  delete fence._oplogObserveDrivers; // 156\n                  //\n                  // This fence cannot fire until we've caught up to \"this point\" in the                                          //\n                  // oplog, and all observers made it back to the steady state.                                                   //\n                  self._mongoHandle._oplogHandle.waitUntilCaughtUp(); // 160\n                  //\n                  _.each(drivers, function (driver) {\n                    // 162\n                    if (driver._stopped) return; // 163\n                    //\n                    var write = fence.beginWrite(); // 166\n                    if (driver._phase === PHASE.STEADY) {\n                      // 167\n                      // Make sure that all of the callbacks have made it through the                                             //\n                      // multiplexer and been delivered to ObserveHandles before committing                                       //\n                      // writes.                                                                                                  //\n                      driver._multiplexer.onFlush(function () {\n                        // 171\n                        write.committed(); // 172\n                      }); // 173\n                    } else {\n                        // 174\n                        driver._writesToCommitWhenWeReachSteady.push(write); // 175\n                      } // 176\n                  }); // 177\n                }); // 178\n              })); // 179\n              //\n              // When Mongo fails over, we need to repoll the query, in case we processed an                                      //\n              // oplog entry that got rolled back.                                                                                //\n              self._stopHandles.push(self._mongoHandle._onFailover(finishIfNeedToPollQuery(function () {\n                // 184\n                self._needToPollQuery(); // 186\n              }))); // 187\n              //\n              // Give _observeChanges a chance to add the new ObserveHandle to our                                                //\n              // multiplexer, so that the added calls get streamed.                                                               //\n              Meteor.defer(finishIfNeedToPollQuery(function () {\n                // 191\n                self._runInitialQuery(); // 192\n              })); // 193\n            }; // 194\n            //\n            _.extend(OplogObserveDriver.prototype, { // 196\n              _addPublished: function _addPublished(id, doc) {\n                // 197\n                var self = this; // 198\n                Meteor._noYieldsAllowed(function () {\n                  // 199\n                  var fields = _.clone(doc); // 200\n                  delete fields._id; // 201\n                  self._published.set(id, self._sharedProjectionFn(doc)); // 202\n                  self._multiplexer.added(id, self._projectionFn(fields)); // 203\n                  //\n                  // After adding this document, the published set might be overflowed                                            //\n                  // (exceeding capacity specified by limit). If so, push the maximum                                             //\n                  // element to the buffer, we might want to save it in memory to reduce the                                      //\n                  // amount of Mongo lookups in the future.                                                                       //\n                  if (self._limit && self._published.size() > self._limit) {\n                    // 209\n                    // XXX in theory the size of published is no more than limit+1                                                //\n                    if (self._published.size() !== self._limit + 1) {\n                      // 211\n                      throw new Error(\"After adding to published, \" + (self._published.size() - self._limit) + \" documents are overflowing the set\");\n                    } // 215\n                    //\n                    var overflowingDocId = self._published.maxElementId(); // 217\n                    var overflowingDoc = self._published.get(overflowingDocId); // 218\n                    //\n                    if (EJSON.equals(overflowingDocId, id)) {\n                      // 220\n                      throw new Error(\"The document just added is overflowing the published set\"); // 221\n                    } // 222\n                    //\n                    self._published.remove(overflowingDocId); // 224\n                    self._multiplexer.removed(overflowingDocId); // 225\n                    self._addBuffered(overflowingDocId, overflowingDoc); // 226\n                  } // 227\n                }); // 228\n              }, // 229\n              _removePublished: function _removePublished(id) {\n                // 230\n                var self = this; // 231\n                Meteor._noYieldsAllowed(function () {\n                  // 232\n                  self._published.remove(id); // 233\n                  self._multiplexer.removed(id); // 234\n                  if (!self._limit || self._published.size() === self._limit) return; // 235\n                  //\n                  if (self._published.size() > self._limit) throw Error(\"self._published got too big\"); // 238\n                  //\n                  // OK, we are publishing less than the limit. Maybe we should look in the                                       //\n                  // buffer to find the next element past what we were publishing before.                                         //\n                  //\n                  if (!self._unpublishedBuffer.empty()) {\n                    // 244\n                    // There's something in the buffer; move the first thing in it to                                             //\n                    // _published.                                                                                                //\n                    var newDocId = self._unpublishedBuffer.minElementId(); // 247\n                    var newDoc = self._unpublishedBuffer.get(newDocId); // 248\n                    self._removeBuffered(newDocId); // 249\n                    self._addPublished(newDocId, newDoc); // 250\n                    return; // 251\n                  } // 252\n                  //\n                  // There's nothing in the buffer.  This could mean one of a few things.                                         //\n                  //\n                  // (a) We could be in the middle of re-running the query (specifically, we                                      //\n                  // could be in _publishNewResults). In that case, _unpublishedBuffer is                                         //\n                  // empty because we clear it at the beginning of _publishNewResults. In                                         //\n                  // this case, our caller already knows the entire answer to the query and                                       //\n                  // we don't need to do anything fancy here.  Just return.                                                       //\n                  if (self._phase === PHASE.QUERYING) return; // 261\n                  //\n                  // (b) We're pretty confident that the union of _published and                                                  //\n                  // _unpublishedBuffer contain all documents that match selector. Because                                        //\n                  // _unpublishedBuffer is empty, that means we're confident that _published                                      //\n                  // contains all documents that match selector. So we have nothing to do.                                        //\n                  if (self._safeAppendToBuffer) return; // 268\n                  //\n                  // (c) Maybe there are other documents out there that should be in our                                          //\n                  // buffer. But in that case, when we emptied _unpublishedBuffer in                                              //\n                  // _removeBuffered, we should have called _needToPollQuery, which will                                          //\n                  // either put something in _unpublishedBuffer or set _safeAppendToBuffer                                        //\n                  // (or both), and it will put us in QUERYING for that whole time. So in                                         //\n                  // fact, we shouldn't be able to get here.                                                                      //\n                  //\n                  throw new Error(\"Buffer inexplicably empty\"); // 278\n                }); // 279\n              }, // 280\n              _changePublished: function _changePublished(id, oldDoc, newDoc) {\n                // 281\n                var self = this; // 282\n                Meteor._noYieldsAllowed(function () {\n                  // 283\n                  self._published.set(id, self._sharedProjectionFn(newDoc)); // 284\n                  var projectedNew = self._projectionFn(newDoc); // 285\n                  var projectedOld = self._projectionFn(oldDoc); // 286\n                  var changed = DiffSequence.makeChangedFields(projectedNew, projectedOld); // 287\n                  if (!_.isEmpty(changed)) self._multiplexer.changed(id, changed); // 289\n                }); // 291\n              }, // 292\n              _addBuffered: function _addBuffered(id, doc) {\n                // 293\n                var self = this; // 294\n                Meteor._noYieldsAllowed(function () {\n                  // 295\n                  self._unpublishedBuffer.set(id, self._sharedProjectionFn(doc)); // 296\n                  //\n                  // If something is overflowing the buffer, we just remove it from cache                                         //\n                  if (self._unpublishedBuffer.size() > self._limit) {\n                    // 299\n                    var maxBufferedId = self._unpublishedBuffer.maxElementId(); // 300\n                    //\n                    self._unpublishedBuffer.remove(maxBufferedId); // 302\n                    //\n                    // Since something matching is removed from cache (both published set and                                     //\n                    // buffer), set flag to false                                                                                 //\n                    self._safeAppendToBuffer = false; // 306\n                  } // 307\n                }); // 308\n              }, // 309\n              // Is called either to remove the doc completely from matching set or to move                                       //\n              // it to the published set later.                                                                                   //\n              _removeBuffered: function _removeBuffered(id) {\n                // 312\n                var self = this; // 313\n                Meteor._noYieldsAllowed(function () {\n                  // 314\n                  self._unpublishedBuffer.remove(id); // 315\n                  // To keep the contract \"buffer is never empty in STEADY phase unless the                                       //\n                  // everything matching fits into published\" true, we poll everything as                                         //\n                  // soon as we see the buffer becoming empty.                                                                    //\n                  if (!self._unpublishedBuffer.size() && !self._safeAppendToBuffer) self._needToPollQuery(); // 319\n                }); // 321\n              }, // 322\n              // Called when a document has joined the \"Matching\" results set.                                                    //\n              // Takes responsibility of keeping _unpublishedBuffer in sync with _published                                       //\n              // and the effect of limit enforced.                                                                                //\n              _addMatching: function _addMatching(doc) {\n                // 326\n                var self = this; // 327\n                Meteor._noYieldsAllowed(function () {\n                  // 328\n                  var id = doc._id; // 329\n                  if (self._published.has(id)) throw Error(\"tried to add something already published \" + id); // 330\n                  if (self._limit && self._unpublishedBuffer.has(id)) throw Error(\"tried to add something already existed in buffer \" + id);\n                  //\n                  var limit = self._limit; // 335\n                  var comparator = self._comparator; // 336\n                  var maxPublished = limit && self._published.size() > 0 ? self._published.get(self._published.maxElementId()) : null;\n                  var maxBuffered = limit && self._unpublishedBuffer.size() > 0 ? self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId()) : null;\n                  // The query is unlimited or didn't publish enough documents yet or the                                         //\n                  // new document would fit into published set pushing the maximum element                                        //\n                  // out, then we need to publish the doc.                                                                        //\n                  var toPublish = !limit || self._published.size() < limit || comparator(doc, maxPublished) < 0; // 345\n                  //\n                  // Otherwise we might need to buffer it (only in case of limited query).                                        //\n                  // Buffering is allowed if the buffer is not filled up yet and all                                              //\n                  // matching docs are either in the published set or in the buffer.                                              //\n                  var canAppendToBuffer = !toPublish && self._safeAppendToBuffer && self._unpublishedBuffer.size() < limit; // 351\n                  //\n                  // Or if it is small enough to be safely inserted to the middle or the                                          //\n                  // beginning of the buffer.                                                                                     //\n                  var canInsertIntoBuffer = !toPublish && maxBuffered && comparator(doc, maxBuffered) <= 0; // 356\n                  //\n                  var toBuffer = canAppendToBuffer || canInsertIntoBuffer; // 359\n                  //\n                  if (toPublish) {\n                    // 361\n                    self._addPublished(id, doc); // 362\n                  } else if (toBuffer) {\n                      // 363\n                      self._addBuffered(id, doc); // 364\n                    } else {\n                        // 365\n                        // dropping it and not saving to the cache                                                                    //\n                        self._safeAppendToBuffer = false; // 367\n                      } // 368\n                }); // 369\n              }, // 370\n              // Called when a document leaves the \"Matching\" results set.                                                        //\n              // Takes responsibility of keeping _unpublishedBuffer in sync with _published                                       //\n              // and the effect of limit enforced.                                                                                //\n              _removeMatching: function _removeMatching(id) {\n                // 374\n                var self = this; // 375\n                Meteor._noYieldsAllowed(function () {\n                  // 376\n                  if (!self._published.has(id) && !self._limit) throw Error(\"tried to remove something matching but not cached \" + id);\n                  //\n                  if (self._published.has(id)) {\n                    // 380\n                    self._removePublished(id); // 381\n                  } else if (self._unpublishedBuffer.has(id)) {\n                      // 382\n                      self._removeBuffered(id); // 383\n                    } // 384\n                }); // 385\n              }, // 386\n              _handleDoc: function _handleDoc(id, newDoc) {\n                // 387\n                var self = this; // 388\n                Meteor._noYieldsAllowed(function () {\n                  // 389\n                  var matchesNow = newDoc && self._matcher.documentMatches(newDoc).result; // 390\n                  //\n                  var publishedBefore = self._published.has(id); // 392\n                  var bufferedBefore = self._limit && self._unpublishedBuffer.has(id); // 393\n                  var cachedBefore = publishedBefore || bufferedBefore; // 394\n                  //\n                  if (matchesNow && !cachedBefore) {\n                    // 396\n                    self._addMatching(newDoc); // 397\n                  } else if (cachedBefore && !matchesNow) {\n                      // 398\n                      self._removeMatching(id); // 399\n                    } else if (cachedBefore && matchesNow) {\n                        // 400\n                        var oldDoc = self._published.get(id); // 401\n                        var comparator = self._comparator; // 402\n                        var minBuffered = self._limit && self._unpublishedBuffer.size() && self._unpublishedBuffer.get(self._unpublishedBuffer.minElementId());\n                        //\n                        if (publishedBefore) {\n                          // 406\n                          // Unlimited case where the document stays in published once it                                             //\n                          // matches or the case when we don't have enough matching docs to                                           //\n                          // publish or the changed but matching doc will stay in published                                           //\n                          // anyways.                                                                                                 //\n                          //                                                                                                          //\n                          // XXX: We rely on the emptiness of buffer. Be sure to maintain the                                         //\n                          // fact that buffer can't be empty if there are matching documents not                                      //\n                          // published. Notably, we don't want to schedule repoll and continue                                        //\n                          // relying on this property.                                                                                //\n                          var staysInPublished = !self._limit || self._unpublishedBuffer.size() === 0 || comparator(newDoc, minBuffered) <= 0;\n                          //\n                          if (staysInPublished) {\n                            // 420\n                            self._changePublished(id, oldDoc, newDoc); // 421\n                          } else {\n                              // 422\n                              // after the change doc doesn't stay in the published, remove it                                          //\n                              self._removePublished(id); // 424\n                              // but it can move into buffered now, check it                                                            //\n                              var maxBuffered = self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId()); // 426\n                              //\n                              var toBuffer = self._safeAppendToBuffer || maxBuffered && comparator(newDoc, maxBuffered) <= 0; // 429\n                              //\n                              if (toBuffer) {\n                                // 432\n                                self._addBuffered(id, newDoc); // 433\n                              } else {\n                                  // 434\n                                  // Throw away from both published set and buffer                                                        //\n                                  self._safeAppendToBuffer = false; // 436\n                                } // 437\n                            } // 438\n                        } else if (bufferedBefore) {\n                            // 439\n                            oldDoc = self._unpublishedBuffer.get(id); // 440\n                            // remove the old version manually instead of using _removeBuffered so                                      //\n                            // we don't trigger the querying immediately.  if we end this block                                         //\n                            // with the buffer empty, we will need to trigger the query poll                                            //\n                            // manually too.                                                                                            //\n                            self._unpublishedBuffer.remove(id); // 445\n                            //\n                            var maxPublished = self._published.get(self._published.maxElementId()); // 447\n                            var maxBuffered = self._unpublishedBuffer.size() && self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId());\n                            //\n                            // the buffered doc was updated, it could move to published                                                 //\n                            var toPublish = comparator(newDoc, maxPublished) < 0; // 454\n                            //\n                            // or stays in buffer even after the change                                                                 //\n                            var staysInBuffer = !toPublish && self._safeAppendToBuffer || !toPublish && maxBuffered && comparator(newDoc, maxBuffered) <= 0;\n                            //\n                            if (toPublish) {\n                              // 461\n                              self._addPublished(id, newDoc); // 462\n                            } else if (staysInBuffer) {\n                                // 463\n                                // stays in buffer but changes                                                                            //\n                                self._unpublishedBuffer.set(id, newDoc); // 465\n                              } else {\n                                  // 466\n                                  // Throw away from both published set and buffer                                                          //\n                                  self._safeAppendToBuffer = false; // 468\n                                  // Normally this check would have been done in _removeBuffered but                                        //\n                                  // we didn't use it, so we need to do it ourself now.                                                     //\n                                  if (!self._unpublishedBuffer.size()) {\n                                    // 471\n                                    self._needToPollQuery(); // 472\n                                  } // 473\n                                } // 474\n                          } else {\n                              // 475\n                              throw new Error(\"cachedBefore implies either of publishedBefore or bufferedBefore is true.\"); // 476\n                            } // 477\n                      } // 478\n                }); // 479\n              }, // 480\n              _fetchModifiedDocuments: function _fetchModifiedDocuments() {\n                // 481\n                var self = this; // 482\n                Meteor._noYieldsAllowed(function () {\n                  // 483\n                  self._registerPhaseChange(PHASE.FETCHING); // 484\n                  // Defer, because nothing called from the oplog entry handler may yield,                                        //\n                  // but fetch() yields.                                                                                          //\n                  Meteor.defer(finishIfNeedToPollQuery(function () {\n                    // 487\n                    while (!self._stopped && !self._needToFetch.empty()) {\n                      // 488\n                      if (self._phase === PHASE.QUERYING) {\n                        // 489\n                        // While fetching, we decided to go into QUERYING mode, and then we                                       //\n                        // saw another oplog entry, so _needToFetch is not empty. But we                                          //\n                        // shouldn't fetch these documents until AFTER the query is done.                                         //\n                        break; // 493\n                      } // 494\n                      //\n                      // Being in steady phase here would be surprising.                                                          //\n                      if (self._phase !== PHASE.FETCHING) throw new Error(\"phase in fetchModifiedDocuments: \" + self._phase); // 497\n                      //\n                      self._currentlyFetching = self._needToFetch; // 500\n                      var thisGeneration = ++self._fetchGeneration; // 501\n                      self._needToFetch = new LocalCollection._IdMap(); // 502\n                      var waiting = 0; // 503\n                      var fut = new Future(); // 504\n                      // This loop is safe, because _currentlyFetching will not be updated                                        //\n                      // during this loop (in fact, it is never mutated).                                                         //\n                      self._currentlyFetching.forEach(function (cacheKey, id) {\n                        // 507\n                        waiting++; // 508\n                        self._mongoHandle._docFetcher.fetch(self._cursorDescription.collectionName, id, cacheKey, finishIfNeedToPollQuery(function (err, doc) {\n                          try {\n                            // 512\n                            if (err) {\n                              // 513\n                              Meteor._debug(\"Got exception while fetching documents: \" + err); // 514\n                              // If we get an error from the fetcher (eg, trouble                                                 //\n                              // connecting to Mongo), let's just abandon the fetch phase                                         //\n                              // altogether and fall back to polling. It's not like we're                                         //\n                              // getting live updates anyway.                                                                     //\n                              if (self._phase !== PHASE.QUERYING) {\n                                // 520\n                                self._needToPollQuery(); // 521\n                              } // 522\n                            } else if (!self._stopped && self._phase === PHASE.FETCHING && self._fetchGeneration === thisGeneration) {\n                                // We re-check the generation in case we've had an explicit                                         //\n                                // _pollQuery call (eg, in another fiber) which should                                              //\n                                // effectively cancel this round of fetches.  (_pollQuery                                           //\n                                // increments the generation.)                                                                      //\n                                self._handleDoc(id, doc); // 529\n                              } // 530\n                          } finally {\n                            // 531\n                            waiting--; // 532\n                            // Because fetch() never calls its callback synchronously,                                            //\n                            // this is safe (ie, we won't call fut.return() before the                                            //\n                            // forEach is done).                                                                                  //\n                            if (waiting === 0) fut['return'](); // 536\n                          } // 538\n                        })); // 539\n                      }); // 540\n                      fut.wait(); // 541\n                      // Exit now if we've had a _pollQuery call (here or in another fiber).                                      //\n                      if (self._phase === PHASE.QUERYING) return; // 543\n                      self._currentlyFetching = null; // 545\n                    } // 546\n                    // We're done fetching, so we can be steady, unless we've had a                                               //\n                    // _pollQuery call (here or in another fiber).                                                                //\n                    if (self._phase !== PHASE.QUERYING) self._beSteady(); // 549\n                  })); // 551\n                }); // 552\n              }, // 553\n              _beSteady: function _beSteady() {\n                // 554\n                var self = this; // 555\n                Meteor._noYieldsAllowed(function () {\n                  // 556\n                  self._registerPhaseChange(PHASE.STEADY); // 557\n                  var writes = self._writesToCommitWhenWeReachSteady; // 558\n                  self._writesToCommitWhenWeReachSteady = []; // 559\n                  self._multiplexer.onFlush(function () {\n                    // 560\n                    _.each(writes, function (w) {\n                      // 561\n                      w.committed(); // 562\n                    }); // 563\n                  }); // 564\n                }); // 565\n              }, // 566\n              _handleOplogEntryQuerying: function _handleOplogEntryQuerying(op) {\n                // 567\n                var self = this; // 568\n                Meteor._noYieldsAllowed(function () {\n                  // 569\n                  self._needToFetch.set(idForOp(op), op.ts.toString()); // 570\n                }); // 571\n              }, // 572\n              _handleOplogEntrySteadyOrFetching: function _handleOplogEntrySteadyOrFetching(op) {\n                // 573\n                var self = this; // 574\n                Meteor._noYieldsAllowed(function () {\n                  // 575\n                  var id = idForOp(op); // 576\n                  // If we're already fetching this one, or about to, we can't optimize;                                          //\n                  // make sure that we fetch it again if necessary.                                                               //\n                  if (self._phase === PHASE.FETCHING && (self._currentlyFetching && self._currentlyFetching.has(id) || self._needToFetch.has(id))) {\n                    self._needToFetch.set(id, op.ts.toString()); // 582\n                    return; // 583\n                  } // 584\n                  //\n                  if (op.op === 'd') {\n                    // 586\n                    if (self._published.has(id) || self._limit && self._unpublishedBuffer.has(id)) self._removeMatching(id); // 587\n                  } else if (op.op === 'i') {\n                      // 590\n                      if (self._published.has(id)) throw new Error(\"insert found for already-existing ID in published\"); // 591\n                      if (self._unpublishedBuffer && self._unpublishedBuffer.has(id)) throw new Error(\"insert found for already-existing ID in buffer\");\n                      //\n                      // XXX what if selector yields?  for now it can't but later it could                                          //\n                      // have $where                                                                                                //\n                      if (self._matcher.documentMatches(op.o).result) self._addMatching(op.o); // 598\n                    } else if (op.op === 'u') {\n                        // 600\n                        // Is this a modifier ($set/$unset, which may require us to poll the                                          //\n                        // database to figure out if the whole document matches the selector) or                                      //\n                        // a replacement (in which case we can just directly re-evaluate the                                          //\n                        // selector)?                                                                                                 //\n                        var isReplace = !_.has(op.o, '$set') && !_.has(op.o, '$unset'); // 605\n                        // If this modifier modifies something inside an EJSON custom type (ie,                                       //\n                        // anything with EJSON$), then we can't try to use                                                            //\n                        // LocalCollection._modify, since that just mutates the EJSON encoding,                                       //\n                        // not the actual object.                                                                                     //\n                        var canDirectlyModifyDoc = !isReplace && modifierCanBeDirectlyApplied(op.o); // 610\n                        //\n                        var publishedBefore = self._published.has(id); // 613\n                        var bufferedBefore = self._limit && self._unpublishedBuffer.has(id); // 614\n                        //\n                        if (isReplace) {\n                          // 616\n                          self._handleDoc(id, _.extend({ _id: id }, op.o)); // 617\n                        } else if ((publishedBefore || bufferedBefore) && canDirectlyModifyDoc) {\n                            // 618\n                            // Oh great, we actually know what the document is, so we can apply                                         //\n                            // this directly.                                                                                           //\n                            var newDoc = self._published.has(id) ? self._published.get(id) : self._unpublishedBuffer.get(id); // 622\n                            newDoc = EJSON.clone(newDoc); // 624\n                            //\n                            newDoc._id = id; // 626\n                            try {\n                              // 627\n                              LocalCollection._modify(newDoc, op.o); // 628\n                            } catch (e) {\n                              // 629\n                              if (e.name !== \"MinimongoError\") throw e; // 630\n                              // We didn't understand the modifier.  Re-fetch.                                                          //\n                              self._needToFetch.set(id, op.ts.toString()); // 633\n                              if (self._phase === PHASE.STEADY) {\n                                // 634\n                                self._fetchModifiedDocuments(); // 635\n                              } // 636\n                              return; // 637\n                            } // 638\n                            self._handleDoc(id, self._sharedProjectionFn(newDoc)); // 639\n                          } else if (!canDirectlyModifyDoc || self._matcher.canBecomeTrueByModifier(op.o) || self._sorter && self._sorter.affectedByModifier(op.o)) {\n                              self._needToFetch.set(id, op.ts.toString()); // 643\n                              if (self._phase === PHASE.STEADY) self._fetchModifiedDocuments(); // 644\n                            } // 646\n                      } else {\n                          // 647\n                          throw Error(\"XXX SURPRISING OPERATION: \" + op); // 648\n                        } // 649\n                }); // 650\n              }, // 651\n              // Yields!                                                                                                          //\n              _runInitialQuery: function _runInitialQuery() {\n                // 653\n                var self = this; // 654\n                if (self._stopped) throw new Error(\"oplog stopped surprisingly early\"); // 655\n                //\n                self._runQuery({ initial: true }); // yields                                                                      // 658\n                //\n                if (self._stopped) return; // can happen on queryError                                                            // 660\n                //\n                // Allow observeChanges calls to return. (After this, it's possible for                                           //\n                // stop() to be called.)                                                                                          //\n                self._multiplexer.ready(); // 665\n                //\n                self._doneQuerying(); // yields                                                                                   // 667\n              }, // 668\n              //\n              // In various circumstances, we may just want to stop processing the oplog and                                      //\n              // re-run the initial query, just as if we were a PollingObserveDriver.                                             //\n              //                                                                                                                  //\n              // This function may not block, because it is called from an oplog entry                                            //\n              // handler.                                                                                                         //\n              //                                                                                                                  //\n              // XXX We should call this when we detect that we've been in FETCHING for \"too                                      //\n              // long\".                                                                                                           //\n              //                                                                                                                  //\n              // XXX We should call this when we detect Mongo failover (since that might                                          //\n              // mean that some of the oplog entries we have processed have been rolled                                           //\n              // back). The Node Mongo driver is in the middle of a bunch of huge                                                 //\n              // refactorings, including the way that it notifies you when primary                                                //\n              // changes. Will put off implementing this until driver 1.4 is out.                                                 //\n              _pollQuery: function _pollQuery() {\n                // 684\n                var self = this; // 685\n                Meteor._noYieldsAllowed(function () {\n                  // 686\n                  if (self._stopped) return; // 687\n                  //\n                  // Yay, we get to forget about all the things we thought we had to fetch.                                       //\n                  self._needToFetch = new LocalCollection._IdMap(); // 691\n                  self._currentlyFetching = null; // 692\n                  ++self._fetchGeneration; // ignore any in-flight fetches                                                        // 693\n                  self._registerPhaseChange(PHASE.QUERYING); // 694\n                  //\n                  // Defer so that we don't yield.  We don't need finishIfNeedToPollQuery                                         //\n                  // here because SwitchedToQuery is not thrown in QUERYING mode.                                                 //\n                  Meteor.defer(function () {\n                    // 698\n                    self._runQuery(); // 699\n                    self._doneQuerying(); // 700\n                  }); // 701\n                }); // 702\n              }, // 703\n              //\n              // Yields!                                                                                                          //\n              _runQuery: function _runQuery(options) {\n                // 706\n                var self = this; // 707\n                options = options || {}; // 708\n                var newResults, newBuffer; // 709\n                //\n                // This while loop is just to retry failures.                                                                     //\n                while (true) {\n                  // 712\n                  // If we've been stopped, we don't have to run anything any more.                                               //\n                  if (self._stopped) return; // 714\n                  //\n                  newResults = new LocalCollection._IdMap(); // 717\n                  newBuffer = new LocalCollection._IdMap(); // 718\n                  //\n                  // Query 2x documents as the half excluded from the original query will go                                      //\n                  // into unpublished buffer to reduce additional Mongo lookups in cases                                          //\n                  // when documents are removed from the published set and need a                                                 //\n                  // replacement.                                                                                                 //\n                  // XXX needs more thought on non-zero skip                                                                      //\n                  // XXX 2 is a \"magic number\" meaning there is an extra chunk of docs for                                        //\n                  // buffer if such is needed.                                                                                    //\n                  var cursor = self._cursorForQuery({ limit: self._limit * 2 }); // 727\n                  try {\n                    // 728\n                    cursor.forEach(function (doc, i) {\n                      // 729\n                      // yields                                                                                                   //\n                      if (!self._limit || i < self._limit) newResults.set(doc._id, doc);else newBuffer.set(doc._id, doc); // 730\n                    }); // 734\n                    break; // 735\n                  } catch (e) {\n                    // 736\n                    if (options.initial && typeof e.code === 'number') {\n                      // 737\n                      // This is an error document sent to us by mongod, not a connection                                         //\n                      // error generated by the client. And we've never seen this query work                                      //\n                      // successfully. Probably it's a bad selector or something, so we                                           //\n                      // should NOT retry. Instead, we should halt the observe (which ends                                        //\n                      // up calling `stop` on us).                                                                                //\n                      self._multiplexer.queryError(e); // 743\n                      return; // 744\n                    } // 745\n                    //\n                    // During failover (eg) if we get an exception we should log and retry                                        //\n                    // instead of crashing.                                                                                       //\n                    Meteor._debug(\"Got exception while polling query: \" + e); // 749\n                    Meteor._sleepForMs(100); // 750\n                  } // 751\n                } // 752\n                //\n                if (self._stopped) return; // 754\n                //\n                self._publishNewResults(newResults, newBuffer); // 757\n              }, // 758\n              //\n              // Transitions to QUERYING and runs another query, or (if already in QUERYING)                                      //\n              // ensures that we will query again later.                                                                          //\n              //                                                                                                                  //\n              // This function may not block, because it is called from an oplog entry                                            //\n              // handler. However, if we were not already in the QUERYING phase, it throws                                        //\n              // an exception that is caught by the closest surrounding                                                           //\n              // finishIfNeedToPollQuery call; this ensures that we don't continue running                                        //\n              // close that was designed for another phase inside PHASE.QUERYING.                                                 //\n              //                                                                                                                  //\n              // (It's also necessary whenever logic in this file yields to check that other                                      //\n              // phases haven't put us into QUERYING mode, though; eg,                                                            //\n              // _fetchModifiedDocuments does this.)                                                                              //\n              _needToPollQuery: function _needToPollQuery() {\n                // 772\n                var self = this; // 773\n                Meteor._noYieldsAllowed(function () {\n                  // 774\n                  if (self._stopped) return; // 775\n                  //\n                  // If we're not already in the middle of a query, we can query now                                              //\n                  // (possibly pausing FETCHING).                                                                                 //\n                  if (self._phase !== PHASE.QUERYING) {\n                    // 780\n                    self._pollQuery(); // 781\n                    throw new SwitchedToQuery(); // 782\n                  } // 783\n                  //\n                  // We're currently in QUERYING. Set a flag to ensure that we run another                                        //\n                  // query when we're done.                                                                                       //\n                  self._requeryWhenDoneThisQuery = true; // 787\n                }); // 788\n              }, // 789\n              //\n              // Yields!                                                                                                          //\n              _doneQuerying: function _doneQuerying() {\n                // 792\n                var self = this; // 793\n                //\n                if (self._stopped) return; // 795\n                self._mongoHandle._oplogHandle.waitUntilCaughtUp(); // yields                                                     // 797\n                if (self._stopped) return; // 798\n                if (self._phase !== PHASE.QUERYING) throw Error(\"Phase unexpectedly \" + self._phase); // 800\n                //\n                Meteor._noYieldsAllowed(function () {\n                  // 803\n                  if (self._requeryWhenDoneThisQuery) {\n                    // 804\n                    self._requeryWhenDoneThisQuery = false; // 805\n                    self._pollQuery(); // 806\n                  } else if (self._needToFetch.empty()) {\n                      // 807\n                      self._beSteady(); // 808\n                    } else {\n                        // 809\n                        self._fetchModifiedDocuments(); // 810\n                      } // 811\n                }); // 812\n              }, // 813\n              //\n              _cursorForQuery: function _cursorForQuery(optionsOverwrite) {\n                // 815\n                var self = this; // 816\n                return Meteor._noYieldsAllowed(function () {\n                  // 817\n                  // The query we run is almost the same as the cursor we are observing,                                          //\n                  // with a few changes. We need to read all the fields that are relevant to                                      //\n                  // the selector, not just the fields we are going to publish (that's the                                        //\n                  // \"shared\" projection). And we don't want to apply any transform in the                                        //\n                  // cursor, because observeChanges shouldn't use the transform.                                                  //\n                  var options = _.clone(self._cursorDescription.options); // 823\n                  //\n                  // Allow the caller to modify the options. Useful to specify different                                          //\n                  // skip and limit values.                                                                                       //\n                  _.extend(options, optionsOverwrite); // 827\n                  //\n                  options.fields = self._sharedProjection; // 829\n                  delete options.transform; // 830\n                  // We are NOT deep cloning fields or selector here, which should be OK.                                         //\n                  var description = new CursorDescription(self._cursorDescription.collectionName, self._cursorDescription.selector, options);\n                  return new Cursor(self._mongoHandle, description); // 836\n                }); // 837\n              }, // 838\n              //\n              // Replace self._published with newResults (both are IdMaps), invoking observe                                      //\n              // callbacks on the multiplexer.                                                                                    //\n              // Replace self._unpublishedBuffer with newBuffer.                                                                  //\n              //                                                                                                                  //\n              // XXX This is very similar to LocalCollection._diffQueryUnorderedChanges. We                                       //\n              // should really: (a) Unify IdMap and OrderedDict into Unordered/OrderedDict                                        //\n              // (b) Rewrite diff.js to use these classes instead of arrays and objects.                                          //\n              _publishNewResults: function _publishNewResults(newResults, newBuffer) {\n                // 848\n                var self = this; // 849\n                Meteor._noYieldsAllowed(function () {\n                  // 850\n                  //\n                  // If the query is limited and there is a buffer, shut down so it doesn't                                       //\n                  // stay in a way.                                                                                               //\n                  if (self._limit) {\n                    // 854\n                    self._unpublishedBuffer.clear(); // 855\n                  } // 856\n                  //\n                  // First remove anything that's gone. Be careful not to modify                                                  //\n                  // self._published while iterating over it.                                                                     //\n                  var idsToRemove = []; // 860\n                  self._published.forEach(function (doc, id) {\n                    // 861\n                    if (!newResults.has(id)) idsToRemove.push(id); // 862\n                  }); // 864\n                  _.each(idsToRemove, function (id) {\n                    // 865\n                    self._removePublished(id); // 866\n                  }); // 867\n                  //\n                  // Now do adds and changes.                                                                                     //\n                  // If self has a buffer and limit, the new fetched result will be                                               //\n                  // limited correctly as the query has sort specifier.                                                           //\n                  newResults.forEach(function (doc, id) {\n                    // 872\n                    self._handleDoc(id, doc); // 873\n                  }); // 874\n                  //\n                  // Sanity-check that everything we tried to put into _published ended up                                        //\n                  // there.                                                                                                       //\n                  // XXX if this is slow, remove it later                                                                         //\n                  if (self._published.size() !== newResults.size()) {\n                    // 879\n                    throw Error(\"The Mongo server and the Meteor query disagree on how \" + \"many documents match your query. Maybe it is hitting a Mongo \" + \"edge case? The query is: \" + EJSON.stringify(self._cursorDescription.selector));\n                  } // 885\n                  self._published.forEach(function (doc, id) {\n                    // 886\n                    if (!newResults.has(id)) throw Error(\"_published has a doc that newResults doesn't; \" + id); // 887\n                  }); // 889\n                  //\n                  // Finally, replace the buffer                                                                                  //\n                  newBuffer.forEach(function (doc, id) {\n                    // 892\n                    self._addBuffered(id, doc); // 893\n                  }); // 894\n                  //\n                  self._safeAppendToBuffer = newBuffer.size() < self._limit; // 896\n                }); // 897\n              }, // 898\n              //\n              // This stop function is invoked from the onStop of the ObserveMultiplexer, so                                      //\n              // it shouldn't actually be possible to call it until the multiplexer is                                            //\n              // ready.                                                                                                           //\n              //                                                                                                                  //\n              // It's important to check self._stopped after every call in this file that                                         //\n              // can yield!                                                                                                       //\n              stop: function stop() {\n                // 906\n                var self = this; // 907\n                if (self._stopped) return; // 908\n                self._stopped = true; // 910\n                _.each(self._stopHandles, function (handle) {\n                  // 911\n                  handle.stop(); // 912\n                }); // 913\n                //\n                // Note: we *don't* use multiplexer.onFlush here because this stop                                                //\n                // callback is actually invoked by the multiplexer itself when it has                                             //\n                // determined that there are no handles left. So nothing is actually going                                        //\n                // to get flushed (and it's probably not valid to call methods on the                                             //\n                // dying multiplexer).                                                                                            //\n                _.each(self._writesToCommitWhenWeReachSteady, function (w) {\n                  // 920\n                  w.committed(); // maybe yields?                                                                                 // 921\n                }); // 922\n                self._writesToCommitWhenWeReachSteady = null; // 923\n                //\n                // Proactively drop references to potentially big things.                                                         //\n                self._published = null; // 926\n                self._unpublishedBuffer = null; // 927\n                self._needToFetch = null; // 928\n                self._currentlyFetching = null; // 929\n                self._oplogEntryHandle = null; // 930\n                self._listenersHandle = null; // 931\n                //\n                Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-oplog\", -1); // 933\n              }, // 935\n              //\n              _registerPhaseChange: function _registerPhaseChange(phase) {\n                // 937\n                var self = this; // 938\n                Meteor._noYieldsAllowed(function () {\n                  // 939\n                  var now = new Date(); // 940\n                  //\n                  if (self._phase) {\n                    // 942\n                    var timeDiff = now - self._phaseStartTime; // 943\n                    Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"time-spent-in-\" + self._phase + \"-phase\", timeDiff);\n                  } // 946\n                  //\n                  self._phase = phase; // 948\n                  self._phaseStartTime = now; // 949\n                }); // 950\n              } // 951\n            }); // 196\n            //\n            // Does our oplog tailing code support this cursor? For now, we are being very                                        //\n            // conservative and allowing only simple queries with simple options.                                                 //\n            // (This is a \"static method\".)                                                                                       //\n            OplogObserveDriver.cursorSupported = function (cursorDescription, matcher) {\n              // 957\n              // First, check the options.                                                                                        //\n              var options = cursorDescription.options; // 959\n              //\n              // Did the user say no explicitly?                                                                                  //\n              // underscored version of the option is COMPAT with 1.2                                                             //\n              if (options.disableOplog || options._disableOplog) return false; // 963\n              //\n              // skip is not supported: to support it we would need to keep track of all                                          //\n              // \"skipped\" documents or at least their ids.                                                                       //\n              // limit w/o a sort specifier is not supported: current implementation needs a                                      //\n              // deterministic way to order documents.                                                                            //\n              if (options.skip || options.limit && !options.sort) return false; // 970\n              //\n              // If a fields projection option is given check if it is supported by                                               //\n              // minimongo (some operators are not supported).                                                                    //\n              if (options.fields) {\n                // 974\n                try {\n                  // 975\n                  LocalCollection._checkSupportedProjection(options.fields); // 976\n                } catch (e) {\n                  // 977\n                  if (e.name === \"MinimongoError\") return false;else throw e; // 978\n                } // 982\n              } // 983\n              //\n              // We don't allow the following selectors:                                                                          //\n              //   - $where (not confident that we provide the same JS environment                                                //\n              //             as Mongo, and can yield!)                                                                            //\n              //   - $near (has \"interesting\" properties in MongoDB, like the possibility                                         //\n              //            of returning an ID multiple times, though even polling maybe                                          //\n              //            have a bug there)                                                                                     //\n              //           XXX: once we support it, we would need to think more on how we                                         //\n              //           initialize the comparators when we create the driver.                                                  //\n              return !matcher.hasWhere() && !matcher.hasGeoQuery(); // 993\n            }; // 994\n            //\n            var modifierCanBeDirectlyApplied = function modifierCanBeDirectlyApplied(modifier) {\n              // 996\n              return _.all(modifier, function (fields, operation) {\n                // 997\n                return _.all(fields, function (value, field) {\n                  // 998\n                  return !/EJSON\\$/.test(field); // 999\n                }); // 1000\n              }); // 1001\n            }; // 1002\n            //\n            MongoInternals.OplogObserveDriver = OplogObserveDriver; // 1004\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }, \"local_collection_driver.js\": function local_collection_driverJs() {\n\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/mongo/local_collection_driver.js                                                                          //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            LocalCollectionDriver = function LocalCollectionDriver() {\n              // 1\n              var self = this; // 2\n              self.noConnCollections = {}; // 3\n            }; // 4\n            //\n            var ensureCollection = function ensureCollection(name, collections) {\n              // 6\n              if (!(name in collections)) collections[name] = new LocalCollection(name); // 7\n              return collections[name]; // 9\n            }; // 10\n            //\n            _.extend(LocalCollectionDriver.prototype, { // 12\n              open: function open(name, conn) {\n                // 13\n                var self = this; // 14\n                if (!name) return new LocalCollection(); // 15\n                if (!conn) {\n                  // 17\n                  return ensureCollection(name, self.noConnCollections); // 18\n                } // 19\n                if (!conn._mongo_livedata_collections) conn._mongo_livedata_collections = {}; // 20\n                // XXX is there a way to keep track of a connection's collections without                                         //\n                // dangling it off the connection object?                                                                         //\n                return ensureCollection(name, conn._mongo_livedata_collections); // 24\n              } // 25\n            }); // 12\n            //\n            // singleton                                                                                                          //\n            LocalCollectionDriver = new LocalCollectionDriver(); // 29\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }, \"remote_collection_driver.js\": function remote_collection_driverJs(require) {\n\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/mongo/remote_collection_driver.js                                                                         //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            MongoInternals.RemoteCollectionDriver = function (mongo_url, options) {\n              // 1\n              var self = this; // 3\n              self.mongo = new MongoConnection(mongo_url, options); // 4\n            }; // 5\n            //\n            _.extend(MongoInternals.RemoteCollectionDriver.prototype, { // 7\n              open: function open(name) {\n                // 8\n                var self = this; // 9\n                var ret = {}; // 10\n                _.each(['find', 'findOne', 'insert', 'update', 'upsert', 'remove', '_ensureIndex', '_dropIndex', '_createCappedCollection', 'dropCollection', 'rawCollection'], function (m) {\n                  ret[m] = _.bind(self.mongo[m], self.mongo, name); // 16\n                }); // 17\n                return ret; // 18\n              } // 19\n            }); // 7\n            //\n            // Create the singleton RemoteCollectionDriver only on demand, so we                                                  //\n            // only require Mongo configuration if it's actually used (eg, not if                                                 //\n            // you're only trying to receive data from a remote DDP server.)                                                      //\n            MongoInternals.defaultRemoteCollectionDriver = _.once(function () {\n              // 26\n              var connectionOptions = {}; // 27\n              //\n              var mongoUrl = process.env.MONGO_URL; // 29\n              //\n              if (process.env.MONGO_OPLOG_URL) {\n                // 31\n                connectionOptions.oplogUrl = process.env.MONGO_OPLOG_URL; // 32\n              } // 33\n              //\n              if (!mongoUrl) throw new Error(\"MONGO_URL must be set in environment\"); // 35\n              //\n              return new MongoInternals.RemoteCollectionDriver(mongoUrl, connectionOptions); // 38\n            }); // 39\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }, \"collection.js\": function collectionJs(require, exports, module) {\n\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/mongo/collection.js                                                                                       //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            // options.connection, if given, is a LivedataClient or LivedataServer                                                //\n            // XXX presently there is no way to destroy/clean up a Collection                                                     //\n            //\n            /**                                                                                                                   //\n             * @summary Namespace for MongoDB-related items                                                                       //\n             * @namespace                                                                                                         //\n             */ //\n            Mongo = {}; // 8\n            //\n            /**                                                                                                                   //\n             * @summary Constructor for a Collection                                                                              //\n             * @locus Anywhere                                                                                                    //\n             * @instancename collection                                                                                           //\n             * @class                                                                                                             //\n             * @param {String} name The name of the collection.  If null, creates an unmanaged (unsynchronized) local collection.\n             * @param {Object} [options]                                                                                          //\n             * @param {Object} options.connection The server connection that will manage this collection. Uses the default connection if not specified.  Pass the return value of calling [`DDP.connect`](#ddp_connect) to specify a different server. Pass `null` to specify no connection. Unmanaged (`name` is null) collections cannot specify a connection.\n             * @param {String} options.idGeneration The method of generating the `_id` fields of new documents in this collection.  Possible values:\n                                                                                                                                  //\n             - **`'STRING'`**: random strings                                                                                     //\n             - **`'MONGO'`**:  random [`Mongo.ObjectID`](#mongo_object_id) values                                                 //\n                                                                                                                                  //\n            The default id generation technique is `'STRING'`.                                                                    //\n             * @param {Function} options.transform An optional transformation function. Documents will be passed through this function before being returned from `fetch` or `findOne`, and before being passed to callbacks of `observe`, `map`, `forEach`, `allow`, and `deny`. Transforms are *not* applied for the callbacks of `observeChanges` or to cursors returned from publish functions.\n             * @param {Boolean} options.defineMutationMethods Set to `false` to skip setting up the mutation methods that enable insert/update/remove from client code. Default `true`.\n             */ //\n            Mongo.Collection = function (name, options) {\n              // 27\n              var self = this; // 28\n              if (!(self instanceof Mongo.Collection)) throw new Error('use \"new\" to construct a Mongo.Collection'); // 29\n              //\n              if (!name && name !== null) {\n                // 32\n                Meteor._debug(\"Warning: creating anonymous collection. It will not be \" + \"saved or synchronized over the network. (Pass null for \" + \"the collection name to turn off this warning.)\");\n                name = null; // 36\n              } // 37\n              //\n              if (name !== null && typeof name !== \"string\") {\n                // 39\n                throw new Error(\"First argument to new Mongo.Collection must be a string or null\"); // 40\n              } // 42\n              //\n              if (options && options.methods) {\n                // 44\n                // Backwards compatibility hack with original signature (which passed                                             //\n                // \"connection\" directly instead of in options. (Connections must have a \"methods\"                                //\n                // method.)                                                                                                       //\n                // XXX remove before 1.0                                                                                          //\n                options = { connection: options }; // 49\n              } // 50\n              // Backwards compatibility: \"connection\" used to be called \"manager\".                                               //\n              if (options && options.manager && !options.connection) {\n                // 52\n                options.connection = options.manager; // 53\n              } // 54\n              options = _.extend({ // 55\n                connection: undefined, // 56\n                idGeneration: 'STRING', // 57\n                transform: null, // 58\n                _driver: undefined, // 59\n                _preventAutopublish: false // 60\n              }, options); // 55\n              //\n              switch (options.idGeneration) {// 63\n                case 'MONGO':\n                  // 64\n                  self._makeNewID = function () {\n                    // 65\n                    var src = name ? DDP.randomStream('/collection/' + name) : Random.insecure; // 66\n                    return new Mongo.ObjectID(src.hexString(24)); // 69\n                  }; // 70\n                  break; // 71\n                case 'STRING': // 72\n                default:\n                  // 73\n                  self._makeNewID = function () {\n                    // 74\n                    var src = name ? DDP.randomStream('/collection/' + name) : Random.insecure; // 75\n                    return src.id(); // 78\n                  }; // 79\n                  break; // 80\n              } // 63\n              //\n              self._transform = LocalCollection.wrapTransform(options.transform); // 83\n              //\n              if (!name || options.connection === null) // 85\n                // note: nameless collections never have a connection                                                             //\n                self._connection = null;else if (options.connection) self._connection = options.connection;else if (Meteor.isClient) self._connection = Meteor.connection;else self._connection = Meteor.server;\n              //\n              if (!options._driver) {\n                // 95\n                // XXX This check assumes that webapp is loaded so that Meteor.server !==                                         //\n                // null. We should fully support the case of \"want to use a Mongo-backed                                          //\n                // collection from Node code without webapp\", but we don't yet.                                                   //\n                // #MeteorServerNull                                                                                              //\n                if (name && self._connection === Meteor.server && typeof MongoInternals !== \"undefined\" && MongoInternals.defaultRemoteCollectionDriver) {\n                  options._driver = MongoInternals.defaultRemoteCollectionDriver(); // 103\n                } else {\n                    // 104\n                    options._driver = LocalCollectionDriver; // 105\n                  } // 106\n              } // 107\n              //\n              self._collection = options._driver.open(name, self._connection); // 109\n              self._name = name; // 110\n              self._driver = options._driver; // 111\n              //\n              if (self._connection && self._connection.registerStore) {\n                // 113\n                // OK, we're going to be a slave, replicating some remote                                                         //\n                // database, except possibly with some temporary divergence while                                                 //\n                // we have unacknowledged RPC's.                                                                                  //\n                var ok = self._connection.registerStore(name, { // 117\n                  // Called at the beginning of a batch of updates. batchSize is the number                                       //\n                  // of update calls to expect.                                                                                   //\n                  //                                                                                                              //\n                  // XXX This interface is pretty janky. reset probably ought to go back to                                       //\n                  // being its own function, and callers shouldn't have to calculate                                              //\n                  // batchSize. The optimization of not calling pause/remove should be                                            //\n                  // delayed until later: the first call to update() should buffer its                                            //\n                  // message, and then we can either directly apply it at endUpdate time if                                       //\n                  // it was the only update, or do pauseObservers/apply/apply at the next                                         //\n                  // update() if there's another one.                                                                             //\n                  beginUpdate: function beginUpdate(batchSize, reset) {\n                    // 128\n                    // pause observers so users don't see flicker when updating several                                           //\n                    // objects at once (including the post-reconnect reset-and-reapply                                            //\n                    // stage), and so that a re-sorting of a query can take advantage of the                                      //\n                    // full _diffQuery moved calculation instead of applying change one at a                                      //\n                    // time.                                                                                                      //\n                    if (batchSize > 1 || reset) self._collection.pauseObservers(); // 134\n                    //\n                    if (reset) self._collection.remove({}); // 137\n                  }, // 139\n                  //\n                  // Apply an update.                                                                                             //\n                  // XXX better specify this interface (not in terms of a wire message)?                                          //\n                  update: function update(msg) {\n                    // 143\n                    var mongoId = MongoID.idParse(msg.id); // 144\n                    var doc = self._collection.findOne(mongoId); // 145\n                    //\n                    // Is this a \"replace the whole doc\" message coming from the quiescence                                       //\n                    // of method writes to an object? (Note that 'undefined' is a valid                                           //\n                    // value meaning \"remove it\".)                                                                                //\n                    if (msg.msg === 'replace') {\n                      // 150\n                      var replace = msg.replace; // 151\n                      if (!replace) {\n                        // 152\n                        if (doc) self._collection.remove(mongoId); // 153\n                      } else if (!doc) {\n                          // 155\n                          self._collection.insert(replace); // 156\n                        } else {\n                            // 157\n                            // XXX check that replace has no $ ops                                                                    //\n                            self._collection.update(mongoId, replace); // 159\n                          } // 160\n                      return; // 161\n                    } else if (msg.msg === 'added') {\n                        // 162\n                        if (doc) {\n                          // 163\n                          throw new Error(\"Expected not to find a document already present for an add\"); // 164\n                        } // 165\n                        self._collection.insert(_.extend({ _id: mongoId }, msg.fields)); // 166\n                      } else if (msg.msg === 'removed') {\n                          // 167\n                          if (!doc) throw new Error(\"Expected to find a document already present for removed\"); // 168\n                          self._collection.remove(mongoId); // 170\n                        } else if (msg.msg === 'changed') {\n                            // 171\n                            if (!doc) throw new Error(\"Expected to find a document to change\"); // 172\n                            if (!_.isEmpty(msg.fields)) {\n                              // 174\n                              var modifier = {}; // 175\n                              _.each(msg.fields, function (value, key) {\n                                // 176\n                                if (value === undefined) {\n                                  // 177\n                                  if (!modifier.$unset) modifier.$unset = {}; // 178\n                                  modifier.$unset[key] = 1; // 180\n                                } else {\n                                    // 181\n                                    if (!modifier.$set) modifier.$set = {}; // 182\n                                    modifier.$set[key] = value; // 184\n                                  } // 185\n                              }); // 186\n                              self._collection.update(mongoId, modifier); // 187\n                            } // 188\n                          } else {\n                              // 189\n                              throw new Error(\"I don't know how to deal with this message\"); // 190\n                            } // 191\n                  }, // 193\n                  //\n                  // Called at the end of a batch of updates.                                                                     //\n                  endUpdate: function endUpdate() {\n                    // 196\n                    self._collection.resumeObservers(); // 197\n                  }, // 198\n                  //\n                  // Called around method stub invocations to capture the original versions                                       //\n                  // of modified documents.                                                                                       //\n                  saveOriginals: function saveOriginals() {\n                    // 202\n                    self._collection.saveOriginals(); // 203\n                  }, // 204\n                  retrieveOriginals: function retrieveOriginals() {\n                    // 205\n                    return self._collection.retrieveOriginals(); // 206\n                  }, // 207\n                  //\n                  // Used to preserve current versions of documents across a store reset.                                         //\n                  getDoc: function getDoc(id) {\n                    // 210\n                    return self.findOne(id); // 211\n                  }, // 212\n                  //\n                  // To be able to get back to the collection from the store.                                                     //\n                  _getCollection: function _getCollection() {\n                    // 215\n                    return self; // 216\n                  } // 217\n                }); // 117\n                //\n                if (!ok) {\n                  // 220\n                  var message = \"There is already a collection named \\\"\" + name + \"\\\"\"; // 221\n                  if (options._suppressSameNameError === true) {\n                    // 222\n                    // XXX In theory we do not have to throw when `ok` is falsy. The store is already defined                     //\n                    // for this collection name, but this will simply be another reference to it and everything                   //\n                    // should work. However, we have historically thrown an error here, so for now we will                        //\n                    // skip the error only when `_suppressSameNameError` is `true`, allowing people to opt in                     //\n                    // and give this some real world testing.                                                                     //\n                    console.warn ? console.warn(message) : console.log(message); // 228\n                  } else {\n                      // 229\n                      throw new Error(message); // 230\n                    } // 231\n                } // 232\n              } // 233\n              //\n              // XXX don't define these until allow or deny is actually used for this                                             //\n              // collection. Could be hard if the security rules are only defined on the                                          //\n              // server.                                                                                                          //\n              if (options.defineMutationMethods !== false) {\n                // 238\n                try {\n                  // 239\n                  self._defineMutationMethods({ useExisting: options._suppressSameNameError === true }); // 240\n                } catch (error) {\n                  // 241\n                  // Throw a more understandable error on the server for same collection name                                     //\n                  if (error.message === \"A method named '/\" + name + \"/insert' is already defined\") throw new Error(\"There is already a collection named \\\"\" + name + \"\\\"\");\n                  throw error; // 245\n                } // 246\n              } // 247\n              //\n              // autopublish                                                                                                      //\n              if (Package.autopublish && !options._preventAutopublish && self._connection && self._connection.publish) {\n                // 250\n                self._connection.publish(null, function () {\n                  // 252\n                  return self.find(); // 253\n                }, { is_auto: true }); // 254\n              } // 255\n            }; // 256\n            //\n            ///                                                                                                                   //\n            /// Main collection API                                                                                               //\n            ///                                                                                                                   //\n            //\n            _.extend(Mongo.Collection.prototype, { // 263\n              //\n              _getFindSelector: function _getFindSelector(args) {\n                // 265\n                if (args.length == 0) return {};else return args[0]; // 266\n              }, // 270\n              //\n              _getFindOptions: function _getFindOptions(args) {\n                // 272\n                var self = this; // 273\n                if (args.length < 2) {\n                  // 274\n                  return { transform: self._transform }; // 275\n                } else {\n                    // 276\n                    check(args[1], Match.Optional(Match.ObjectIncluding({ // 277\n                      fields: Match.Optional(Match.OneOf(Object, undefined)), // 278\n                      sort: Match.Optional(Match.OneOf(Object, Array, Function, undefined)), // 279\n                      limit: Match.Optional(Match.OneOf(Number, undefined)), // 280\n                      skip: Match.Optional(Match.OneOf(Number, undefined)) // 281\n                    }))); // 277\n                    //\n                    return _.extend({ // 284\n                      transform: self._transform // 285\n                    }, args[1]); // 284\n                  } // 287\n              }, // 288\n              //\n              /**                                                                                                                 //\n               * @summary Find the documents in a collection that match the selector.                                             //\n               * @locus Anywhere                                                                                                  //\n               * @method find                                                                                                     //\n               * @memberOf Mongo.Collection                                                                                       //\n               * @instance                                                                                                        //\n               * @param {MongoSelector} [selector] A query describing the documents to find                                       //\n               * @param {Object} [options]                                                                                        //\n               * @param {MongoSortSpecifier} options.sort Sort order (default: natural order)                                     //\n               * @param {Number} options.skip Number of results to skip at the beginning                                          //\n               * @param {Number} options.limit Maximum number of results to return                                                //\n               * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.                           //\n               * @param {Boolean} options.reactive (Client only) Default `true`; pass `false` to disable reactivity               //\n               * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections) for this cursor.  Pass `null` to disable transformation.\n               * @param {Boolean} options.disableOplog (Server only) Pass true to disable oplog-tailing on this query. This affects the way server processes calls to `observe` on this query. Disabling the oplog can be useful when working with data that updates in large batches.\n               * @param {Number} options.pollingIntervalMs (Server only) How often to poll this query when observing on the server. In milliseconds. Defaults to 10 seconds.\n               * @param {Number} options.pollingThrottleMs (Server only) Minimum time to allow between re-polling. Increasing this will save CPU and mongo load at the expense of slower updates to users. Decreasing this is not recommended. In milliseconds. Defaults to 50 milliseconds.\n               * @returns {Mongo.Cursor}                                                                                          //\n               */ //\n              find: function find() /* selector, options */{\n                // 309\n                // Collection.find() (return all docs) behaves differently                                                        //\n                // from Collection.find(undefined) (return 0 docs).  so be                                                        //\n                // careful about the length of arguments.                                                                         //\n                var self = this; // 313\n                var argArray = _.toArray(arguments); // 314\n                return self._collection.find(self._getFindSelector(argArray), self._getFindOptions(argArray)); // 315\n              }, // 317\n              //\n              /**                                                                                                                 //\n               * @summary Finds the first document that matches the selector, as ordered by sort and skip options. Returns `undefined` if no matching document is found.\n               * @locus Anywhere                                                                                                  //\n               * @method findOne                                                                                                  //\n               * @memberOf Mongo.Collection                                                                                       //\n               * @instance                                                                                                        //\n               * @param {MongoSelector} [selector] A query describing the documents to find                                       //\n               * @param {Object} [options]                                                                                        //\n               * @param {MongoSortSpecifier} options.sort Sort order (default: natural order)                                     //\n               * @param {Number} options.skip Number of results to skip at the beginning                                          //\n               * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.                           //\n               * @param {Boolean} options.reactive (Client only) Default true; pass false to disable reactivity                   //\n               * @param {Function} options.transform Overrides `transform` on the [`Collection`](#collections) for this cursor.  Pass `null` to disable transformation.\n               * @returns {Object}                                                                                                //\n               */ //\n              findOne: function findOne() /* selector, options */{\n                // 334\n                var self = this; // 335\n                var argArray = _.toArray(arguments); // 336\n                return self._collection.findOne(self._getFindSelector(argArray), self._getFindOptions(argArray)); // 337\n              } // 339\n              //\n            }); // 263\n            //\n            Mongo.Collection._publishCursor = function (cursor, sub, collection) {\n              // 343\n              var observeHandle = cursor.observeChanges({ // 344\n                added: function added(id, fields) {\n                  // 345\n                  sub.added(collection, id, fields); // 346\n                }, // 347\n                changed: function changed(id, fields) {\n                  // 348\n                  sub.changed(collection, id, fields); // 349\n                }, // 350\n                removed: function removed(id) {\n                  // 351\n                  sub.removed(collection, id); // 352\n                } // 353\n              }); // 344\n              //\n              // We don't call sub.ready() here: it gets called in livedata_server, after                                         //\n              // possibly calling _publishCursor on multiple returned cursors.                                                    //\n              //\n              // register stop callback (expects lambda w/ no args).                                                              //\n              sub.onStop(function () {\n                // 360\n                observeHandle.stop(); // 360\n              }); // 360\n              //\n              // return the observeHandle in case it needs to be stopped early                                                    //\n              return observeHandle; // 363\n            }; // 364\n            //\n            // protect against dangerous selectors.  falsey and {_id: falsey} are both                                            //\n            // likely programmer error, and not what you want, particularly for destructive                                       //\n            // operations.  JS regexps don't serialize over DDP but can be trivially                                              //\n            // replaced by $regex.                                                                                                //\n            Mongo.Collection._rewriteSelector = function (selector) {\n              // 370\n              // shorthand -- scalars match _id                                                                                   //\n              if (LocalCollection._selectorIsId(selector)) selector = { _id: selector }; // 372\n              //\n              if (_.isArray(selector)) {\n                // 375\n                // This is consistent with the Mongo console itself; if we don't do this                                          //\n                // check passing an empty array ends up selecting all items                                                       //\n                throw new Error(\"Mongo selector can't be an array.\"); // 378\n              } // 379\n              //\n              if (!selector || '_id' in selector && !selector._id) // 381\n                // can't match anything                                                                                           //\n                return { _id: Random.id() }; // 383\n              //\n              var ret = {}; // 385\n              _.each(selector, function (value, key) {\n                // 386\n                // Mongo supports both {field: /foo/} and {field: {$regex: /foo/}}                                                //\n                if (value instanceof RegExp) {\n                  // 388\n                  ret[key] = convertRegexpToMongoSelector(value); // 389\n                } else if (value && value.$regex instanceof RegExp) {\n                    // 390\n                    ret[key] = convertRegexpToMongoSelector(value.$regex); // 391\n                    // if value is {$regex: /foo/, $options: ...} then $options                                                     //\n                    // override the ones set on $regex.                                                                             //\n                    if (value.$options !== undefined) ret[key].$options = value.$options; // 394\n                  } else if (_.contains(['$or', '$and', '$nor'], key)) {\n                      // 396\n                      // Translate lower levels of $and/$or/$nor                                                                      //\n                      ret[key] = _.map(value, function (v) {\n                        // 399\n                        return Mongo.Collection._rewriteSelector(v); // 400\n                      }); // 401\n                    } else {\n                        // 402\n                        ret[key] = value; // 403\n                      } // 404\n              }); // 405\n              return ret; // 406\n            }; // 407\n            //\n            // convert a JS RegExp object to a Mongo {$regex: ..., $options: ...}                                                 //\n            // selector                                                                                                           //\n            function convertRegexpToMongoSelector(regexp) {\n              // 411\n              check(regexp, RegExp); // safety belt                                                                               // 412\n              //\n              var selector = { $regex: regexp.source }; // 414\n              var regexOptions = ''; // 415\n              // JS RegExp objects support 'i', 'm', and 'g'. Mongo regex $options                                                //\n              // support 'i', 'm', 'x', and 's'. So we support 'i' and 'm' here.                                                  //\n              if (regexp.ignoreCase) regexOptions += 'i'; // 418\n              if (regexp.multiline) regexOptions += 'm'; // 420\n              if (regexOptions) selector.$options = regexOptions; // 422\n              //\n              return selector; // 425\n            }; // 426\n            //\n            // 'insert' immediately returns the inserted document's new _id.                                                      //\n            // The others return values immediately if you are in a stub, an in-memory                                            //\n            // unmanaged collection, or a mongo-backed collection and you don't pass a                                            //\n            // callback. 'update' and 'remove' return the number of affected                                                      //\n            // documents. 'upsert' returns an object with keys 'numberAffected' and, if an                                        //\n            // insert happened, 'insertedId'.                                                                                     //\n            //                                                                                                                    //\n            // Otherwise, the semantics are exactly like other methods: they take                                                 //\n            // a callback as an optional last argument; if no callback is                                                         //\n            // provided, they block until the operation is complete, and throw an                                                 //\n            // exception if it fails; if a callback is provided, then they don't                                                  //\n            // necessarily block, and they call the callback when they finish with error and                                      //\n            // result arguments.  (The insert method provides the document ID as its result;                                      //\n            // update and remove provide the number of affected docs as the result; upsert                                        //\n            // provides an object with numberAffected and maybe insertedId.)                                                      //\n            //                                                                                                                    //\n            // On the client, blocking is impossible, so if a callback                                                            //\n            // isn't provided, they just return immediately and any error                                                         //\n            // information is lost.                                                                                               //\n            //                                                                                                                    //\n            // There's one more tweak. On the client, if you don't provide a                                                      //\n            // callback, then if there is an error, a message will be logged with                                                 //\n            // Meteor._debug.                                                                                                     //\n            //                                                                                                                    //\n            // The intent (though this is actually determined by the underlying                                                   //\n            // drivers) is that the operations should be done synchronously, not                                                  //\n            // generating their result until the database has acknowledged                                                        //\n            // them. In the future maybe we should provide a flag to turn this                                                    //\n            // off.                                                                                                               //\n            //\n            /**                                                                                                                   //\n             * @summary Insert a document in the collection.  Returns its unique _id.                                             //\n             * @locus Anywhere                                                                                                    //\n             * @method  insert                                                                                                    //\n             * @memberOf Mongo.Collection                                                                                         //\n             * @instance                                                                                                          //\n             * @param {Object} doc The document to insert. May not yet have an _id attribute, in which case Meteor will generate one for you.\n             * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the _id as the second.\n             */ //\n            Mongo.Collection.prototype.insert = function insert(doc, callback) {\n              // 467\n              // Make sure we were passed a document to insert                                                                    //\n              if (!doc) {\n                // 469\n                throw new Error(\"insert requires an argument\"); // 470\n              } // 471\n              //\n              // Shallow-copy the document and possibly generate an ID                                                            //\n              doc = _.extend({}, doc); // 474\n              //\n              if ('_id' in doc) {\n                // 476\n                if (!doc._id || !(typeof doc._id === 'string' || doc._id instanceof Mongo.ObjectID)) {\n                  // 477\n                  throw new Error(\"Meteor requires document _id fields to be non-empty strings or ObjectIDs\"); // 479\n                } // 480\n              } else {\n                  // 481\n                  var generateId = true; // 482\n                  //\n                  // Don't generate the id if we're the client and the 'outermost' call                                             //\n                  // This optimization saves us passing both the randomSeed and the id                                              //\n                  // Passing both is redundant.                                                                                     //\n                  if (this._isRemoteCollection()) {\n                    // 487\n                    var enclosing = DDP._CurrentInvocation.get(); // 488\n                    if (!enclosing) {\n                      // 489\n                      generateId = false; // 490\n                    } // 491\n                  } // 492\n                  //\n                  if (generateId) {\n                    // 494\n                    doc._id = this._makeNewID(); // 495\n                  } // 496\n                } // 497\n              //\n              // On inserts, always return the id that we generated; on all other                                                 //\n              // operations, just return the result from the collection.                                                          //\n              var chooseReturnValueFromCollectionResult = function chooseReturnValueFromCollectionResult(result) {\n                // 501\n                if (doc._id) {\n                  // 502\n                  return doc._id; // 503\n                } // 504\n                //\n                // XXX what is this for??                                                                                         //\n                // It's some iteraction between the callback to _callMutatorMethod and                                            //\n                // the return value conversion                                                                                    //\n                doc._id = result; // 509\n                //\n                return result; // 511\n              }; // 512\n              //\n              var wrappedCallback = wrapCallback(callback, chooseReturnValueFromCollectionResult); // 514\n              //\n              if (this._isRemoteCollection()) {\n                // 517\n                var result = this._callMutatorMethod(\"insert\", [doc], wrappedCallback); // 518\n                return chooseReturnValueFromCollectionResult(result); // 519\n              } // 520\n              //\n              // it's my collection.  descend into the collection object                                                          //\n              // and propagate any exception.                                                                                     //\n              try {\n                // 524\n                // If the user provided a callback and the collection implements this                                             //\n                // operation asynchronously, then queryRet will be undefined, and the                                             //\n                // result will be returned through the callback instead.                                                          //\n                var _result = this._collection.insert(doc, wrappedCallback); // 528\n                return chooseReturnValueFromCollectionResult(_result); // 529\n              } catch (e) {\n                // 530\n                if (callback) {\n                  // 531\n                  callback(e); // 532\n                  return null; // 533\n                } // 534\n                throw e; // 535\n              } // 536\n            }; // 537\n            //\n            /**                                                                                                                   //\n             * @summary Modify one or more documents in the collection. Returns the number of matched documents.                  //\n             * @locus Anywhere                                                                                                    //\n             * @method update                                                                                                     //\n             * @memberOf Mongo.Collection                                                                                         //\n             * @instance                                                                                                          //\n             * @param {MongoSelector} selector Specifies which documents to modify                                                //\n             * @param {MongoModifier} modifier Specifies how to modify the documents                                              //\n             * @param {Object} [options]                                                                                          //\n             * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n             * @param {Boolean} options.upsert True to insert a document if no matching documents are found.                      //\n             * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.\n             */ //\n            Mongo.Collection.prototype.update = function update(selector, modifier) {\n              // 552\n              for (var _len = arguments.length, optionsAndCallback = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n                optionsAndCallback[_key - 2] = arguments[_key]; // 552\n              } // 552\n              //\n              var callback = popCallbackFromArgs(optionsAndCallback); // 553\n              //\n              selector = Mongo.Collection._rewriteSelector(selector); // 555\n              //\n              // We've already popped off the callback, so we are left with an array                                              //\n              // of one or zero items                                                                                             //\n              var options = _.clone(optionsAndCallback[0]) || {}; // 559\n              if (options && options.upsert) {\n                // 560\n                // set `insertedId` if absent.  `insertedId` is a Meteor extension.                                               //\n                if (options.insertedId) {\n                  // 562\n                  if (!(typeof options.insertedId === 'string' || options.insertedId instanceof Mongo.ObjectID)) throw new Error(\"insertedId must be string or ObjectID\");\n                } else if (!selector._id) {\n                  // 566\n                  options.insertedId = this._makeNewID(); // 567\n                } // 568\n              } // 569\n              //\n              var wrappedCallback = wrapCallback(callback); // 571\n              //\n              if (this._isRemoteCollection()) {\n                // 573\n                var args = [selector, modifier, options]; // 574\n                //\n                return this._callMutatorMethod(\"update\", args, wrappedCallback); // 580\n              } // 581\n              //\n              // it's my collection.  descend into the collection object                                                          //\n              // and propagate any exception.                                                                                     //\n              try {\n                // 585\n                // If the user provided a callback and the collection implements this                                             //\n                // operation asynchronously, then queryRet will be undefined, and the                                             //\n                // result will be returned through the callback instead.                                                          //\n                return this._collection.update(selector, modifier, options, wrappedCallback); // 589\n              } catch (e) {\n                // 591\n                if (callback) {\n                  // 592\n                  callback(e); // 593\n                  return null; // 594\n                } // 595\n                throw e; // 596\n              } // 597\n            }; // 598\n            //\n            /**                                                                                                                   //\n             * @summary Remove documents from the collection                                                                      //\n             * @locus Anywhere                                                                                                    //\n             * @method remove                                                                                                     //\n             * @memberOf Mongo.Collection                                                                                         //\n             * @instance                                                                                                          //\n             * @param {MongoSelector} selector Specifies which documents to remove                                                //\n             * @param {Function} [callback] Optional.  If present, called with an error object as its argument.                   //\n             */ //\n            Mongo.Collection.prototype.remove = function remove(selector, callback) {\n              // 609\n              selector = Mongo.Collection._rewriteSelector(selector); // 610\n              //\n              var wrappedCallback = wrapCallback(callback); // 612\n              //\n              if (this._isRemoteCollection()) {\n                // 614\n                return this._callMutatorMethod(\"remove\", [selector], wrappedCallback); // 615\n              } // 616\n              //\n              // it's my collection.  descend into the collection object                                                          //\n              // and propagate any exception.                                                                                     //\n              try {\n                // 620\n                // If the user provided a callback and the collection implements this                                             //\n                // operation asynchronously, then queryRet will be undefined, and the                                             //\n                // result will be returned through the callback instead.                                                          //\n                return this._collection.remove(selector, wrappedCallback); // 624\n              } catch (e) {\n                // 625\n                if (callback) {\n                  // 626\n                  callback(e); // 627\n                  return null; // 628\n                } // 629\n                throw e; // 630\n              } // 631\n            }; // 632\n            //\n            // Determine if this collection is simply a minimongo representation of a real                                        //\n            // database on another server                                                                                         //\n            Mongo.Collection.prototype._isRemoteCollection = function _isRemoteCollection() {\n              // 636\n              // XXX see #MeteorServerNull                                                                                        //\n              return this._connection && this._connection !== Meteor.server; // 638\n            }; // 639\n            //\n            // Convert the callback to not return a result if there is an error                                                   //\n            function wrapCallback(callback, convertResult) {\n              // 642\n              if (!callback) {\n                // 643\n                return; // 644\n              } // 645\n              //\n              // If no convert function was passed in, just use a \"blank function\"                                                //\n              convertResult = convertResult || _.identity; // 648\n              //\n              return function (error, result) {\n                // 650\n                callback(error, !error && convertResult(result)); // 651\n              }; // 652\n            } // 653\n            //\n            /**                                                                                                                   //\n             * @summary Modify one or more documents in the collection, or insert one if no matching documents were found. Returns an object with keys `numberAffected` (the number of documents modified)  and `insertedId` (the unique _id of the document that was inserted, if any).\n             * @locus Anywhere                                                                                                    //\n             * @param {MongoSelector} selector Specifies which documents to modify                                                //\n             * @param {MongoModifier} modifier Specifies how to modify the documents                                              //\n             * @param {Object} [options]                                                                                          //\n             * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n             * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.\n             */ //\n            Mongo.Collection.prototype.upsert = function upsert(selector, modifier, options, callback) {\n              // 664\n              if (!callback && typeof options === \"function\") {\n                // 666\n                callback = options; // 667\n                options = {}; // 668\n              } // 669\n              //\n              var updateOptions = _.extend({}, options, { // 671\n                _returnObject: true, // 672\n                upsert: true // 673\n              }); // 671\n              //\n              return this.update(selector, modifier, updateOptions, callback); // 676\n            }; // 677\n            //\n            // We'll actually design an index API later. For now, we just pass through to                                         //\n            // Mongo's, but make it synchronous.                                                                                  //\n            Mongo.Collection.prototype._ensureIndex = function (index, options) {\n              // 681\n              var self = this; // 682\n              if (!self._collection._ensureIndex) throw new Error(\"Can only call _ensureIndex on server collections\"); // 683\n              self._collection._ensureIndex(index, options); // 685\n            }; // 686\n            Mongo.Collection.prototype._dropIndex = function (index) {\n              // 687\n              var self = this; // 688\n              if (!self._collection._dropIndex) throw new Error(\"Can only call _dropIndex on server collections\"); // 689\n              self._collection._dropIndex(index); // 691\n            }; // 692\n            Mongo.Collection.prototype._dropCollection = function () {\n              // 693\n              var self = this; // 694\n              if (!self._collection.dropCollection) throw new Error(\"Can only call _dropCollection on server collections\"); // 695\n              self._collection.dropCollection(); // 697\n            }; // 698\n            Mongo.Collection.prototype._createCappedCollection = function (byteSize, maxDocuments) {\n              // 699\n              var self = this; // 700\n              if (!self._collection._createCappedCollection) throw new Error(\"Can only call _createCappedCollection on server collections\");\n              self._collection._createCappedCollection(byteSize, maxDocuments); // 703\n            }; // 704\n            //\n            /**                                                                                                                   //\n             * @summary Returns the [`Collection`](http://mongodb.github.io/node-mongodb-native/1.4/api-generated/collection.html) object corresponding to this collection from the [npm `mongodb` driver module](https://www.npmjs.com/package/mongodb) which is wrapped by `Mongo.Collection`.\n             * @locus Server                                                                                                      //\n             */ //\n            Mongo.Collection.prototype.rawCollection = function () {\n              // 710\n              var self = this; // 711\n              if (!self._collection.rawCollection) {\n                // 712\n                throw new Error(\"Can only call rawCollection on server collections\"); // 713\n              } // 714\n              return self._collection.rawCollection(); // 715\n            }; // 716\n            //\n            /**                                                                                                                   //\n             * @summary Returns the [`Db`](http://mongodb.github.io/node-mongodb-native/1.4/api-generated/db.html) object corresponding to this collection's database connection from the [npm `mongodb` driver module](https://www.npmjs.com/package/mongodb) which is wrapped by `Mongo.Collection`.\n             * @locus Server                                                                                                      //\n             */ //\n            Mongo.Collection.prototype.rawDatabase = function () {\n              // 722\n              var self = this; // 723\n              if (!(self._driver.mongo && self._driver.mongo.db)) {\n                // 724\n                throw new Error(\"Can only call rawDatabase on server collections\"); // 725\n              } // 726\n              return self._driver.mongo.db; // 727\n            }; // 728\n            //\n            /**                                                                                                                   //\n             * @summary Create a Mongo-style `ObjectID`.  If you don't specify a `hexString`, the `ObjectID` will generated randomly (not using MongoDB's ID construction rules).\n             * @locus Anywhere                                                                                                    //\n             * @class                                                                                                             //\n             * @param {String} [hexString] Optional.  The 24-character hexadecimal contents of the ObjectID to create             //\n             */ //\n            Mongo.ObjectID = MongoID.ObjectID; // 737\n            //\n            /**                                                                                                                   //\n             * @summary To create a cursor, use find. To access the documents in a cursor, use forEach, map, or fetch.            //\n             * @class                                                                                                             //\n             * @instanceName cursor                                                                                               //\n             */ //\n            Mongo.Cursor = LocalCollection.Cursor; // 744\n            //\n            /**                                                                                                                   //\n             * @deprecated in 0.9.1                                                                                               //\n             */ //\n            Mongo.Collection.Cursor = Mongo.Cursor; // 749\n            //\n            /**                                                                                                                   //\n             * @deprecated in 0.9.1                                                                                               //\n             */ //\n            Mongo.Collection.ObjectID = Mongo.ObjectID; // 754\n            //\n            /**                                                                                                                   //\n             * @deprecated in 0.9.1                                                                                               //\n             */ //\n            Meteor.Collection = Mongo.Collection; // 759\n            //\n            // Allow deny stuff is now in the allow-deny package                                                                  //\n            _.extend(Meteor.Collection.prototype, AllowDeny.CollectionPrototype); // 762\n            //\n            function popCallbackFromArgs(args) {\n              // 764\n              // Pull off any callback (or perhaps a 'callback' variable that was passed                                          //\n              // in undefined, like how 'upsert' does it).                                                                        //\n              if (args.length && (args[args.length - 1] === undefined || args[args.length - 1] instanceof Function)) {\n                // 767\n                return args.pop(); // 770\n              } // 771\n            } // 772\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }, \"connection_options.js\": function connection_optionsJs() {\n\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/mongo/connection_options.js                                                                               //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            /**                                                                                                                   //\n             * @summary Allows for user specified connection options                                                              //\n             * @example http://mongodb.github.io/node-mongodb-native/2.1/reference/connecting/connection-settings/                //\n             * @locus Server                                                                                                      //\n             * @param {Object} options User specified Mongo connection options                                                    //\n             */ //\n            Mongo.setConnectionOptions = function setConnectionOptions(options) {\n              // 7\n              check(options, Object); // 8\n              Mongo._connectionOptions = options; // 9\n            }; // 10\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          } } } } }, { \"extensions\": [\".js\", \".json\"] });\n  require(\"./node_modules/meteor/mongo/mongo_driver.js\");\n  require(\"./node_modules/meteor/mongo/oplog_tailing.js\");\n  require(\"./node_modules/meteor/mongo/observe_multiplex.js\");\n  require(\"./node_modules/meteor/mongo/doc_fetcher.js\");\n  require(\"./node_modules/meteor/mongo/polling_observe_driver.js\");\n  require(\"./node_modules/meteor/mongo/oplog_observe_driver.js\");\n  require(\"./node_modules/meteor/mongo/local_collection_driver.js\");\n  require(\"./node_modules/meteor/mongo/remote_collection_driver.js\");\n  require(\"./node_modules/meteor/mongo/collection.js\");\n  require(\"./node_modules/meteor/mongo/connection_options.js\");\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package.mongo = {}, {\n    MongoInternals: MongoInternals,\n    MongoTest: MongoTest,\n    Mongo: Mongo\n  });\n})();\n\n//# sourceMappingURL=mongo.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/mongo.js"],"names":[],"mappings":"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","file":"/bundle/programs/server/packages/mongo.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar NpmModuleMongodb = Package['npm-mongo'].NpmModuleMongodb;\nvar NpmModuleMongodbVersion = Package['npm-mongo'].NpmModuleMongodbVersion;\nvar AllowDeny = Package['allow-deny'].AllowDeny;\nvar Random = Package.random.Random;\nvar EJSON = Package.ejson.EJSON;\nvar _ = Package.underscore._;\nvar LocalCollection = Package.minimongo.LocalCollection;\nvar Minimongo = Package.minimongo.Minimongo;\nvar DDP = Package['ddp-client'].DDP;\nvar DDPServer = Package['ddp-server'].DDPServer;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar DiffSequence = Package['diff-sequence'].DiffSequence;\nvar MongoID = Package['mongo-id'].MongoID;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar MaxHeap = Package['binary-heap'].MaxHeap;\nvar MinHeap = Package['binary-heap'].MinHeap;\nvar MinMaxHeap = Package['binary-heap'].MinMaxHeap;\nvar Hook = Package['callback-hook'].Hook;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Buffer = Package.modules.Buffer;\nvar process = Package.modules.process;\nvar Symbol = Package['ecmascript-runtime'].Symbol;\nvar Map = Package['ecmascript-runtime'].Map;\nvar Set = Package['ecmascript-runtime'].Set;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar MongoInternals, MongoTest, MongoConnection, mongoResult, CursorDescription, Cursor, listenAll, forEachTrigger, OPLOG_COLLECTION, idForOp, OplogHandle, ObserveMultiplexer, ObserveHandle, DocFetcher, PollingObserveDriver, OplogObserveDriver, LocalCollectionDriver, Mongo;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"mongo\":{\"mongo_driver.js\":[\"babel-runtime/helpers/typeof\",function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/mongo/mongo_driver.js                                                                                     //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nvar _typeof;module.import('babel-runtime/helpers/typeof',{\"default\":function(v){_typeof=v}});                         //\n/**                                                                                                                   //\n * Provide a synchronous Collection API using fibers, backed by                                                       //\n * MongoDB.  This is only for use on the server, and mostly identical                                                 //\n * to the client API.                                                                                                 //\n *                                                                                                                    //\n * NOTE: the public API methods must be run within a fiber. If you call                                               //\n * these outside of a fiber they will explode!                                                                        //\n */                                                                                                                   //\n                                                                                                                      //\nvar path = Npm.require('path');                                                                                       // 10\nvar MongoDB = NpmModuleMongodb;                                                                                       // 11\nvar Fiber = Npm.require('fibers');                                                                                    // 12\nvar Future = Npm.require(path.join('fibers', 'future'));                                                              // 13\n                                                                                                                      //\nMongoInternals = {};                                                                                                  // 15\nMongoTest = {};                                                                                                       // 16\n                                                                                                                      //\nMongoInternals.NpmModules = {                                                                                         // 18\n  mongodb: {                                                                                                          // 19\n    version: NpmModuleMongodbVersion,                                                                                 // 20\n    module: MongoDB                                                                                                   // 21\n  }                                                                                                                   // 19\n};                                                                                                                    // 18\n                                                                                                                      //\n// Older version of what is now available via                                                                         //\n// MongoInternals.NpmModules.mongodb.module.  It was never documented, but                                            //\n// people do use it.                                                                                                  //\n// XXX COMPAT WITH 1.0.3.2                                                                                            //\nMongoInternals.NpmModule = MongoDB;                                                                                   // 29\n                                                                                                                      //\n// This is used to add or remove EJSON from the beginning of everything nested                                        //\n// inside an EJSON custom type. It should only be called on pure JSON!                                                //\nvar replaceNames = function replaceNames(filter, thing) {                                                             // 33\n  if ((typeof thing === 'undefined' ? 'undefined' : _typeof(thing)) === \"object\") {                                   // 34\n    if (_.isArray(thing)) {                                                                                           // 35\n      return _.map(thing, _.bind(replaceNames, null, filter));                                                        // 36\n    }                                                                                                                 // 37\n    var ret = {};                                                                                                     // 38\n    _.each(thing, function (value, key) {                                                                             // 39\n      ret[filter(key)] = replaceNames(filter, value);                                                                 // 40\n    });                                                                                                               // 41\n    return ret;                                                                                                       // 42\n  }                                                                                                                   // 43\n  return thing;                                                                                                       // 44\n};                                                                                                                    // 45\n                                                                                                                      //\n// Ensure that EJSON.clone keeps a Timestamp as a Timestamp (instead of just                                          //\n// doing a structural clone).                                                                                         //\n// XXX how ok is this? what if there are multiple copies of MongoDB loaded?                                           //\nMongoDB.Timestamp.prototype.clone = function () {                                                                     // 50\n  // Timestamps should be immutable.                                                                                  //\n  return this;                                                                                                        // 52\n};                                                                                                                    // 53\n                                                                                                                      //\nvar makeMongoLegal = function makeMongoLegal(name) {                                                                  // 55\n  return \"EJSON\" + name;                                                                                              // 55\n};                                                                                                                    // 55\nvar unmakeMongoLegal = function unmakeMongoLegal(name) {                                                              // 56\n  return name.substr(5);                                                                                              // 56\n};                                                                                                                    // 56\n                                                                                                                      //\nvar replaceMongoAtomWithMeteor = function replaceMongoAtomWithMeteor(document) {                                      // 58\n  if (document instanceof MongoDB.Binary) {                                                                           // 59\n    var buffer = document.value(true);                                                                                // 60\n    return new Uint8Array(buffer);                                                                                    // 61\n  }                                                                                                                   // 62\n  if (document instanceof MongoDB.ObjectID) {                                                                         // 63\n    return new Mongo.ObjectID(document.toHexString());                                                                // 64\n  }                                                                                                                   // 65\n  if (document[\"EJSON$type\"] && document[\"EJSON$value\"] && _.size(document) === 2) {                                  // 66\n    return EJSON.fromJSONValue(replaceNames(unmakeMongoLegal, document));                                             // 68\n  }                                                                                                                   // 69\n  if (document instanceof MongoDB.Timestamp) {                                                                        // 70\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!                                      //\n    // this is a weird internal thing used in the oplog!) is the same as the                                          //\n    // Mongo representation. We need to do this explicitly or else we would do a                                      //\n    // structural clone and lose the prototype.                                                                       //\n    return document;                                                                                                  // 75\n  }                                                                                                                   // 76\n  return undefined;                                                                                                   // 77\n};                                                                                                                    // 78\n                                                                                                                      //\nvar replaceMeteorAtomWithMongo = function replaceMeteorAtomWithMongo(document) {                                      // 80\n  if (EJSON.isBinary(document)) {                                                                                     // 81\n    // This does more copies than we'd like, but is necessary because                                                 //\n    // MongoDB.BSON only looks like it takes a Uint8Array (and doesn't actually                                       //\n    // serialize it correctly).                                                                                       //\n    return new MongoDB.Binary(new Buffer(document));                                                                  // 85\n  }                                                                                                                   // 86\n  if (document instanceof Mongo.ObjectID) {                                                                           // 87\n    return new MongoDB.ObjectID(document.toHexString());                                                              // 88\n  }                                                                                                                   // 89\n  if (document instanceof MongoDB.Timestamp) {                                                                        // 90\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!                                      //\n    // this is a weird internal thing used in the oplog!) is the same as the                                          //\n    // Mongo representation. We need to do this explicitly or else we would do a                                      //\n    // structural clone and lose the prototype.                                                                       //\n    return document;                                                                                                  // 95\n  }                                                                                                                   // 96\n  if (EJSON._isCustomType(document)) {                                                                                // 97\n    return replaceNames(makeMongoLegal, EJSON.toJSONValue(document));                                                 // 98\n  }                                                                                                                   // 99\n  // It is not ordinarily possible to stick dollar-sign keys into mongo                                               //\n  // so we don't bother checking for things that need escaping at this time.                                          //\n  return undefined;                                                                                                   // 102\n};                                                                                                                    // 103\n                                                                                                                      //\nvar replaceTypes = function replaceTypes(document, atomTransformer) {                                                 // 105\n  if ((typeof document === 'undefined' ? 'undefined' : _typeof(document)) !== 'object' || document === null) return document;\n                                                                                                                      //\n  var replacedTopLevelAtom = atomTransformer(document);                                                               // 109\n  if (replacedTopLevelAtom !== undefined) return replacedTopLevelAtom;                                                // 110\n                                                                                                                      //\n  var ret = document;                                                                                                 // 113\n  _.each(document, function (val, key) {                                                                              // 114\n    var valReplaced = replaceTypes(val, atomTransformer);                                                             // 115\n    if (val !== valReplaced) {                                                                                        // 116\n      // Lazy clone. Shallow copy.                                                                                    //\n      if (ret === document) ret = _.clone(document);                                                                  // 118\n      ret[key] = valReplaced;                                                                                         // 120\n    }                                                                                                                 // 121\n  });                                                                                                                 // 122\n  return ret;                                                                                                         // 123\n};                                                                                                                    // 124\n                                                                                                                      //\nMongoConnection = function MongoConnection(url, options) {                                                            // 127\n  var self = this;                                                                                                    // 128\n  options = options || {};                                                                                            // 129\n  self._observeMultiplexers = {};                                                                                     // 130\n  self._onFailoverHook = new Hook();                                                                                  // 131\n                                                                                                                      //\n  var mongoOptions = _.extend({ db: { safe: true }, server: {}, replSet: {} }, Mongo._connectionOptions);             // 133\n                                                                                                                      //\n  // Set autoReconnect to true, unless passed on the URL. Why someone                                                 //\n  // would want to set autoReconnect to false, I'm not really sure, but                                               //\n  // keeping this for backwards compatibility for now.                                                                //\n  if (!/[\\?&]auto_?[rR]econnect=/.test(url)) {                                                                        // 139\n    mongoOptions.server.auto_reconnect = true;                                                                        // 140\n  }                                                                                                                   // 141\n                                                                                                                      //\n  // Disable the native parser by default, unless specifically enabled                                                //\n  // in the mongo URL.                                                                                                //\n  // - The native driver can cause errors which normally would be                                                     //\n  //   thrown, caught, and handled into segfaults that take down the                                                  //\n  //   whole app.                                                                                                     //\n  // - Binary modules don't yet work when you bundle and move the bundle                                              //\n  //   to a different platform (aka deploy)                                                                           //\n  // We should revisit this after binary npm module support lands.                                                    //\n  if (!/[\\?&]native_?[pP]arser=/.test(url)) {                                                                         // 151\n    mongoOptions.db.native_parser = false;                                                                            // 152\n  }                                                                                                                   // 153\n                                                                                                                      //\n  // Internally the oplog connections specify their own poolSize                                                      //\n  // which we don't want to overwrite with any user defined value                                                     //\n  if (_.has(options, 'poolSize')) {                                                                                   // 157\n    // If we just set this for \"server\", replSet will override it. If we just                                         //\n    // set it for replSet, it will be ignored if we're not using a replSet.                                           //\n    mongoOptions.server.poolSize = options.poolSize;                                                                  // 160\n    mongoOptions.replSet.poolSize = options.poolSize;                                                                 // 161\n  }                                                                                                                   // 162\n                                                                                                                      //\n  self.db = null;                                                                                                     // 164\n  // We keep track of the ReplSet's primary, so that we can trigger hooks when                                        //\n  // it changes.  The Node driver's joined callback seems to fire way too                                             //\n  // often, which is why we need to track it ourselves.                                                               //\n  self._primary = null;                                                                                               // 168\n  self._oplogHandle = null;                                                                                           // 169\n  self._docFetcher = null;                                                                                            // 170\n                                                                                                                      //\n  var connectFuture = new Future();                                                                                   // 173\n  MongoDB.connect(url, mongoOptions, Meteor.bindEnvironment(function (err, db) {                                      // 174\n    if (err) {                                                                                                        // 179\n      throw err;                                                                                                      // 180\n    }                                                                                                                 // 181\n                                                                                                                      //\n    // First, figure out what the current primary is, if any.                                                         //\n    if (db.serverConfig.isMasterDoc) {                                                                                // 184\n      self._primary = db.serverConfig.isMasterDoc.primary;                                                            // 185\n    }                                                                                                                 // 186\n                                                                                                                      //\n    db.serverConfig.on('joined', Meteor.bindEnvironment(function (kind, doc) {                                        // 188\n      if (kind === 'primary') {                                                                                       // 190\n        if (doc.primary !== self._primary) {                                                                          // 191\n          self._primary = doc.primary;                                                                                // 192\n          self._onFailoverHook.each(function (callback) {                                                             // 193\n            callback();                                                                                               // 194\n            return true;                                                                                              // 195\n          });                                                                                                         // 196\n        }                                                                                                             // 197\n      } else if (doc.me === self._primary) {                                                                          // 198\n        // The thing we thought was primary is now something other than                                               //\n        // primary.  Forget that we thought it was primary.  (This means                                              //\n        // that if a server stops being primary and then starts being                                                 //\n        // primary again without another server becoming primary in the                                               //\n        // middle, we'll correctly count it as a failover.)                                                           //\n        self._primary = null;                                                                                         // 204\n      }                                                                                                               // 205\n    }));                                                                                                              // 206\n                                                                                                                      //\n    // Allow the constructor to return.                                                                               //\n    connectFuture['return'](db);                                                                                      // 209\n  }, connectFuture.resolver() // onException                                                                          // 210\n  ));                                                                                                                 // 177\n                                                                                                                      //\n  // Wait for the connection to be successful; throws on failure.                                                     //\n  self.db = connectFuture.wait();                                                                                     // 216\n                                                                                                                      //\n  if (options.oplogUrl && !Package['disable-oplog']) {                                                                // 218\n    self._oplogHandle = new OplogHandle(options.oplogUrl, self.db.databaseName);                                      // 219\n    self._docFetcher = new DocFetcher(self);                                                                          // 220\n  }                                                                                                                   // 221\n};                                                                                                                    // 222\n                                                                                                                      //\nMongoConnection.prototype.close = function () {                                                                       // 224\n  var self = this;                                                                                                    // 225\n                                                                                                                      //\n  if (!self.db) throw Error(\"close called before Connection created?\");                                               // 227\n                                                                                                                      //\n  // XXX probably untested                                                                                            //\n  var oplogHandle = self._oplogHandle;                                                                                // 231\n  self._oplogHandle = null;                                                                                           // 232\n  if (oplogHandle) oplogHandle.stop();                                                                                // 233\n                                                                                                                      //\n  // Use Future.wrap so that errors get thrown. This happens to                                                       //\n  // work even outside a fiber since the 'close' method is not                                                        //\n  // actually asynchronous.                                                                                           //\n  Future.wrap(_.bind(self.db.close, self.db))(true).wait();                                                           // 239\n};                                                                                                                    // 240\n                                                                                                                      //\n// Returns the Mongo Collection object; may yield.                                                                    //\nMongoConnection.prototype.rawCollection = function (collectionName) {                                                 // 243\n  var self = this;                                                                                                    // 244\n                                                                                                                      //\n  if (!self.db) throw Error(\"rawCollection called before Connection created?\");                                       // 246\n                                                                                                                      //\n  var future = new Future();                                                                                          // 249\n  self.db.collection(collectionName, future.resolver());                                                              // 250\n  return future.wait();                                                                                               // 251\n};                                                                                                                    // 252\n                                                                                                                      //\nMongoConnection.prototype._createCappedCollection = function (collectionName, byteSize, maxDocuments) {               // 254\n  var self = this;                                                                                                    // 256\n                                                                                                                      //\n  if (!self.db) throw Error(\"_createCappedCollection called before Connection created?\");                             // 258\n                                                                                                                      //\n  var future = new Future();                                                                                          // 261\n  self.db.createCollection(collectionName, { capped: true, size: byteSize, max: maxDocuments }, future.resolver());   // 262\n  future.wait();                                                                                                      // 266\n};                                                                                                                    // 267\n                                                                                                                      //\n// This should be called synchronously with a write, to create a                                                      //\n// transaction on the current write fence, if any. After we can read                                                  //\n// the write, and after observers have been notified (or at least,                                                    //\n// after the observer notifiers have added themselves to the write                                                    //\n// fence), you should call 'committed()' on the object returned.                                                      //\nMongoConnection.prototype._maybeBeginWrite = function () {                                                            // 274\n  var self = this;                                                                                                    // 275\n  var fence = DDPServer._CurrentWriteFence.get();                                                                     // 276\n  if (fence) return fence.beginWrite();else return { committed: function committed() {} };                            // 277\n};                                                                                                                    // 281\n                                                                                                                      //\n// Internal interface: adds a callback which is called when the Mongo primary                                         //\n// changes. Returns a stop handle.                                                                                    //\nMongoConnection.prototype._onFailover = function (callback) {                                                         // 285\n  return this._onFailoverHook.register(callback);                                                                     // 286\n};                                                                                                                    // 287\n                                                                                                                      //\n//////////// Public API //////////                                                                                    //\n                                                                                                                      //\n// The write methods block until the database has confirmed the write (it may                                         //\n// not be replicated or stable on disk, but one server has confirmed it) if no                                        //\n// callback is provided. If a callback is provided, then they call the callback                                       //\n// when the write is confirmed. They return nothing on success, and raise an                                          //\n// exception on failure.                                                                                              //\n//                                                                                                                    //\n// After making a write (with insert, update, remove), observers are                                                  //\n// notified asynchronously. If you want to receive a callback once all                                                //\n// of the observer notifications have landed for your write, do the                                                   //\n// writes inside a write fence (set DDPServer._CurrentWriteFence to a new                                             //\n// _WriteFence, and then set a callback on the write fence.)                                                          //\n//                                                                                                                    //\n// Since our execution environment is single-threaded, this is                                                        //\n// well-defined -- a write \"has been made\" if it's returned, and an                                                   //\n// observer \"has been notified\" if its callback has returned.                                                         //\n                                                                                                                      //\nvar writeCallback = function writeCallback(write, refresh, callback) {                                                // 308\n  return function (err, result) {                                                                                     // 309\n    if (!err) {                                                                                                       // 310\n      // XXX We don't have to run this on error, right?                                                               //\n      try {                                                                                                           // 312\n        refresh();                                                                                                    // 313\n      } catch (refreshErr) {                                                                                          // 314\n        if (callback) {                                                                                               // 315\n          callback(refreshErr);                                                                                       // 316\n          return;                                                                                                     // 317\n        } else {                                                                                                      // 318\n          throw refreshErr;                                                                                           // 319\n        }                                                                                                             // 320\n      }                                                                                                               // 321\n    }                                                                                                                 // 322\n    write.committed();                                                                                                // 323\n    if (callback) callback(err, result);else if (err) throw err;                                                      // 324\n  };                                                                                                                  // 328\n};                                                                                                                    // 329\n                                                                                                                      //\nvar bindEnvironmentForWrite = function bindEnvironmentForWrite(callback) {                                            // 331\n  return Meteor.bindEnvironment(callback, \"Mongo write\");                                                             // 332\n};                                                                                                                    // 333\n                                                                                                                      //\nMongoConnection.prototype._insert = function (collection_name, document, callback) {                                  // 335\n  var self = this;                                                                                                    // 337\n                                                                                                                      //\n  var sendError = function sendError(e) {                                                                             // 339\n    if (callback) return callback(e);                                                                                 // 340\n    throw e;                                                                                                          // 342\n  };                                                                                                                  // 343\n                                                                                                                      //\n  if (collection_name === \"___meteor_failure_test_collection\") {                                                      // 345\n    var e = new Error(\"Failure test\");                                                                                // 346\n    e.expected = true;                                                                                                // 347\n    sendError(e);                                                                                                     // 348\n    return;                                                                                                           // 349\n  }                                                                                                                   // 350\n                                                                                                                      //\n  if (!(LocalCollection._isPlainObject(document) && !EJSON._isCustomType(document))) {                                // 352\n    sendError(new Error(\"Only plain objects may be inserted into MongoDB\"));                                          // 354\n    return;                                                                                                           // 356\n  }                                                                                                                   // 357\n                                                                                                                      //\n  var write = self._maybeBeginWrite();                                                                                // 359\n  var refresh = function refresh() {                                                                                  // 360\n    Meteor.refresh({ collection: collection_name, id: document._id });                                                // 361\n  };                                                                                                                  // 362\n  callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));                                        // 363\n  try {                                                                                                               // 364\n    var collection = self.rawCollection(collection_name);                                                             // 365\n    collection.insert(replaceTypes(document, replaceMeteorAtomWithMongo), { safe: true }, callback);                  // 366\n  } catch (e) {                                                                                                       // 368\n    write.committed();                                                                                                // 369\n    throw e;                                                                                                          // 370\n  }                                                                                                                   // 371\n};                                                                                                                    // 372\n                                                                                                                      //\n// Cause queries that may be affected by the selector to poll in this write                                           //\n// fence.                                                                                                             //\nMongoConnection.prototype._refresh = function (collectionName, selector) {                                            // 376\n  var self = this;                                                                                                    // 377\n  var refreshKey = { collection: collectionName };                                                                    // 378\n  // If we know which documents we're removing, don't poll queries that are                                           //\n  // specific to other documents. (Note that multiple notifications here should                                       //\n  // not cause multiple polls, since all our listener is doing is enqueueing a                                        //\n  // poll.)                                                                                                           //\n  var specificIds = LocalCollection._idsMatchedBySelector(selector);                                                  // 383\n  if (specificIds) {                                                                                                  // 384\n    _.each(specificIds, function (id) {                                                                               // 385\n      Meteor.refresh(_.extend({ id: id }, refreshKey));                                                               // 386\n    });                                                                                                               // 387\n  } else {                                                                                                            // 388\n    Meteor.refresh(refreshKey);                                                                                       // 389\n  }                                                                                                                   // 390\n};                                                                                                                    // 391\n                                                                                                                      //\nMongoConnection.prototype._remove = function (collection_name, selector, callback) {                                  // 393\n  var self = this;                                                                                                    // 395\n                                                                                                                      //\n  if (collection_name === \"___meteor_failure_test_collection\") {                                                      // 397\n    var e = new Error(\"Failure test\");                                                                                // 398\n    e.expected = true;                                                                                                // 399\n    if (callback) return callback(e);else throw e;                                                                    // 400\n  }                                                                                                                   // 404\n                                                                                                                      //\n  var write = self._maybeBeginWrite();                                                                                // 406\n  var refresh = function refresh() {                                                                                  // 407\n    self._refresh(collection_name, selector);                                                                         // 408\n  };                                                                                                                  // 409\n  callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));                                        // 410\n                                                                                                                      //\n  try {                                                                                                               // 412\n    var collection = self.rawCollection(collection_name);                                                             // 413\n    var wrappedCallback = function wrappedCallback(err, driverResult) {                                               // 414\n      callback(err, transformResult(driverResult).numberAffected);                                                    // 415\n    };                                                                                                                // 416\n    collection.remove(replaceTypes(selector, replaceMeteorAtomWithMongo), { safe: true }, wrappedCallback);           // 417\n  } catch (e) {                                                                                                       // 419\n    write.committed();                                                                                                // 420\n    throw e;                                                                                                          // 421\n  }                                                                                                                   // 422\n};                                                                                                                    // 423\n                                                                                                                      //\nMongoConnection.prototype._dropCollection = function (collectionName, cb) {                                           // 425\n  var self = this;                                                                                                    // 426\n                                                                                                                      //\n  var write = self._maybeBeginWrite();                                                                                // 428\n  var refresh = function refresh() {                                                                                  // 429\n    Meteor.refresh({ collection: collectionName, id: null,                                                            // 430\n      dropCollection: true });                                                                                        // 431\n  };                                                                                                                  // 432\n  cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));                                                    // 433\n                                                                                                                      //\n  try {                                                                                                               // 435\n    var collection = self.rawCollection(collectionName);                                                              // 436\n    collection.drop(cb);                                                                                              // 437\n  } catch (e) {                                                                                                       // 438\n    write.committed();                                                                                                // 439\n    throw e;                                                                                                          // 440\n  }                                                                                                                   // 441\n};                                                                                                                    // 442\n                                                                                                                      //\n// For testing only.  Slightly better than `c.rawDatabase().dropDatabase()`                                           //\n// because it lets the test's fence wait for it to be complete.                                                       //\nMongoConnection.prototype._dropDatabase = function (cb) {                                                             // 446\n  var self = this;                                                                                                    // 447\n                                                                                                                      //\n  var write = self._maybeBeginWrite();                                                                                // 449\n  var refresh = function refresh() {                                                                                  // 450\n    Meteor.refresh({ dropDatabase: true });                                                                           // 451\n  };                                                                                                                  // 452\n  cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));                                                    // 453\n                                                                                                                      //\n  try {                                                                                                               // 455\n    self.db.dropDatabase(cb);                                                                                         // 456\n  } catch (e) {                                                                                                       // 457\n    write.committed();                                                                                                // 458\n    throw e;                                                                                                          // 459\n  }                                                                                                                   // 460\n};                                                                                                                    // 461\n                                                                                                                      //\nMongoConnection.prototype._update = function (collection_name, selector, mod, options, callback) {                    // 463\n  var self = this;                                                                                                    // 465\n                                                                                                                      //\n  if (!callback && options instanceof Function) {                                                                     // 467\n    callback = options;                                                                                               // 468\n    options = null;                                                                                                   // 469\n  }                                                                                                                   // 470\n                                                                                                                      //\n  if (collection_name === \"___meteor_failure_test_collection\") {                                                      // 472\n    var e = new Error(\"Failure test\");                                                                                // 473\n    e.expected = true;                                                                                                // 474\n    if (callback) return callback(e);else throw e;                                                                    // 475\n  }                                                                                                                   // 479\n                                                                                                                      //\n  // explicit safety check. null and undefined can crash the mongo                                                    //\n  // driver. Although the node driver and minimongo do 'support'                                                      //\n  // non-object modifier in that they don't crash, they are not                                                       //\n  // meaningful operations and do not do anything. Defensively throw an                                               //\n  // error here.                                                                                                      //\n  if (!mod || (typeof mod === 'undefined' ? 'undefined' : _typeof(mod)) !== 'object') throw new Error(\"Invalid modifier. Modifier must be an object.\");\n                                                                                                                      //\n  if (!(LocalCollection._isPlainObject(mod) && !EJSON._isCustomType(mod))) {                                          // 489\n    throw new Error(\"Only plain objects may be used as replacement\" + \" documents in MongoDB\");                       // 491\n    return;                                                                                                           // 494\n  }                                                                                                                   // 495\n                                                                                                                      //\n  if (!options) options = {};                                                                                         // 497\n                                                                                                                      //\n  var write = self._maybeBeginWrite();                                                                                // 499\n  var refresh = function refresh() {                                                                                  // 500\n    self._refresh(collection_name, selector);                                                                         // 501\n  };                                                                                                                  // 502\n  callback = writeCallback(write, refresh, callback);                                                                 // 503\n  try {                                                                                                               // 504\n    var collection = self.rawCollection(collection_name);                                                             // 505\n    var mongoOpts = { safe: true };                                                                                   // 506\n    // explictly enumerate options that minimongo supports                                                            //\n    if (options.upsert) mongoOpts.upsert = true;                                                                      // 508\n    if (options.multi) mongoOpts.multi = true;                                                                        // 509\n    // Lets you get a more more full result from MongoDB. Use with caution:                                           //\n    // might not work with C.upsert (as opposed to C.update({upsert:true}) or                                         //\n    // with simulated upsert.                                                                                         //\n    if (options.fullResult) mongoOpts.fullResult = true;                                                              // 513\n                                                                                                                      //\n    var mongoSelector = replaceTypes(selector, replaceMeteorAtomWithMongo);                                           // 515\n    var mongoMod = replaceTypes(mod, replaceMeteorAtomWithMongo);                                                     // 516\n                                                                                                                      //\n    var isModify = isModificationMod(mongoMod);                                                                       // 518\n    var knownId = selector._id || mod._id;                                                                            // 519\n                                                                                                                      //\n    if (options._forbidReplace && !isModify) {                                                                        // 521\n      var e = new Error(\"Invalid modifier. Replacements are forbidden.\");                                             // 522\n      if (callback) {                                                                                                 // 523\n        return callback(e);                                                                                           // 524\n      } else {                                                                                                        // 525\n        throw e;                                                                                                      // 526\n      }                                                                                                               // 527\n    }                                                                                                                 // 528\n                                                                                                                      //\n    if (options.upsert && !knownId && options.insertedId) {                                                           // 530\n      // XXX If we know we're using Mongo 2.6 (and this isn't a replacement)                                          //\n      //     we should be able to just use $setOnInsert instead of this                                               //\n      //     simulated upsert thing. (We can't use $setOnInsert with                                                  //\n      //     replacements because there's nowhere to write it, and $setOnInsert                                       //\n      //     can't set _id on Mongo 2.4.)                                                                             //\n      //                                                                                                              //\n      //     Also, in the future we could do a real upsert for the mongo id                                           //\n      //     generation case, if the the node mongo driver gives us back the id                                       //\n      //     of the upserted doc (which our current version does not).                                                //\n      //                                                                                                              //\n      //     For more context, see                                                                                    //\n      //     https://github.com/meteor/meteor/issues/2278#issuecomment-64252706                                       //\n      simulateUpsertWithInsertedId(collection, mongoSelector, mongoMod, isModify, options,                            // 543\n      // This callback does not need to be bindEnvironment'ed because                                                 //\n      // simulateUpsertWithInsertedId() wraps it and then passes it through                                           //\n      // bindEnvironmentForWrite.                                                                                     //\n      function (err, result) {                                                                                        // 549\n        // If we got here via a upsert() call, then options._returnObject will                                        //\n        // be set and we should return the whole object. Otherwise, we should                                         //\n        // just return the number of affected docs to match the mongo API.                                            //\n        if (result && !options._returnObject) callback(err, result.numberAffected);else callback(err, result);        // 553\n      });                                                                                                             // 557\n    } else {                                                                                                          // 559\n      collection.update(mongoSelector, mongoMod, mongoOpts, bindEnvironmentForWrite(function (err, result) {          // 560\n        if (!err) {                                                                                                   // 563\n          var meteorResult = transformResult(result);                                                                 // 564\n          if (meteorResult && options._returnObject) {                                                                // 565\n            // If this was an upsert() call, and we ended up                                                          //\n            // inserting a new doc and we know its id, then                                                           //\n            // return that id as well.                                                                                //\n                                                                                                                      //\n            if (options.upsert && meteorResult.insertedId && knownId) {                                               // 570\n              meteorResult.insertedId = knownId;                                                                      // 571\n            }                                                                                                         // 572\n            callback(err, meteorResult);                                                                              // 573\n          } else {                                                                                                    // 574\n            callback(err, meteorResult.numberAffected);                                                               // 575\n          }                                                                                                           // 576\n        } else {                                                                                                      // 577\n          callback(err);                                                                                              // 578\n        }                                                                                                             // 579\n      }));                                                                                                            // 580\n    }                                                                                                                 // 581\n  } catch (e) {                                                                                                       // 582\n    write.committed();                                                                                                // 583\n    throw e;                                                                                                          // 584\n  }                                                                                                                   // 585\n};                                                                                                                    // 586\n                                                                                                                      //\nvar isModificationMod = function isModificationMod(mod) {                                                             // 588\n  var isReplace = false;                                                                                              // 589\n  var isModify = false;                                                                                               // 590\n  for (var k in mod) {                                                                                                // 591\n    if (k.substr(0, 1) === '$') {                                                                                     // 592\n      isModify = true;                                                                                                // 593\n    } else {                                                                                                          // 594\n      isReplace = true;                                                                                               // 595\n    }                                                                                                                 // 596\n  }                                                                                                                   // 597\n  if (isModify && isReplace) {                                                                                        // 598\n    throw new Error(\"Update parameter cannot have both modifier and non-modifier fields.\");                           // 599\n  }                                                                                                                   // 601\n  return isModify;                                                                                                    // 602\n};                                                                                                                    // 603\n                                                                                                                      //\nvar transformResult = function transformResult(driverResult) {                                                        // 605\n  var meteorResult = { numberAffected: 0 };                                                                           // 606\n  if (driverResult) {                                                                                                 // 607\n    mongoResult = driverResult.result;                                                                                // 608\n                                                                                                                      //\n    // On updates with upsert:true, the inserted values come as a list of                                             //\n    // upserted values -- even with options.multi, when the upsert does insert,                                       //\n    // it only inserts one element.                                                                                   //\n    if (mongoResult.upserted) {                                                                                       // 613\n      meteorResult.numberAffected += mongoResult.upserted.length;                                                     // 614\n                                                                                                                      //\n      if (mongoResult.upserted.length == 1) {                                                                         // 616\n        meteorResult.insertedId = mongoResult.upserted[0]._id;                                                        // 617\n      }                                                                                                               // 618\n    } else {                                                                                                          // 619\n      meteorResult.numberAffected = mongoResult.n;                                                                    // 620\n    }                                                                                                                 // 621\n  }                                                                                                                   // 622\n                                                                                                                      //\n  return meteorResult;                                                                                                // 624\n};                                                                                                                    // 625\n                                                                                                                      //\nvar NUM_OPTIMISTIC_TRIES = 3;                                                                                         // 628\n                                                                                                                      //\n// exposed for testing                                                                                                //\nMongoConnection._isCannotChangeIdError = function (err) {                                                             // 631\n  // First check for what this error looked like in Mongo 2.4.  Either of these                                       //\n  // checks should work, but just to be safe...                                                                       //\n  if (err.code === 13596) return true;                                                                                // 634\n  if (err.errmsg.indexOf(\"cannot change _id of a document\") === 0) return true;                                       // 636\n                                                                                                                      //\n  // Now look for what it looks like in Mongo 2.6.  We don't use the error code                                       //\n  // here, because the error code we observed it producing (16837) appears to be                                      //\n  // a far more generic error code based on examining the source.                                                     //\n  if (err.errmsg.indexOf(\"The _id field cannot be changed\") === 0) return true;                                       // 642\n                                                                                                                      //\n  return false;                                                                                                       // 645\n};                                                                                                                    // 646\n                                                                                                                      //\nvar simulateUpsertWithInsertedId = function simulateUpsertWithInsertedId(collection, selector, mod, isModify, options, callback) {\n  // STRATEGY:  First try doing a plain update.  If it affected 0 documents,                                          //\n  // then without affecting the database, we know we should probably do an                                            //\n  // insert.  We then do a *conditional* insert that will fail in the case                                            //\n  // of a race condition.  This conditional insert is actually an                                                     //\n  // upsert-replace with an _id, which will never successfully update an                                              //\n  // existing document.  If this upsert fails with an error saying it                                                 //\n  // couldn't change an existing _id, then we know an intervening write has                                           //\n  // caused the query to match something.  We go back to step one and repeat.                                         //\n  // Like all \"optimistic write\" schemes, we rely on the fact that it's                                               //\n  // unlikely our writes will continue to be interfered with under normal                                             //\n  // circumstances (though sufficiently heavy contention with writers                                                 //\n  // disagreeing on the existence of an object will cause writes to fail                                              //\n  // in theory).                                                                                                      //\n                                                                                                                      //\n  var newDoc;                                                                                                         // 664\n  // Run this code up front so that it fails fast if someone uses                                                     //\n  // a Mongo update operator we don't support.                                                                        //\n  if (isModify) {                                                                                                     // 667\n    // We've already run replaceTypes/replaceMeteorAtomWithMongo on                                                   //\n    // selector and mod.  We assume it doesn't matter, as far as                                                      //\n    // the behavior of modifiers is concerned, whether `_modify`                                                      //\n    // is run on EJSON or on mongo-converted EJSON.                                                                   //\n    var selectorDoc = LocalCollection._removeDollarOperators(selector);                                               // 672\n                                                                                                                      //\n    newDoc = selectorDoc;                                                                                             // 674\n                                                                                                                      //\n    // Convert dotted keys into objects. (Resolves issue #4522).                                                      //\n    _.each(newDoc, function (value, key) {                                                                            // 677\n      var trail = key.split(\".\");                                                                                     // 678\n                                                                                                                      //\n      if (trail.length > 1) {                                                                                         // 680\n        //Key is dotted. Convert it into an object.                                                                   //\n        delete newDoc[key];                                                                                           // 682\n                                                                                                                      //\n        var obj = newDoc,                                                                                             // 684\n            leaf = trail.pop();                                                                                       // 684\n                                                                                                                      //\n        // XXX It is not quite certain what should be done if there are clashing                                      //\n        // keys on the trail of the dotted key. For now we will just override it                                      //\n        // It wouldn't be a very sane query in the first place, but should look                                       //\n        // up what mongo does in this case.                                                                           //\n                                                                                                                      //\n        while (key = trail.shift()) {                                                                                 // 692\n          if (_typeof(obj[key]) !== \"object\") {                                                                       // 693\n            obj[key] = {};                                                                                            // 694\n          }                                                                                                           // 695\n                                                                                                                      //\n          obj = obj[key];                                                                                             // 697\n        }                                                                                                             // 698\n                                                                                                                      //\n        obj[leaf] = value;                                                                                            // 700\n      }                                                                                                               // 701\n    });                                                                                                               // 702\n                                                                                                                      //\n    LocalCollection._modify(newDoc, mod, { isInsert: true });                                                         // 704\n  } else {                                                                                                            // 705\n    newDoc = mod;                                                                                                     // 706\n  }                                                                                                                   // 707\n                                                                                                                      //\n  var insertedId = options.insertedId; // must exist                                                                  // 709\n  var mongoOptsForUpdate = {                                                                                          // 710\n    safe: true,                                                                                                       // 711\n    multi: options.multi                                                                                              // 712\n  };                                                                                                                  // 710\n  var mongoOptsForInsert = {                                                                                          // 714\n    safe: true,                                                                                                       // 715\n    upsert: true                                                                                                      // 716\n  };                                                                                                                  // 714\n                                                                                                                      //\n  var tries = NUM_OPTIMISTIC_TRIES;                                                                                   // 719\n                                                                                                                      //\n  var doUpdate = function doUpdate() {                                                                                // 721\n    tries--;                                                                                                          // 722\n    if (!tries) {                                                                                                     // 723\n      callback(new Error(\"Upsert failed after \" + NUM_OPTIMISTIC_TRIES + \" tries.\"));                                 // 724\n    } else {                                                                                                          // 725\n      collection.update(selector, mod, mongoOptsForUpdate, bindEnvironmentForWrite(function (err, result) {           // 726\n        if (err) {                                                                                                    // 728\n          callback(err);                                                                                              // 729\n        } else if (result && result.result.n != 0) {                                                                  // 730\n          callback(null, {                                                                                            // 731\n            numberAffected: result.result.n                                                                           // 732\n          });                                                                                                         // 731\n        } else {                                                                                                      // 734\n          doConditionalInsert();                                                                                      // 735\n        }                                                                                                             // 736\n      }));                                                                                                            // 737\n    }                                                                                                                 // 738\n  };                                                                                                                  // 739\n                                                                                                                      //\n  var doConditionalInsert = function doConditionalInsert() {                                                          // 741\n    var replacementWithId = _.extend(replaceTypes({ _id: insertedId }, replaceMeteorAtomWithMongo), newDoc);          // 742\n    collection.update(selector, replacementWithId, mongoOptsForInsert, bindEnvironmentForWrite(function (err, result) {\n      if (err) {                                                                                                      // 747\n        // figure out if this is a                                                                                    //\n        // \"cannot change _id of document\" error, and                                                                 //\n        // if so, try doUpdate() again, up to 3 times.                                                                //\n        if (MongoConnection._isCannotChangeIdError(err)) {                                                            // 751\n          doUpdate();                                                                                                 // 752\n        } else {                                                                                                      // 753\n          callback(err);                                                                                              // 754\n        }                                                                                                             // 755\n      } else {                                                                                                        // 756\n        callback(null, {                                                                                              // 757\n          numberAffected: result.result.upserted.length,                                                              // 758\n          insertedId: insertedId                                                                                      // 759\n        });                                                                                                           // 757\n      }                                                                                                               // 761\n    }));                                                                                                              // 762\n  };                                                                                                                  // 763\n                                                                                                                      //\n  doUpdate();                                                                                                         // 765\n};                                                                                                                    // 766\n                                                                                                                      //\n_.each([\"insert\", \"update\", \"remove\", \"dropCollection\", \"dropDatabase\"], function (method) {                          // 768\n  MongoConnection.prototype[method] = function () /* arguments */{                                                    // 769\n    var self = this;                                                                                                  // 770\n    return Meteor.wrapAsync(self[\"_\" + method]).apply(self, arguments);                                               // 771\n  };                                                                                                                  // 772\n});                                                                                                                   // 773\n                                                                                                                      //\n// XXX MongoConnection.upsert() does not return the id of the inserted document                                       //\n// unless you set it explicitly in the selector or modifier (as a replacement                                         //\n// doc).                                                                                                              //\nMongoConnection.prototype.upsert = function (collectionName, selector, mod, options, callback) {                      // 778\n  var self = this;                                                                                                    // 780\n  if (typeof options === \"function\" && !callback) {                                                                   // 781\n    callback = options;                                                                                               // 782\n    options = {};                                                                                                     // 783\n  }                                                                                                                   // 784\n                                                                                                                      //\n  return self.update(collectionName, selector, mod, _.extend({}, options, {                                           // 786\n    upsert: true,                                                                                                     // 788\n    _returnObject: true                                                                                               // 789\n  }), callback);                                                                                                      // 787\n};                                                                                                                    // 791\n                                                                                                                      //\nMongoConnection.prototype.find = function (collectionName, selector, options) {                                       // 793\n  var self = this;                                                                                                    // 794\n                                                                                                                      //\n  if (arguments.length === 1) selector = {};                                                                          // 796\n                                                                                                                      //\n  return new Cursor(self, new CursorDescription(collectionName, selector, options));                                  // 799\n};                                                                                                                    // 801\n                                                                                                                      //\nMongoConnection.prototype.findOne = function (collection_name, selector, options) {                                   // 803\n  var self = this;                                                                                                    // 805\n  if (arguments.length === 1) selector = {};                                                                          // 806\n                                                                                                                      //\n  options = options || {};                                                                                            // 809\n  options.limit = 1;                                                                                                  // 810\n  return self.find(collection_name, selector, options).fetch()[0];                                                    // 811\n};                                                                                                                    // 812\n                                                                                                                      //\n// We'll actually design an index API later. For now, we just pass through to                                         //\n// Mongo's, but make it synchronous.                                                                                  //\nMongoConnection.prototype._ensureIndex = function (collectionName, index, options) {                                  // 816\n  var self = this;                                                                                                    // 818\n                                                                                                                      //\n  // We expect this function to be called at startup, not from within a method,                                       //\n  // so we don't interact with the write fence.                                                                       //\n  var collection = self.rawCollection(collectionName);                                                                // 822\n  var future = new Future();                                                                                          // 823\n  var indexName = collection.ensureIndex(index, options, future.resolver());                                          // 824\n  future.wait();                                                                                                      // 825\n};                                                                                                                    // 826\nMongoConnection.prototype._dropIndex = function (collectionName, index) {                                             // 827\n  var self = this;                                                                                                    // 828\n                                                                                                                      //\n  // This function is only used by test code, not within a method, so we don't                                        //\n  // interact with the write fence.                                                                                   //\n  var collection = self.rawCollection(collectionName);                                                                // 832\n  var future = new Future();                                                                                          // 833\n  var indexName = collection.dropIndex(index, future.resolver());                                                     // 834\n  future.wait();                                                                                                      // 835\n};                                                                                                                    // 836\n                                                                                                                      //\n// CURSORS                                                                                                            //\n                                                                                                                      //\n// There are several classes which relate to cursors:                                                                 //\n//                                                                                                                    //\n// CursorDescription represents the arguments used to construct a cursor:                                             //\n// collectionName, selector, and (find) options.  Because it is used as a key                                         //\n// for cursor de-dup, everything in it should either be JSON-stringifiable or                                         //\n// not affect observeChanges output (eg, options.transform functions are not                                          //\n// stringifiable but do not affect observeChanges).                                                                   //\n//                                                                                                                    //\n// SynchronousCursor is a wrapper around a MongoDB cursor                                                             //\n// which includes fully-synchronous versions of forEach, etc.                                                         //\n//                                                                                                                    //\n// Cursor is the cursor object returned from find(), which implements the                                             //\n// documented Mongo.Collection cursor API.  It wraps a CursorDescription and a                                        //\n// SynchronousCursor (lazily: it doesn't contact Mongo until you call a method                                        //\n// like fetch or forEach on it).                                                                                      //\n//                                                                                                                    //\n// ObserveHandle is the \"observe handle\" returned from observeChanges. It has a                                       //\n// reference to an ObserveMultiplexer.                                                                                //\n//                                                                                                                    //\n// ObserveMultiplexer allows multiple identical ObserveHandles to be driven by a                                      //\n// single observe driver.                                                                                             //\n//                                                                                                                    //\n// There are two \"observe drivers\" which drive ObserveMultiplexers:                                                   //\n//   - PollingObserveDriver caches the results of a query and reruns it when                                          //\n//     necessary.                                                                                                     //\n//   - OplogObserveDriver follows the Mongo operation log to directly observe                                         //\n//     database changes.                                                                                              //\n// Both implementations follow the same simple interface: when you create them,                                       //\n// they start sending observeChanges callbacks (and a ready() invocation) to                                          //\n// their ObserveMultiplexer, and you stop them by calling their stop() method.                                        //\n                                                                                                                      //\nCursorDescription = function CursorDescription(collectionName, selector, options) {                                   // 871\n  var self = this;                                                                                                    // 872\n  self.collectionName = collectionName;                                                                               // 873\n  self.selector = Mongo.Collection._rewriteSelector(selector);                                                        // 874\n  self.options = options || {};                                                                                       // 875\n};                                                                                                                    // 876\n                                                                                                                      //\nCursor = function Cursor(mongo, cursorDescription) {                                                                  // 878\n  var self = this;                                                                                                    // 879\n                                                                                                                      //\n  self._mongo = mongo;                                                                                                // 881\n  self._cursorDescription = cursorDescription;                                                                        // 882\n  self._synchronousCursor = null;                                                                                     // 883\n};                                                                                                                    // 884\n                                                                                                                      //\n_.each(['forEach', 'map', 'fetch', 'count'], function (method) {                                                      // 886\n  Cursor.prototype[method] = function () {                                                                            // 887\n    var self = this;                                                                                                  // 888\n                                                                                                                      //\n    // You can only observe a tailable cursor.                                                                        //\n    if (self._cursorDescription.options.tailable) throw new Error(\"Cannot call \" + method + \" on a tailable cursor\");\n                                                                                                                      //\n    if (!self._synchronousCursor) {                                                                                   // 894\n      self._synchronousCursor = self._mongo._createSynchronousCursor(self._cursorDescription, {                       // 895\n        // Make sure that the \"self\" argument to forEach/map callbacks is the                                         //\n        // Cursor, not the SynchronousCursor.                                                                         //\n        selfForIteration: self,                                                                                       // 899\n        useTransform: true                                                                                            // 900\n      });                                                                                                             // 896\n    }                                                                                                                 // 902\n                                                                                                                      //\n    return self._synchronousCursor[method].apply(self._synchronousCursor, arguments);                                 // 904\n  };                                                                                                                  // 906\n});                                                                                                                   // 907\n                                                                                                                      //\n// Since we don't actually have a \"nextObject\" interface, there's really no                                           //\n// reason to have a \"rewind\" interface.  All it did was make multiple calls                                           //\n// to fetch/map/forEach return nothing the second time.                                                               //\n// XXX COMPAT WITH 0.8.1                                                                                              //\nCursor.prototype.rewind = function () {};                                                                             // 913\n                                                                                                                      //\nCursor.prototype.getTransform = function () {                                                                         // 916\n  return this._cursorDescription.options.transform;                                                                   // 917\n};                                                                                                                    // 918\n                                                                                                                      //\n// When you call Meteor.publish() with a function that returns a Cursor, we need                                      //\n// to transmute it into the equivalent subscription.  This is the function that                                       //\n// does that.                                                                                                         //\n                                                                                                                      //\nCursor.prototype._publishCursor = function (sub) {                                                                    // 924\n  var self = this;                                                                                                    // 925\n  var collection = self._cursorDescription.collectionName;                                                            // 926\n  return Mongo.Collection._publishCursor(self, sub, collection);                                                      // 927\n};                                                                                                                    // 928\n                                                                                                                      //\n// Used to guarantee that publish functions return at most one cursor per                                             //\n// collection. Private, because we might later have cursors that include                                              //\n// documents from multiple collections somehow.                                                                       //\nCursor.prototype._getCollectionName = function () {                                                                   // 933\n  var self = this;                                                                                                    // 934\n  return self._cursorDescription.collectionName;                                                                      // 935\n};                                                                                                                    // 936\n                                                                                                                      //\nCursor.prototype.observe = function (callbacks) {                                                                     // 938\n  var self = this;                                                                                                    // 939\n  return LocalCollection._observeFromObserveChanges(self, callbacks);                                                 // 940\n};                                                                                                                    // 941\n                                                                                                                      //\nCursor.prototype.observeChanges = function (callbacks) {                                                              // 943\n  var self = this;                                                                                                    // 944\n  var ordered = LocalCollection._observeChangesCallbacksAreOrdered(callbacks);                                        // 945\n  return self._mongo._observeChanges(self._cursorDescription, ordered, callbacks);                                    // 946\n};                                                                                                                    // 948\n                                                                                                                      //\nMongoConnection.prototype._createSynchronousCursor = function (cursorDescription, options) {                          // 950\n  var self = this;                                                                                                    // 952\n  options = _.pick(options || {}, 'selfForIteration', 'useTransform');                                                // 953\n                                                                                                                      //\n  var collection = self.rawCollection(cursorDescription.collectionName);                                              // 955\n  var cursorOptions = cursorDescription.options;                                                                      // 956\n  var mongoOptions = {                                                                                                // 957\n    sort: cursorOptions.sort,                                                                                         // 958\n    limit: cursorOptions.limit,                                                                                       // 959\n    skip: cursorOptions.skip                                                                                          // 960\n  };                                                                                                                  // 957\n                                                                                                                      //\n  // Do we want a tailable cursor (which only works on capped collections)?                                           //\n  if (cursorOptions.tailable) {                                                                                       // 964\n    // We want a tailable cursor...                                                                                   //\n    mongoOptions.tailable = true;                                                                                     // 966\n    // ... and for the server to wait a bit if any getMore has no data (rather                                        //\n    // than making us put the relevant sleeps in the client)...                                                       //\n    mongoOptions.awaitdata = true;                                                                                    // 969\n    // ... and to keep querying the server indefinitely rather than just 5 times                                      //\n    // if there's no more data.                                                                                       //\n    mongoOptions.numberOfRetries = -1;                                                                                // 972\n    // And if this is on the oplog collection and the cursor specifies a 'ts',                                        //\n    // then set the undocumented oplog replay flag, which does a special scan to                                      //\n    // find the first document (instead of creating an index on ts). This is a                                        //\n    // very hard-coded Mongo flag which only works on the oplog collection and                                        //\n    // only works with the ts field.                                                                                  //\n    if (cursorDescription.collectionName === OPLOG_COLLECTION && cursorDescription.selector.ts) {                     // 978\n      mongoOptions.oplogReplay = true;                                                                                // 980\n    }                                                                                                                 // 981\n  }                                                                                                                   // 982\n                                                                                                                      //\n  var dbCursor = collection.find(replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo), cursorOptions.fields, mongoOptions);\n                                                                                                                      //\n  return new SynchronousCursor(dbCursor, cursorDescription, options);                                                 // 988\n};                                                                                                                    // 989\n                                                                                                                      //\nvar SynchronousCursor = function SynchronousCursor(dbCursor, cursorDescription, options) {                            // 991\n  var self = this;                                                                                                    // 992\n  options = _.pick(options || {}, 'selfForIteration', 'useTransform');                                                // 993\n                                                                                                                      //\n  self._dbCursor = dbCursor;                                                                                          // 995\n  self._cursorDescription = cursorDescription;                                                                        // 996\n  // The \"self\" argument passed to forEach/map callbacks. If we're wrapped                                            //\n  // inside a user-visible Cursor, we want to provide the outer cursor!                                               //\n  self._selfForIteration = options.selfForIteration || self;                                                          // 999\n  if (options.useTransform && cursorDescription.options.transform) {                                                  // 1000\n    self._transform = LocalCollection.wrapTransform(cursorDescription.options.transform);                             // 1001\n  } else {                                                                                                            // 1003\n    self._transform = null;                                                                                           // 1004\n  }                                                                                                                   // 1005\n                                                                                                                      //\n  // Need to specify that the callback is the first argument to nextObject,                                           //\n  // since otherwise when we try to call it with no args the driver will                                              //\n  // interpret \"undefined\" first arg as an options hash and crash.                                                    //\n  self._synchronousNextObject = Future.wrap(dbCursor.nextObject.bind(dbCursor), 0);                                   // 1010\n  self._synchronousCount = Future.wrap(dbCursor.count.bind(dbCursor));                                                // 1012\n  self._visitedIds = new LocalCollection._IdMap();                                                                    // 1013\n};                                                                                                                    // 1014\n                                                                                                                      //\n_.extend(SynchronousCursor.prototype, {                                                                               // 1016\n  _nextObject: function _nextObject() {                                                                               // 1017\n    var self = this;                                                                                                  // 1018\n                                                                                                                      //\n    while (true) {                                                                                                    // 1020\n      var doc = self._synchronousNextObject().wait();                                                                 // 1021\n                                                                                                                      //\n      if (!doc) return null;                                                                                          // 1023\n      doc = replaceTypes(doc, replaceMongoAtomWithMeteor);                                                            // 1024\n                                                                                                                      //\n      if (!self._cursorDescription.options.tailable && _.has(doc, '_id')) {                                           // 1026\n        // Did Mongo give us duplicate documents in the same cursor? If so,                                           //\n        // ignore this one. (Do this before the transform, since transform might                                      //\n        // return some unrelated value.) We don't do this for tailable cursors,                                       //\n        // because we want to maintain O(1) memory usage. And if there isn't _id                                      //\n        // for some reason (maybe it's the oplog), then we don't do this either.                                      //\n        // (Be careful to do this for falsey but existing _id, though.)                                               //\n        if (self._visitedIds.has(doc._id)) continue;                                                                  // 1033\n        self._visitedIds.set(doc._id, true);                                                                          // 1034\n      }                                                                                                               // 1035\n                                                                                                                      //\n      if (self._transform) doc = self._transform(doc);                                                                // 1037\n                                                                                                                      //\n      return doc;                                                                                                     // 1040\n    }                                                                                                                 // 1041\n  },                                                                                                                  // 1042\n                                                                                                                      //\n  forEach: function forEach(callback, thisArg) {                                                                      // 1044\n    var self = this;                                                                                                  // 1045\n                                                                                                                      //\n    // Get back to the beginning.                                                                                     //\n    self._rewind();                                                                                                   // 1048\n                                                                                                                      //\n    // We implement the loop ourself instead of using self._dbCursor.each,                                            //\n    // because \"each\" will call its callback outside of a fiber which makes it                                        //\n    // much more complex to make this function synchronous.                                                           //\n    var index = 0;                                                                                                    // 1053\n    while (true) {                                                                                                    // 1054\n      var doc = self._nextObject();                                                                                   // 1055\n      if (!doc) return;                                                                                               // 1056\n      callback.call(thisArg, doc, index++, self._selfForIteration);                                                   // 1057\n    }                                                                                                                 // 1058\n  },                                                                                                                  // 1059\n                                                                                                                      //\n  // XXX Allow overlapping callback executions if callback yields.                                                    //\n  map: function map(callback, thisArg) {                                                                              // 1062\n    var self = this;                                                                                                  // 1063\n    var res = [];                                                                                                     // 1064\n    self.forEach(function (doc, index) {                                                                              // 1065\n      res.push(callback.call(thisArg, doc, index, self._selfForIteration));                                           // 1066\n    });                                                                                                               // 1067\n    return res;                                                                                                       // 1068\n  },                                                                                                                  // 1069\n                                                                                                                      //\n  _rewind: function _rewind() {                                                                                       // 1071\n    var self = this;                                                                                                  // 1072\n                                                                                                                      //\n    // known to be synchronous                                                                                        //\n    self._dbCursor.rewind();                                                                                          // 1075\n                                                                                                                      //\n    self._visitedIds = new LocalCollection._IdMap();                                                                  // 1077\n  },                                                                                                                  // 1078\n                                                                                                                      //\n  // Mostly usable for tailable cursors.                                                                              //\n  close: function close() {                                                                                           // 1081\n    var self = this;                                                                                                  // 1082\n                                                                                                                      //\n    self._dbCursor.close();                                                                                           // 1084\n  },                                                                                                                  // 1085\n                                                                                                                      //\n  fetch: function fetch() {                                                                                           // 1087\n    var self = this;                                                                                                  // 1088\n    return self.map(_.identity);                                                                                      // 1089\n  },                                                                                                                  // 1090\n                                                                                                                      //\n  count: function count(applySkipLimit) {                                                                             // 1092\n    var self = this;                                                                                                  // 1093\n    return self._synchronousCount(applySkipLimit).wait();                                                             // 1094\n  },                                                                                                                  // 1095\n                                                                                                                      //\n  // This method is NOT wrapped in Cursor.                                                                            //\n  getRawObjects: function getRawObjects(ordered) {                                                                    // 1098\n    var self = this;                                                                                                  // 1099\n    if (ordered) {                                                                                                    // 1100\n      return self.fetch();                                                                                            // 1101\n    } else {                                                                                                          // 1102\n      var results = new LocalCollection._IdMap();                                                                     // 1103\n      self.forEach(function (doc) {                                                                                   // 1104\n        results.set(doc._id, doc);                                                                                    // 1105\n      });                                                                                                             // 1106\n      return results;                                                                                                 // 1107\n    }                                                                                                                 // 1108\n  }                                                                                                                   // 1109\n});                                                                                                                   // 1016\n                                                                                                                      //\nMongoConnection.prototype.tail = function (cursorDescription, docCallback) {                                          // 1112\n  var self = this;                                                                                                    // 1113\n  if (!cursorDescription.options.tailable) throw new Error(\"Can only tail a tailable cursor\");                        // 1114\n                                                                                                                      //\n  var cursor = self._createSynchronousCursor(cursorDescription);                                                      // 1117\n                                                                                                                      //\n  var stopped = false;                                                                                                // 1119\n  var lastTS = undefined;                                                                                             // 1120\n  var loop = function loop() {                                                                                        // 1121\n    while (true) {                                                                                                    // 1122\n      if (stopped) return;                                                                                            // 1123\n      try {                                                                                                           // 1125\n        var doc = cursor._nextObject();                                                                               // 1126\n      } catch (err) {                                                                                                 // 1127\n        // There's no good way to figure out if this was actually an error                                            //\n        // from Mongo. Ah well. But either way, we need to retry the cursor                                           //\n        // (unless the failure was because the observe got stopped).                                                  //\n        doc = null;                                                                                                   // 1131\n      }                                                                                                               // 1132\n      // Since cursor._nextObject can yield, we need to check again to see if                                         //\n      // we've been stopped before calling the callback.                                                              //\n      if (stopped) return;                                                                                            // 1135\n      if (doc) {                                                                                                      // 1137\n        // If a tailable cursor contains a \"ts\" field, use it to recreate the                                         //\n        // cursor on error. (\"ts\" is a standard that Mongo uses internally for                                        //\n        // the oplog, and there's a special flag that lets you do binary search                                       //\n        // on it instead of needing to use an index.)                                                                 //\n        lastTS = doc.ts;                                                                                              // 1142\n        docCallback(doc);                                                                                             // 1143\n      } else {                                                                                                        // 1144\n        var newSelector = _.clone(cursorDescription.selector);                                                        // 1145\n        if (lastTS) {                                                                                                 // 1146\n          newSelector.ts = { $gt: lastTS };                                                                           // 1147\n        }                                                                                                             // 1148\n        cursor = self._createSynchronousCursor(new CursorDescription(cursorDescription.collectionName, newSelector, cursorDescription.options));\n        // Mongo failover takes many seconds.  Retry in a bit.  (Without this                                         //\n        // setTimeout, we peg the CPU at 100% and never notice the actual                                             //\n        // failover.                                                                                                  //\n        Meteor.setTimeout(loop, 100);                                                                                 // 1156\n        break;                                                                                                        // 1157\n      }                                                                                                               // 1158\n    }                                                                                                                 // 1159\n  };                                                                                                                  // 1160\n                                                                                                                      //\n  Meteor.defer(loop);                                                                                                 // 1162\n                                                                                                                      //\n  return {                                                                                                            // 1164\n    stop: function stop() {                                                                                           // 1165\n      stopped = true;                                                                                                 // 1166\n      cursor.close();                                                                                                 // 1167\n    }                                                                                                                 // 1168\n  };                                                                                                                  // 1164\n};                                                                                                                    // 1170\n                                                                                                                      //\nMongoConnection.prototype._observeChanges = function (cursorDescription, ordered, callbacks) {                        // 1172\n  var self = this;                                                                                                    // 1174\n                                                                                                                      //\n  if (cursorDescription.options.tailable) {                                                                           // 1176\n    return self._observeChangesTailable(cursorDescription, ordered, callbacks);                                       // 1177\n  }                                                                                                                   // 1178\n                                                                                                                      //\n  // You may not filter out _id when observing changes, because the id is a core                                      //\n  // part of the observeChanges API.                                                                                  //\n  if (cursorDescription.options.fields && (cursorDescription.options.fields._id === 0 || cursorDescription.options.fields._id === false)) {\n    throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");                                              // 1185\n  }                                                                                                                   // 1186\n                                                                                                                      //\n  var observeKey = JSON.stringify(_.extend({ ordered: ordered }, cursorDescription));                                 // 1188\n                                                                                                                      //\n  var multiplexer, observeDriver;                                                                                     // 1191\n  var firstHandle = false;                                                                                            // 1192\n                                                                                                                      //\n  // Find a matching ObserveMultiplexer, or create a new one. This next block is                                      //\n  // guaranteed to not yield (and it doesn't call anything that can observe a                                         //\n  // new query), so no other calls to this function can interleave with it.                                           //\n  Meteor._noYieldsAllowed(function () {                                                                               // 1197\n    if (_.has(self._observeMultiplexers, observeKey)) {                                                               // 1198\n      multiplexer = self._observeMultiplexers[observeKey];                                                            // 1199\n    } else {                                                                                                          // 1200\n      firstHandle = true;                                                                                             // 1201\n      // Create a new ObserveMultiplexer.                                                                             //\n      multiplexer = new ObserveMultiplexer({                                                                          // 1203\n        ordered: ordered,                                                                                             // 1204\n        onStop: function onStop() {                                                                                   // 1205\n          delete self._observeMultiplexers[observeKey];                                                               // 1206\n          observeDriver.stop();                                                                                       // 1207\n        }                                                                                                             // 1208\n      });                                                                                                             // 1203\n      self._observeMultiplexers[observeKey] = multiplexer;                                                            // 1210\n    }                                                                                                                 // 1211\n  });                                                                                                                 // 1212\n                                                                                                                      //\n  var observeHandle = new ObserveHandle(multiplexer, callbacks);                                                      // 1214\n                                                                                                                      //\n  if (firstHandle) {                                                                                                  // 1216\n    var matcher, sorter;                                                                                              // 1217\n    var canUseOplog = _.all([function () {                                                                            // 1218\n      // At a bare minimum, using the oplog requires us to have an oplog, to                                          //\n      // want unordered callbacks, and to not want a callback on the polls                                            //\n      // that won't happen.                                                                                           //\n      return self._oplogHandle && !ordered && !callbacks._testOnlyPollCallback;                                       // 1223\n    }, function () {                                                                                                  // 1225\n      // We need to be able to compile the selector. Fall back to polling for                                         //\n      // some newfangled $selector that minimongo doesn't support yet.                                                //\n      try {                                                                                                           // 1228\n        matcher = new Minimongo.Matcher(cursorDescription.selector);                                                  // 1229\n        return true;                                                                                                  // 1230\n      } catch (e) {                                                                                                   // 1231\n        // XXX make all compilation errors MinimongoError or something                                                //\n        //     so that this doesn't ignore unrelated exceptions                                                       //\n        return false;                                                                                                 // 1234\n      }                                                                                                               // 1235\n    }, function () {                                                                                                  // 1236\n      // ... and the selector itself needs to support oplog.                                                          //\n      return OplogObserveDriver.cursorSupported(cursorDescription, matcher);                                          // 1238\n    }, function () {                                                                                                  // 1239\n      // And we need to be able to compile the sort, if any.  eg, can't be                                            //\n      // {$natural: 1}.                                                                                               //\n      if (!cursorDescription.options.sort) return true;                                                               // 1242\n      try {                                                                                                           // 1244\n        sorter = new Minimongo.Sorter(cursorDescription.options.sort, { matcher: matcher });                          // 1245\n        return true;                                                                                                  // 1247\n      } catch (e) {                                                                                                   // 1248\n        // XXX make all compilation errors MinimongoError or something                                                //\n        //     so that this doesn't ignore unrelated exceptions                                                       //\n        return false;                                                                                                 // 1251\n      }                                                                                                               // 1252\n    }], function (f) {                                                                                                // 1253\n      return f();                                                                                                     // 1253\n    }); // invoke each function                                                                                       // 1253\n                                                                                                                      //\n    var driverClass = canUseOplog ? OplogObserveDriver : PollingObserveDriver;                                        // 1255\n    observeDriver = new driverClass({                                                                                 // 1256\n      cursorDescription: cursorDescription,                                                                           // 1257\n      mongoHandle: self,                                                                                              // 1258\n      multiplexer: multiplexer,                                                                                       // 1259\n      ordered: ordered,                                                                                               // 1260\n      matcher: matcher, // ignored by polling                                                                         // 1261\n      sorter: sorter, // ignored by polling                                                                           // 1262\n      _testOnlyPollCallback: callbacks._testOnlyPollCallback                                                          // 1263\n    });                                                                                                               // 1256\n                                                                                                                      //\n    // This field is only set for use in tests.                                                                       //\n    multiplexer._observeDriver = observeDriver;                                                                       // 1267\n  }                                                                                                                   // 1268\n                                                                                                                      //\n  // Blocks until the initial adds have been sent.                                                                    //\n  multiplexer.addHandleAndSendInitialAdds(observeHandle);                                                             // 1271\n                                                                                                                      //\n  return observeHandle;                                                                                               // 1273\n};                                                                                                                    // 1274\n                                                                                                                      //\n// Listen for the invalidation messages that will trigger us to poll the                                              //\n// database for changes. If this selector specifies specific IDs, specify them                                        //\n// here, so that updates to different specific IDs don't cause us to poll.                                            //\n// listenCallback is the same kind of (notification, complete) callback passed                                        //\n// to InvalidationCrossbar.listen.                                                                                    //\n                                                                                                                      //\nlistenAll = function listenAll(cursorDescription, listenCallback) {                                                   // 1282\n  var listeners = [];                                                                                                 // 1283\n  forEachTrigger(cursorDescription, function (trigger) {                                                              // 1284\n    listeners.push(DDPServer._InvalidationCrossbar.listen(trigger, listenCallback));                                  // 1285\n  });                                                                                                                 // 1287\n                                                                                                                      //\n  return {                                                                                                            // 1289\n    stop: function stop() {                                                                                           // 1290\n      _.each(listeners, function (listener) {                                                                         // 1291\n        listener.stop();                                                                                              // 1292\n      });                                                                                                             // 1293\n    }                                                                                                                 // 1294\n  };                                                                                                                  // 1289\n};                                                                                                                    // 1296\n                                                                                                                      //\nforEachTrigger = function forEachTrigger(cursorDescription, triggerCallback) {                                        // 1298\n  var key = { collection: cursorDescription.collectionName };                                                         // 1299\n  var specificIds = LocalCollection._idsMatchedBySelector(cursorDescription.selector);                                // 1300\n  if (specificIds) {                                                                                                  // 1302\n    _.each(specificIds, function (id) {                                                                               // 1303\n      triggerCallback(_.extend({ id: id }, key));                                                                     // 1304\n    });                                                                                                               // 1305\n    triggerCallback(_.extend({ dropCollection: true, id: null }, key));                                               // 1306\n  } else {                                                                                                            // 1307\n    triggerCallback(key);                                                                                             // 1308\n  }                                                                                                                   // 1309\n  // Everyone cares about the database being dropped.                                                                 //\n  triggerCallback({ dropDatabase: true });                                                                            // 1311\n};                                                                                                                    // 1312\n                                                                                                                      //\n// observeChanges for tailable cursors on capped collections.                                                         //\n//                                                                                                                    //\n// Some differences from normal cursors:                                                                              //\n//   - Will never produce anything other than 'added' or 'addedBefore'. If you                                        //\n//     do update a document that has already been produced, this will not notice                                      //\n//     it.                                                                                                            //\n//   - If you disconnect and reconnect from Mongo, it will essentially restart                                        //\n//     the query, which will lead to duplicate results. This is pretty bad,                                           //\n//     but if you include a field called 'ts' which is inserted as                                                    //\n//     new MongoInternals.MongoTimestamp(0, 0) (which is initialized to the                                           //\n//     current Mongo-style timestamp), we'll be able to find the place to                                             //\n//     restart properly. (This field is specifically understood by Mongo with an                                      //\n//     optimization which allows it to find the right place to start without                                          //\n//     an index on ts. It's how the oplog works.)                                                                     //\n//   - No callbacks are triggered synchronously with the call (there's no                                             //\n//     differentiation between \"initial data\" and \"later changes\"; everything                                         //\n//     that matches the query gets sent asynchronously).                                                              //\n//   - De-duplication is not implemented.                                                                             //\n//   - Does not yet interact with the write fence. Probably, this should work by                                      //\n//     ignoring removes (which don't work on capped collections) and updates                                          //\n//     (which don't affect tailable cursors), and just keeping track of the ID                                        //\n//     of the inserted object, and closing the write fence once you get to that                                       //\n//     ID (or timestamp?).  This doesn't work well if the document doesn't match                                      //\n//     the query, though.  On the other hand, the write fence can close                                               //\n//     immediately if it does not match the query. So if we trust minimongo                                           //\n//     enough to accurately evaluate the query against the write fence, we                                            //\n//     should be able to do this...  Of course, minimongo doesn't even support                                        //\n//     Mongo Timestamps yet.                                                                                          //\nMongoConnection.prototype._observeChangesTailable = function (cursorDescription, ordered, callbacks) {                // 1342\n  var self = this;                                                                                                    // 1344\n                                                                                                                      //\n  // Tailable cursors only ever call added/addedBefore callbacks, so it's an                                          //\n  // error if you didn't provide them.                                                                                //\n  if (ordered && !callbacks.addedBefore || !ordered && !callbacks.added) {                                            // 1348\n    throw new Error(\"Can't observe an \" + (ordered ? \"ordered\" : \"unordered\") + \" tailable cursor without a \" + (ordered ? \"addedBefore\" : \"added\") + \" callback\");\n  }                                                                                                                   // 1353\n                                                                                                                      //\n  return self.tail(cursorDescription, function (doc) {                                                                // 1355\n    var id = doc._id;                                                                                                 // 1356\n    delete doc._id;                                                                                                   // 1357\n    // The ts is an implementation detail. Hide it.                                                                   //\n    delete doc.ts;                                                                                                    // 1359\n    if (ordered) {                                                                                                    // 1360\n      callbacks.addedBefore(id, doc, null);                                                                           // 1361\n    } else {                                                                                                          // 1362\n      callbacks.added(id, doc);                                                                                       // 1363\n    }                                                                                                                 // 1364\n  });                                                                                                                 // 1365\n};                                                                                                                    // 1366\n                                                                                                                      //\n// XXX We probably need to find a better way to expose this. Right now                                                //\n// it's only used by tests, but in fact you need it in normal                                                         //\n// operation to interact with capped collections.                                                                     //\nMongoInternals.MongoTimestamp = MongoDB.Timestamp;                                                                    // 1371\n                                                                                                                      //\nMongoInternals.Connection = MongoConnection;                                                                          // 1373\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"oplog_tailing.js\":function(require){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/mongo/oplog_tailing.js                                                                                    //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nvar Future = Npm.require('fibers/future');                                                                            // 1\n                                                                                                                      //\nOPLOG_COLLECTION = 'oplog.rs';                                                                                        // 3\n                                                                                                                      //\nvar TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;                                                 // 5\n                                                                                                                      //\nvar showTS = function showTS(ts) {                                                                                    // 7\n  return \"Timestamp(\" + ts.getHighBits() + \", \" + ts.getLowBits() + \")\";                                              // 8\n};                                                                                                                    // 9\n                                                                                                                      //\nidForOp = function idForOp(op) {                                                                                      // 11\n  if (op.op === 'd') return op.o._id;else if (op.op === 'i') return op.o._id;else if (op.op === 'u') return op.o2._id;else if (op.op === 'c') throw Error(\"Operator 'c' doesn't supply an object with id: \" + EJSON.stringify(op));else throw Error(\"Unknown op: \" + EJSON.stringify(op));\n};                                                                                                                    // 23\n                                                                                                                      //\nOplogHandle = function OplogHandle(oplogUrl, dbName) {                                                                // 25\n  var self = this;                                                                                                    // 26\n  self._oplogUrl = oplogUrl;                                                                                          // 27\n  self._dbName = dbName;                                                                                              // 28\n                                                                                                                      //\n  self._oplogLastEntryConnection = null;                                                                              // 30\n  self._oplogTailConnection = null;                                                                                   // 31\n  self._stopped = false;                                                                                              // 32\n  self._tailHandle = null;                                                                                            // 33\n  self._readyFuture = new Future();                                                                                   // 34\n  self._crossbar = new DDPServer._Crossbar({                                                                          // 35\n    factPackage: \"mongo-livedata\", factName: \"oplog-watchers\"                                                         // 36\n  });                                                                                                                 // 35\n  self._baseOplogSelector = {                                                                                         // 38\n    ns: new RegExp('^' + Meteor._escapeRegExp(self._dbName) + '\\\\.'),                                                 // 39\n    $or: [{ op: { $in: ['i', 'u', 'd'] } },                                                                           // 40\n    // drop collection                                                                                                //\n    { op: 'c', 'o.drop': { $exists: true } }, { op: 'c', 'o.dropDatabase': 1 }]                                       // 43\n  };                                                                                                                  // 38\n                                                                                                                      //\n  // Data structures to support waitUntilCaughtUp(). Each oplog entry has a                                           //\n  // MongoTimestamp object on it (which is not the same as a Date --- it's a                                          //\n  // combination of time and an incrementing counter; see                                                             //\n  // http://docs.mongodb.org/manual/reference/bson-types/#timestamps).                                                //\n  //                                                                                                                  //\n  // _catchingUpFutures is an array of {ts: MongoTimestamp, future: Future}                                           //\n  // objects, sorted by ascending timestamp. _lastProcessedTS is the                                                  //\n  // MongoTimestamp of the last oplog entry we've processed.                                                          //\n  //                                                                                                                  //\n  // Each time we call waitUntilCaughtUp, we take a peek at the final oplog                                           //\n  // entry in the db.  If we've already processed it (ie, it is not greater than                                      //\n  // _lastProcessedTS), waitUntilCaughtUp immediately returns. Otherwise,                                             //\n  // waitUntilCaughtUp makes a new Future and inserts it along with the final                                         //\n  // timestamp entry that it read, into _catchingUpFutures. waitUntilCaughtUp                                         //\n  // then waits on that future, which is resolved once _lastProcessedTS is                                            //\n  // incremented to be past its timestamp by the worker fiber.                                                        //\n  //                                                                                                                  //\n  // XXX use a priority queue or something else that's faster than an array                                           //\n  self._catchingUpFutures = [];                                                                                       // 66\n  self._lastProcessedTS = null;                                                                                       // 67\n                                                                                                                      //\n  self._onSkippedEntriesHook = new Hook({                                                                             // 69\n    debugPrintExceptions: \"onSkippedEntries callback\"                                                                 // 70\n  });                                                                                                                 // 69\n                                                                                                                      //\n  self._entryQueue = new Meteor._DoubleEndedQueue();                                                                  // 73\n  self._workerActive = false;                                                                                         // 74\n                                                                                                                      //\n  self._startTailing();                                                                                               // 76\n};                                                                                                                    // 77\n                                                                                                                      //\n_.extend(OplogHandle.prototype, {                                                                                     // 79\n  stop: function stop() {                                                                                             // 80\n    var self = this;                                                                                                  // 81\n    if (self._stopped) return;                                                                                        // 82\n    self._stopped = true;                                                                                             // 84\n    if (self._tailHandle) self._tailHandle.stop();                                                                    // 85\n    // XXX should close connections too                                                                               //\n  },                                                                                                                  // 88\n  onOplogEntry: function onOplogEntry(trigger, callback) {                                                            // 89\n    var self = this;                                                                                                  // 90\n    if (self._stopped) throw new Error(\"Called onOplogEntry on stopped handle!\");                                     // 91\n                                                                                                                      //\n    // Calling onOplogEntry requires us to wait for the tailing to be ready.                                          //\n    self._readyFuture.wait();                                                                                         // 95\n                                                                                                                      //\n    var originalCallback = callback;                                                                                  // 97\n    callback = Meteor.bindEnvironment(function (notification) {                                                       // 98\n      // XXX can we avoid this clone by making oplog.js careful?                                                      //\n      originalCallback(EJSON.clone(notification));                                                                    // 100\n    }, function (err) {                                                                                               // 101\n      Meteor._debug(\"Error in oplog callback\", err.stack);                                                            // 102\n    });                                                                                                               // 103\n    var listenHandle = self._crossbar.listen(trigger, callback);                                                      // 104\n    return {                                                                                                          // 105\n      stop: function stop() {                                                                                         // 106\n        listenHandle.stop();                                                                                          // 107\n      }                                                                                                               // 108\n    };                                                                                                                // 105\n  },                                                                                                                  // 110\n  // Register a callback to be invoked any time we skip oplog entries (eg,                                            //\n  // because we are too far behind).                                                                                  //\n  onSkippedEntries: function onSkippedEntries(callback) {                                                             // 113\n    var self = this;                                                                                                  // 114\n    if (self._stopped) throw new Error(\"Called onSkippedEntries on stopped handle!\");                                 // 115\n    return self._onSkippedEntriesHook.register(callback);                                                             // 117\n  },                                                                                                                  // 118\n  // Calls `callback` once the oplog has been processed up to a point that is                                         //\n  // roughly \"now\": specifically, once we've processed all ops that are                                               //\n  // currently visible.                                                                                               //\n  // XXX become convinced that this is actually safe even if oplogConnection                                          //\n  // is some kind of pool                                                                                             //\n  waitUntilCaughtUp: function waitUntilCaughtUp() {                                                                   // 124\n    var self = this;                                                                                                  // 125\n    if (self._stopped) throw new Error(\"Called waitUntilCaughtUp on stopped handle!\");                                // 126\n                                                                                                                      //\n    // Calling waitUntilCaughtUp requries us to wait for the oplog connection to                                      //\n    // be ready.                                                                                                      //\n    self._readyFuture.wait();                                                                                         // 131\n                                                                                                                      //\n    while (!self._stopped) {                                                                                          // 133\n      // We need to make the selector at least as restrictive as the actual                                           //\n      // tailing selector (ie, we need to specify the DB name) or else we might                                       //\n      // find a TS that won't show up in the actual tail stream.                                                      //\n      try {                                                                                                           // 137\n        var lastEntry = self._oplogLastEntryConnection.findOne(OPLOG_COLLECTION, self._baseOplogSelector, { fields: { ts: 1 }, sort: { $natural: -1 } });\n        break;                                                                                                        // 141\n      } catch (e) {                                                                                                   // 142\n        // During failover (eg) if we get an exception we should log and retry                                        //\n        // instead of crashing.                                                                                       //\n        Meteor._debug(\"Got exception while reading last entry: \" + e);                                                // 145\n        Meteor._sleepForMs(100);                                                                                      // 146\n      }                                                                                                               // 147\n    }                                                                                                                 // 148\n                                                                                                                      //\n    if (self._stopped) return;                                                                                        // 150\n                                                                                                                      //\n    if (!lastEntry) {                                                                                                 // 153\n      // Really, nothing in the oplog? Well, we've processed everything.                                              //\n      return;                                                                                                         // 155\n    }                                                                                                                 // 156\n                                                                                                                      //\n    var ts = lastEntry.ts;                                                                                            // 158\n    if (!ts) throw Error(\"oplog entry without ts: \" + EJSON.stringify(lastEntry));                                    // 159\n                                                                                                                      //\n    if (self._lastProcessedTS && ts.lessThanOrEqual(self._lastProcessedTS)) {                                         // 162\n      // We've already caught up to here.                                                                             //\n      return;                                                                                                         // 164\n    }                                                                                                                 // 165\n                                                                                                                      //\n    // Insert the future into our list. Almost always, this will be at the end,                                       //\n    // but it's conceivable that if we fail over from one primary to another,                                         //\n    // the oplog entries we see will go backwards.                                                                    //\n    var insertAfter = self._catchingUpFutures.length;                                                                 // 171\n    while (insertAfter - 1 > 0 && self._catchingUpFutures[insertAfter - 1].ts.greaterThan(ts)) {                      // 172\n      insertAfter--;                                                                                                  // 174\n    }                                                                                                                 // 175\n    var f = new Future();                                                                                             // 176\n    self._catchingUpFutures.splice(insertAfter, 0, { ts: ts, future: f });                                            // 177\n    f.wait();                                                                                                         // 178\n  },                                                                                                                  // 179\n  _startTailing: function _startTailing() {                                                                           // 180\n    var self = this;                                                                                                  // 181\n    // First, make sure that we're talking to the local database.                                                     //\n    var mongodbUri = Npm.require('mongodb-uri');                                                                      // 183\n    if (mongodbUri.parse(self._oplogUrl).database !== 'local') {                                                      // 184\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" + \"a Mongo replica set\");                // 185\n    }                                                                                                                 // 187\n                                                                                                                      //\n    // We make two separate connections to Mongo. The Node Mongo driver                                               //\n    // implements a naive round-robin connection pool: each \"connection\" is a                                         //\n    // pool of several (5 by default) TCP connections, and each request is                                            //\n    // rotated through the pools. Tailable cursor queries block on the server                                         //\n    // until there is some data to return (or until a few seconds have                                                //\n    // passed). So if the connection pool used for tailing cursors is the same                                        //\n    // pool used for other queries, the other queries will be delayed by seconds                                      //\n    // 1/5 of the time.                                                                                               //\n    //                                                                                                                //\n    // The tail connection will only ever be running a single tail command, so                                        //\n    // it only needs to make one underlying TCP connection.                                                           //\n    self._oplogTailConnection = new MongoConnection(self._oplogUrl, { poolSize: 1 });                                 // 200\n    // XXX better docs, but: it's to get monotonic results                                                            //\n    // XXX is it safe to say \"if there's an in flight query, just use its                                             //\n    //     results\"? I don't think so but should consider that                                                        //\n    self._oplogLastEntryConnection = new MongoConnection(self._oplogUrl, { poolSize: 1 });                            // 205\n                                                                                                                      //\n    // Now, make sure that there actually is a repl set here. If not, oplog                                           //\n    // tailing won't ever find anything!                                                                              //\n    // More on the isMasterDoc                                                                                        //\n    // https://docs.mongodb.com/manual/reference/command/isMaster/                                                    //\n    var f = new Future();                                                                                             // 212\n    self._oplogLastEntryConnection.db.admin().command({ ismaster: 1 }, f.resolver());                                 // 213\n    var isMasterDoc = f.wait();                                                                                       // 215\n                                                                                                                      //\n    if (!(isMasterDoc && isMasterDoc.setName)) {                                                                      // 217\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" + \"a Mongo replica set\");                // 218\n    }                                                                                                                 // 220\n                                                                                                                      //\n    // Find the last oplog entry.                                                                                     //\n    var lastOplogEntry = self._oplogLastEntryConnection.findOne(OPLOG_COLLECTION, {}, { sort: { $natural: -1 }, fields: { ts: 1 } });\n                                                                                                                      //\n    var oplogSelector = _.clone(self._baseOplogSelector);                                                             // 226\n    if (lastOplogEntry) {                                                                                             // 227\n      // Start after the last entry that currently exists.                                                            //\n      oplogSelector.ts = { $gt: lastOplogEntry.ts };                                                                  // 229\n      // If there are any calls to callWhenProcessedLatest before any other                                           //\n      // oplog entries show up, allow callWhenProcessedLatest to call its                                             //\n      // callback immediately.                                                                                        //\n      self._lastProcessedTS = lastOplogEntry.ts;                                                                      // 233\n    }                                                                                                                 // 234\n                                                                                                                      //\n    var cursorDescription = new CursorDescription(OPLOG_COLLECTION, oplogSelector, { tailable: true });               // 236\n                                                                                                                      //\n    self._tailHandle = self._oplogTailConnection.tail(cursorDescription, function (doc) {                             // 239\n      self._entryQueue.push(doc);                                                                                     // 241\n      self._maybeStartWorker();                                                                                       // 242\n    });                                                                                                               // 243\n    self._readyFuture['return']();                                                                                    // 245\n  },                                                                                                                  // 246\n                                                                                                                      //\n  _maybeStartWorker: function _maybeStartWorker() {                                                                   // 248\n    var self = this;                                                                                                  // 249\n    if (self._workerActive) return;                                                                                   // 250\n    self._workerActive = true;                                                                                        // 252\n    Meteor.defer(function () {                                                                                        // 253\n      try {                                                                                                           // 254\n        while (!self._stopped && !self._entryQueue.isEmpty()) {                                                       // 255\n          // Are we too far behind? Just tell our observers that they need to                                         //\n          // repoll, and drop our queue.                                                                              //\n          if (self._entryQueue.length > TOO_FAR_BEHIND) {                                                             // 258\n            var lastEntry = self._entryQueue.pop();                                                                   // 259\n            self._entryQueue.clear();                                                                                 // 260\n                                                                                                                      //\n            self._onSkippedEntriesHook.each(function (callback) {                                                     // 262\n              callback();                                                                                             // 263\n              return true;                                                                                            // 264\n            });                                                                                                       // 265\n                                                                                                                      //\n            // Free any waitUntilCaughtUp() calls that were waiting for us to                                         //\n            // pass something that we just skipped.                                                                   //\n            self._setLastProcessedTS(lastEntry.ts);                                                                   // 269\n            continue;                                                                                                 // 270\n          }                                                                                                           // 271\n                                                                                                                      //\n          var doc = self._entryQueue.shift();                                                                         // 273\n                                                                                                                      //\n          if (!(doc.ns && doc.ns.length > self._dbName.length + 1 && doc.ns.substr(0, self._dbName.length + 1) === self._dbName + '.')) {\n            throw new Error(\"Unexpected ns\");                                                                         // 278\n          }                                                                                                           // 279\n                                                                                                                      //\n          var trigger = { collection: doc.ns.substr(self._dbName.length + 1),                                         // 281\n            dropCollection: false,                                                                                    // 282\n            dropDatabase: false,                                                                                      // 283\n            op: doc };                                                                                                // 284\n                                                                                                                      //\n          // Is it a special command and the collection name is hidden somewhere                                      //\n          // in operator?                                                                                             //\n          if (trigger.collection === \"$cmd\") {                                                                        // 288\n            if (doc.o.dropDatabase) {                                                                                 // 289\n              delete trigger.collection;                                                                              // 290\n              trigger.dropDatabase = true;                                                                            // 291\n            } else if (_.has(doc.o, 'drop')) {                                                                        // 292\n              trigger.collection = doc.o.drop;                                                                        // 293\n              trigger.dropCollection = true;                                                                          // 294\n              trigger.id = null;                                                                                      // 295\n            } else {                                                                                                  // 296\n              throw Error(\"Unknown command \" + JSON.stringify(doc));                                                  // 297\n            }                                                                                                         // 298\n          } else {                                                                                                    // 299\n            // All other ops have an id.                                                                              //\n            trigger.id = idForOp(doc);                                                                                // 301\n          }                                                                                                           // 302\n                                                                                                                      //\n          self._crossbar.fire(trigger);                                                                               // 304\n                                                                                                                      //\n          // Now that we've processed this operation, process pending                                                 //\n          // sequencers.                                                                                              //\n          if (!doc.ts) throw Error(\"oplog entry without ts: \" + EJSON.stringify(doc));                                // 308\n          self._setLastProcessedTS(doc.ts);                                                                           // 310\n        }                                                                                                             // 311\n      } finally {                                                                                                     // 312\n        self._workerActive = false;                                                                                   // 313\n      }                                                                                                               // 314\n    });                                                                                                               // 315\n  },                                                                                                                  // 316\n  _setLastProcessedTS: function _setLastProcessedTS(ts) {                                                             // 317\n    var self = this;                                                                                                  // 318\n    self._lastProcessedTS = ts;                                                                                       // 319\n    while (!_.isEmpty(self._catchingUpFutures) && self._catchingUpFutures[0].ts.lessThanOrEqual(self._lastProcessedTS)) {\n      var sequencer = self._catchingUpFutures.shift();                                                                // 323\n      sequencer.future['return']();                                                                                   // 324\n    }                                                                                                                 // 325\n  },                                                                                                                  // 326\n                                                                                                                      //\n  //Methods used on tests to dinamically change TOO_FAR_BEHIND                                                        //\n  _defineTooFarBehind: function _defineTooFarBehind(value) {                                                          // 329\n    TOO_FAR_BEHIND = value;                                                                                           // 330\n  },                                                                                                                  // 331\n  _resetTooFarBehind: function _resetTooFarBehind() {                                                                 // 332\n    TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;                                                 // 333\n  }                                                                                                                   // 334\n});                                                                                                                   // 79\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"observe_multiplex.js\":function(require){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/mongo/observe_multiplex.js                                                                                //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nvar Future = Npm.require('fibers/future');                                                                            // 1\n                                                                                                                      //\nObserveMultiplexer = function ObserveMultiplexer(options) {                                                           // 3\n  var self = this;                                                                                                    // 4\n                                                                                                                      //\n  if (!options || !_.has(options, 'ordered')) throw Error(\"must specified ordered\");                                  // 6\n                                                                                                                      //\n  Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-multiplexers\", 1);              // 9\n                                                                                                                      //\n  self._ordered = options.ordered;                                                                                    // 12\n  self._onStop = options.onStop || function () {};                                                                    // 13\n  self._queue = new Meteor._SynchronousQueue();                                                                       // 14\n  self._handles = {};                                                                                                 // 15\n  self._readyFuture = new Future();                                                                                   // 16\n  self._cache = new LocalCollection._CachingChangeObserver({                                                          // 17\n    ordered: options.ordered });                                                                                      // 18\n  // Number of addHandleAndSendInitialAdds tasks scheduled but not yet                                                //\n  // running. removeHandle uses this to know if it's time to call the onStop                                          //\n  // callback.                                                                                                        //\n  self._addHandleTasksScheduledButNotPerformed = 0;                                                                   // 22\n                                                                                                                      //\n  _.each(self.callbackNames(), function (callbackName) {                                                              // 24\n    self[callbackName] = function () /* ... */{                                                                       // 25\n      self._applyCallback(callbackName, _.toArray(arguments));                                                        // 26\n    };                                                                                                                // 27\n  });                                                                                                                 // 28\n};                                                                                                                    // 29\n                                                                                                                      //\n_.extend(ObserveMultiplexer.prototype, {                                                                              // 31\n  addHandleAndSendInitialAdds: function addHandleAndSendInitialAdds(handle) {                                         // 32\n    var self = this;                                                                                                  // 33\n                                                                                                                      //\n    // Check this before calling runTask (even though runTask does the same                                           //\n    // check) so that we don't leak an ObserveMultiplexer on error by                                                 //\n    // incrementing _addHandleTasksScheduledButNotPerformed and never                                                 //\n    // decrementing it.                                                                                               //\n    if (!self._queue.safeToRunTask()) throw new Error(\"Can't call observeChanges from an observe callback on the same query\");\n    ++self._addHandleTasksScheduledButNotPerformed;                                                                   // 42\n                                                                                                                      //\n    Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-handles\", 1);                 // 44\n                                                                                                                      //\n    self._queue.runTask(function () {                                                                                 // 47\n      self._handles[handle._id] = handle;                                                                             // 48\n      // Send out whatever adds we have so far (whether or not we the                                                 //\n      // multiplexer is ready).                                                                                       //\n      self._sendAdds(handle);                                                                                         // 51\n      --self._addHandleTasksScheduledButNotPerformed;                                                                 // 52\n    });                                                                                                               // 53\n    // *outside* the task, since otherwise we'd deadlock                                                              //\n    self._readyFuture.wait();                                                                                         // 55\n  },                                                                                                                  // 56\n                                                                                                                      //\n  // Remove an observe handle. If it was the last observe handle, call the                                            //\n  // onStop callback; you cannot add any more observe handles after this.                                             //\n  //                                                                                                                  //\n  // This is not synchronized with polls and handle additions: this means that                                        //\n  // you can safely call it from within an observe callback, but it also means                                        //\n  // that we have to be careful when we iterate over _handles.                                                        //\n  removeHandle: function removeHandle(id) {                                                                           // 64\n    var self = this;                                                                                                  // 65\n                                                                                                                      //\n    // This should not be possible: you can only call removeHandle by having                                          //\n    // access to the ObserveHandle, which isn't returned to user code until the                                       //\n    // multiplex is ready.                                                                                            //\n    if (!self._ready()) throw new Error(\"Can't remove handles until the multiplex is ready\");                         // 70\n                                                                                                                      //\n    delete self._handles[id];                                                                                         // 73\n                                                                                                                      //\n    Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-handles\", -1);                // 75\n                                                                                                                      //\n    if (_.isEmpty(self._handles) && self._addHandleTasksScheduledButNotPerformed === 0) {                             // 78\n      self._stop();                                                                                                   // 80\n    }                                                                                                                 // 81\n  },                                                                                                                  // 82\n  _stop: function _stop(options) {                                                                                    // 83\n    var self = this;                                                                                                  // 84\n    options = options || {};                                                                                          // 85\n                                                                                                                      //\n    // It shouldn't be possible for us to stop when all our handles still                                             //\n    // haven't been returned from observeChanges!                                                                     //\n    if (!self._ready() && !options.fromQueryError) throw Error(\"surprising _stop: not ready\");                        // 89\n                                                                                                                      //\n    // Call stop callback (which kills the underlying process which sends us                                          //\n    // callbacks and removes us from the connection's dictionary).                                                    //\n    self._onStop();                                                                                                   // 94\n    Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-multiplexers\", -1);           // 95\n                                                                                                                      //\n    // Cause future addHandleAndSendInitialAdds calls to throw (but the onStop                                        //\n    // callback should make our connection forget about us).                                                          //\n    self._handles = null;                                                                                             // 100\n  },                                                                                                                  // 101\n                                                                                                                      //\n  // Allows all addHandleAndSendInitialAdds calls to return, once all preceding                                       //\n  // adds have been processed. Does not block.                                                                        //\n  ready: function ready() {                                                                                           // 105\n    var self = this;                                                                                                  // 106\n    self._queue.queueTask(function () {                                                                               // 107\n      if (self._ready()) throw Error(\"can't make ObserveMultiplex ready twice!\");                                     // 108\n      self._readyFuture['return']();                                                                                  // 110\n    });                                                                                                               // 111\n  },                                                                                                                  // 112\n                                                                                                                      //\n  // If trying to execute the query results in an error, call this. This is                                           //\n  // intended for permanent errors, not transient network errors that could be                                        //\n  // fixed. It should only be called before ready(), because if you called ready                                      //\n  // that meant that you managed to run the query once. It will stop this                                             //\n  // ObserveMultiplex and cause addHandleAndSendInitialAdds calls (and thus                                           //\n  // observeChanges calls) to throw the error.                                                                        //\n  queryError: function queryError(err) {                                                                              // 120\n    var self = this;                                                                                                  // 121\n    self._queue.runTask(function () {                                                                                 // 122\n      if (self._ready()) throw Error(\"can't claim query has an error after it worked!\");                              // 123\n      self._stop({ fromQueryError: true });                                                                           // 125\n      self._readyFuture['throw'](err);                                                                                // 126\n    });                                                                                                               // 127\n  },                                                                                                                  // 128\n                                                                                                                      //\n  // Calls \"cb\" once the effects of all \"ready\", \"addHandleAndSendInitialAdds\"                                        //\n  // and observe callbacks which came before this call have been propagated to                                        //\n  // all handles. \"ready\" must have already been called on this multiplexer.                                          //\n  onFlush: function onFlush(cb) {                                                                                     // 133\n    var self = this;                                                                                                  // 134\n    self._queue.queueTask(function () {                                                                               // 135\n      if (!self._ready()) throw Error(\"only call onFlush on a multiplexer that will be ready\");                       // 136\n      cb();                                                                                                           // 138\n    });                                                                                                               // 139\n  },                                                                                                                  // 140\n  callbackNames: function callbackNames() {                                                                           // 141\n    var self = this;                                                                                                  // 142\n    if (self._ordered) return [\"addedBefore\", \"changed\", \"movedBefore\", \"removed\"];else return [\"added\", \"changed\", \"removed\"];\n  },                                                                                                                  // 147\n  _ready: function _ready() {                                                                                         // 148\n    return this._readyFuture.isResolved();                                                                            // 149\n  },                                                                                                                  // 150\n  _applyCallback: function _applyCallback(callbackName, args) {                                                       // 151\n    var self = this;                                                                                                  // 152\n    self._queue.queueTask(function () {                                                                               // 153\n      // If we stopped in the meantime, do nothing.                                                                   //\n      if (!self._handles) return;                                                                                     // 155\n                                                                                                                      //\n      // First, apply the change to the cache.                                                                        //\n      // XXX We could make applyChange callbacks promise not to hang on to any                                        //\n      // state from their arguments (assuming that their supplied callbacks                                           //\n      // don't) and skip this clone. Currently 'changed' hangs on to state                                            //\n      // though.                                                                                                      //\n      self._cache.applyChange[callbackName].apply(null, EJSON.clone(args));                                           // 163\n                                                                                                                      //\n      // If we haven't finished the initial adds, then we should only be getting                                      //\n      // adds.                                                                                                        //\n      if (!self._ready() && callbackName !== 'added' && callbackName !== 'addedBefore') {                             // 167\n        throw new Error(\"Got \" + callbackName + \" during initial adds\");                                              // 169\n      }                                                                                                               // 170\n                                                                                                                      //\n      // Now multiplex the callbacks out to all observe handles. It's OK if                                           //\n      // these calls yield; since we're inside a task, no other use of our queue                                      //\n      // can continue until these are done. (But we do have to be careful to not                                      //\n      // use a handle that got removed, because removeHandle does not use the                                         //\n      // queue; thus, we iterate over an array of keys that we control.)                                              //\n      _.each(_.keys(self._handles), function (handleId) {                                                             // 177\n        var handle = self._handles && self._handles[handleId];                                                        // 178\n        if (!handle) return;                                                                                          // 179\n        var callback = handle['_' + callbackName];                                                                    // 181\n        // clone arguments so that callbacks can mutate their arguments                                               //\n        callback && callback.apply(null, EJSON.clone(args));                                                          // 183\n      });                                                                                                             // 184\n    });                                                                                                               // 185\n  },                                                                                                                  // 186\n                                                                                                                      //\n  // Sends initial adds to a handle. It should only be called from within a task                                      //\n  // (the task that is processing the addHandleAndSendInitialAdds call). It                                           //\n  // synchronously invokes the handle's added or addedBefore; there's no need to                                      //\n  // flush the queue afterwards to ensure that the callbacks get out.                                                 //\n  _sendAdds: function _sendAdds(handle) {                                                                             // 192\n    var self = this;                                                                                                  // 193\n    if (self._queue.safeToRunTask()) throw Error(\"_sendAdds may only be called from within a task!\");                 // 194\n    var add = self._ordered ? handle._addedBefore : handle._added;                                                    // 196\n    if (!add) return;                                                                                                 // 197\n    // note: docs may be an _IdMap or an OrderedDict                                                                  //\n    self._cache.docs.forEach(function (doc, id) {                                                                     // 200\n      if (!_.has(self._handles, handle._id)) throw Error(\"handle got removed before sending initial adds!\");          // 201\n      var fields = EJSON.clone(doc);                                                                                  // 203\n      delete fields._id;                                                                                              // 204\n      if (self._ordered) add(id, fields, null); // we're going in order, so add at end                                // 205\n      else add(id, fields);                                                                                           // 205\n    });                                                                                                               // 209\n  }                                                                                                                   // 210\n});                                                                                                                   // 31\n                                                                                                                      //\nvar nextObserveHandleId = 1;                                                                                          // 214\nObserveHandle = function ObserveHandle(multiplexer, callbacks) {                                                      // 215\n  var self = this;                                                                                                    // 216\n  // The end user is only supposed to call stop().  The other fields are                                              //\n  // accessible to the multiplexer, though.                                                                           //\n  self._multiplexer = multiplexer;                                                                                    // 219\n  _.each(multiplexer.callbackNames(), function (name) {                                                               // 220\n    if (callbacks[name]) {                                                                                            // 221\n      self['_' + name] = callbacks[name];                                                                             // 222\n    } else if (name === \"addedBefore\" && callbacks.added) {                                                           // 223\n      // Special case: if you specify \"added\" and \"movedBefore\", you get an                                           //\n      // ordered observe where for some reason you don't get ordering data on                                         //\n      // the adds.  I dunno, we wrote tests for it, there must have been a                                            //\n      // reason.                                                                                                      //\n      self._addedBefore = function (id, fields, before) {                                                             // 228\n        callbacks.added(id, fields);                                                                                  // 229\n      };                                                                                                              // 230\n    }                                                                                                                 // 231\n  });                                                                                                                 // 232\n  self._stopped = false;                                                                                              // 233\n  self._id = nextObserveHandleId++;                                                                                   // 234\n};                                                                                                                    // 235\nObserveHandle.prototype.stop = function () {                                                                          // 236\n  var self = this;                                                                                                    // 237\n  if (self._stopped) return;                                                                                          // 238\n  self._stopped = true;                                                                                               // 240\n  self._multiplexer.removeHandle(self._id);                                                                           // 241\n};                                                                                                                    // 242\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"doc_fetcher.js\":function(require){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/mongo/doc_fetcher.js                                                                                      //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nvar Fiber = Npm.require('fibers');                                                                                    // 1\nvar Future = Npm.require('fibers/future');                                                                            // 2\n                                                                                                                      //\nDocFetcher = function DocFetcher(mongoConnection) {                                                                   // 4\n  var self = this;                                                                                                    // 5\n  self._mongoConnection = mongoConnection;                                                                            // 6\n  // Map from cache key -> [callback]                                                                                 //\n  self._callbacksForCacheKey = {};                                                                                    // 8\n};                                                                                                                    // 9\n                                                                                                                      //\n_.extend(DocFetcher.prototype, {                                                                                      // 11\n  // Fetches document \"id\" from collectionName, returning it or null if not                                           //\n  // found.                                                                                                           //\n  //                                                                                                                  //\n  // If you make multiple calls to fetch() with the same cacheKey (a string),                                         //\n  // DocFetcher may assume that they all return the same document. (It does                                           //\n  // not check to see if collectionName/id match.)                                                                    //\n  //                                                                                                                  //\n  // You may assume that callback is never called synchronously (and in fact                                          //\n  // OplogObserveDriver does so).                                                                                     //\n  fetch: function fetch(collectionName, id, cacheKey, callback) {                                                     // 21\n    var self = this;                                                                                                  // 22\n                                                                                                                      //\n    check(collectionName, String);                                                                                    // 24\n    // id is some sort of scalar                                                                                      //\n    check(cacheKey, String);                                                                                          // 26\n                                                                                                                      //\n    // If there's already an in-progress fetch for this cache key, yield until                                        //\n    // it's done and return whatever it returns.                                                                      //\n    if (_.has(self._callbacksForCacheKey, cacheKey)) {                                                                // 30\n      self._callbacksForCacheKey[cacheKey].push(callback);                                                            // 31\n      return;                                                                                                         // 32\n    }                                                                                                                 // 33\n                                                                                                                      //\n    var callbacks = self._callbacksForCacheKey[cacheKey] = [callback];                                                // 35\n                                                                                                                      //\n    Fiber(function () {                                                                                               // 37\n      try {                                                                                                           // 38\n        var doc = self._mongoConnection.findOne(collectionName, { _id: id }) || null;                                 // 39\n        // Return doc to all relevant callbacks. Note that this array can                                             //\n        // continue to grow during callback excecution.                                                               //\n        while (!_.isEmpty(callbacks)) {                                                                               // 43\n          // Clone the document so that the various calls to fetch don't return                                       //\n          // objects that are intertwingled with each other. Clone before                                             //\n          // popping the future, so that if clone throws, the error gets passed                                       //\n          // to the next callback.                                                                                    //\n          var clonedDoc = EJSON.clone(doc);                                                                           // 48\n          callbacks.pop()(null, clonedDoc);                                                                           // 49\n        }                                                                                                             // 50\n      } catch (e) {                                                                                                   // 51\n        while (!_.isEmpty(callbacks)) {                                                                               // 52\n          callbacks.pop()(e);                                                                                         // 53\n        }                                                                                                             // 54\n      } finally {                                                                                                     // 55\n        // XXX consider keeping the doc around for a period of time before                                            //\n        // removing from the cache                                                                                    //\n        delete self._callbacksForCacheKey[cacheKey];                                                                  // 58\n      }                                                                                                               // 59\n    }).run();                                                                                                         // 60\n  }                                                                                                                   // 61\n});                                                                                                                   // 11\n                                                                                                                      //\nMongoTest.DocFetcher = DocFetcher;                                                                                    // 64\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"polling_observe_driver.js\":function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/mongo/polling_observe_driver.js                                                                           //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nPollingObserveDriver = function PollingObserveDriver(options) {                                                       // 1\n  var self = this;                                                                                                    // 2\n                                                                                                                      //\n  self._cursorDescription = options.cursorDescription;                                                                // 4\n  self._mongoHandle = options.mongoHandle;                                                                            // 5\n  self._ordered = options.ordered;                                                                                    // 6\n  self._multiplexer = options.multiplexer;                                                                            // 7\n  self._stopCallbacks = [];                                                                                           // 8\n  self._stopped = false;                                                                                              // 9\n                                                                                                                      //\n  self._synchronousCursor = self._mongoHandle._createSynchronousCursor(self._cursorDescription);                      // 11\n                                                                                                                      //\n  // previous results snapshot.  on each poll cycle, diffs against                                                    //\n  // results drives the callbacks.                                                                                    //\n  self._results = null;                                                                                               // 16\n                                                                                                                      //\n  // The number of _pollMongo calls that have been added to self._taskQueue but                                       //\n  // have not started running. Used to make sure we never schedule more than one                                      //\n  // _pollMongo (other than possibly the one that is currently running). It's                                         //\n  // also used by _suspendPolling to pretend there's a poll scheduled. Usually,                                       //\n  // it's either 0 (for \"no polls scheduled other than maybe one currently                                            //\n  // running\") or 1 (for \"a poll scheduled that isn't running yet\"), but it can                                       //\n  // also be 2 if incremented by _suspendPolling.                                                                     //\n  self._pollsScheduledButNotStarted = 0;                                                                              // 25\n  self._pendingWrites = []; // people to notify when polling completes                                                // 26\n                                                                                                                      //\n  // Make sure to create a separately throttled function for each                                                     //\n  // PollingObserveDriver object.                                                                                     //\n  self._ensurePollIsScheduled = _.throttle(self._unthrottledEnsurePollIsScheduled, self._cursorDescription.options.pollingThrottleMs || 50 /* ms */);\n                                                                                                                      //\n  // XXX figure out if we still need a queue                                                                          //\n  self._taskQueue = new Meteor._SynchronousQueue();                                                                   // 35\n                                                                                                                      //\n  var listenersHandle = listenAll(self._cursorDescription, function (notification) {                                  // 37\n    // When someone does a transaction that might affect us, schedule a poll                                          //\n    // of the database. If that transaction happens inside of a write fence,                                          //\n    // block the fence until we've polled and notified observers.                                                     //\n    var fence = DDPServer._CurrentWriteFence.get();                                                                   // 42\n    if (fence) self._pendingWrites.push(fence.beginWrite());                                                          // 43\n    // Ensure a poll is scheduled... but if we already know that one is,                                              //\n    // don't hit the throttled _ensurePollIsScheduled function (which might                                           //\n    // lead to us calling it unnecessarily in <pollingThrottleMs> ms).                                                //\n    if (self._pollsScheduledButNotStarted === 0) self._ensurePollIsScheduled();                                       // 48\n  });                                                                                                                 // 50\n  self._stopCallbacks.push(function () {                                                                              // 52\n    listenersHandle.stop();                                                                                           // 52\n  });                                                                                                                 // 52\n                                                                                                                      //\n  // every once and a while, poll even if we don't think we're dirty, for                                             //\n  // eventual consistency with database writes from outside the Meteor                                                //\n  // universe.                                                                                                        //\n  //                                                                                                                  //\n  // For testing, there's an undocumented callback argument to observeChanges                                         //\n  // which disables time-based polling and gets called at the beginning of each                                       //\n  // poll.                                                                                                            //\n  if (options._testOnlyPollCallback) {                                                                                // 61\n    self._testOnlyPollCallback = options._testOnlyPollCallback;                                                       // 62\n  } else {                                                                                                            // 63\n    var pollingInterval = self._cursorDescription.options.pollingIntervalMs || self._cursorDescription.options._pollingInterval || // COMPAT with 1.2\n    10 * 1000;                                                                                                        // 67\n    var intervalHandle = Meteor.setInterval(_.bind(self._ensurePollIsScheduled, self), pollingInterval);              // 68\n    self._stopCallbacks.push(function () {                                                                            // 70\n      Meteor.clearInterval(intervalHandle);                                                                           // 71\n    });                                                                                                               // 72\n  }                                                                                                                   // 73\n                                                                                                                      //\n  // Make sure we actually poll soon!                                                                                 //\n  self._unthrottledEnsurePollIsScheduled();                                                                           // 76\n                                                                                                                      //\n  Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-polling\", 1);           // 78\n};                                                                                                                    // 80\n                                                                                                                      //\n_.extend(PollingObserveDriver.prototype, {                                                                            // 82\n  // This is always called through _.throttle (except once at startup).                                               //\n  _unthrottledEnsurePollIsScheduled: function _unthrottledEnsurePollIsScheduled() {                                   // 84\n    var self = this;                                                                                                  // 85\n    if (self._pollsScheduledButNotStarted > 0) return;                                                                // 86\n    ++self._pollsScheduledButNotStarted;                                                                              // 88\n    self._taskQueue.queueTask(function () {                                                                           // 89\n      self._pollMongo();                                                                                              // 90\n    });                                                                                                               // 91\n  },                                                                                                                  // 92\n                                                                                                                      //\n  // test-only interface for controlling polling.                                                                     //\n  //                                                                                                                  //\n  // _suspendPolling blocks until any currently running and scheduled polls are                                       //\n  // done, and prevents any further polls from being scheduled. (new                                                  //\n  // ObserveHandles can be added and receive their initial added callbacks,                                           //\n  // though.)                                                                                                         //\n  //                                                                                                                  //\n  // _resumePolling immediately polls, and allows further polls to occur.                                             //\n  _suspendPolling: function _suspendPolling() {                                                                       // 102\n    var self = this;                                                                                                  // 103\n    // Pretend that there's another poll scheduled (which will prevent                                                //\n    // _ensurePollIsScheduled from queueing any more polls).                                                          //\n    ++self._pollsScheduledButNotStarted;                                                                              // 106\n    // Now block until all currently running or scheduled polls are done.                                             //\n    self._taskQueue.runTask(function () {});                                                                          // 108\n                                                                                                                      //\n    // Confirm that there is only one \"poll\" (the fake one we're pretending to                                        //\n    // have) scheduled.                                                                                               //\n    if (self._pollsScheduledButNotStarted !== 1) throw new Error(\"_pollsScheduledButNotStarted is \" + self._pollsScheduledButNotStarted);\n  },                                                                                                                  // 115\n  _resumePolling: function _resumePolling() {                                                                         // 116\n    var self = this;                                                                                                  // 117\n    // We should be in the same state as in the end of _suspendPolling.                                               //\n    if (self._pollsScheduledButNotStarted !== 1) throw new Error(\"_pollsScheduledButNotStarted is \" + self._pollsScheduledButNotStarted);\n    // Run a poll synchronously (which will counteract the                                                            //\n    // ++_pollsScheduledButNotStarted from _suspendPolling).                                                          //\n    self._taskQueue.runTask(function () {                                                                             // 124\n      self._pollMongo();                                                                                              // 125\n    });                                                                                                               // 126\n  },                                                                                                                  // 127\n                                                                                                                      //\n  _pollMongo: function _pollMongo() {                                                                                 // 129\n    var self = this;                                                                                                  // 130\n    --self._pollsScheduledButNotStarted;                                                                              // 131\n                                                                                                                      //\n    if (self._stopped) return;                                                                                        // 133\n                                                                                                                      //\n    var first = false;                                                                                                // 136\n    var oldResults = self._results;                                                                                   // 137\n    if (!oldResults) {                                                                                                // 138\n      first = true;                                                                                                   // 139\n      // XXX maybe use OrderedDict instead?                                                                           //\n      oldResults = self._ordered ? [] : new LocalCollection._IdMap();                                                 // 141\n    }                                                                                                                 // 142\n                                                                                                                      //\n    self._testOnlyPollCallback && self._testOnlyPollCallback();                                                       // 144\n                                                                                                                      //\n    // Save the list of pending writes which this round will commit.                                                  //\n    var writesForCycle = self._pendingWrites;                                                                         // 147\n    self._pendingWrites = [];                                                                                         // 148\n                                                                                                                      //\n    // Get the new query results. (This yields.)                                                                      //\n    try {                                                                                                             // 151\n      var newResults = self._synchronousCursor.getRawObjects(self._ordered);                                          // 152\n    } catch (e) {                                                                                                     // 153\n      if (first && typeof e.code === 'number') {                                                                      // 154\n        // This is an error document sent to us by mongod, not a connection                                           //\n        // error generated by the client. And we've never seen this query work                                        //\n        // successfully. Probably it's a bad selector or something, so we should                                      //\n        // NOT retry. Instead, we should halt the observe (which ends up calling                                      //\n        // `stop` on us).                                                                                             //\n        self._multiplexer.queryError(new Error(\"Exception while polling query \" + JSON.stringify(self._cursorDescription) + \": \" + e.message));\n        return;                                                                                                       // 164\n      }                                                                                                               // 165\n                                                                                                                      //\n      // getRawObjects can throw if we're having trouble talking to the                                               //\n      // database.  That's fine --- we will repoll later anyway. But we should                                        //\n      // make sure not to lose track of this cycle's writes.                                                          //\n      // (It also can throw if there's just something invalid about this query;                                       //\n      // unfortunately the ObserveDriver API doesn't provide a good way to                                            //\n      // \"cancel\" the observe from the inside in this case.                                                           //\n      Array.prototype.push.apply(self._pendingWrites, writesForCycle);                                                // 173\n      Meteor._debug(\"Exception while polling query \" + JSON.stringify(self._cursorDescription) + \": \" + e.stack);     // 174\n      return;                                                                                                         // 176\n    }                                                                                                                 // 177\n                                                                                                                      //\n    // Run diffs.                                                                                                     //\n    if (!self._stopped) {                                                                                             // 180\n      LocalCollection._diffQueryChanges(self._ordered, oldResults, newResults, self._multiplexer);                    // 181\n    }                                                                                                                 // 183\n                                                                                                                      //\n    // Signals the multiplexer to allow all observeChanges calls that share this                                      //\n    // multiplexer to return. (This happens asynchronously, via the                                                   //\n    // multiplexer's queue.)                                                                                          //\n    if (first) self._multiplexer.ready();                                                                             // 188\n                                                                                                                      //\n    // Replace self._results atomically.  (This assignment is what makes `first`                                      //\n    // stay through on the next cycle, so we've waited until after we've                                              //\n    // committed to ready-ing the multiplexer.)                                                                       //\n    self._results = newResults;                                                                                       // 194\n                                                                                                                      //\n    // Once the ObserveMultiplexer has processed everything we've done in this                                        //\n    // round, mark all the writes which existed before this call as                                                   //\n    // commmitted. (If new writes have shown up in the meantime, there'll                                             //\n    // already be another _pollMongo task scheduled.)                                                                 //\n    self._multiplexer.onFlush(function () {                                                                           // 200\n      _.each(writesForCycle, function (w) {                                                                           // 201\n        w.committed();                                                                                                // 202\n      });                                                                                                             // 203\n    });                                                                                                               // 204\n  },                                                                                                                  // 205\n                                                                                                                      //\n  stop: function stop() {                                                                                             // 207\n    var self = this;                                                                                                  // 208\n    self._stopped = true;                                                                                             // 209\n    _.each(self._stopCallbacks, function (c) {                                                                        // 210\n      c();                                                                                                            // 210\n    });                                                                                                               // 210\n    // Release any write fences that are waiting on us.                                                               //\n    _.each(self._pendingWrites, function (w) {                                                                        // 212\n      w.committed();                                                                                                  // 213\n    });                                                                                                               // 214\n    Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-polling\", -1);        // 215\n  }                                                                                                                   // 217\n});                                                                                                                   // 82\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"oplog_observe_driver.js\":function(require){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/mongo/oplog_observe_driver.js                                                                             //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nvar Fiber = Npm.require('fibers');                                                                                    // 1\nvar Future = Npm.require('fibers/future');                                                                            // 2\n                                                                                                                      //\nvar PHASE = {                                                                                                         // 4\n  QUERYING: \"QUERYING\",                                                                                               // 5\n  FETCHING: \"FETCHING\",                                                                                               // 6\n  STEADY: \"STEADY\"                                                                                                    // 7\n};                                                                                                                    // 4\n                                                                                                                      //\n// Exception thrown by _needToPollQuery which unrolls the stack up to the                                             //\n// enclosing call to finishIfNeedToPollQuery.                                                                         //\nvar SwitchedToQuery = function SwitchedToQuery() {};                                                                  // 12\nvar finishIfNeedToPollQuery = function finishIfNeedToPollQuery(f) {                                                   // 13\n  return function () {                                                                                                // 14\n    try {                                                                                                             // 15\n      f.apply(this, arguments);                                                                                       // 16\n    } catch (e) {                                                                                                     // 17\n      if (!(e instanceof SwitchedToQuery)) throw e;                                                                   // 18\n    }                                                                                                                 // 20\n  };                                                                                                                  // 21\n};                                                                                                                    // 22\n                                                                                                                      //\nvar currentId = 0;                                                                                                    // 24\n                                                                                                                      //\n// OplogObserveDriver is an alternative to PollingObserveDriver which follows                                         //\n// the Mongo operation log instead of just re-polling the query. It obeys the                                         //\n// same simple interface: constructing it starts sending observeChanges                                               //\n// callbacks (and a ready() invocation) to the ObserveMultiplexer, and you stop                                       //\n// it by calling the stop() method.                                                                                   //\nOplogObserveDriver = function OplogObserveDriver(options) {                                                           // 31\n  var self = this;                                                                                                    // 32\n  self._usesOplog = true; // tests look at this                                                                       // 33\n                                                                                                                      //\n  self._id = currentId;                                                                                               // 35\n  currentId++;                                                                                                        // 36\n                                                                                                                      //\n  self._cursorDescription = options.cursorDescription;                                                                // 38\n  self._mongoHandle = options.mongoHandle;                                                                            // 39\n  self._multiplexer = options.multiplexer;                                                                            // 40\n                                                                                                                      //\n  if (options.ordered) {                                                                                              // 42\n    throw Error(\"OplogObserveDriver only supports unordered observeChanges\");                                         // 43\n  }                                                                                                                   // 44\n                                                                                                                      //\n  var sorter = options.sorter;                                                                                        // 46\n  // We don't support $near and other geo-queries so it's OK to initialize the                                        //\n  // comparator only once in the constructor.                                                                         //\n  var comparator = sorter && sorter.getComparator();                                                                  // 49\n                                                                                                                      //\n  if (options.cursorDescription.options.limit) {                                                                      // 51\n    // There are several properties ordered driver implements:                                                        //\n    // - _limit is a positive number                                                                                  //\n    // - _comparator is a function-comparator by which the query is ordered                                           //\n    // - _unpublishedBuffer is non-null Min/Max Heap,                                                                 //\n    //                      the empty buffer in STEADY phase implies that the                                         //\n    //                      everything that matches the queries selector fits                                         //\n    //                      into published set.                                                                       //\n    // - _published - Min Heap (also implements IdMap methods)                                                        //\n                                                                                                                      //\n    var heapOptions = { IdMap: LocalCollection._IdMap };                                                              // 61\n    self._limit = self._cursorDescription.options.limit;                                                              // 62\n    self._comparator = comparator;                                                                                    // 63\n    self._sorter = sorter;                                                                                            // 64\n    self._unpublishedBuffer = new MinMaxHeap(comparator, heapOptions);                                                // 65\n    // We need something that can find Max value in addition to IdMap interface                                       //\n    self._published = new MaxHeap(comparator, heapOptions);                                                           // 67\n  } else {                                                                                                            // 68\n    self._limit = 0;                                                                                                  // 69\n    self._comparator = null;                                                                                          // 70\n    self._sorter = null;                                                                                              // 71\n    self._unpublishedBuffer = null;                                                                                   // 72\n    self._published = new LocalCollection._IdMap();                                                                   // 73\n  }                                                                                                                   // 74\n                                                                                                                      //\n  // Indicates if it is safe to insert a new document at the end of the buffer                                        //\n  // for this query. i.e. it is known that there are no documents matching the                                        //\n  // selector those are not in published or buffer.                                                                   //\n  self._safeAppendToBuffer = false;                                                                                   // 79\n                                                                                                                      //\n  self._stopped = false;                                                                                              // 81\n  self._stopHandles = [];                                                                                             // 82\n                                                                                                                      //\n  Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-oplog\", 1);             // 84\n                                                                                                                      //\n  self._registerPhaseChange(PHASE.QUERYING);                                                                          // 87\n                                                                                                                      //\n  var selector = self._cursorDescription.selector;                                                                    // 89\n  self._matcher = options.matcher;                                                                                    // 90\n  var projection = self._cursorDescription.options.fields || {};                                                      // 91\n  self._projectionFn = LocalCollection._compileProjection(projection);                                                // 92\n  // Projection function, result of combining important fields for selector and                                       //\n  // existing fields projection                                                                                       //\n  self._sharedProjection = self._matcher.combineIntoProjection(projection);                                           // 95\n  if (sorter) self._sharedProjection = sorter.combineIntoProjection(self._sharedProjection);                          // 96\n  self._sharedProjectionFn = LocalCollection._compileProjection(self._sharedProjection);                              // 98\n                                                                                                                      //\n  self._needToFetch = new LocalCollection._IdMap();                                                                   // 101\n  self._currentlyFetching = null;                                                                                     // 102\n  self._fetchGeneration = 0;                                                                                          // 103\n                                                                                                                      //\n  self._requeryWhenDoneThisQuery = false;                                                                             // 105\n  self._writesToCommitWhenWeReachSteady = [];                                                                         // 106\n                                                                                                                      //\n  // If the oplog handle tells us that it skipped some entries (because it got                                        //\n  // behind, say), re-poll.                                                                                           //\n  self._stopHandles.push(self._mongoHandle._oplogHandle.onSkippedEntries(finishIfNeedToPollQuery(function () {        // 110\n    self._needToPollQuery();                                                                                          // 112\n  })));                                                                                                               // 113\n                                                                                                                      //\n  forEachTrigger(self._cursorDescription, function (trigger) {                                                        // 116\n    self._stopHandles.push(self._mongoHandle._oplogHandle.onOplogEntry(trigger, function (notification) {             // 117\n      Meteor._noYieldsAllowed(finishIfNeedToPollQuery(function () {                                                   // 119\n        var op = notification.op;                                                                                     // 120\n        if (notification.dropCollection || notification.dropDatabase) {                                               // 121\n          // Note: this call is not allowed to block on anything (especially                                          //\n          // on waiting for oplog entries to catch up) because that will block                                        //\n          // onOplogEntry!                                                                                            //\n          self._needToPollQuery();                                                                                    // 125\n        } else {                                                                                                      // 126\n          // All other operators should be handled depending on phase                                                 //\n          if (self._phase === PHASE.QUERYING) self._handleOplogEntryQuerying(op);else self._handleOplogEntrySteadyOrFetching(op);\n        }                                                                                                             // 132\n      }));                                                                                                            // 133\n    }));                                                                                                              // 134\n  });                                                                                                                 // 136\n                                                                                                                      //\n  // XXX ordering w.r.t. everything else?                                                                             //\n  self._stopHandles.push(listenAll(self._cursorDescription, function (notification) {                                 // 139\n    // If we're not in a pre-fire write fence, we don't have to do anything.                                          //\n    var fence = DDPServer._CurrentWriteFence.get();                                                                   // 142\n    if (!fence || fence.fired) return;                                                                                // 143\n                                                                                                                      //\n    if (fence._oplogObserveDrivers) {                                                                                 // 146\n      fence._oplogObserveDrivers[self._id] = self;                                                                    // 147\n      return;                                                                                                         // 148\n    }                                                                                                                 // 149\n                                                                                                                      //\n    fence._oplogObserveDrivers = {};                                                                                  // 151\n    fence._oplogObserveDrivers[self._id] = self;                                                                      // 152\n                                                                                                                      //\n    fence.onBeforeFire(function () {                                                                                  // 154\n      var drivers = fence._oplogObserveDrivers;                                                                       // 155\n      delete fence._oplogObserveDrivers;                                                                              // 156\n                                                                                                                      //\n      // This fence cannot fire until we've caught up to \"this point\" in the                                          //\n      // oplog, and all observers made it back to the steady state.                                                   //\n      self._mongoHandle._oplogHandle.waitUntilCaughtUp();                                                             // 160\n                                                                                                                      //\n      _.each(drivers, function (driver) {                                                                             // 162\n        if (driver._stopped) return;                                                                                  // 163\n                                                                                                                      //\n        var write = fence.beginWrite();                                                                               // 166\n        if (driver._phase === PHASE.STEADY) {                                                                         // 167\n          // Make sure that all of the callbacks have made it through the                                             //\n          // multiplexer and been delivered to ObserveHandles before committing                                       //\n          // writes.                                                                                                  //\n          driver._multiplexer.onFlush(function () {                                                                   // 171\n            write.committed();                                                                                        // 172\n          });                                                                                                         // 173\n        } else {                                                                                                      // 174\n          driver._writesToCommitWhenWeReachSteady.push(write);                                                        // 175\n        }                                                                                                             // 176\n      });                                                                                                             // 177\n    });                                                                                                               // 178\n  }));                                                                                                                // 179\n                                                                                                                      //\n  // When Mongo fails over, we need to repoll the query, in case we processed an                                      //\n  // oplog entry that got rolled back.                                                                                //\n  self._stopHandles.push(self._mongoHandle._onFailover(finishIfNeedToPollQuery(function () {                          // 184\n    self._needToPollQuery();                                                                                          // 186\n  })));                                                                                                               // 187\n                                                                                                                      //\n  // Give _observeChanges a chance to add the new ObserveHandle to our                                                //\n  // multiplexer, so that the added calls get streamed.                                                               //\n  Meteor.defer(finishIfNeedToPollQuery(function () {                                                                  // 191\n    self._runInitialQuery();                                                                                          // 192\n  }));                                                                                                                // 193\n};                                                                                                                    // 194\n                                                                                                                      //\n_.extend(OplogObserveDriver.prototype, {                                                                              // 196\n  _addPublished: function _addPublished(id, doc) {                                                                    // 197\n    var self = this;                                                                                                  // 198\n    Meteor._noYieldsAllowed(function () {                                                                             // 199\n      var fields = _.clone(doc);                                                                                      // 200\n      delete fields._id;                                                                                              // 201\n      self._published.set(id, self._sharedProjectionFn(doc));                                                         // 202\n      self._multiplexer.added(id, self._projectionFn(fields));                                                        // 203\n                                                                                                                      //\n      // After adding this document, the published set might be overflowed                                            //\n      // (exceeding capacity specified by limit). If so, push the maximum                                             //\n      // element to the buffer, we might want to save it in memory to reduce the                                      //\n      // amount of Mongo lookups in the future.                                                                       //\n      if (self._limit && self._published.size() > self._limit) {                                                      // 209\n        // XXX in theory the size of published is no more than limit+1                                                //\n        if (self._published.size() !== self._limit + 1) {                                                             // 211\n          throw new Error(\"After adding to published, \" + (self._published.size() - self._limit) + \" documents are overflowing the set\");\n        }                                                                                                             // 215\n                                                                                                                      //\n        var overflowingDocId = self._published.maxElementId();                                                        // 217\n        var overflowingDoc = self._published.get(overflowingDocId);                                                   // 218\n                                                                                                                      //\n        if (EJSON.equals(overflowingDocId, id)) {                                                                     // 220\n          throw new Error(\"The document just added is overflowing the published set\");                                // 221\n        }                                                                                                             // 222\n                                                                                                                      //\n        self._published.remove(overflowingDocId);                                                                     // 224\n        self._multiplexer.removed(overflowingDocId);                                                                  // 225\n        self._addBuffered(overflowingDocId, overflowingDoc);                                                          // 226\n      }                                                                                                               // 227\n    });                                                                                                               // 228\n  },                                                                                                                  // 229\n  _removePublished: function _removePublished(id) {                                                                   // 230\n    var self = this;                                                                                                  // 231\n    Meteor._noYieldsAllowed(function () {                                                                             // 232\n      self._published.remove(id);                                                                                     // 233\n      self._multiplexer.removed(id);                                                                                  // 234\n      if (!self._limit || self._published.size() === self._limit) return;                                             // 235\n                                                                                                                      //\n      if (self._published.size() > self._limit) throw Error(\"self._published got too big\");                           // 238\n                                                                                                                      //\n      // OK, we are publishing less than the limit. Maybe we should look in the                                       //\n      // buffer to find the next element past what we were publishing before.                                         //\n                                                                                                                      //\n      if (!self._unpublishedBuffer.empty()) {                                                                         // 244\n        // There's something in the buffer; move the first thing in it to                                             //\n        // _published.                                                                                                //\n        var newDocId = self._unpublishedBuffer.minElementId();                                                        // 247\n        var newDoc = self._unpublishedBuffer.get(newDocId);                                                           // 248\n        self._removeBuffered(newDocId);                                                                               // 249\n        self._addPublished(newDocId, newDoc);                                                                         // 250\n        return;                                                                                                       // 251\n      }                                                                                                               // 252\n                                                                                                                      //\n      // There's nothing in the buffer.  This could mean one of a few things.                                         //\n                                                                                                                      //\n      // (a) We could be in the middle of re-running the query (specifically, we                                      //\n      // could be in _publishNewResults). In that case, _unpublishedBuffer is                                         //\n      // empty because we clear it at the beginning of _publishNewResults. In                                         //\n      // this case, our caller already knows the entire answer to the query and                                       //\n      // we don't need to do anything fancy here.  Just return.                                                       //\n      if (self._phase === PHASE.QUERYING) return;                                                                     // 261\n                                                                                                                      //\n      // (b) We're pretty confident that the union of _published and                                                  //\n      // _unpublishedBuffer contain all documents that match selector. Because                                        //\n      // _unpublishedBuffer is empty, that means we're confident that _published                                      //\n      // contains all documents that match selector. So we have nothing to do.                                        //\n      if (self._safeAppendToBuffer) return;                                                                           // 268\n                                                                                                                      //\n      // (c) Maybe there are other documents out there that should be in our                                          //\n      // buffer. But in that case, when we emptied _unpublishedBuffer in                                              //\n      // _removeBuffered, we should have called _needToPollQuery, which will                                          //\n      // either put something in _unpublishedBuffer or set _safeAppendToBuffer                                        //\n      // (or both), and it will put us in QUERYING for that whole time. So in                                         //\n      // fact, we shouldn't be able to get here.                                                                      //\n                                                                                                                      //\n      throw new Error(\"Buffer inexplicably empty\");                                                                   // 278\n    });                                                                                                               // 279\n  },                                                                                                                  // 280\n  _changePublished: function _changePublished(id, oldDoc, newDoc) {                                                   // 281\n    var self = this;                                                                                                  // 282\n    Meteor._noYieldsAllowed(function () {                                                                             // 283\n      self._published.set(id, self._sharedProjectionFn(newDoc));                                                      // 284\n      var projectedNew = self._projectionFn(newDoc);                                                                  // 285\n      var projectedOld = self._projectionFn(oldDoc);                                                                  // 286\n      var changed = DiffSequence.makeChangedFields(projectedNew, projectedOld);                                       // 287\n      if (!_.isEmpty(changed)) self._multiplexer.changed(id, changed);                                                // 289\n    });                                                                                                               // 291\n  },                                                                                                                  // 292\n  _addBuffered: function _addBuffered(id, doc) {                                                                      // 293\n    var self = this;                                                                                                  // 294\n    Meteor._noYieldsAllowed(function () {                                                                             // 295\n      self._unpublishedBuffer.set(id, self._sharedProjectionFn(doc));                                                 // 296\n                                                                                                                      //\n      // If something is overflowing the buffer, we just remove it from cache                                         //\n      if (self._unpublishedBuffer.size() > self._limit) {                                                             // 299\n        var maxBufferedId = self._unpublishedBuffer.maxElementId();                                                   // 300\n                                                                                                                      //\n        self._unpublishedBuffer.remove(maxBufferedId);                                                                // 302\n                                                                                                                      //\n        // Since something matching is removed from cache (both published set and                                     //\n        // buffer), set flag to false                                                                                 //\n        self._safeAppendToBuffer = false;                                                                             // 306\n      }                                                                                                               // 307\n    });                                                                                                               // 308\n  },                                                                                                                  // 309\n  // Is called either to remove the doc completely from matching set or to move                                       //\n  // it to the published set later.                                                                                   //\n  _removeBuffered: function _removeBuffered(id) {                                                                     // 312\n    var self = this;                                                                                                  // 313\n    Meteor._noYieldsAllowed(function () {                                                                             // 314\n      self._unpublishedBuffer.remove(id);                                                                             // 315\n      // To keep the contract \"buffer is never empty in STEADY phase unless the                                       //\n      // everything matching fits into published\" true, we poll everything as                                         //\n      // soon as we see the buffer becoming empty.                                                                    //\n      if (!self._unpublishedBuffer.size() && !self._safeAppendToBuffer) self._needToPollQuery();                      // 319\n    });                                                                                                               // 321\n  },                                                                                                                  // 322\n  // Called when a document has joined the \"Matching\" results set.                                                    //\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published                                       //\n  // and the effect of limit enforced.                                                                                //\n  _addMatching: function _addMatching(doc) {                                                                          // 326\n    var self = this;                                                                                                  // 327\n    Meteor._noYieldsAllowed(function () {                                                                             // 328\n      var id = doc._id;                                                                                               // 329\n      if (self._published.has(id)) throw Error(\"tried to add something already published \" + id);                     // 330\n      if (self._limit && self._unpublishedBuffer.has(id)) throw Error(\"tried to add something already existed in buffer \" + id);\n                                                                                                                      //\n      var limit = self._limit;                                                                                        // 335\n      var comparator = self._comparator;                                                                              // 336\n      var maxPublished = limit && self._published.size() > 0 ? self._published.get(self._published.maxElementId()) : null;\n      var maxBuffered = limit && self._unpublishedBuffer.size() > 0 ? self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId()) : null;\n      // The query is unlimited or didn't publish enough documents yet or the                                         //\n      // new document would fit into published set pushing the maximum element                                        //\n      // out, then we need to publish the doc.                                                                        //\n      var toPublish = !limit || self._published.size() < limit || comparator(doc, maxPublished) < 0;                  // 345\n                                                                                                                      //\n      // Otherwise we might need to buffer it (only in case of limited query).                                        //\n      // Buffering is allowed if the buffer is not filled up yet and all                                              //\n      // matching docs are either in the published set or in the buffer.                                              //\n      var canAppendToBuffer = !toPublish && self._safeAppendToBuffer && self._unpublishedBuffer.size() < limit;       // 351\n                                                                                                                      //\n      // Or if it is small enough to be safely inserted to the middle or the                                          //\n      // beginning of the buffer.                                                                                     //\n      var canInsertIntoBuffer = !toPublish && maxBuffered && comparator(doc, maxBuffered) <= 0;                       // 356\n                                                                                                                      //\n      var toBuffer = canAppendToBuffer || canInsertIntoBuffer;                                                        // 359\n                                                                                                                      //\n      if (toPublish) {                                                                                                // 361\n        self._addPublished(id, doc);                                                                                  // 362\n      } else if (toBuffer) {                                                                                          // 363\n        self._addBuffered(id, doc);                                                                                   // 364\n      } else {                                                                                                        // 365\n        // dropping it and not saving to the cache                                                                    //\n        self._safeAppendToBuffer = false;                                                                             // 367\n      }                                                                                                               // 368\n    });                                                                                                               // 369\n  },                                                                                                                  // 370\n  // Called when a document leaves the \"Matching\" results set.                                                        //\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published                                       //\n  // and the effect of limit enforced.                                                                                //\n  _removeMatching: function _removeMatching(id) {                                                                     // 374\n    var self = this;                                                                                                  // 375\n    Meteor._noYieldsAllowed(function () {                                                                             // 376\n      if (!self._published.has(id) && !self._limit) throw Error(\"tried to remove something matching but not cached \" + id);\n                                                                                                                      //\n      if (self._published.has(id)) {                                                                                  // 380\n        self._removePublished(id);                                                                                    // 381\n      } else if (self._unpublishedBuffer.has(id)) {                                                                   // 382\n        self._removeBuffered(id);                                                                                     // 383\n      }                                                                                                               // 384\n    });                                                                                                               // 385\n  },                                                                                                                  // 386\n  _handleDoc: function _handleDoc(id, newDoc) {                                                                       // 387\n    var self = this;                                                                                                  // 388\n    Meteor._noYieldsAllowed(function () {                                                                             // 389\n      var matchesNow = newDoc && self._matcher.documentMatches(newDoc).result;                                        // 390\n                                                                                                                      //\n      var publishedBefore = self._published.has(id);                                                                  // 392\n      var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);                                            // 393\n      var cachedBefore = publishedBefore || bufferedBefore;                                                           // 394\n                                                                                                                      //\n      if (matchesNow && !cachedBefore) {                                                                              // 396\n        self._addMatching(newDoc);                                                                                    // 397\n      } else if (cachedBefore && !matchesNow) {                                                                       // 398\n        self._removeMatching(id);                                                                                     // 399\n      } else if (cachedBefore && matchesNow) {                                                                        // 400\n        var oldDoc = self._published.get(id);                                                                         // 401\n        var comparator = self._comparator;                                                                            // 402\n        var minBuffered = self._limit && self._unpublishedBuffer.size() && self._unpublishedBuffer.get(self._unpublishedBuffer.minElementId());\n                                                                                                                      //\n        if (publishedBefore) {                                                                                        // 406\n          // Unlimited case where the document stays in published once it                                             //\n          // matches or the case when we don't have enough matching docs to                                           //\n          // publish or the changed but matching doc will stay in published                                           //\n          // anyways.                                                                                                 //\n          //                                                                                                          //\n          // XXX: We rely on the emptiness of buffer. Be sure to maintain the                                         //\n          // fact that buffer can't be empty if there are matching documents not                                      //\n          // published. Notably, we don't want to schedule repoll and continue                                        //\n          // relying on this property.                                                                                //\n          var staysInPublished = !self._limit || self._unpublishedBuffer.size() === 0 || comparator(newDoc, minBuffered) <= 0;\n                                                                                                                      //\n          if (staysInPublished) {                                                                                     // 420\n            self._changePublished(id, oldDoc, newDoc);                                                                // 421\n          } else {                                                                                                    // 422\n            // after the change doc doesn't stay in the published, remove it                                          //\n            self._removePublished(id);                                                                                // 424\n            // but it can move into buffered now, check it                                                            //\n            var maxBuffered = self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId());                    // 426\n                                                                                                                      //\n            var toBuffer = self._safeAppendToBuffer || maxBuffered && comparator(newDoc, maxBuffered) <= 0;           // 429\n                                                                                                                      //\n            if (toBuffer) {                                                                                           // 432\n              self._addBuffered(id, newDoc);                                                                          // 433\n            } else {                                                                                                  // 434\n              // Throw away from both published set and buffer                                                        //\n              self._safeAppendToBuffer = false;                                                                       // 436\n            }                                                                                                         // 437\n          }                                                                                                           // 438\n        } else if (bufferedBefore) {                                                                                  // 439\n          oldDoc = self._unpublishedBuffer.get(id);                                                                   // 440\n          // remove the old version manually instead of using _removeBuffered so                                      //\n          // we don't trigger the querying immediately.  if we end this block                                         //\n          // with the buffer empty, we will need to trigger the query poll                                            //\n          // manually too.                                                                                            //\n          self._unpublishedBuffer.remove(id);                                                                         // 445\n                                                                                                                      //\n          var maxPublished = self._published.get(self._published.maxElementId());                                     // 447\n          var maxBuffered = self._unpublishedBuffer.size() && self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId());\n                                                                                                                      //\n          // the buffered doc was updated, it could move to published                                                 //\n          var toPublish = comparator(newDoc, maxPublished) < 0;                                                       // 454\n                                                                                                                      //\n          // or stays in buffer even after the change                                                                 //\n          var staysInBuffer = !toPublish && self._safeAppendToBuffer || !toPublish && maxBuffered && comparator(newDoc, maxBuffered) <= 0;\n                                                                                                                      //\n          if (toPublish) {                                                                                            // 461\n            self._addPublished(id, newDoc);                                                                           // 462\n          } else if (staysInBuffer) {                                                                                 // 463\n            // stays in buffer but changes                                                                            //\n            self._unpublishedBuffer.set(id, newDoc);                                                                  // 465\n          } else {                                                                                                    // 466\n            // Throw away from both published set and buffer                                                          //\n            self._safeAppendToBuffer = false;                                                                         // 468\n            // Normally this check would have been done in _removeBuffered but                                        //\n            // we didn't use it, so we need to do it ourself now.                                                     //\n            if (!self._unpublishedBuffer.size()) {                                                                    // 471\n              self._needToPollQuery();                                                                                // 472\n            }                                                                                                         // 473\n          }                                                                                                           // 474\n        } else {                                                                                                      // 475\n          throw new Error(\"cachedBefore implies either of publishedBefore or bufferedBefore is true.\");               // 476\n        }                                                                                                             // 477\n      }                                                                                                               // 478\n    });                                                                                                               // 479\n  },                                                                                                                  // 480\n  _fetchModifiedDocuments: function _fetchModifiedDocuments() {                                                       // 481\n    var self = this;                                                                                                  // 482\n    Meteor._noYieldsAllowed(function () {                                                                             // 483\n      self._registerPhaseChange(PHASE.FETCHING);                                                                      // 484\n      // Defer, because nothing called from the oplog entry handler may yield,                                        //\n      // but fetch() yields.                                                                                          //\n      Meteor.defer(finishIfNeedToPollQuery(function () {                                                              // 487\n        while (!self._stopped && !self._needToFetch.empty()) {                                                        // 488\n          if (self._phase === PHASE.QUERYING) {                                                                       // 489\n            // While fetching, we decided to go into QUERYING mode, and then we                                       //\n            // saw another oplog entry, so _needToFetch is not empty. But we                                          //\n            // shouldn't fetch these documents until AFTER the query is done.                                         //\n            break;                                                                                                    // 493\n          }                                                                                                           // 494\n                                                                                                                      //\n          // Being in steady phase here would be surprising.                                                          //\n          if (self._phase !== PHASE.FETCHING) throw new Error(\"phase in fetchModifiedDocuments: \" + self._phase);     // 497\n                                                                                                                      //\n          self._currentlyFetching = self._needToFetch;                                                                // 500\n          var thisGeneration = ++self._fetchGeneration;                                                               // 501\n          self._needToFetch = new LocalCollection._IdMap();                                                           // 502\n          var waiting = 0;                                                                                            // 503\n          var fut = new Future();                                                                                     // 504\n          // This loop is safe, because _currentlyFetching will not be updated                                        //\n          // during this loop (in fact, it is never mutated).                                                         //\n          self._currentlyFetching.forEach(function (cacheKey, id) {                                                   // 507\n            waiting++;                                                                                                // 508\n            self._mongoHandle._docFetcher.fetch(self._cursorDescription.collectionName, id, cacheKey, finishIfNeedToPollQuery(function (err, doc) {\n              try {                                                                                                   // 512\n                if (err) {                                                                                            // 513\n                  Meteor._debug(\"Got exception while fetching documents: \" + err);                                    // 514\n                  // If we get an error from the fetcher (eg, trouble                                                 //\n                  // connecting to Mongo), let's just abandon the fetch phase                                         //\n                  // altogether and fall back to polling. It's not like we're                                         //\n                  // getting live updates anyway.                                                                     //\n                  if (self._phase !== PHASE.QUERYING) {                                                               // 520\n                    self._needToPollQuery();                                                                          // 521\n                  }                                                                                                   // 522\n                } else if (!self._stopped && self._phase === PHASE.FETCHING && self._fetchGeneration === thisGeneration) {\n                  // We re-check the generation in case we've had an explicit                                         //\n                  // _pollQuery call (eg, in another fiber) which should                                              //\n                  // effectively cancel this round of fetches.  (_pollQuery                                           //\n                  // increments the generation.)                                                                      //\n                  self._handleDoc(id, doc);                                                                           // 529\n                }                                                                                                     // 530\n              } finally {                                                                                             // 531\n                waiting--;                                                                                            // 532\n                // Because fetch() never calls its callback synchronously,                                            //\n                // this is safe (ie, we won't call fut.return() before the                                            //\n                // forEach is done).                                                                                  //\n                if (waiting === 0) fut['return']();                                                                   // 536\n              }                                                                                                       // 538\n            }));                                                                                                      // 539\n          });                                                                                                         // 540\n          fut.wait();                                                                                                 // 541\n          // Exit now if we've had a _pollQuery call (here or in another fiber).                                      //\n          if (self._phase === PHASE.QUERYING) return;                                                                 // 543\n          self._currentlyFetching = null;                                                                             // 545\n        }                                                                                                             // 546\n        // We're done fetching, so we can be steady, unless we've had a                                               //\n        // _pollQuery call (here or in another fiber).                                                                //\n        if (self._phase !== PHASE.QUERYING) self._beSteady();                                                         // 549\n      }));                                                                                                            // 551\n    });                                                                                                               // 552\n  },                                                                                                                  // 553\n  _beSteady: function _beSteady() {                                                                                   // 554\n    var self = this;                                                                                                  // 555\n    Meteor._noYieldsAllowed(function () {                                                                             // 556\n      self._registerPhaseChange(PHASE.STEADY);                                                                        // 557\n      var writes = self._writesToCommitWhenWeReachSteady;                                                             // 558\n      self._writesToCommitWhenWeReachSteady = [];                                                                     // 559\n      self._multiplexer.onFlush(function () {                                                                         // 560\n        _.each(writes, function (w) {                                                                                 // 561\n          w.committed();                                                                                              // 562\n        });                                                                                                           // 563\n      });                                                                                                             // 564\n    });                                                                                                               // 565\n  },                                                                                                                  // 566\n  _handleOplogEntryQuerying: function _handleOplogEntryQuerying(op) {                                                 // 567\n    var self = this;                                                                                                  // 568\n    Meteor._noYieldsAllowed(function () {                                                                             // 569\n      self._needToFetch.set(idForOp(op), op.ts.toString());                                                           // 570\n    });                                                                                                               // 571\n  },                                                                                                                  // 572\n  _handleOplogEntrySteadyOrFetching: function _handleOplogEntrySteadyOrFetching(op) {                                 // 573\n    var self = this;                                                                                                  // 574\n    Meteor._noYieldsAllowed(function () {                                                                             // 575\n      var id = idForOp(op);                                                                                           // 576\n      // If we're already fetching this one, or about to, we can't optimize;                                          //\n      // make sure that we fetch it again if necessary.                                                               //\n      if (self._phase === PHASE.FETCHING && (self._currentlyFetching && self._currentlyFetching.has(id) || self._needToFetch.has(id))) {\n        self._needToFetch.set(id, op.ts.toString());                                                                  // 582\n        return;                                                                                                       // 583\n      }                                                                                                               // 584\n                                                                                                                      //\n      if (op.op === 'd') {                                                                                            // 586\n        if (self._published.has(id) || self._limit && self._unpublishedBuffer.has(id)) self._removeMatching(id);      // 587\n      } else if (op.op === 'i') {                                                                                     // 590\n        if (self._published.has(id)) throw new Error(\"insert found for already-existing ID in published\");            // 591\n        if (self._unpublishedBuffer && self._unpublishedBuffer.has(id)) throw new Error(\"insert found for already-existing ID in buffer\");\n                                                                                                                      //\n        // XXX what if selector yields?  for now it can't but later it could                                          //\n        // have $where                                                                                                //\n        if (self._matcher.documentMatches(op.o).result) self._addMatching(op.o);                                      // 598\n      } else if (op.op === 'u') {                                                                                     // 600\n        // Is this a modifier ($set/$unset, which may require us to poll the                                          //\n        // database to figure out if the whole document matches the selector) or                                      //\n        // a replacement (in which case we can just directly re-evaluate the                                          //\n        // selector)?                                                                                                 //\n        var isReplace = !_.has(op.o, '$set') && !_.has(op.o, '$unset');                                               // 605\n        // If this modifier modifies something inside an EJSON custom type (ie,                                       //\n        // anything with EJSON$), then we can't try to use                                                            //\n        // LocalCollection._modify, since that just mutates the EJSON encoding,                                       //\n        // not the actual object.                                                                                     //\n        var canDirectlyModifyDoc = !isReplace && modifierCanBeDirectlyApplied(op.o);                                  // 610\n                                                                                                                      //\n        var publishedBefore = self._published.has(id);                                                                // 613\n        var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);                                          // 614\n                                                                                                                      //\n        if (isReplace) {                                                                                              // 616\n          self._handleDoc(id, _.extend({ _id: id }, op.o));                                                           // 617\n        } else if ((publishedBefore || bufferedBefore) && canDirectlyModifyDoc) {                                     // 618\n          // Oh great, we actually know what the document is, so we can apply                                         //\n          // this directly.                                                                                           //\n          var newDoc = self._published.has(id) ? self._published.get(id) : self._unpublishedBuffer.get(id);           // 622\n          newDoc = EJSON.clone(newDoc);                                                                               // 624\n                                                                                                                      //\n          newDoc._id = id;                                                                                            // 626\n          try {                                                                                                       // 627\n            LocalCollection._modify(newDoc, op.o);                                                                    // 628\n          } catch (e) {                                                                                               // 629\n            if (e.name !== \"MinimongoError\") throw e;                                                                 // 630\n            // We didn't understand the modifier.  Re-fetch.                                                          //\n            self._needToFetch.set(id, op.ts.toString());                                                              // 633\n            if (self._phase === PHASE.STEADY) {                                                                       // 634\n              self._fetchModifiedDocuments();                                                                         // 635\n            }                                                                                                         // 636\n            return;                                                                                                   // 637\n          }                                                                                                           // 638\n          self._handleDoc(id, self._sharedProjectionFn(newDoc));                                                      // 639\n        } else if (!canDirectlyModifyDoc || self._matcher.canBecomeTrueByModifier(op.o) || self._sorter && self._sorter.affectedByModifier(op.o)) {\n          self._needToFetch.set(id, op.ts.toString());                                                                // 643\n          if (self._phase === PHASE.STEADY) self._fetchModifiedDocuments();                                           // 644\n        }                                                                                                             // 646\n      } else {                                                                                                        // 647\n        throw Error(\"XXX SURPRISING OPERATION: \" + op);                                                               // 648\n      }                                                                                                               // 649\n    });                                                                                                               // 650\n  },                                                                                                                  // 651\n  // Yields!                                                                                                          //\n  _runInitialQuery: function _runInitialQuery() {                                                                     // 653\n    var self = this;                                                                                                  // 654\n    if (self._stopped) throw new Error(\"oplog stopped surprisingly early\");                                           // 655\n                                                                                                                      //\n    self._runQuery({ initial: true }); // yields                                                                      // 658\n                                                                                                                      //\n    if (self._stopped) return; // can happen on queryError                                                            // 660\n                                                                                                                      //\n    // Allow observeChanges calls to return. (After this, it's possible for                                           //\n    // stop() to be called.)                                                                                          //\n    self._multiplexer.ready();                                                                                        // 665\n                                                                                                                      //\n    self._doneQuerying(); // yields                                                                                   // 667\n  },                                                                                                                  // 668\n                                                                                                                      //\n  // In various circumstances, we may just want to stop processing the oplog and                                      //\n  // re-run the initial query, just as if we were a PollingObserveDriver.                                             //\n  //                                                                                                                  //\n  // This function may not block, because it is called from an oplog entry                                            //\n  // handler.                                                                                                         //\n  //                                                                                                                  //\n  // XXX We should call this when we detect that we've been in FETCHING for \"too                                      //\n  // long\".                                                                                                           //\n  //                                                                                                                  //\n  // XXX We should call this when we detect Mongo failover (since that might                                          //\n  // mean that some of the oplog entries we have processed have been rolled                                           //\n  // back). The Node Mongo driver is in the middle of a bunch of huge                                                 //\n  // refactorings, including the way that it notifies you when primary                                                //\n  // changes. Will put off implementing this until driver 1.4 is out.                                                 //\n  _pollQuery: function _pollQuery() {                                                                                 // 684\n    var self = this;                                                                                                  // 685\n    Meteor._noYieldsAllowed(function () {                                                                             // 686\n      if (self._stopped) return;                                                                                      // 687\n                                                                                                                      //\n      // Yay, we get to forget about all the things we thought we had to fetch.                                       //\n      self._needToFetch = new LocalCollection._IdMap();                                                               // 691\n      self._currentlyFetching = null;                                                                                 // 692\n      ++self._fetchGeneration; // ignore any in-flight fetches                                                        // 693\n      self._registerPhaseChange(PHASE.QUERYING);                                                                      // 694\n                                                                                                                      //\n      // Defer so that we don't yield.  We don't need finishIfNeedToPollQuery                                         //\n      // here because SwitchedToQuery is not thrown in QUERYING mode.                                                 //\n      Meteor.defer(function () {                                                                                      // 698\n        self._runQuery();                                                                                             // 699\n        self._doneQuerying();                                                                                         // 700\n      });                                                                                                             // 701\n    });                                                                                                               // 702\n  },                                                                                                                  // 703\n                                                                                                                      //\n  // Yields!                                                                                                          //\n  _runQuery: function _runQuery(options) {                                                                            // 706\n    var self = this;                                                                                                  // 707\n    options = options || {};                                                                                          // 708\n    var newResults, newBuffer;                                                                                        // 709\n                                                                                                                      //\n    // This while loop is just to retry failures.                                                                     //\n    while (true) {                                                                                                    // 712\n      // If we've been stopped, we don't have to run anything any more.                                               //\n      if (self._stopped) return;                                                                                      // 714\n                                                                                                                      //\n      newResults = new LocalCollection._IdMap();                                                                      // 717\n      newBuffer = new LocalCollection._IdMap();                                                                       // 718\n                                                                                                                      //\n      // Query 2x documents as the half excluded from the original query will go                                      //\n      // into unpublished buffer to reduce additional Mongo lookups in cases                                          //\n      // when documents are removed from the published set and need a                                                 //\n      // replacement.                                                                                                 //\n      // XXX needs more thought on non-zero skip                                                                      //\n      // XXX 2 is a \"magic number\" meaning there is an extra chunk of docs for                                        //\n      // buffer if such is needed.                                                                                    //\n      var cursor = self._cursorForQuery({ limit: self._limit * 2 });                                                  // 727\n      try {                                                                                                           // 728\n        cursor.forEach(function (doc, i) {                                                                            // 729\n          // yields                                                                                                   //\n          if (!self._limit || i < self._limit) newResults.set(doc._id, doc);else newBuffer.set(doc._id, doc);         // 730\n        });                                                                                                           // 734\n        break;                                                                                                        // 735\n      } catch (e) {                                                                                                   // 736\n        if (options.initial && typeof e.code === 'number') {                                                          // 737\n          // This is an error document sent to us by mongod, not a connection                                         //\n          // error generated by the client. And we've never seen this query work                                      //\n          // successfully. Probably it's a bad selector or something, so we                                           //\n          // should NOT retry. Instead, we should halt the observe (which ends                                        //\n          // up calling `stop` on us).                                                                                //\n          self._multiplexer.queryError(e);                                                                            // 743\n          return;                                                                                                     // 744\n        }                                                                                                             // 745\n                                                                                                                      //\n        // During failover (eg) if we get an exception we should log and retry                                        //\n        // instead of crashing.                                                                                       //\n        Meteor._debug(\"Got exception while polling query: \" + e);                                                     // 749\n        Meteor._sleepForMs(100);                                                                                      // 750\n      }                                                                                                               // 751\n    }                                                                                                                 // 752\n                                                                                                                      //\n    if (self._stopped) return;                                                                                        // 754\n                                                                                                                      //\n    self._publishNewResults(newResults, newBuffer);                                                                   // 757\n  },                                                                                                                  // 758\n                                                                                                                      //\n  // Transitions to QUERYING and runs another query, or (if already in QUERYING)                                      //\n  // ensures that we will query again later.                                                                          //\n  //                                                                                                                  //\n  // This function may not block, because it is called from an oplog entry                                            //\n  // handler. However, if we were not already in the QUERYING phase, it throws                                        //\n  // an exception that is caught by the closest surrounding                                                           //\n  // finishIfNeedToPollQuery call; this ensures that we don't continue running                                        //\n  // close that was designed for another phase inside PHASE.QUERYING.                                                 //\n  //                                                                                                                  //\n  // (It's also necessary whenever logic in this file yields to check that other                                      //\n  // phases haven't put us into QUERYING mode, though; eg,                                                            //\n  // _fetchModifiedDocuments does this.)                                                                              //\n  _needToPollQuery: function _needToPollQuery() {                                                                     // 772\n    var self = this;                                                                                                  // 773\n    Meteor._noYieldsAllowed(function () {                                                                             // 774\n      if (self._stopped) return;                                                                                      // 775\n                                                                                                                      //\n      // If we're not already in the middle of a query, we can query now                                              //\n      // (possibly pausing FETCHING).                                                                                 //\n      if (self._phase !== PHASE.QUERYING) {                                                                           // 780\n        self._pollQuery();                                                                                            // 781\n        throw new SwitchedToQuery();                                                                                  // 782\n      }                                                                                                               // 783\n                                                                                                                      //\n      // We're currently in QUERYING. Set a flag to ensure that we run another                                        //\n      // query when we're done.                                                                                       //\n      self._requeryWhenDoneThisQuery = true;                                                                          // 787\n    });                                                                                                               // 788\n  },                                                                                                                  // 789\n                                                                                                                      //\n  // Yields!                                                                                                          //\n  _doneQuerying: function _doneQuerying() {                                                                           // 792\n    var self = this;                                                                                                  // 793\n                                                                                                                      //\n    if (self._stopped) return;                                                                                        // 795\n    self._mongoHandle._oplogHandle.waitUntilCaughtUp(); // yields                                                     // 797\n    if (self._stopped) return;                                                                                        // 798\n    if (self._phase !== PHASE.QUERYING) throw Error(\"Phase unexpectedly \" + self._phase);                             // 800\n                                                                                                                      //\n    Meteor._noYieldsAllowed(function () {                                                                             // 803\n      if (self._requeryWhenDoneThisQuery) {                                                                           // 804\n        self._requeryWhenDoneThisQuery = false;                                                                       // 805\n        self._pollQuery();                                                                                            // 806\n      } else if (self._needToFetch.empty()) {                                                                         // 807\n        self._beSteady();                                                                                             // 808\n      } else {                                                                                                        // 809\n        self._fetchModifiedDocuments();                                                                               // 810\n      }                                                                                                               // 811\n    });                                                                                                               // 812\n  },                                                                                                                  // 813\n                                                                                                                      //\n  _cursorForQuery: function _cursorForQuery(optionsOverwrite) {                                                       // 815\n    var self = this;                                                                                                  // 816\n    return Meteor._noYieldsAllowed(function () {                                                                      // 817\n      // The query we run is almost the same as the cursor we are observing,                                          //\n      // with a few changes. We need to read all the fields that are relevant to                                      //\n      // the selector, not just the fields we are going to publish (that's the                                        //\n      // \"shared\" projection). And we don't want to apply any transform in the                                        //\n      // cursor, because observeChanges shouldn't use the transform.                                                  //\n      var options = _.clone(self._cursorDescription.options);                                                         // 823\n                                                                                                                      //\n      // Allow the caller to modify the options. Useful to specify different                                          //\n      // skip and limit values.                                                                                       //\n      _.extend(options, optionsOverwrite);                                                                            // 827\n                                                                                                                      //\n      options.fields = self._sharedProjection;                                                                        // 829\n      delete options.transform;                                                                                       // 830\n      // We are NOT deep cloning fields or selector here, which should be OK.                                         //\n      var description = new CursorDescription(self._cursorDescription.collectionName, self._cursorDescription.selector, options);\n      return new Cursor(self._mongoHandle, description);                                                              // 836\n    });                                                                                                               // 837\n  },                                                                                                                  // 838\n                                                                                                                      //\n  // Replace self._published with newResults (both are IdMaps), invoking observe                                      //\n  // callbacks on the multiplexer.                                                                                    //\n  // Replace self._unpublishedBuffer with newBuffer.                                                                  //\n  //                                                                                                                  //\n  // XXX This is very similar to LocalCollection._diffQueryUnorderedChanges. We                                       //\n  // should really: (a) Unify IdMap and OrderedDict into Unordered/OrderedDict                                        //\n  // (b) Rewrite diff.js to use these classes instead of arrays and objects.                                          //\n  _publishNewResults: function _publishNewResults(newResults, newBuffer) {                                            // 848\n    var self = this;                                                                                                  // 849\n    Meteor._noYieldsAllowed(function () {                                                                             // 850\n                                                                                                                      //\n      // If the query is limited and there is a buffer, shut down so it doesn't                                       //\n      // stay in a way.                                                                                               //\n      if (self._limit) {                                                                                              // 854\n        self._unpublishedBuffer.clear();                                                                              // 855\n      }                                                                                                               // 856\n                                                                                                                      //\n      // First remove anything that's gone. Be careful not to modify                                                  //\n      // self._published while iterating over it.                                                                     //\n      var idsToRemove = [];                                                                                           // 860\n      self._published.forEach(function (doc, id) {                                                                    // 861\n        if (!newResults.has(id)) idsToRemove.push(id);                                                                // 862\n      });                                                                                                             // 864\n      _.each(idsToRemove, function (id) {                                                                             // 865\n        self._removePublished(id);                                                                                    // 866\n      });                                                                                                             // 867\n                                                                                                                      //\n      // Now do adds and changes.                                                                                     //\n      // If self has a buffer and limit, the new fetched result will be                                               //\n      // limited correctly as the query has sort specifier.                                                           //\n      newResults.forEach(function (doc, id) {                                                                         // 872\n        self._handleDoc(id, doc);                                                                                     // 873\n      });                                                                                                             // 874\n                                                                                                                      //\n      // Sanity-check that everything we tried to put into _published ended up                                        //\n      // there.                                                                                                       //\n      // XXX if this is slow, remove it later                                                                         //\n      if (self._published.size() !== newResults.size()) {                                                             // 879\n        throw Error(\"The Mongo server and the Meteor query disagree on how \" + \"many documents match your query. Maybe it is hitting a Mongo \" + \"edge case? The query is: \" + EJSON.stringify(self._cursorDescription.selector));\n      }                                                                                                               // 885\n      self._published.forEach(function (doc, id) {                                                                    // 886\n        if (!newResults.has(id)) throw Error(\"_published has a doc that newResults doesn't; \" + id);                  // 887\n      });                                                                                                             // 889\n                                                                                                                      //\n      // Finally, replace the buffer                                                                                  //\n      newBuffer.forEach(function (doc, id) {                                                                          // 892\n        self._addBuffered(id, doc);                                                                                   // 893\n      });                                                                                                             // 894\n                                                                                                                      //\n      self._safeAppendToBuffer = newBuffer.size() < self._limit;                                                      // 896\n    });                                                                                                               // 897\n  },                                                                                                                  // 898\n                                                                                                                      //\n  // This stop function is invoked from the onStop of the ObserveMultiplexer, so                                      //\n  // it shouldn't actually be possible to call it until the multiplexer is                                            //\n  // ready.                                                                                                           //\n  //                                                                                                                  //\n  // It's important to check self._stopped after every call in this file that                                         //\n  // can yield!                                                                                                       //\n  stop: function stop() {                                                                                             // 906\n    var self = this;                                                                                                  // 907\n    if (self._stopped) return;                                                                                        // 908\n    self._stopped = true;                                                                                             // 910\n    _.each(self._stopHandles, function (handle) {                                                                     // 911\n      handle.stop();                                                                                                  // 912\n    });                                                                                                               // 913\n                                                                                                                      //\n    // Note: we *don't* use multiplexer.onFlush here because this stop                                                //\n    // callback is actually invoked by the multiplexer itself when it has                                             //\n    // determined that there are no handles left. So nothing is actually going                                        //\n    // to get flushed (and it's probably not valid to call methods on the                                             //\n    // dying multiplexer).                                                                                            //\n    _.each(self._writesToCommitWhenWeReachSteady, function (w) {                                                      // 920\n      w.committed(); // maybe yields?                                                                                 // 921\n    });                                                                                                               // 922\n    self._writesToCommitWhenWeReachSteady = null;                                                                     // 923\n                                                                                                                      //\n    // Proactively drop references to potentially big things.                                                         //\n    self._published = null;                                                                                           // 926\n    self._unpublishedBuffer = null;                                                                                   // 927\n    self._needToFetch = null;                                                                                         // 928\n    self._currentlyFetching = null;                                                                                   // 929\n    self._oplogEntryHandle = null;                                                                                    // 930\n    self._listenersHandle = null;                                                                                     // 931\n                                                                                                                      //\n    Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-oplog\", -1);          // 933\n  },                                                                                                                  // 935\n                                                                                                                      //\n  _registerPhaseChange: function _registerPhaseChange(phase) {                                                        // 937\n    var self = this;                                                                                                  // 938\n    Meteor._noYieldsAllowed(function () {                                                                             // 939\n      var now = new Date();                                                                                           // 940\n                                                                                                                      //\n      if (self._phase) {                                                                                              // 942\n        var timeDiff = now - self._phaseStartTime;                                                                    // 943\n        Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"time-spent-in-\" + self._phase + \"-phase\", timeDiff);\n      }                                                                                                               // 946\n                                                                                                                      //\n      self._phase = phase;                                                                                            // 948\n      self._phaseStartTime = now;                                                                                     // 949\n    });                                                                                                               // 950\n  }                                                                                                                   // 951\n});                                                                                                                   // 196\n                                                                                                                      //\n// Does our oplog tailing code support this cursor? For now, we are being very                                        //\n// conservative and allowing only simple queries with simple options.                                                 //\n// (This is a \"static method\".)                                                                                       //\nOplogObserveDriver.cursorSupported = function (cursorDescription, matcher) {                                          // 957\n  // First, check the options.                                                                                        //\n  var options = cursorDescription.options;                                                                            // 959\n                                                                                                                      //\n  // Did the user say no explicitly?                                                                                  //\n  // underscored version of the option is COMPAT with 1.2                                                             //\n  if (options.disableOplog || options._disableOplog) return false;                                                    // 963\n                                                                                                                      //\n  // skip is not supported: to support it we would need to keep track of all                                          //\n  // \"skipped\" documents or at least their ids.                                                                       //\n  // limit w/o a sort specifier is not supported: current implementation needs a                                      //\n  // deterministic way to order documents.                                                                            //\n  if (options.skip || options.limit && !options.sort) return false;                                                   // 970\n                                                                                                                      //\n  // If a fields projection option is given check if it is supported by                                               //\n  // minimongo (some operators are not supported).                                                                    //\n  if (options.fields) {                                                                                               // 974\n    try {                                                                                                             // 975\n      LocalCollection._checkSupportedProjection(options.fields);                                                      // 976\n    } catch (e) {                                                                                                     // 977\n      if (e.name === \"MinimongoError\") return false;else throw e;                                                     // 978\n    }                                                                                                                 // 982\n  }                                                                                                                   // 983\n                                                                                                                      //\n  // We don't allow the following selectors:                                                                          //\n  //   - $where (not confident that we provide the same JS environment                                                //\n  //             as Mongo, and can yield!)                                                                            //\n  //   - $near (has \"interesting\" properties in MongoDB, like the possibility                                         //\n  //            of returning an ID multiple times, though even polling maybe                                          //\n  //            have a bug there)                                                                                     //\n  //           XXX: once we support it, we would need to think more on how we                                         //\n  //           initialize the comparators when we create the driver.                                                  //\n  return !matcher.hasWhere() && !matcher.hasGeoQuery();                                                               // 993\n};                                                                                                                    // 994\n                                                                                                                      //\nvar modifierCanBeDirectlyApplied = function modifierCanBeDirectlyApplied(modifier) {                                  // 996\n  return _.all(modifier, function (fields, operation) {                                                               // 997\n    return _.all(fields, function (value, field) {                                                                    // 998\n      return !/EJSON\\$/.test(field);                                                                                  // 999\n    });                                                                                                               // 1000\n  });                                                                                                                 // 1001\n};                                                                                                                    // 1002\n                                                                                                                      //\nMongoInternals.OplogObserveDriver = OplogObserveDriver;                                                               // 1004\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"local_collection_driver.js\":function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/mongo/local_collection_driver.js                                                                          //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nLocalCollectionDriver = function LocalCollectionDriver() {                                                            // 1\n  var self = this;                                                                                                    // 2\n  self.noConnCollections = {};                                                                                        // 3\n};                                                                                                                    // 4\n                                                                                                                      //\nvar ensureCollection = function ensureCollection(name, collections) {                                                 // 6\n  if (!(name in collections)) collections[name] = new LocalCollection(name);                                          // 7\n  return collections[name];                                                                                           // 9\n};                                                                                                                    // 10\n                                                                                                                      //\n_.extend(LocalCollectionDriver.prototype, {                                                                           // 12\n  open: function open(name, conn) {                                                                                   // 13\n    var self = this;                                                                                                  // 14\n    if (!name) return new LocalCollection();                                                                          // 15\n    if (!conn) {                                                                                                      // 17\n      return ensureCollection(name, self.noConnCollections);                                                          // 18\n    }                                                                                                                 // 19\n    if (!conn._mongo_livedata_collections) conn._mongo_livedata_collections = {};                                     // 20\n    // XXX is there a way to keep track of a connection's collections without                                         //\n    // dangling it off the connection object?                                                                         //\n    return ensureCollection(name, conn._mongo_livedata_collections);                                                  // 24\n  }                                                                                                                   // 25\n});                                                                                                                   // 12\n                                                                                                                      //\n// singleton                                                                                                          //\nLocalCollectionDriver = new LocalCollectionDriver();                                                                  // 29\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"remote_collection_driver.js\":function(require){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/mongo/remote_collection_driver.js                                                                         //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nMongoInternals.RemoteCollectionDriver = function (mongo_url, options) {                                               // 1\n  var self = this;                                                                                                    // 3\n  self.mongo = new MongoConnection(mongo_url, options);                                                               // 4\n};                                                                                                                    // 5\n                                                                                                                      //\n_.extend(MongoInternals.RemoteCollectionDriver.prototype, {                                                           // 7\n  open: function open(name) {                                                                                         // 8\n    var self = this;                                                                                                  // 9\n    var ret = {};                                                                                                     // 10\n    _.each(['find', 'findOne', 'insert', 'update', 'upsert', 'remove', '_ensureIndex', '_dropIndex', '_createCappedCollection', 'dropCollection', 'rawCollection'], function (m) {\n      ret[m] = _.bind(self.mongo[m], self.mongo, name);                                                               // 16\n    });                                                                                                               // 17\n    return ret;                                                                                                       // 18\n  }                                                                                                                   // 19\n});                                                                                                                   // 7\n                                                                                                                      //\n// Create the singleton RemoteCollectionDriver only on demand, so we                                                  //\n// only require Mongo configuration if it's actually used (eg, not if                                                 //\n// you're only trying to receive data from a remote DDP server.)                                                      //\nMongoInternals.defaultRemoteCollectionDriver = _.once(function () {                                                   // 26\n  var connectionOptions = {};                                                                                         // 27\n                                                                                                                      //\n  var mongoUrl = process.env.MONGO_URL;                                                                               // 29\n                                                                                                                      //\n  if (process.env.MONGO_OPLOG_URL) {                                                                                  // 31\n    connectionOptions.oplogUrl = process.env.MONGO_OPLOG_URL;                                                         // 32\n  }                                                                                                                   // 33\n                                                                                                                      //\n  if (!mongoUrl) throw new Error(\"MONGO_URL must be set in environment\");                                             // 35\n                                                                                                                      //\n  return new MongoInternals.RemoteCollectionDriver(mongoUrl, connectionOptions);                                      // 38\n});                                                                                                                   // 39\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"collection.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/mongo/collection.js                                                                                       //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n// options.connection, if given, is a LivedataClient or LivedataServer                                                //\n// XXX presently there is no way to destroy/clean up a Collection                                                     //\n                                                                                                                      //\n/**                                                                                                                   //\n * @summary Namespace for MongoDB-related items                                                                       //\n * @namespace                                                                                                         //\n */                                                                                                                   //\nMongo = {};                                                                                                           // 8\n                                                                                                                      //\n/**                                                                                                                   //\n * @summary Constructor for a Collection                                                                              //\n * @locus Anywhere                                                                                                    //\n * @instancename collection                                                                                           //\n * @class                                                                                                             //\n * @param {String} name The name of the collection.  If null, creates an unmanaged (unsynchronized) local collection.\n * @param {Object} [options]                                                                                          //\n * @param {Object} options.connection The server connection that will manage this collection. Uses the default connection if not specified.  Pass the return value of calling [`DDP.connect`](#ddp_connect) to specify a different server. Pass `null` to specify no connection. Unmanaged (`name` is null) collections cannot specify a connection.\n * @param {String} options.idGeneration The method of generating the `_id` fields of new documents in this collection.  Possible values:\n                                                                                                                      //\n - **`'STRING'`**: random strings                                                                                     //\n - **`'MONGO'`**:  random [`Mongo.ObjectID`](#mongo_object_id) values                                                 //\n                                                                                                                      //\nThe default id generation technique is `'STRING'`.                                                                    //\n * @param {Function} options.transform An optional transformation function. Documents will be passed through this function before being returned from `fetch` or `findOne`, and before being passed to callbacks of `observe`, `map`, `forEach`, `allow`, and `deny`. Transforms are *not* applied for the callbacks of `observeChanges` or to cursors returned from publish functions.\n * @param {Boolean} options.defineMutationMethods Set to `false` to skip setting up the mutation methods that enable insert/update/remove from client code. Default `true`.\n */                                                                                                                   //\nMongo.Collection = function (name, options) {                                                                         // 27\n  var self = this;                                                                                                    // 28\n  if (!(self instanceof Mongo.Collection)) throw new Error('use \"new\" to construct a Mongo.Collection');              // 29\n                                                                                                                      //\n  if (!name && name !== null) {                                                                                       // 32\n    Meteor._debug(\"Warning: creating anonymous collection. It will not be \" + \"saved or synchronized over the network. (Pass null for \" + \"the collection name to turn off this warning.)\");\n    name = null;                                                                                                      // 36\n  }                                                                                                                   // 37\n                                                                                                                      //\n  if (name !== null && typeof name !== \"string\") {                                                                    // 39\n    throw new Error(\"First argument to new Mongo.Collection must be a string or null\");                               // 40\n  }                                                                                                                   // 42\n                                                                                                                      //\n  if (options && options.methods) {                                                                                   // 44\n    // Backwards compatibility hack with original signature (which passed                                             //\n    // \"connection\" directly instead of in options. (Connections must have a \"methods\"                                //\n    // method.)                                                                                                       //\n    // XXX remove before 1.0                                                                                          //\n    options = { connection: options };                                                                                // 49\n  }                                                                                                                   // 50\n  // Backwards compatibility: \"connection\" used to be called \"manager\".                                               //\n  if (options && options.manager && !options.connection) {                                                            // 52\n    options.connection = options.manager;                                                                             // 53\n  }                                                                                                                   // 54\n  options = _.extend({                                                                                                // 55\n    connection: undefined,                                                                                            // 56\n    idGeneration: 'STRING',                                                                                           // 57\n    transform: null,                                                                                                  // 58\n    _driver: undefined,                                                                                               // 59\n    _preventAutopublish: false                                                                                        // 60\n  }, options);                                                                                                        // 55\n                                                                                                                      //\n  switch (options.idGeneration) {                                                                                     // 63\n    case 'MONGO':                                                                                                     // 64\n      self._makeNewID = function () {                                                                                 // 65\n        var src = name ? DDP.randomStream('/collection/' + name) : Random.insecure;                                   // 66\n        return new Mongo.ObjectID(src.hexString(24));                                                                 // 69\n      };                                                                                                              // 70\n      break;                                                                                                          // 71\n    case 'STRING':                                                                                                    // 72\n    default:                                                                                                          // 73\n      self._makeNewID = function () {                                                                                 // 74\n        var src = name ? DDP.randomStream('/collection/' + name) : Random.insecure;                                   // 75\n        return src.id();                                                                                              // 78\n      };                                                                                                              // 79\n      break;                                                                                                          // 80\n  }                                                                                                                   // 63\n                                                                                                                      //\n  self._transform = LocalCollection.wrapTransform(options.transform);                                                 // 83\n                                                                                                                      //\n  if (!name || options.connection === null)                                                                           // 85\n    // note: nameless collections never have a connection                                                             //\n    self._connection = null;else if (options.connection) self._connection = options.connection;else if (Meteor.isClient) self._connection = Meteor.connection;else self._connection = Meteor.server;\n                                                                                                                      //\n  if (!options._driver) {                                                                                             // 95\n    // XXX This check assumes that webapp is loaded so that Meteor.server !==                                         //\n    // null. We should fully support the case of \"want to use a Mongo-backed                                          //\n    // collection from Node code without webapp\", but we don't yet.                                                   //\n    // #MeteorServerNull                                                                                              //\n    if (name && self._connection === Meteor.server && typeof MongoInternals !== \"undefined\" && MongoInternals.defaultRemoteCollectionDriver) {\n      options._driver = MongoInternals.defaultRemoteCollectionDriver();                                               // 103\n    } else {                                                                                                          // 104\n      options._driver = LocalCollectionDriver;                                                                        // 105\n    }                                                                                                                 // 106\n  }                                                                                                                   // 107\n                                                                                                                      //\n  self._collection = options._driver.open(name, self._connection);                                                    // 109\n  self._name = name;                                                                                                  // 110\n  self._driver = options._driver;                                                                                     // 111\n                                                                                                                      //\n  if (self._connection && self._connection.registerStore) {                                                           // 113\n    // OK, we're going to be a slave, replicating some remote                                                         //\n    // database, except possibly with some temporary divergence while                                                 //\n    // we have unacknowledged RPC's.                                                                                  //\n    var ok = self._connection.registerStore(name, {                                                                   // 117\n      // Called at the beginning of a batch of updates. batchSize is the number                                       //\n      // of update calls to expect.                                                                                   //\n      //                                                                                                              //\n      // XXX This interface is pretty janky. reset probably ought to go back to                                       //\n      // being its own function, and callers shouldn't have to calculate                                              //\n      // batchSize. The optimization of not calling pause/remove should be                                            //\n      // delayed until later: the first call to update() should buffer its                                            //\n      // message, and then we can either directly apply it at endUpdate time if                                       //\n      // it was the only update, or do pauseObservers/apply/apply at the next                                         //\n      // update() if there's another one.                                                                             //\n      beginUpdate: function beginUpdate(batchSize, reset) {                                                           // 128\n        // pause observers so users don't see flicker when updating several                                           //\n        // objects at once (including the post-reconnect reset-and-reapply                                            //\n        // stage), and so that a re-sorting of a query can take advantage of the                                      //\n        // full _diffQuery moved calculation instead of applying change one at a                                      //\n        // time.                                                                                                      //\n        if (batchSize > 1 || reset) self._collection.pauseObservers();                                                // 134\n                                                                                                                      //\n        if (reset) self._collection.remove({});                                                                       // 137\n      },                                                                                                              // 139\n                                                                                                                      //\n      // Apply an update.                                                                                             //\n      // XXX better specify this interface (not in terms of a wire message)?                                          //\n      update: function update(msg) {                                                                                  // 143\n        var mongoId = MongoID.idParse(msg.id);                                                                        // 144\n        var doc = self._collection.findOne(mongoId);                                                                  // 145\n                                                                                                                      //\n        // Is this a \"replace the whole doc\" message coming from the quiescence                                       //\n        // of method writes to an object? (Note that 'undefined' is a valid                                           //\n        // value meaning \"remove it\".)                                                                                //\n        if (msg.msg === 'replace') {                                                                                  // 150\n          var replace = msg.replace;                                                                                  // 151\n          if (!replace) {                                                                                             // 152\n            if (doc) self._collection.remove(mongoId);                                                                // 153\n          } else if (!doc) {                                                                                          // 155\n            self._collection.insert(replace);                                                                         // 156\n          } else {                                                                                                    // 157\n            // XXX check that replace has no $ ops                                                                    //\n            self._collection.update(mongoId, replace);                                                                // 159\n          }                                                                                                           // 160\n          return;                                                                                                     // 161\n        } else if (msg.msg === 'added') {                                                                             // 162\n          if (doc) {                                                                                                  // 163\n            throw new Error(\"Expected not to find a document already present for an add\");                            // 164\n          }                                                                                                           // 165\n          self._collection.insert(_.extend({ _id: mongoId }, msg.fields));                                            // 166\n        } else if (msg.msg === 'removed') {                                                                           // 167\n          if (!doc) throw new Error(\"Expected to find a document already present for removed\");                       // 168\n          self._collection.remove(mongoId);                                                                           // 170\n        } else if (msg.msg === 'changed') {                                                                           // 171\n          if (!doc) throw new Error(\"Expected to find a document to change\");                                         // 172\n          if (!_.isEmpty(msg.fields)) {                                                                               // 174\n            var modifier = {};                                                                                        // 175\n            _.each(msg.fields, function (value, key) {                                                                // 176\n              if (value === undefined) {                                                                              // 177\n                if (!modifier.$unset) modifier.$unset = {};                                                           // 178\n                modifier.$unset[key] = 1;                                                                             // 180\n              } else {                                                                                                // 181\n                if (!modifier.$set) modifier.$set = {};                                                               // 182\n                modifier.$set[key] = value;                                                                           // 184\n              }                                                                                                       // 185\n            });                                                                                                       // 186\n            self._collection.update(mongoId, modifier);                                                               // 187\n          }                                                                                                           // 188\n        } else {                                                                                                      // 189\n          throw new Error(\"I don't know how to deal with this message\");                                              // 190\n        }                                                                                                             // 191\n      },                                                                                                              // 193\n                                                                                                                      //\n      // Called at the end of a batch of updates.                                                                     //\n      endUpdate: function endUpdate() {                                                                               // 196\n        self._collection.resumeObservers();                                                                           // 197\n      },                                                                                                              // 198\n                                                                                                                      //\n      // Called around method stub invocations to capture the original versions                                       //\n      // of modified documents.                                                                                       //\n      saveOriginals: function saveOriginals() {                                                                       // 202\n        self._collection.saveOriginals();                                                                             // 203\n      },                                                                                                              // 204\n      retrieveOriginals: function retrieveOriginals() {                                                               // 205\n        return self._collection.retrieveOriginals();                                                                  // 206\n      },                                                                                                              // 207\n                                                                                                                      //\n      // Used to preserve current versions of documents across a store reset.                                         //\n      getDoc: function getDoc(id) {                                                                                   // 210\n        return self.findOne(id);                                                                                      // 211\n      },                                                                                                              // 212\n                                                                                                                      //\n      // To be able to get back to the collection from the store.                                                     //\n      _getCollection: function _getCollection() {                                                                     // 215\n        return self;                                                                                                  // 216\n      }                                                                                                               // 217\n    });                                                                                                               // 117\n                                                                                                                      //\n    if (!ok) {                                                                                                        // 220\n      var message = \"There is already a collection named \\\"\" + name + \"\\\"\";                                           // 221\n      if (options._suppressSameNameError === true) {                                                                  // 222\n        // XXX In theory we do not have to throw when `ok` is falsy. The store is already defined                     //\n        // for this collection name, but this will simply be another reference to it and everything                   //\n        // should work. However, we have historically thrown an error here, so for now we will                        //\n        // skip the error only when `_suppressSameNameError` is `true`, allowing people to opt in                     //\n        // and give this some real world testing.                                                                     //\n        console.warn ? console.warn(message) : console.log(message);                                                  // 228\n      } else {                                                                                                        // 229\n        throw new Error(message);                                                                                     // 230\n      }                                                                                                               // 231\n    }                                                                                                                 // 232\n  }                                                                                                                   // 233\n                                                                                                                      //\n  // XXX don't define these until allow or deny is actually used for this                                             //\n  // collection. Could be hard if the security rules are only defined on the                                          //\n  // server.                                                                                                          //\n  if (options.defineMutationMethods !== false) {                                                                      // 238\n    try {                                                                                                             // 239\n      self._defineMutationMethods({ useExisting: options._suppressSameNameError === true });                          // 240\n    } catch (error) {                                                                                                 // 241\n      // Throw a more understandable error on the server for same collection name                                     //\n      if (error.message === \"A method named '/\" + name + \"/insert' is already defined\") throw new Error(\"There is already a collection named \\\"\" + name + \"\\\"\");\n      throw error;                                                                                                    // 245\n    }                                                                                                                 // 246\n  }                                                                                                                   // 247\n                                                                                                                      //\n  // autopublish                                                                                                      //\n  if (Package.autopublish && !options._preventAutopublish && self._connection && self._connection.publish) {          // 250\n    self._connection.publish(null, function () {                                                                      // 252\n      return self.find();                                                                                             // 253\n    }, { is_auto: true });                                                                                            // 254\n  }                                                                                                                   // 255\n};                                                                                                                    // 256\n                                                                                                                      //\n///                                                                                                                   //\n/// Main collection API                                                                                               //\n///                                                                                                                   //\n                                                                                                                      //\n_.extend(Mongo.Collection.prototype, {                                                                                // 263\n                                                                                                                      //\n  _getFindSelector: function _getFindSelector(args) {                                                                 // 265\n    if (args.length == 0) return {};else return args[0];                                                              // 266\n  },                                                                                                                  // 270\n                                                                                                                      //\n  _getFindOptions: function _getFindOptions(args) {                                                                   // 272\n    var self = this;                                                                                                  // 273\n    if (args.length < 2) {                                                                                            // 274\n      return { transform: self._transform };                                                                          // 275\n    } else {                                                                                                          // 276\n      check(args[1], Match.Optional(Match.ObjectIncluding({                                                           // 277\n        fields: Match.Optional(Match.OneOf(Object, undefined)),                                                       // 278\n        sort: Match.Optional(Match.OneOf(Object, Array, Function, undefined)),                                        // 279\n        limit: Match.Optional(Match.OneOf(Number, undefined)),                                                        // 280\n        skip: Match.Optional(Match.OneOf(Number, undefined))                                                          // 281\n      })));                                                                                                           // 277\n                                                                                                                      //\n      return _.extend({                                                                                               // 284\n        transform: self._transform                                                                                    // 285\n      }, args[1]);                                                                                                    // 284\n    }                                                                                                                 // 287\n  },                                                                                                                  // 288\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Find the documents in a collection that match the selector.                                             //\n   * @locus Anywhere                                                                                                  //\n   * @method find                                                                                                     //\n   * @memberOf Mongo.Collection                                                                                       //\n   * @instance                                                                                                        //\n   * @param {MongoSelector} [selector] A query describing the documents to find                                       //\n   * @param {Object} [options]                                                                                        //\n   * @param {MongoSortSpecifier} options.sort Sort order (default: natural order)                                     //\n   * @param {Number} options.skip Number of results to skip at the beginning                                          //\n   * @param {Number} options.limit Maximum number of results to return                                                //\n   * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.                           //\n   * @param {Boolean} options.reactive (Client only) Default `true`; pass `false` to disable reactivity               //\n   * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections) for this cursor.  Pass `null` to disable transformation.\n   * @param {Boolean} options.disableOplog (Server only) Pass true to disable oplog-tailing on this query. This affects the way server processes calls to `observe` on this query. Disabling the oplog can be useful when working with data that updates in large batches.\n   * @param {Number} options.pollingIntervalMs (Server only) How often to poll this query when observing on the server. In milliseconds. Defaults to 10 seconds.\n   * @param {Number} options.pollingThrottleMs (Server only) Minimum time to allow between re-polling. Increasing this will save CPU and mongo load at the expense of slower updates to users. Decreasing this is not recommended. In milliseconds. Defaults to 50 milliseconds.\n   * @returns {Mongo.Cursor}                                                                                          //\n   */                                                                                                                 //\n  find: function find() /* selector, options */{                                                                      // 309\n    // Collection.find() (return all docs) behaves differently                                                        //\n    // from Collection.find(undefined) (return 0 docs).  so be                                                        //\n    // careful about the length of arguments.                                                                         //\n    var self = this;                                                                                                  // 313\n    var argArray = _.toArray(arguments);                                                                              // 314\n    return self._collection.find(self._getFindSelector(argArray), self._getFindOptions(argArray));                    // 315\n  },                                                                                                                  // 317\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Finds the first document that matches the selector, as ordered by sort and skip options. Returns `undefined` if no matching document is found.\n   * @locus Anywhere                                                                                                  //\n   * @method findOne                                                                                                  //\n   * @memberOf Mongo.Collection                                                                                       //\n   * @instance                                                                                                        //\n   * @param {MongoSelector} [selector] A query describing the documents to find                                       //\n   * @param {Object} [options]                                                                                        //\n   * @param {MongoSortSpecifier} options.sort Sort order (default: natural order)                                     //\n   * @param {Number} options.skip Number of results to skip at the beginning                                          //\n   * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.                           //\n   * @param {Boolean} options.reactive (Client only) Default true; pass false to disable reactivity                   //\n   * @param {Function} options.transform Overrides `transform` on the [`Collection`](#collections) for this cursor.  Pass `null` to disable transformation.\n   * @returns {Object}                                                                                                //\n   */                                                                                                                 //\n  findOne: function findOne() /* selector, options */{                                                                // 334\n    var self = this;                                                                                                  // 335\n    var argArray = _.toArray(arguments);                                                                              // 336\n    return self._collection.findOne(self._getFindSelector(argArray), self._getFindOptions(argArray));                 // 337\n  }                                                                                                                   // 339\n                                                                                                                      //\n});                                                                                                                   // 263\n                                                                                                                      //\nMongo.Collection._publishCursor = function (cursor, sub, collection) {                                                // 343\n  var observeHandle = cursor.observeChanges({                                                                         // 344\n    added: function added(id, fields) {                                                                               // 345\n      sub.added(collection, id, fields);                                                                              // 346\n    },                                                                                                                // 347\n    changed: function changed(id, fields) {                                                                           // 348\n      sub.changed(collection, id, fields);                                                                            // 349\n    },                                                                                                                // 350\n    removed: function removed(id) {                                                                                   // 351\n      sub.removed(collection, id);                                                                                    // 352\n    }                                                                                                                 // 353\n  });                                                                                                                 // 344\n                                                                                                                      //\n  // We don't call sub.ready() here: it gets called in livedata_server, after                                         //\n  // possibly calling _publishCursor on multiple returned cursors.                                                    //\n                                                                                                                      //\n  // register stop callback (expects lambda w/ no args).                                                              //\n  sub.onStop(function () {                                                                                            // 360\n    observeHandle.stop();                                                                                             // 360\n  });                                                                                                                 // 360\n                                                                                                                      //\n  // return the observeHandle in case it needs to be stopped early                                                    //\n  return observeHandle;                                                                                               // 363\n};                                                                                                                    // 364\n                                                                                                                      //\n// protect against dangerous selectors.  falsey and {_id: falsey} are both                                            //\n// likely programmer error, and not what you want, particularly for destructive                                       //\n// operations.  JS regexps don't serialize over DDP but can be trivially                                              //\n// replaced by $regex.                                                                                                //\nMongo.Collection._rewriteSelector = function (selector) {                                                             // 370\n  // shorthand -- scalars match _id                                                                                   //\n  if (LocalCollection._selectorIsId(selector)) selector = { _id: selector };                                          // 372\n                                                                                                                      //\n  if (_.isArray(selector)) {                                                                                          // 375\n    // This is consistent with the Mongo console itself; if we don't do this                                          //\n    // check passing an empty array ends up selecting all items                                                       //\n    throw new Error(\"Mongo selector can't be an array.\");                                                             // 378\n  }                                                                                                                   // 379\n                                                                                                                      //\n  if (!selector || '_id' in selector && !selector._id)                                                                // 381\n    // can't match anything                                                                                           //\n    return { _id: Random.id() };                                                                                      // 383\n                                                                                                                      //\n  var ret = {};                                                                                                       // 385\n  _.each(selector, function (value, key) {                                                                            // 386\n    // Mongo supports both {field: /foo/} and {field: {$regex: /foo/}}                                                //\n    if (value instanceof RegExp) {                                                                                    // 388\n      ret[key] = convertRegexpToMongoSelector(value);                                                                 // 389\n    } else if (value && value.$regex instanceof RegExp) {                                                             // 390\n      ret[key] = convertRegexpToMongoSelector(value.$regex);                                                          // 391\n      // if value is {$regex: /foo/, $options: ...} then $options                                                     //\n      // override the ones set on $regex.                                                                             //\n      if (value.$options !== undefined) ret[key].$options = value.$options;                                           // 394\n    } else if (_.contains(['$or', '$and', '$nor'], key)) {                                                            // 396\n      // Translate lower levels of $and/$or/$nor                                                                      //\n      ret[key] = _.map(value, function (v) {                                                                          // 399\n        return Mongo.Collection._rewriteSelector(v);                                                                  // 400\n      });                                                                                                             // 401\n    } else {                                                                                                          // 402\n      ret[key] = value;                                                                                               // 403\n    }                                                                                                                 // 404\n  });                                                                                                                 // 405\n  return ret;                                                                                                         // 406\n};                                                                                                                    // 407\n                                                                                                                      //\n// convert a JS RegExp object to a Mongo {$regex: ..., $options: ...}                                                 //\n// selector                                                                                                           //\nfunction convertRegexpToMongoSelector(regexp) {                                                                       // 411\n  check(regexp, RegExp); // safety belt                                                                               // 412\n                                                                                                                      //\n  var selector = { $regex: regexp.source };                                                                           // 414\n  var regexOptions = '';                                                                                              // 415\n  // JS RegExp objects support 'i', 'm', and 'g'. Mongo regex $options                                                //\n  // support 'i', 'm', 'x', and 's'. So we support 'i' and 'm' here.                                                  //\n  if (regexp.ignoreCase) regexOptions += 'i';                                                                         // 418\n  if (regexp.multiline) regexOptions += 'm';                                                                          // 420\n  if (regexOptions) selector.$options = regexOptions;                                                                 // 422\n                                                                                                                      //\n  return selector;                                                                                                    // 425\n};                                                                                                                    // 426\n                                                                                                                      //\n// 'insert' immediately returns the inserted document's new _id.                                                      //\n// The others return values immediately if you are in a stub, an in-memory                                            //\n// unmanaged collection, or a mongo-backed collection and you don't pass a                                            //\n// callback. 'update' and 'remove' return the number of affected                                                      //\n// documents. 'upsert' returns an object with keys 'numberAffected' and, if an                                        //\n// insert happened, 'insertedId'.                                                                                     //\n//                                                                                                                    //\n// Otherwise, the semantics are exactly like other methods: they take                                                 //\n// a callback as an optional last argument; if no callback is                                                         //\n// provided, they block until the operation is complete, and throw an                                                 //\n// exception if it fails; if a callback is provided, then they don't                                                  //\n// necessarily block, and they call the callback when they finish with error and                                      //\n// result arguments.  (The insert method provides the document ID as its result;                                      //\n// update and remove provide the number of affected docs as the result; upsert                                        //\n// provides an object with numberAffected and maybe insertedId.)                                                      //\n//                                                                                                                    //\n// On the client, blocking is impossible, so if a callback                                                            //\n// isn't provided, they just return immediately and any error                                                         //\n// information is lost.                                                                                               //\n//                                                                                                                    //\n// There's one more tweak. On the client, if you don't provide a                                                      //\n// callback, then if there is an error, a message will be logged with                                                 //\n// Meteor._debug.                                                                                                     //\n//                                                                                                                    //\n// The intent (though this is actually determined by the underlying                                                   //\n// drivers) is that the operations should be done synchronously, not                                                  //\n// generating their result until the database has acknowledged                                                        //\n// them. In the future maybe we should provide a flag to turn this                                                    //\n// off.                                                                                                               //\n                                                                                                                      //\n/**                                                                                                                   //\n * @summary Insert a document in the collection.  Returns its unique _id.                                             //\n * @locus Anywhere                                                                                                    //\n * @method  insert                                                                                                    //\n * @memberOf Mongo.Collection                                                                                         //\n * @instance                                                                                                          //\n * @param {Object} doc The document to insert. May not yet have an _id attribute, in which case Meteor will generate one for you.\n * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the _id as the second.\n */                                                                                                                   //\nMongo.Collection.prototype.insert = function insert(doc, callback) {                                                  // 467\n  // Make sure we were passed a document to insert                                                                    //\n  if (!doc) {                                                                                                         // 469\n    throw new Error(\"insert requires an argument\");                                                                   // 470\n  }                                                                                                                   // 471\n                                                                                                                      //\n  // Shallow-copy the document and possibly generate an ID                                                            //\n  doc = _.extend({}, doc);                                                                                            // 474\n                                                                                                                      //\n  if ('_id' in doc) {                                                                                                 // 476\n    if (!doc._id || !(typeof doc._id === 'string' || doc._id instanceof Mongo.ObjectID)) {                            // 477\n      throw new Error(\"Meteor requires document _id fields to be non-empty strings or ObjectIDs\");                    // 479\n    }                                                                                                                 // 480\n  } else {                                                                                                            // 481\n    var generateId = true;                                                                                            // 482\n                                                                                                                      //\n    // Don't generate the id if we're the client and the 'outermost' call                                             //\n    // This optimization saves us passing both the randomSeed and the id                                              //\n    // Passing both is redundant.                                                                                     //\n    if (this._isRemoteCollection()) {                                                                                 // 487\n      var enclosing = DDP._CurrentInvocation.get();                                                                   // 488\n      if (!enclosing) {                                                                                               // 489\n        generateId = false;                                                                                           // 490\n      }                                                                                                               // 491\n    }                                                                                                                 // 492\n                                                                                                                      //\n    if (generateId) {                                                                                                 // 494\n      doc._id = this._makeNewID();                                                                                    // 495\n    }                                                                                                                 // 496\n  }                                                                                                                   // 497\n                                                                                                                      //\n  // On inserts, always return the id that we generated; on all other                                                 //\n  // operations, just return the result from the collection.                                                          //\n  var chooseReturnValueFromCollectionResult = function chooseReturnValueFromCollectionResult(result) {                // 501\n    if (doc._id) {                                                                                                    // 502\n      return doc._id;                                                                                                 // 503\n    }                                                                                                                 // 504\n                                                                                                                      //\n    // XXX what is this for??                                                                                         //\n    // It's some iteraction between the callback to _callMutatorMethod and                                            //\n    // the return value conversion                                                                                    //\n    doc._id = result;                                                                                                 // 509\n                                                                                                                      //\n    return result;                                                                                                    // 511\n  };                                                                                                                  // 512\n                                                                                                                      //\n  var wrappedCallback = wrapCallback(callback, chooseReturnValueFromCollectionResult);                                // 514\n                                                                                                                      //\n  if (this._isRemoteCollection()) {                                                                                   // 517\n    var result = this._callMutatorMethod(\"insert\", [doc], wrappedCallback);                                           // 518\n    return chooseReturnValueFromCollectionResult(result);                                                             // 519\n  }                                                                                                                   // 520\n                                                                                                                      //\n  // it's my collection.  descend into the collection object                                                          //\n  // and propagate any exception.                                                                                     //\n  try {                                                                                                               // 524\n    // If the user provided a callback and the collection implements this                                             //\n    // operation asynchronously, then queryRet will be undefined, and the                                             //\n    // result will be returned through the callback instead.                                                          //\n    var _result = this._collection.insert(doc, wrappedCallback);                                                      // 528\n    return chooseReturnValueFromCollectionResult(_result);                                                            // 529\n  } catch (e) {                                                                                                       // 530\n    if (callback) {                                                                                                   // 531\n      callback(e);                                                                                                    // 532\n      return null;                                                                                                    // 533\n    }                                                                                                                 // 534\n    throw e;                                                                                                          // 535\n  }                                                                                                                   // 536\n};                                                                                                                    // 537\n                                                                                                                      //\n/**                                                                                                                   //\n * @summary Modify one or more documents in the collection. Returns the number of matched documents.                  //\n * @locus Anywhere                                                                                                    //\n * @method update                                                                                                     //\n * @memberOf Mongo.Collection                                                                                         //\n * @instance                                                                                                          //\n * @param {MongoSelector} selector Specifies which documents to modify                                                //\n * @param {MongoModifier} modifier Specifies how to modify the documents                                              //\n * @param {Object} [options]                                                                                          //\n * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n * @param {Boolean} options.upsert True to insert a document if no matching documents are found.                      //\n * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.\n */                                                                                                                   //\nMongo.Collection.prototype.update = function update(selector, modifier) {                                             // 552\n  for (var _len = arguments.length, optionsAndCallback = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    optionsAndCallback[_key - 2] = arguments[_key];                                                                   // 552\n  }                                                                                                                   // 552\n                                                                                                                      //\n  var callback = popCallbackFromArgs(optionsAndCallback);                                                             // 553\n                                                                                                                      //\n  selector = Mongo.Collection._rewriteSelector(selector);                                                             // 555\n                                                                                                                      //\n  // We've already popped off the callback, so we are left with an array                                              //\n  // of one or zero items                                                                                             //\n  var options = _.clone(optionsAndCallback[0]) || {};                                                                 // 559\n  if (options && options.upsert) {                                                                                    // 560\n    // set `insertedId` if absent.  `insertedId` is a Meteor extension.                                               //\n    if (options.insertedId) {                                                                                         // 562\n      if (!(typeof options.insertedId === 'string' || options.insertedId instanceof Mongo.ObjectID)) throw new Error(\"insertedId must be string or ObjectID\");\n    } else if (!selector._id) {                                                                                       // 566\n      options.insertedId = this._makeNewID();                                                                         // 567\n    }                                                                                                                 // 568\n  }                                                                                                                   // 569\n                                                                                                                      //\n  var wrappedCallback = wrapCallback(callback);                                                                       // 571\n                                                                                                                      //\n  if (this._isRemoteCollection()) {                                                                                   // 573\n    var args = [selector, modifier, options];                                                                         // 574\n                                                                                                                      //\n    return this._callMutatorMethod(\"update\", args, wrappedCallback);                                                  // 580\n  }                                                                                                                   // 581\n                                                                                                                      //\n  // it's my collection.  descend into the collection object                                                          //\n  // and propagate any exception.                                                                                     //\n  try {                                                                                                               // 585\n    // If the user provided a callback and the collection implements this                                             //\n    // operation asynchronously, then queryRet will be undefined, and the                                             //\n    // result will be returned through the callback instead.                                                          //\n    return this._collection.update(selector, modifier, options, wrappedCallback);                                     // 589\n  } catch (e) {                                                                                                       // 591\n    if (callback) {                                                                                                   // 592\n      callback(e);                                                                                                    // 593\n      return null;                                                                                                    // 594\n    }                                                                                                                 // 595\n    throw e;                                                                                                          // 596\n  }                                                                                                                   // 597\n};                                                                                                                    // 598\n                                                                                                                      //\n/**                                                                                                                   //\n * @summary Remove documents from the collection                                                                      //\n * @locus Anywhere                                                                                                    //\n * @method remove                                                                                                     //\n * @memberOf Mongo.Collection                                                                                         //\n * @instance                                                                                                          //\n * @param {MongoSelector} selector Specifies which documents to remove                                                //\n * @param {Function} [callback] Optional.  If present, called with an error object as its argument.                   //\n */                                                                                                                   //\nMongo.Collection.prototype.remove = function remove(selector, callback) {                                             // 609\n  selector = Mongo.Collection._rewriteSelector(selector);                                                             // 610\n                                                                                                                      //\n  var wrappedCallback = wrapCallback(callback);                                                                       // 612\n                                                                                                                      //\n  if (this._isRemoteCollection()) {                                                                                   // 614\n    return this._callMutatorMethod(\"remove\", [selector], wrappedCallback);                                            // 615\n  }                                                                                                                   // 616\n                                                                                                                      //\n  // it's my collection.  descend into the collection object                                                          //\n  // and propagate any exception.                                                                                     //\n  try {                                                                                                               // 620\n    // If the user provided a callback and the collection implements this                                             //\n    // operation asynchronously, then queryRet will be undefined, and the                                             //\n    // result will be returned through the callback instead.                                                          //\n    return this._collection.remove(selector, wrappedCallback);                                                        // 624\n  } catch (e) {                                                                                                       // 625\n    if (callback) {                                                                                                   // 626\n      callback(e);                                                                                                    // 627\n      return null;                                                                                                    // 628\n    }                                                                                                                 // 629\n    throw e;                                                                                                          // 630\n  }                                                                                                                   // 631\n};                                                                                                                    // 632\n                                                                                                                      //\n// Determine if this collection is simply a minimongo representation of a real                                        //\n// database on another server                                                                                         //\nMongo.Collection.prototype._isRemoteCollection = function _isRemoteCollection() {                                     // 636\n  // XXX see #MeteorServerNull                                                                                        //\n  return this._connection && this._connection !== Meteor.server;                                                      // 638\n};                                                                                                                    // 639\n                                                                                                                      //\n// Convert the callback to not return a result if there is an error                                                   //\nfunction wrapCallback(callback, convertResult) {                                                                      // 642\n  if (!callback) {                                                                                                    // 643\n    return;                                                                                                           // 644\n  }                                                                                                                   // 645\n                                                                                                                      //\n  // If no convert function was passed in, just use a \"blank function\"                                                //\n  convertResult = convertResult || _.identity;                                                                        // 648\n                                                                                                                      //\n  return function (error, result) {                                                                                   // 650\n    callback(error, !error && convertResult(result));                                                                 // 651\n  };                                                                                                                  // 652\n}                                                                                                                     // 653\n                                                                                                                      //\n/**                                                                                                                   //\n * @summary Modify one or more documents in the collection, or insert one if no matching documents were found. Returns an object with keys `numberAffected` (the number of documents modified)  and `insertedId` (the unique _id of the document that was inserted, if any).\n * @locus Anywhere                                                                                                    //\n * @param {MongoSelector} selector Specifies which documents to modify                                                //\n * @param {MongoModifier} modifier Specifies how to modify the documents                                              //\n * @param {Object} [options]                                                                                          //\n * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.\n */                                                                                                                   //\nMongo.Collection.prototype.upsert = function upsert(selector, modifier, options, callback) {                          // 664\n  if (!callback && typeof options === \"function\") {                                                                   // 666\n    callback = options;                                                                                               // 667\n    options = {};                                                                                                     // 668\n  }                                                                                                                   // 669\n                                                                                                                      //\n  var updateOptions = _.extend({}, options, {                                                                         // 671\n    _returnObject: true,                                                                                              // 672\n    upsert: true                                                                                                      // 673\n  });                                                                                                                 // 671\n                                                                                                                      //\n  return this.update(selector, modifier, updateOptions, callback);                                                    // 676\n};                                                                                                                    // 677\n                                                                                                                      //\n// We'll actually design an index API later. For now, we just pass through to                                         //\n// Mongo's, but make it synchronous.                                                                                  //\nMongo.Collection.prototype._ensureIndex = function (index, options) {                                                 // 681\n  var self = this;                                                                                                    // 682\n  if (!self._collection._ensureIndex) throw new Error(\"Can only call _ensureIndex on server collections\");            // 683\n  self._collection._ensureIndex(index, options);                                                                      // 685\n};                                                                                                                    // 686\nMongo.Collection.prototype._dropIndex = function (index) {                                                            // 687\n  var self = this;                                                                                                    // 688\n  if (!self._collection._dropIndex) throw new Error(\"Can only call _dropIndex on server collections\");                // 689\n  self._collection._dropIndex(index);                                                                                 // 691\n};                                                                                                                    // 692\nMongo.Collection.prototype._dropCollection = function () {                                                            // 693\n  var self = this;                                                                                                    // 694\n  if (!self._collection.dropCollection) throw new Error(\"Can only call _dropCollection on server collections\");       // 695\n  self._collection.dropCollection();                                                                                  // 697\n};                                                                                                                    // 698\nMongo.Collection.prototype._createCappedCollection = function (byteSize, maxDocuments) {                              // 699\n  var self = this;                                                                                                    // 700\n  if (!self._collection._createCappedCollection) throw new Error(\"Can only call _createCappedCollection on server collections\");\n  self._collection._createCappedCollection(byteSize, maxDocuments);                                                   // 703\n};                                                                                                                    // 704\n                                                                                                                      //\n/**                                                                                                                   //\n * @summary Returns the [`Collection`](http://mongodb.github.io/node-mongodb-native/1.4/api-generated/collection.html) object corresponding to this collection from the [npm `mongodb` driver module](https://www.npmjs.com/package/mongodb) which is wrapped by `Mongo.Collection`.\n * @locus Server                                                                                                      //\n */                                                                                                                   //\nMongo.Collection.prototype.rawCollection = function () {                                                              // 710\n  var self = this;                                                                                                    // 711\n  if (!self._collection.rawCollection) {                                                                              // 712\n    throw new Error(\"Can only call rawCollection on server collections\");                                             // 713\n  }                                                                                                                   // 714\n  return self._collection.rawCollection();                                                                            // 715\n};                                                                                                                    // 716\n                                                                                                                      //\n/**                                                                                                                   //\n * @summary Returns the [`Db`](http://mongodb.github.io/node-mongodb-native/1.4/api-generated/db.html) object corresponding to this collection's database connection from the [npm `mongodb` driver module](https://www.npmjs.com/package/mongodb) which is wrapped by `Mongo.Collection`.\n * @locus Server                                                                                                      //\n */                                                                                                                   //\nMongo.Collection.prototype.rawDatabase = function () {                                                                // 722\n  var self = this;                                                                                                    // 723\n  if (!(self._driver.mongo && self._driver.mongo.db)) {                                                               // 724\n    throw new Error(\"Can only call rawDatabase on server collections\");                                               // 725\n  }                                                                                                                   // 726\n  return self._driver.mongo.db;                                                                                       // 727\n};                                                                                                                    // 728\n                                                                                                                      //\n/**                                                                                                                   //\n * @summary Create a Mongo-style `ObjectID`.  If you don't specify a `hexString`, the `ObjectID` will generated randomly (not using MongoDB's ID construction rules).\n * @locus Anywhere                                                                                                    //\n * @class                                                                                                             //\n * @param {String} [hexString] Optional.  The 24-character hexadecimal contents of the ObjectID to create             //\n */                                                                                                                   //\nMongo.ObjectID = MongoID.ObjectID;                                                                                    // 737\n                                                                                                                      //\n/**                                                                                                                   //\n * @summary To create a cursor, use find. To access the documents in a cursor, use forEach, map, or fetch.            //\n * @class                                                                                                             //\n * @instanceName cursor                                                                                               //\n */                                                                                                                   //\nMongo.Cursor = LocalCollection.Cursor;                                                                                // 744\n                                                                                                                      //\n/**                                                                                                                   //\n * @deprecated in 0.9.1                                                                                               //\n */                                                                                                                   //\nMongo.Collection.Cursor = Mongo.Cursor;                                                                               // 749\n                                                                                                                      //\n/**                                                                                                                   //\n * @deprecated in 0.9.1                                                                                               //\n */                                                                                                                   //\nMongo.Collection.ObjectID = Mongo.ObjectID;                                                                           // 754\n                                                                                                                      //\n/**                                                                                                                   //\n * @deprecated in 0.9.1                                                                                               //\n */                                                                                                                   //\nMeteor.Collection = Mongo.Collection;                                                                                 // 759\n                                                                                                                      //\n// Allow deny stuff is now in the allow-deny package                                                                  //\n_.extend(Meteor.Collection.prototype, AllowDeny.CollectionPrototype);                                                 // 762\n                                                                                                                      //\nfunction popCallbackFromArgs(args) {                                                                                  // 764\n  // Pull off any callback (or perhaps a 'callback' variable that was passed                                          //\n  // in undefined, like how 'upsert' does it).                                                                        //\n  if (args.length && (args[args.length - 1] === undefined || args[args.length - 1] instanceof Function)) {            // 767\n    return args.pop();                                                                                                // 770\n  }                                                                                                                   // 771\n}                                                                                                                     // 772\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"connection_options.js\":function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/mongo/connection_options.js                                                                               //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n/**                                                                                                                   //\n * @summary Allows for user specified connection options                                                              //\n * @example http://mongodb.github.io/node-mongodb-native/2.1/reference/connecting/connection-settings/                //\n * @locus Server                                                                                                      //\n * @param {Object} options User specified Mongo connection options                                                    //\n */                                                                                                                   //\nMongo.setConnectionOptions = function setConnectionOptions(options) {                                                 // 7\n  check(options, Object);                                                                                             // 8\n  Mongo._connectionOptions = options;                                                                                 // 9\n};                                                                                                                    // 10\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\"extensions\":[\".js\",\".json\"]});\nrequire(\"./node_modules/meteor/mongo/mongo_driver.js\");\nrequire(\"./node_modules/meteor/mongo/oplog_tailing.js\");\nrequire(\"./node_modules/meteor/mongo/observe_multiplex.js\");\nrequire(\"./node_modules/meteor/mongo/doc_fetcher.js\");\nrequire(\"./node_modules/meteor/mongo/polling_observe_driver.js\");\nrequire(\"./node_modules/meteor/mongo/oplog_observe_driver.js\");\nrequire(\"./node_modules/meteor/mongo/local_collection_driver.js\");\nrequire(\"./node_modules/meteor/mongo/remote_collection_driver.js\");\nrequire(\"./node_modules/meteor/mongo/collection.js\");\nrequire(\"./node_modules/meteor/mongo/connection_options.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package.mongo = {}, {\n  MongoInternals: MongoInternals,\n  MongoTest: MongoTest,\n  Mongo: Mongo\n});\n\n})();\n\n//# sourceMappingURL=mongo.js.map\n"]},"hash":"68e12c25c98aeefea2f531528ca618c5c408f628"}

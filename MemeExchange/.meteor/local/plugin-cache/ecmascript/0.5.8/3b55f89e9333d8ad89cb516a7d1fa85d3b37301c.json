{"metadata":{"usedHelpers":["typeof"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/spacebars-compiler.js","filenameRelative":"/bundle/programs/server/packages/spacebars-compiler.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/spacebars-compiler.js.map","sourceFileName":"/bundle/programs/server/packages/spacebars-compiler.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"spacebars-compiler"},"ignored":false,"code":"var _typeof;module.import('babel-runtime/helpers/typeof',{\"default\":function(v){_typeof=v}});\n(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var _ = Package.underscore._;\n  var HTML = Package.htmljs.HTML;\n  var HTMLTools = Package['html-tools'].HTMLTools;\n  var BlazeTools = Package['blaze-tools'].BlazeTools;\n\n  /* Package-scope variables */\n  var SpacebarsCompiler, TemplateTag, ReactComponentSiblingForbidder;\n\n  (function () {\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                     //\n    // packages/spacebars-compiler/templatetag.js                                                          //\n    //                                                                                                     //\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    SpacebarsCompiler = {};\n\n    // A TemplateTag is the result of parsing a single `{{...}}` tag.\n    //\n    // The `.type` of a TemplateTag is one of:\n    //\n    // - `\"DOUBLE\"` - `{{foo}}`\n    // - `\"TRIPLE\"` - `{{{foo}}}`\n    // - `\"EXPR\"` - `(foo)`\n    // - `\"COMMENT\"` - `{{! foo}}`\n    // - `\"BLOCKCOMMENT\" - `{{!-- foo--}}`\n    // - `\"INCLUSION\"` - `{{> foo}}`\n    // - `\"BLOCKOPEN\"` - `{{#foo}}`\n    // - `\"BLOCKCLOSE\"` - `{{/foo}}`\n    // - `\"ELSE\"` - `{{else}}`\n    // - `\"ESCAPE\"` - `{{|`, `{{{|`, `{{{{|` and so on\n    //\n    // Besides `type`, the mandatory properties of a TemplateTag are:\n    //\n    // - `path` - An array of one or more strings.  The path of `{{foo.bar}}`\n    //   is `[\"foo\", \"bar\"]`.  Applies to DOUBLE, TRIPLE, INCLUSION, BLOCKOPEN,\n    //   and BLOCKCLOSE.\n    //\n    // - `args` - An array of zero or more argument specs.  An argument spec\n    //   is a two or three element array, consisting of a type, value, and\n    //   optional keyword name.  For example, the `args` of `{{foo \"bar\" x=3}}`\n    //   are `[[\"STRING\", \"bar\"], [\"NUMBER\", 3, \"x\"]]`.  Applies to DOUBLE,\n    //   TRIPLE, INCLUSION, and BLOCKOPEN.\n    //\n    // - `value` - A string of the comment's text. Applies to COMMENT and\n    //   BLOCKCOMMENT.\n    //\n    // These additional are typically set during parsing:\n    //\n    // - `position` - The HTMLTools.TEMPLATE_TAG_POSITION specifying at what sort\n    //   of site the TemplateTag was encountered (e.g. at element level or as\n    //   part of an attribute value). Its absence implies\n    //   TEMPLATE_TAG_POSITION.ELEMENT.\n    //\n    // - `content` and `elseContent` - When a BLOCKOPEN tag's contents are\n    //   parsed, they are put here.  `elseContent` will only be present if\n    //   an `{{else}}` was found.\n\n    var TEMPLATE_TAG_POSITION = HTMLTools.TEMPLATE_TAG_POSITION;\n\n    TemplateTag = SpacebarsCompiler.TemplateTag = function () {\n      HTMLTools.TemplateTag.apply(this, arguments);\n    };\n    TemplateTag.prototype = new HTMLTools.TemplateTag();\n    TemplateTag.prototype.constructorName = 'SpacebarsCompiler.TemplateTag';\n\n    var makeStacheTagStartRegex = function makeStacheTagStartRegex(r) {\n      return new RegExp(r.source + /(?![{>!#/])/.source, r.ignoreCase ? 'i' : '');\n    };\n\n    // \"starts\" regexes are used to see what type of template\n    // tag the parser is looking at.  They must match a non-empty\n    // result, but not the interesting part of the tag.\n    var starts = {\n      ESCAPE: /^\\{\\{(?=\\{*\\|)/,\n      ELSE: makeStacheTagStartRegex(/^\\{\\{\\s*else(?=[\\s}])/i),\n      DOUBLE: makeStacheTagStartRegex(/^\\{\\{\\s*(?!\\s)/),\n      TRIPLE: makeStacheTagStartRegex(/^\\{\\{\\{\\s*(?!\\s)/),\n      BLOCKCOMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!--/),\n      COMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!/),\n      INCLUSION: makeStacheTagStartRegex(/^\\{\\{\\s*>\\s*(?!\\s)/),\n      BLOCKOPEN: makeStacheTagStartRegex(/^\\{\\{\\s*#\\s*(?!\\s)/),\n      BLOCKCLOSE: makeStacheTagStartRegex(/^\\{\\{\\s*\\/\\s*(?!\\s)/)\n    };\n\n    var ends = {\n      DOUBLE: /^\\s*\\}\\}/,\n      TRIPLE: /^\\s*\\}\\}\\}/,\n      EXPR: /^\\s*\\)/\n    };\n\n    var endsString = {\n      DOUBLE: '}}',\n      TRIPLE: '}}}',\n      EXPR: ')'\n    };\n\n    // Parse a tag from the provided scanner or string.  If the input\n    // doesn't start with `{{`, returns null.  Otherwise, either succeeds\n    // and returns a SpacebarsCompiler.TemplateTag, or throws an error (using\n    // `scanner.fatal` if a scanner is provided).\n    TemplateTag.parse = function (scannerOrString) {\n      var scanner = scannerOrString;\n      if (typeof scanner === 'string') scanner = new HTMLTools.Scanner(scannerOrString);\n\n      if (!(scanner.peek() === '{' && scanner.rest().slice(0, 2) === '{{')) return null;\n\n      var run = function run(regex) {\n        // regex is assumed to start with `^`\n        var result = regex.exec(scanner.rest());\n        if (!result) return null;\n        var ret = result[0];\n        scanner.pos += ret.length;\n        return ret;\n      };\n\n      var advance = function advance(amount) {\n        scanner.pos += amount;\n      };\n\n      var scanIdentifier = function scanIdentifier(isFirstInPath) {\n        var id = BlazeTools.parseExtendedIdentifierName(scanner);\n        if (!id) {\n          expected('IDENTIFIER');\n        }\n        if (isFirstInPath && (id === 'null' || id === 'true' || id === 'false')) scanner.fatal(\"Can't use null, true, or false, as an identifier at start of path\");\n\n        return id;\n      };\n\n      var scanPath = function scanPath() {\n        var segments = [];\n\n        // handle initial `.`, `..`, `./`, `../`, `../..`, `../../`, etc\n        var dots;\n        if (dots = run(/^[\\.\\/]+/)) {\n          var ancestorStr = '.'; // eg `../../..` maps to `....`\n          var endsWithSlash = /\\/$/.test(dots);\n\n          if (endsWithSlash) dots = dots.slice(0, -1);\n\n          _.each(dots.split('/'), function (dotClause, index) {\n            if (index === 0) {\n              if (dotClause !== '.' && dotClause !== '..') expected(\"`.`, `..`, `./` or `../`\");\n            } else {\n              if (dotClause !== '..') expected(\"`..` or `../`\");\n            }\n\n            if (dotClause === '..') ancestorStr += '.';\n          });\n\n          segments.push(ancestorStr);\n\n          if (!endsWithSlash) return segments;\n        }\n\n        while (true) {\n          // scan a path segment\n\n          if (run(/^\\[/)) {\n            var seg = run(/^[\\s\\S]*?\\]/);\n            if (!seg) error(\"Unterminated path segment\");\n            seg = seg.slice(0, -1);\n            if (!seg && !segments.length) error(\"Path can't start with empty string\");\n            segments.push(seg);\n          } else {\n            var id = scanIdentifier(!segments.length);\n            if (id === 'this') {\n              if (!segments.length) {\n                // initial `this`\n                segments.push('.');\n              } else {\n                error(\"Can only use `this` at the beginning of a path.\\nInstead of `foo.this` or `../this`, just write `foo` or `..`.\");\n              }\n            } else {\n              segments.push(id);\n            }\n          }\n\n          var sep = run(/^[\\.\\/]/);\n          if (!sep) break;\n        }\n\n        return segments;\n      };\n\n      // scan the keyword portion of a keyword argument\n      // (the \"foo\" portion in \"foo=bar\").\n      // Result is either the keyword matched, or null\n      // if we're not at a keyword argument position.\n      var scanArgKeyword = function scanArgKeyword() {\n        var match = /^([^\\{\\}\\(\\)\\>#=\\s\"'\\[\\]]+)\\s*=\\s*/.exec(scanner.rest());\n        if (match) {\n          scanner.pos += match[0].length;\n          return match[1];\n        } else {\n          return null;\n        }\n      };\n\n      // scan an argument; succeeds or errors.\n      // Result is an array of two or three items:\n      // type , value, and (indicating a keyword argument)\n      // keyword name.\n      var scanArg = function scanArg() {\n        var keyword = scanArgKeyword(); // null if not parsing a kwarg\n        var value = scanArgValue();\n        return keyword ? value.concat(keyword) : value;\n      };\n\n      // scan an argument value (for keyword or positional arguments);\n      // succeeds or errors.  Result is an array of type, value.\n      var scanArgValue = function scanArgValue() {\n        var startPos = scanner.pos;\n        var result;\n        if (result = BlazeTools.parseNumber(scanner)) {\n          return ['NUMBER', result.value];\n        } else if (result = BlazeTools.parseStringLiteral(scanner)) {\n          return ['STRING', result.value];\n        } else if (/^[\\.\\[]/.test(scanner.peek())) {\n          return ['PATH', scanPath()];\n        } else if (run(/^\\(/)) {\n          return ['EXPR', scanExpr('EXPR')];\n        } else if (result = BlazeTools.parseExtendedIdentifierName(scanner)) {\n          var id = result;\n          if (id === 'null') {\n            return ['NULL', null];\n          } else if (id === 'true' || id === 'false') {\n            return ['BOOLEAN', id === 'true'];\n          } else {\n            scanner.pos = startPos; // unconsume `id`\n            return ['PATH', scanPath()];\n          }\n        } else {\n          expected('identifier, number, string, boolean, null, or a sub expression enclosed in \"(\", \")\"');\n        }\n      };\n\n      var scanExpr = function scanExpr(type) {\n        var endType = type;\n        if (type === 'INCLUSION' || type === 'BLOCKOPEN') endType = 'DOUBLE';\n\n        var tag = new TemplateTag();\n        tag.type = type;\n        tag.path = scanPath();\n        tag.args = [];\n        var foundKwArg = false;\n        while (true) {\n          run(/^\\s*/);\n          if (run(ends[endType])) break;else if (/^[})]/.test(scanner.peek())) {\n            expected('`' + endsString[endType] + '`');\n          }\n          var newArg = scanArg();\n          if (newArg.length === 3) {\n            foundKwArg = true;\n          } else {\n            if (foundKwArg) error(\"Can't have a non-keyword argument after a keyword argument\");\n          }\n          tag.args.push(newArg);\n\n          // expect a whitespace or a closing ')' or '}'\n          if (run(/^(?=[\\s})])/) !== '') expected('space');\n        }\n\n        return tag;\n      };\n\n      var type;\n\n      var error = function error(msg) {\n        scanner.fatal(msg);\n      };\n\n      var expected = function expected(what) {\n        error('Expected ' + what);\n      };\n\n      // must do ESCAPE first, immediately followed by ELSE\n      // order of others doesn't matter\n      if (run(starts.ESCAPE)) type = 'ESCAPE';else if (run(starts.ELSE)) type = 'ELSE';else if (run(starts.DOUBLE)) type = 'DOUBLE';else if (run(starts.TRIPLE)) type = 'TRIPLE';else if (run(starts.BLOCKCOMMENT)) type = 'BLOCKCOMMENT';else if (run(starts.COMMENT)) type = 'COMMENT';else if (run(starts.INCLUSION)) type = 'INCLUSION';else if (run(starts.BLOCKOPEN)) type = 'BLOCKOPEN';else if (run(starts.BLOCKCLOSE)) type = 'BLOCKCLOSE';else error('Unknown stache tag');\n\n      var tag = new TemplateTag();\n      tag.type = type;\n\n      if (type === 'BLOCKCOMMENT') {\n        var result = run(/^[\\s\\S]*?--\\s*?\\}\\}/);\n        if (!result) error(\"Unclosed block comment\");\n        tag.value = result.slice(0, result.lastIndexOf('--'));\n      } else if (type === 'COMMENT') {\n        var result = run(/^[\\s\\S]*?\\}\\}/);\n        if (!result) error(\"Unclosed comment\");\n        tag.value = result.slice(0, -2);\n      } else if (type === 'BLOCKCLOSE') {\n        tag.path = scanPath();\n        if (!run(ends.DOUBLE)) expected('`}}`');\n      } else if (type === 'ELSE') {\n        if (!run(ends.DOUBLE)) expected('`}}`');\n      } else if (type === 'ESCAPE') {\n        var result = run(/^\\{*\\|/);\n        tag.value = '{{' + result.slice(0, -1);\n      } else {\n        // DOUBLE, TRIPLE, BLOCKOPEN, INCLUSION\n        tag = scanExpr(type);\n      }\n\n      return tag;\n    };\n\n    // Returns a SpacebarsCompiler.TemplateTag parsed from `scanner`, leaving scanner\n    // at its original position.\n    //\n    // An error will still be thrown if there is not a valid template tag at\n    // the current position.\n    TemplateTag.peek = function (scanner) {\n      var startPos = scanner.pos;\n      var result = TemplateTag.parse(scanner);\n      scanner.pos = startPos;\n      return result;\n    };\n\n    // Like `TemplateTag.parse`, but in the case of blocks, parse the complete\n    // `{{#foo}}...{{/foo}}` with `content` and possible `elseContent`, rather\n    // than just the BLOCKOPEN tag.\n    //\n    // In addition:\n    //\n    // - Throws an error if `{{else}}` or `{{/foo}}` tag is encountered.\n    //\n    // - Returns `null` for a COMMENT.  (This case is distinguishable from\n    //   parsing no tag by the fact that the scanner is advanced.)\n    //\n    // - Takes an HTMLTools.TEMPLATE_TAG_POSITION `position` and sets it as the\n    //   TemplateTag's `.position` property.\n    //\n    // - Validates the tag's well-formedness and legality at in its position.\n    TemplateTag.parseCompleteTag = function (scannerOrString, position) {\n      var scanner = scannerOrString;\n      if (typeof scanner === 'string') scanner = new HTMLTools.Scanner(scannerOrString);\n\n      var startPos = scanner.pos; // for error messages\n      var result = TemplateTag.parse(scannerOrString);\n      if (!result) return result;\n\n      if (result.type === 'BLOCKCOMMENT') return null;\n\n      if (result.type === 'COMMENT') return null;\n\n      if (result.type === 'ELSE') scanner.fatal(\"Unexpected {{else}}\");\n\n      if (result.type === 'BLOCKCLOSE') scanner.fatal(\"Unexpected closing template tag\");\n\n      position = position || TEMPLATE_TAG_POSITION.ELEMENT;\n      if (position !== TEMPLATE_TAG_POSITION.ELEMENT) result.position = position;\n\n      if (result.type === 'BLOCKOPEN') {\n        // parse block contents\n\n        // Construct a string version of `.path` for comparing start and\n        // end tags.  For example, `foo/[0]` was parsed into `[\"foo\", \"0\"]`\n        // and now becomes `foo,0`.  This form may also show up in error\n        // messages.\n        var blockName = result.path.join(',');\n\n        var textMode = null;\n        if (blockName === 'markdown' || position === TEMPLATE_TAG_POSITION.IN_RAWTEXT) {\n          textMode = HTML.TEXTMODE.STRING;\n        } else if (position === TEMPLATE_TAG_POSITION.IN_RCDATA || position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n          textMode = HTML.TEXTMODE.RCDATA;\n        }\n        var parserOptions = {\n          getTemplateTag: TemplateTag.parseCompleteTag,\n          shouldStop: isAtBlockCloseOrElse,\n          textMode: textMode\n        };\n        result.content = HTMLTools.parseFragment(scanner, parserOptions);\n\n        if (scanner.rest().slice(0, 2) !== '{{') scanner.fatal(\"Expected {{else}} or block close for \" + blockName);\n\n        var lastPos = scanner.pos; // save for error messages\n        var tmplTag = TemplateTag.parse(scanner); // {{else}} or {{/foo}}\n\n        if (tmplTag.type === 'ELSE') {\n          // parse {{else}} and content up to close tag\n          result.elseContent = HTMLTools.parseFragment(scanner, parserOptions);\n\n          if (scanner.rest().slice(0, 2) !== '{{') scanner.fatal(\"Expected block close for \" + blockName);\n\n          lastPos = scanner.pos;\n          tmplTag = TemplateTag.parse(scanner);\n        }\n\n        if (tmplTag.type === 'BLOCKCLOSE') {\n          var blockName2 = tmplTag.path.join(',');\n          if (blockName !== blockName2) {\n            scanner.pos = lastPos;\n            scanner.fatal('Expected tag to close ' + blockName + ', found ' + blockName2);\n          }\n        } else {\n          scanner.pos = lastPos;\n          scanner.fatal('Expected tag to close ' + blockName + ', found ' + tmplTag.type);\n        }\n      }\n\n      var finalPos = scanner.pos;\n      scanner.pos = startPos;\n      validateTag(result, scanner);\n      scanner.pos = finalPos;\n\n      return result;\n    };\n\n    var isAtBlockCloseOrElse = function isAtBlockCloseOrElse(scanner) {\n      // Detect `{{else}}` or `{{/foo}}`.\n      //\n      // We do as much work ourselves before deferring to `TemplateTag.peek`,\n      // for efficiency (we're called for every input token) and to be\n      // less obtrusive, because `TemplateTag.peek` will throw an error if it\n      // sees `{{` followed by a malformed tag.\n      var rest, type;\n      return scanner.peek() === '{' && (rest = scanner.rest()).slice(0, 2) === '{{' && /^\\{\\{\\s*(\\/|else\\b)/.test(rest) && (type = TemplateTag.peek(scanner).type) && (type === 'BLOCKCLOSE' || type === 'ELSE');\n    };\n\n    // Validate that `templateTag` is correctly formed and legal for its\n    // HTML position.  Use `scanner` to report errors. On success, does\n    // nothing.\n    var validateTag = function validateTag(ttag, scanner) {\n\n      if (ttag.type === 'INCLUSION' || ttag.type === 'BLOCKOPEN') {\n        var args = ttag.args;\n        if (ttag.path[0] === 'each' && args[1] && args[1][0] === 'PATH' && args[1][1][0] === 'in') {\n          // For slightly better error messages, we detect the each-in case\n          // here in order not to complain if the user writes `{{#each 3 in x}}`\n          // that \"3 is not a function\"\n        } else {\n            if (args.length > 1 && args[0].length === 2 && args[0][0] !== 'PATH') {\n              // we have a positional argument that is not a PATH followed by\n              // other arguments\n              scanner.fatal(\"First argument must be a function, to be called on \" + \"the rest of the arguments; found \" + args[0][0]);\n            }\n          }\n      }\n\n      var position = ttag.position || TEMPLATE_TAG_POSITION.ELEMENT;\n      if (position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n        if (ttag.type === 'DOUBLE' || ttag.type === 'ESCAPE') {\n          return;\n        } else if (ttag.type === 'BLOCKOPEN') {\n          var path = ttag.path;\n          var path0 = path[0];\n          if (!(path.length === 1 && (path0 === 'if' || path0 === 'unless' || path0 === 'with' || path0 === 'each'))) {\n            scanner.fatal(\"Custom block helpers are not allowed in an HTML attribute, only built-in ones like #each and #if\");\n          }\n        } else {\n          scanner.fatal(ttag.type + \" template tag is not allowed in an HTML attribute\");\n        }\n      } else if (position === TEMPLATE_TAG_POSITION.IN_START_TAG) {\n        if (!(ttag.type === 'DOUBLE')) {\n          scanner.fatal(\"Reactive HTML attributes must either have a constant name or consist of a single {{helper}} providing a dictionary of names and values.  A template tag of type \" + ttag.type + \" is not allowed here.\");\n        }\n        if (scanner.peek() === '=') {\n          scanner.fatal(\"Template tags are not allowed in attribute names, only in attribute values or in the form of a single {{helper}} that evaluates to a dictionary of name=value pairs.\");\n        }\n      }\n    };\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  (function () {\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                     //\n    // packages/spacebars-compiler/optimizer.js                                                            //\n    //                                                                                                     //\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // Optimize parts of an HTMLjs tree into raw HTML strings when they don't\n    // contain template tags.\n\n    var constant = function constant(value) {\n      return function () {\n        return value;\n      };\n    };\n\n    var OPTIMIZABLE = {\n      NONE: 0,\n      PARTS: 1,\n      FULL: 2\n    };\n\n    // We can only turn content into an HTML string if it contains no template\n    // tags and no \"tricky\" HTML tags.  If we can optimize the entire content\n    // into a string, we return OPTIMIZABLE.FULL.  If the we are given an\n    // unoptimizable node, we return OPTIMIZABLE.NONE.  If we are given a tree\n    // that contains an unoptimizable node somewhere, we return OPTIMIZABLE.PARTS.\n    //\n    // For example, we always create SVG elements programmatically, since SVG\n    // doesn't have innerHTML.  If we are given an SVG element, we return NONE.\n    // However, if we are given a big tree that contains SVG somewhere, we\n    // return PARTS so that the optimizer can descend into the tree and optimize\n    // other parts of it.\n    var CanOptimizeVisitor = HTML.Visitor.extend();\n    CanOptimizeVisitor.def({\n      visitNull: constant(OPTIMIZABLE.FULL),\n      visitPrimitive: constant(OPTIMIZABLE.FULL),\n      visitComment: constant(OPTIMIZABLE.FULL),\n      visitCharRef: constant(OPTIMIZABLE.FULL),\n      visitRaw: constant(OPTIMIZABLE.FULL),\n      visitObject: constant(OPTIMIZABLE.NONE),\n      visitFunction: constant(OPTIMIZABLE.NONE),\n      visitArray: function visitArray(x) {\n        for (var i = 0; i < x.length; i++) {\n          if (this.visit(x[i]) !== OPTIMIZABLE.FULL) return OPTIMIZABLE.PARTS;\n        }return OPTIMIZABLE.FULL;\n      },\n      visitTag: function visitTag(tag) {\n        var tagName = tag.tagName;\n        if (tagName === 'textarea') {\n          // optimizing into a TEXTAREA's RCDATA would require being a little\n          // more clever.\n          return OPTIMIZABLE.NONE;\n        } else if (tagName === 'script') {\n          // script tags don't work when rendered from strings\n          return OPTIMIZABLE.NONE;\n        } else if (!(HTML.isKnownElement(tagName) && !HTML.isKnownSVGElement(tagName))) {\n          // foreign elements like SVG can't be stringified for innerHTML.\n          return OPTIMIZABLE.NONE;\n        } else if (tagName === 'table') {\n          // Avoid ever producing HTML containing `<table><tr>...`, because the\n          // browser will insert a TBODY.  If we just `createElement(\"table\")` and\n          // `createElement(\"tr\")`, on the other hand, no TBODY is necessary\n          // (assuming IE 8+).\n          return OPTIMIZABLE.NONE;\n        }\n\n        var children = tag.children;\n        for (var i = 0; i < children.length; i++) {\n          if (this.visit(children[i]) !== OPTIMIZABLE.FULL) return OPTIMIZABLE.PARTS;\n        }if (this.visitAttributes(tag.attrs) !== OPTIMIZABLE.FULL) return OPTIMIZABLE.PARTS;\n\n        return OPTIMIZABLE.FULL;\n      },\n      visitAttributes: function visitAttributes(attrs) {\n        if (attrs) {\n          var isArray = HTML.isArray(attrs);\n          for (var i = 0; i < (isArray ? attrs.length : 1); i++) {\n            var a = isArray ? attrs[i] : attrs;\n            if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== 'object' || a instanceof HTMLTools.TemplateTag) return OPTIMIZABLE.PARTS;\n            for (var k in a) {\n              if (this.visit(a[k]) !== OPTIMIZABLE.FULL) return OPTIMIZABLE.PARTS;\n            }\n          }\n        }\n        return OPTIMIZABLE.FULL;\n      }\n    });\n\n    var getOptimizability = function getOptimizability(content) {\n      return new CanOptimizeVisitor().visit(content);\n    };\n\n    var toRaw = function toRaw(x) {\n      return HTML.Raw(HTML.toHTML(x));\n    };\n\n    var TreeTransformer = HTML.TransformingVisitor.extend();\n    TreeTransformer.def({\n      visitAttributes: function visitAttributes(attrs /*, ...*/) {\n        // pass template tags through by default\n        if (attrs instanceof HTMLTools.TemplateTag) return attrs;\n\n        return HTML.TransformingVisitor.prototype.visitAttributes.apply(this, arguments);\n      }\n    });\n\n    // Replace parts of the HTMLjs tree that have no template tags (or\n    // tricky HTML tags) with HTML.Raw objects containing raw HTML.\n    var OptimizingVisitor = TreeTransformer.extend();\n    OptimizingVisitor.def({\n      visitNull: toRaw,\n      visitPrimitive: toRaw,\n      visitComment: toRaw,\n      visitCharRef: toRaw,\n      visitArray: function visitArray(array) {\n        var optimizability = getOptimizability(array);\n        if (optimizability === OPTIMIZABLE.FULL) {\n          return toRaw(array);\n        } else if (optimizability === OPTIMIZABLE.PARTS) {\n          return TreeTransformer.prototype.visitArray.call(this, array);\n        } else {\n          return array;\n        }\n      },\n      visitTag: function visitTag(tag) {\n        var optimizability = getOptimizability(tag);\n        if (optimizability === OPTIMIZABLE.FULL) {\n          return toRaw(tag);\n        } else if (optimizability === OPTIMIZABLE.PARTS) {\n          return TreeTransformer.prototype.visitTag.call(this, tag);\n        } else {\n          return tag;\n        }\n      },\n      visitChildren: function visitChildren(children) {\n        // don't optimize the children array into a Raw object!\n        return TreeTransformer.prototype.visitArray.call(this, children);\n      },\n      visitAttributes: function visitAttributes(attrs) {\n        return attrs;\n      }\n    });\n\n    // Combine consecutive HTML.Raws.  Remove empty ones.\n    var RawCompactingVisitor = TreeTransformer.extend();\n    RawCompactingVisitor.def({\n      visitArray: function visitArray(array) {\n        var result = [];\n        for (var i = 0; i < array.length; i++) {\n          var item = array[i];\n          if (item instanceof HTML.Raw && (!item.value || result.length && result[result.length - 1] instanceof HTML.Raw)) {\n            // two cases: item is an empty Raw, or previous item is\n            // a Raw as well.  In the latter case, replace the previous\n            // Raw with a longer one that includes the new Raw.\n            if (item.value) {\n              result[result.length - 1] = HTML.Raw(result[result.length - 1].value + item.value);\n            }\n          } else {\n            result.push(item);\n          }\n        }\n        return result;\n      }\n    });\n\n    // Replace pointless Raws like `HTMl.Raw('foo')` that contain no special\n    // characters with simple strings.\n    var RawReplacingVisitor = TreeTransformer.extend();\n    RawReplacingVisitor.def({\n      visitRaw: function visitRaw(raw) {\n        var html = raw.value;\n        if (html.indexOf('&') < 0 && html.indexOf('<') < 0) {\n          return html;\n        } else {\n          return raw;\n        }\n      }\n    });\n\n    SpacebarsCompiler.optimize = function (tree) {\n      tree = new OptimizingVisitor().visit(tree);\n      tree = new RawCompactingVisitor().visit(tree);\n      tree = new RawReplacingVisitor().visit(tree);\n      return tree;\n    };\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  (function () {\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                     //\n    // packages/spacebars-compiler/react.js                                                                //\n    //                                                                                                     //\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // A visitor to ensure that React components included via the `{{>\n    // React}}` template defined in the react-template-helper package are\n    // the only child in their parent component. Otherwise `React.render`\n    // would eliminate all of their sibling nodes.\n    //\n    // It's a little strange that this logic is in spacebars-compiler if\n    // it's only relevant to a specific package but there's no way to have\n    // a package hook into a build plugin.\n    ReactComponentSiblingForbidder = HTML.Visitor.extend();\n    ReactComponentSiblingForbidder.def({\n      visitArray: function visitArray(array, parentTag) {\n        for (var i = 0; i < array.length; i++) {\n          this.visit(array[i], parentTag);\n        }\n      },\n      visitObject: function visitObject(obj, parentTag) {\n        if (obj.type === \"INCLUSION\" && obj.path.length === 1 && obj.path[0] === \"React\") {\n          if (!parentTag) {\n            throw new Error(\"{{> React}} must be used in a container element\" + (this.sourceName ? \" in \" + this.sourceName : \"\") + \". Learn more at https://github.com/meteor/meteor/wiki/React-components-must-be-the-only-thing-in-their-wrapper-element\");\n          }\n\n          var numSiblings = 0;\n          for (var i = 0; i < parentTag.children.length; i++) {\n            var child = parentTag.children[i];\n            if (child !== obj && !(typeof child === \"string\" && child.match(/^\\s*$/))) {\n              numSiblings++;\n            }\n          }\n\n          if (numSiblings > 0) {\n            throw new Error(\"{{> React}} must be used as the only child in a container element\" + (this.sourceName ? \" in \" + this.sourceName : \"\") + \". Learn more at https://github.com/meteor/meteor/wiki/React-components-must-be-the-only-thing-in-their-wrapper-element\");\n          }\n        }\n      },\n      visitTag: function visitTag(tag) {\n        this.visitArray(tag.children, tag /*parentTag*/);\n      }\n    });\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  (function () {\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                     //\n    // packages/spacebars-compiler/codegen.js                                                              //\n    //                                                                                                     //\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // ============================================================\n    // Code-generation of template tags\n\n    // The `CodeGen` class currently has no instance state, but in theory\n    // it could be useful to track per-function state, like whether we\n    // need to emit `var self = this` or not.\n    var CodeGen = SpacebarsCompiler.CodeGen = function () {};\n\n    var builtInBlockHelpers = SpacebarsCompiler._builtInBlockHelpers = {\n      'if': 'Blaze.If',\n      'unless': 'Blaze.Unless',\n      'with': 'Spacebars.With',\n      'each': 'Blaze.Each',\n      'let': 'Blaze.Let'\n    };\n\n    // Mapping of \"macros\" which, when preceded by `Template.`, expand\n    // to special code rather than following the lookup rules for dotted\n    // symbols.\n    var builtInTemplateMacros = {\n      // `view` is a local variable defined in the generated render\n      // function for the template in which `Template.contentBlock` or\n      // `Template.elseBlock` is invoked.\n      'contentBlock': 'view.templateContentBlock',\n      'elseBlock': 'view.templateElseBlock',\n\n      // Confusingly, this makes `{{> Template.dynamic}}` an alias\n      // for `{{> __dynamic}}`, where \"__dynamic\" is the template that\n      // implements the dynamic template feature.\n      'dynamic': 'Template.__dynamic',\n\n      'subscriptionsReady': 'view.templateInstance().subscriptionsReady()'\n    };\n\n    var additionalReservedNames = [\"body\", \"toString\", \"instance\", \"constructor\", \"toString\", \"toLocaleString\", \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"__defineGetter__\", \"__lookupGetter__\", \"__defineSetter__\", \"__lookupSetter__\", \"__proto__\", \"dynamic\", \"registerHelper\", \"currentData\", \"parentData\"];\n\n    // A \"reserved name\" can't be used as a <template> name.  This\n    // function is used by the template file scanner.\n    //\n    // Note that the runtime imposes additional restrictions, for example\n    // banning the name \"body\" and names of built-in object properties\n    // like \"toString\".\n    SpacebarsCompiler.isReservedName = function (name) {\n      return builtInBlockHelpers.hasOwnProperty(name) || builtInTemplateMacros.hasOwnProperty(name) || _.indexOf(additionalReservedNames, name) > -1;\n    };\n\n    var makeObjectLiteral = function makeObjectLiteral(obj) {\n      var parts = [];\n      for (var k in obj) {\n        parts.push(BlazeTools.toObjectLiteralKey(k) + ': ' + obj[k]);\n      }return '{' + parts.join(', ') + '}';\n    };\n\n    _.extend(CodeGen.prototype, {\n      codeGenTemplateTag: function codeGenTemplateTag(tag) {\n        var self = this;\n        if (tag.position === HTMLTools.TEMPLATE_TAG_POSITION.IN_START_TAG) {\n          // Special dynamic attributes: `<div {{attrs}}>...`\n          // only `tag.type === 'DOUBLE'` allowed (by earlier validation)\n          return BlazeTools.EmitCode('function () { return ' + self.codeGenMustache(tag.path, tag.args, 'attrMustache') + '; }');\n        } else {\n          if (tag.type === 'DOUBLE' || tag.type === 'TRIPLE') {\n            var code = self.codeGenMustache(tag.path, tag.args);\n            if (tag.type === 'TRIPLE') {\n              code = 'Spacebars.makeRaw(' + code + ')';\n            }\n            if (tag.position !== HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n              // Reactive attributes are already wrapped in a function,\n              // and there's no fine-grained reactivity.\n              // Anywhere else, we need to create a View.\n              code = 'Blaze.View(' + BlazeTools.toJSLiteral('lookup:' + tag.path.join('.')) + ', ' + 'function () { return ' + code + '; })';\n            }\n            return BlazeTools.EmitCode(code);\n          } else if (tag.type === 'INCLUSION' || tag.type === 'BLOCKOPEN') {\n            var path = tag.path;\n            var args = tag.args;\n\n            if (tag.type === 'BLOCKOPEN' && builtInBlockHelpers.hasOwnProperty(path[0])) {\n              // if, unless, with, each.\n              //\n              // If someone tries to do `{{> if}}`, we don't\n              // get here, but an error is thrown when we try to codegen the path.\n\n              // Note: If we caught these errors earlier, while scanning, we'd be able to\n              // provide nice line numbers.\n              if (path.length > 1) throw new Error(\"Unexpected dotted path beginning with \" + path[0]);\n              if (!args.length) throw new Error(\"#\" + path[0] + \" requires an argument\");\n\n              var dataCode = null;\n              // #each has a special treatment as it features two different forms:\n              // - {{#each people}}\n              // - {{#each person in people}}\n              if (path[0] === 'each' && args.length >= 2 && args[1][0] === 'PATH' && args[1][1].length && args[1][1][0] === 'in') {\n                // minimum conditions are met for each-in.  now validate this\n                // isn't some weird case.\n                var eachUsage = \"Use either {{#each items}} or \" + \"{{#each item in items}} form of #each.\";\n                var inArg = args[1];\n                if (!(args.length >= 3 && inArg[1].length === 1)) {\n                  // we don't have at least 3 space-separated parts after #each, or\n                  // inArg doesn't look like ['PATH',['in']]\n                  throw new Error(\"Malformed #each. \" + eachUsage);\n                }\n                // split out the variable name and sequence arguments\n                var variableArg = args[0];\n                if (!(variableArg[0] === \"PATH\" && variableArg[1].length === 1 && variableArg[1][0].replace(/\\./g, ''))) {\n                  throw new Error(\"Bad variable name in #each\");\n                }\n                var variable = variableArg[1][0];\n                dataCode = 'function () { return { _sequence: ' + self.codeGenInclusionData(args.slice(2)) + ', _variable: ' + BlazeTools.toJSLiteral(variable) + ' }; }';\n              } else if (path[0] === 'let') {\n                var dataProps = {};\n                _.each(args, function (arg) {\n                  if (arg.length !== 3) {\n                    // not a keyword arg (x=y)\n                    throw new Error(\"Incorrect form of #let\");\n                  }\n                  var argKey = arg[2];\n                  dataProps[argKey] = 'function () { return Spacebars.call(' + self.codeGenArgValue(arg) + '); }';\n                });\n                dataCode = makeObjectLiteral(dataProps);\n              }\n\n              if (!dataCode) {\n                // `args` must exist (tag.args.length > 0)\n                dataCode = self.codeGenInclusionDataFunc(args) || 'null';\n              }\n\n              // `content` must exist\n              var contentBlock = 'content' in tag ? self.codeGenBlock(tag.content) : null;\n              // `elseContent` may not exist\n              var elseContentBlock = 'elseContent' in tag ? self.codeGenBlock(tag.elseContent) : null;\n\n              var callArgs = [dataCode, contentBlock];\n              if (elseContentBlock) callArgs.push(elseContentBlock);\n\n              return BlazeTools.EmitCode(builtInBlockHelpers[path[0]] + '(' + callArgs.join(', ') + ')');\n            } else {\n              var compCode = self.codeGenPath(path, { lookupTemplate: true });\n              if (path.length > 1) {\n                // capture reactivity\n                compCode = 'function () { return Spacebars.call(' + compCode + '); }';\n              }\n\n              var dataCode = self.codeGenInclusionDataFunc(tag.args);\n              var content = 'content' in tag ? self.codeGenBlock(tag.content) : null;\n              var elseContent = 'elseContent' in tag ? self.codeGenBlock(tag.elseContent) : null;\n\n              var includeArgs = [compCode];\n              if (content) {\n                includeArgs.push(content);\n                if (elseContent) includeArgs.push(elseContent);\n              }\n\n              var includeCode = 'Spacebars.include(' + includeArgs.join(', ') + ')';\n\n              // calling convention compat -- set the data context around the\n              // entire inclusion, so that if the name of the inclusion is\n              // a helper function, it gets the data context in `this`.\n              // This makes for a pretty confusing calling convention --\n              // In `{{#foo bar}}`, `foo` is evaluated in the context of `bar`\n              // -- but it's what we shipped for 0.8.0.  The rationale is that\n              // `{{#foo bar}}` is sugar for `{{#with bar}}{{#foo}}...`.\n              if (dataCode) {\n                includeCode = 'Blaze._TemplateWith(' + dataCode + ', function () { return ' + includeCode + '; })';\n              }\n\n              // XXX BACK COMPAT - UI is the old name, Template is the new\n              if ((path[0] === 'UI' || path[0] === 'Template') && (path[1] === 'contentBlock' || path[1] === 'elseBlock')) {\n                // Call contentBlock and elseBlock in the appropriate scope\n                includeCode = 'Blaze._InOuterTemplateScope(view, function () { return ' + includeCode + '; })';\n              }\n\n              return BlazeTools.EmitCode(includeCode);\n            }\n          } else if (tag.type === 'ESCAPE') {\n            return tag.value;\n          } else {\n            // Can't get here; TemplateTag validation should catch any\n            // inappropriate tag types that might come out of the parser.\n            throw new Error(\"Unexpected template tag type: \" + tag.type);\n          }\n        }\n      },\n\n      // `path` is an array of at least one string.\n      //\n      // If `path.length > 1`, the generated code may be reactive\n      // (i.e. it may invalidate the current computation).\n      //\n      // No code is generated to call the result if it's a function.\n      //\n      // Options:\n      //\n      // - lookupTemplate {Boolean} If true, generated code also looks in\n      //   the list of templates. (After helpers, before data context).\n      //   Used when generating code for `{{> foo}}` or `{{#foo}}`. Only\n      //   used for non-dotted paths.\n      codeGenPath: function codeGenPath(path, opts) {\n        if (builtInBlockHelpers.hasOwnProperty(path[0])) throw new Error(\"Can't use the built-in '\" + path[0] + \"' here\");\n        // Let `{{#if Template.contentBlock}}` check whether this template was\n        // invoked via inclusion or as a block helper, in addition to supporting\n        // `{{> Template.contentBlock}}`.\n        // XXX BACK COMPAT - UI is the old name, Template is the new\n        if (path.length >= 2 && (path[0] === 'UI' || path[0] === 'Template') && builtInTemplateMacros.hasOwnProperty(path[1])) {\n          if (path.length > 2) throw new Error(\"Unexpected dotted path beginning with \" + path[0] + '.' + path[1]);\n          return builtInTemplateMacros[path[1]];\n        }\n\n        var firstPathItem = BlazeTools.toJSLiteral(path[0]);\n        var lookupMethod = 'lookup';\n        if (opts && opts.lookupTemplate && path.length === 1) lookupMethod = 'lookupTemplate';\n        var code = 'view.' + lookupMethod + '(' + firstPathItem + ')';\n\n        if (path.length > 1) {\n          code = 'Spacebars.dot(' + code + ', ' + _.map(path.slice(1), BlazeTools.toJSLiteral).join(', ') + ')';\n        }\n\n        return code;\n      },\n\n      // Generates code for an `[argType, argValue]` argument spec,\n      // ignoring the third element (keyword argument name) if present.\n      //\n      // The resulting code may be reactive (in the case of a PATH of\n      // more than one element) and is not wrapped in a closure.\n      codeGenArgValue: function codeGenArgValue(arg) {\n        var self = this;\n\n        var argType = arg[0];\n        var argValue = arg[1];\n\n        var argCode;\n        switch (argType) {\n          case 'STRING':\n          case 'NUMBER':\n          case 'BOOLEAN':\n          case 'NULL':\n            argCode = BlazeTools.toJSLiteral(argValue);\n            break;\n          case 'PATH':\n            argCode = self.codeGenPath(argValue);\n            break;\n          case 'EXPR':\n            // The format of EXPR is ['EXPR', { type: 'EXPR', path: [...], args: { ... } }]\n            argCode = self.codeGenMustache(argValue.path, argValue.args, 'dataMustache');\n            break;\n          default:\n            // can't get here\n            throw new Error(\"Unexpected arg type: \" + argType);\n        }\n\n        return argCode;\n      },\n\n      // Generates a call to `Spacebars.fooMustache` on evaluated arguments.\n      // The resulting code has no function literals and must be wrapped in\n      // one for fine-grained reactivity.\n      codeGenMustache: function codeGenMustache(path, args, mustacheType) {\n        var self = this;\n\n        var nameCode = self.codeGenPath(path);\n        var argCode = self.codeGenMustacheArgs(args);\n        var mustache = mustacheType || 'mustache';\n\n        return 'Spacebars.' + mustache + '(' + nameCode + (argCode ? ', ' + argCode.join(', ') : '') + ')';\n      },\n\n      // returns: array of source strings, or null if no\n      // args at all.\n      codeGenMustacheArgs: function codeGenMustacheArgs(tagArgs) {\n        var self = this;\n\n        var kwArgs = null; // source -> source\n        var args = null; // [source]\n\n        // tagArgs may be null\n        _.each(tagArgs, function (arg) {\n          var argCode = self.codeGenArgValue(arg);\n\n          if (arg.length > 2) {\n            // keyword argument (represented as [type, value, name])\n            kwArgs = kwArgs || {};\n            kwArgs[arg[2]] = argCode;\n          } else {\n            // positional argument\n            args = args || [];\n            args.push(argCode);\n          }\n        });\n\n        // put kwArgs in options dictionary at end of args\n        if (kwArgs) {\n          args = args || [];\n          args.push('Spacebars.kw(' + makeObjectLiteral(kwArgs) + ')');\n        }\n\n        return args;\n      },\n\n      codeGenBlock: function codeGenBlock(content) {\n        return SpacebarsCompiler.codeGen(content);\n      },\n\n      codeGenInclusionData: function codeGenInclusionData(args) {\n        var self = this;\n\n        if (!args.length) {\n          // e.g. `{{#foo}}`\n          return null;\n        } else if (args[0].length === 3) {\n          // keyword arguments only, e.g. `{{> point x=1 y=2}}`\n          var dataProps = {};\n          _.each(args, function (arg) {\n            var argKey = arg[2];\n            dataProps[argKey] = 'Spacebars.call(' + self.codeGenArgValue(arg) + ')';\n          });\n          return makeObjectLiteral(dataProps);\n        } else if (args[0][0] !== 'PATH') {\n          // literal first argument, e.g. `{{> foo \"blah\"}}`\n          //\n          // tag validation has confirmed, in this case, that there is only\n          // one argument (`args.length === 1`)\n          return self.codeGenArgValue(args[0]);\n        } else if (args.length === 1) {\n          // one argument, must be a PATH\n          return 'Spacebars.call(' + self.codeGenPath(args[0][1]) + ')';\n        } else {\n          // Multiple positional arguments; treat them as a nested\n          // \"data mustache\"\n          return self.codeGenMustache(args[0][1], args.slice(1), 'dataMustache');\n        }\n      },\n\n      codeGenInclusionDataFunc: function codeGenInclusionDataFunc(args) {\n        var self = this;\n        var dataCode = self.codeGenInclusionData(args);\n        if (dataCode) {\n          return 'function () { return ' + dataCode + '; }';\n        } else {\n          return null;\n        }\n      }\n\n    });\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  (function () {\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                     //\n    // packages/spacebars-compiler/compiler.js                                                             //\n    //                                                                                                     //\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n\n    SpacebarsCompiler.parse = function (input) {\n\n      var tree = HTMLTools.parseFragment(input, { getTemplateTag: TemplateTag.parseCompleteTag });\n\n      return tree;\n    };\n\n    SpacebarsCompiler.compile = function (input, options) {\n      var tree = SpacebarsCompiler.parse(input);\n      return SpacebarsCompiler.codeGen(tree, options);\n    };\n\n    SpacebarsCompiler._TemplateTagReplacer = HTML.TransformingVisitor.extend();\n    SpacebarsCompiler._TemplateTagReplacer.def({\n      visitObject: function visitObject(x) {\n        if (x instanceof HTMLTools.TemplateTag) {\n\n          // Make sure all TemplateTags in attributes have the right\n          // `.position` set on them.  This is a bit of a hack\n          // (we shouldn't be mutating that here), but it allows\n          // cleaner codegen of \"synthetic\" attributes like TEXTAREA's\n          // \"value\", where the template tags were originally not\n          // in an attribute.\n          if (this.inAttributeValue) x.position = HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE;\n\n          return this.codegen.codeGenTemplateTag(x);\n        }\n\n        return HTML.TransformingVisitor.prototype.visitObject.call(this, x);\n      },\n      visitAttributes: function visitAttributes(attrs) {\n        if (attrs instanceof HTMLTools.TemplateTag) return this.codegen.codeGenTemplateTag(attrs);\n\n        // call super (e.g. for case where `attrs` is an array)\n        return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);\n      },\n      visitAttribute: function visitAttribute(name, value, tag) {\n        this.inAttributeValue = true;\n        var result = this.visit(value);\n        this.inAttributeValue = false;\n\n        if (result !== value) {\n          // some template tags must have been replaced, because otherwise\n          // we try to keep things `===` when transforming.  Wrap the code\n          // in a function as per the rules.  You can't have\n          // `{id: Blaze.View(...)}` as an attributes dict because the View\n          // would be rendered more than once; you need to wrap it in a function\n          // so that it's a different View each time.\n          return BlazeTools.EmitCode(this.codegen.codeGenBlock(result));\n        }\n        return result;\n      }\n    });\n\n    SpacebarsCompiler.codeGen = function (parseTree, options) {\n      // is this a template, rather than a block passed to\n      // a block helper, say\n      var isTemplate = options && options.isTemplate;\n      var isBody = options && options.isBody;\n      var sourceName = options && options.sourceName;\n\n      var tree = parseTree;\n\n      // The flags `isTemplate` and `isBody` are kind of a hack.\n      if (isTemplate || isBody) {\n        // optimizing fragments would require being smarter about whether we are\n        // in a TEXTAREA, say.\n        tree = SpacebarsCompiler.optimize(tree);\n      }\n\n      // throws an error if using `{{> React}}` with siblings\n      new ReactComponentSiblingForbidder({ sourceName: sourceName }).visit(tree);\n\n      var codegen = new SpacebarsCompiler.CodeGen();\n      tree = new SpacebarsCompiler._TemplateTagReplacer({ codegen: codegen }).visit(tree);\n\n      var code = '(function () { ';\n      if (isTemplate || isBody) {\n        code += 'var view = this; ';\n      }\n      code += 'return ';\n      code += BlazeTools.toJS(tree);\n      code += '; })';\n\n      code = SpacebarsCompiler._beautify(code);\n\n      return code;\n    };\n\n    SpacebarsCompiler._beautify = function (code) {\n      if (Package['minifier-js'] && Package['minifier-js'].UglifyJSMinify) {\n        var result = Package['minifier-js'].UglifyJSMinify(code, { fromString: true,\n          mangle: false,\n          compress: false,\n          output: { beautify: true,\n            indent_level: 2,\n            width: 80 } });\n        var output = result.code;\n        // Uglify interprets our expression as a statement and may add a semicolon.\n        // Strip trailing semicolon.\n        output = output.replace(/;$/, '');\n        return output;\n      } else {\n        // don't actually beautify; no UglifyJS\n        return code;\n      }\n    };\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package['spacebars-compiler'] = {}, {\n    SpacebarsCompiler: SpacebarsCompiler\n  });\n})();\n\n//# sourceMappingURL=spacebars-compiler.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/spacebars-compiler.js"],"names":[],"mappings":"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","file":"/bundle/programs/server/packages/spacebars-compiler.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar HTML = Package.htmljs.HTML;\nvar HTMLTools = Package['html-tools'].HTMLTools;\nvar BlazeTools = Package['blaze-tools'].BlazeTools;\n\n/* Package-scope variables */\nvar SpacebarsCompiler, TemplateTag, ReactComponentSiblingForbidder;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/spacebars-compiler/templatetag.js                                                          //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\nSpacebarsCompiler = {};\n\n// A TemplateTag is the result of parsing a single `{{...}}` tag.\n//\n// The `.type` of a TemplateTag is one of:\n//\n// - `\"DOUBLE\"` - `{{foo}}`\n// - `\"TRIPLE\"` - `{{{foo}}}`\n// - `\"EXPR\"` - `(foo)`\n// - `\"COMMENT\"` - `{{! foo}}`\n// - `\"BLOCKCOMMENT\" - `{{!-- foo--}}`\n// - `\"INCLUSION\"` - `{{> foo}}`\n// - `\"BLOCKOPEN\"` - `{{#foo}}`\n// - `\"BLOCKCLOSE\"` - `{{/foo}}`\n// - `\"ELSE\"` - `{{else}}`\n// - `\"ESCAPE\"` - `{{|`, `{{{|`, `{{{{|` and so on\n//\n// Besides `type`, the mandatory properties of a TemplateTag are:\n//\n// - `path` - An array of one or more strings.  The path of `{{foo.bar}}`\n//   is `[\"foo\", \"bar\"]`.  Applies to DOUBLE, TRIPLE, INCLUSION, BLOCKOPEN,\n//   and BLOCKCLOSE.\n//\n// - `args` - An array of zero or more argument specs.  An argument spec\n//   is a two or three element array, consisting of a type, value, and\n//   optional keyword name.  For example, the `args` of `{{foo \"bar\" x=3}}`\n//   are `[[\"STRING\", \"bar\"], [\"NUMBER\", 3, \"x\"]]`.  Applies to DOUBLE,\n//   TRIPLE, INCLUSION, and BLOCKOPEN.\n//\n// - `value` - A string of the comment's text. Applies to COMMENT and\n//   BLOCKCOMMENT.\n//\n// These additional are typically set during parsing:\n//\n// - `position` - The HTMLTools.TEMPLATE_TAG_POSITION specifying at what sort\n//   of site the TemplateTag was encountered (e.g. at element level or as\n//   part of an attribute value). Its absence implies\n//   TEMPLATE_TAG_POSITION.ELEMENT.\n//\n// - `content` and `elseContent` - When a BLOCKOPEN tag's contents are\n//   parsed, they are put here.  `elseContent` will only be present if\n//   an `{{else}}` was found.\n\nvar TEMPLATE_TAG_POSITION = HTMLTools.TEMPLATE_TAG_POSITION;\n\nTemplateTag = SpacebarsCompiler.TemplateTag = function () {\n  HTMLTools.TemplateTag.apply(this, arguments);\n};\nTemplateTag.prototype = new HTMLTools.TemplateTag;\nTemplateTag.prototype.constructorName = 'SpacebarsCompiler.TemplateTag';\n\nvar makeStacheTagStartRegex = function (r) {\n  return new RegExp(r.source + /(?![{>!#/])/.source,\n                    r.ignoreCase ? 'i' : '');\n};\n\n// \"starts\" regexes are used to see what type of template\n// tag the parser is looking at.  They must match a non-empty\n// result, but not the interesting part of the tag.\nvar starts = {\n  ESCAPE: /^\\{\\{(?=\\{*\\|)/,\n  ELSE: makeStacheTagStartRegex(/^\\{\\{\\s*else(?=[\\s}])/i),\n  DOUBLE: makeStacheTagStartRegex(/^\\{\\{\\s*(?!\\s)/),\n  TRIPLE: makeStacheTagStartRegex(/^\\{\\{\\{\\s*(?!\\s)/),\n  BLOCKCOMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!--/),\n  COMMENT: makeStacheTagStartRegex(/^\\{\\{\\s*!/),\n  INCLUSION: makeStacheTagStartRegex(/^\\{\\{\\s*>\\s*(?!\\s)/),\n  BLOCKOPEN: makeStacheTagStartRegex(/^\\{\\{\\s*#\\s*(?!\\s)/),\n  BLOCKCLOSE: makeStacheTagStartRegex(/^\\{\\{\\s*\\/\\s*(?!\\s)/)\n};\n\nvar ends = {\n  DOUBLE: /^\\s*\\}\\}/,\n  TRIPLE: /^\\s*\\}\\}\\}/,\n  EXPR: /^\\s*\\)/\n};\n\nvar endsString = {\n  DOUBLE: '}}',\n  TRIPLE: '}}}',\n  EXPR: ')'\n};\n\n// Parse a tag from the provided scanner or string.  If the input\n// doesn't start with `{{`, returns null.  Otherwise, either succeeds\n// and returns a SpacebarsCompiler.TemplateTag, or throws an error (using\n// `scanner.fatal` if a scanner is provided).\nTemplateTag.parse = function (scannerOrString) {\n  var scanner = scannerOrString;\n  if (typeof scanner === 'string')\n    scanner = new HTMLTools.Scanner(scannerOrString);\n\n  if (! (scanner.peek() === '{' &&\n         (scanner.rest()).slice(0, 2) === '{{'))\n    return null;\n\n  var run = function (regex) {\n    // regex is assumed to start with `^`\n    var result = regex.exec(scanner.rest());\n    if (! result)\n      return null;\n    var ret = result[0];\n    scanner.pos += ret.length;\n    return ret;\n  };\n\n  var advance = function (amount) {\n    scanner.pos += amount;\n  };\n\n  var scanIdentifier = function (isFirstInPath) {\n    var id = BlazeTools.parseExtendedIdentifierName(scanner);\n    if (! id) {\n      expected('IDENTIFIER');\n    }\n    if (isFirstInPath &&\n        (id === 'null' || id === 'true' || id === 'false'))\n      scanner.fatal(\"Can't use null, true, or false, as an identifier at start of path\");\n\n    return id;\n  };\n\n  var scanPath = function () {\n    var segments = [];\n\n    // handle initial `.`, `..`, `./`, `../`, `../..`, `../../`, etc\n    var dots;\n    if ((dots = run(/^[\\.\\/]+/))) {\n      var ancestorStr = '.'; // eg `../../..` maps to `....`\n      var endsWithSlash = /\\/$/.test(dots);\n\n      if (endsWithSlash)\n        dots = dots.slice(0, -1);\n\n      _.each(dots.split('/'), function(dotClause, index) {\n        if (index === 0) {\n          if (dotClause !== '.' && dotClause !== '..')\n            expected(\"`.`, `..`, `./` or `../`\");\n        } else {\n          if (dotClause !== '..')\n            expected(\"`..` or `../`\");\n        }\n\n        if (dotClause === '..')\n          ancestorStr += '.';\n      });\n\n      segments.push(ancestorStr);\n\n      if (!endsWithSlash)\n        return segments;\n    }\n\n    while (true) {\n      // scan a path segment\n\n      if (run(/^\\[/)) {\n        var seg = run(/^[\\s\\S]*?\\]/);\n        if (! seg)\n          error(\"Unterminated path segment\");\n        seg = seg.slice(0, -1);\n        if (! seg && ! segments.length)\n          error(\"Path can't start with empty string\");\n        segments.push(seg);\n      } else {\n        var id = scanIdentifier(! segments.length);\n        if (id === 'this') {\n          if (! segments.length) {\n            // initial `this`\n            segments.push('.');\n          } else {\n            error(\"Can only use `this` at the beginning of a path.\\nInstead of `foo.this` or `../this`, just write `foo` or `..`.\");\n          }\n        } else {\n          segments.push(id);\n        }\n      }\n\n      var sep = run(/^[\\.\\/]/);\n      if (! sep)\n        break;\n    }\n\n    return segments;\n  };\n\n  // scan the keyword portion of a keyword argument\n  // (the \"foo\" portion in \"foo=bar\").\n  // Result is either the keyword matched, or null\n  // if we're not at a keyword argument position.\n  var scanArgKeyword = function () {\n    var match = /^([^\\{\\}\\(\\)\\>#=\\s\"'\\[\\]]+)\\s*=\\s*/.exec(scanner.rest());\n    if (match) {\n      scanner.pos += match[0].length;\n      return match[1];\n    } else {\n      return null;\n    }\n  };\n\n  // scan an argument; succeeds or errors.\n  // Result is an array of two or three items:\n  // type , value, and (indicating a keyword argument)\n  // keyword name.\n  var scanArg = function () {\n    var keyword = scanArgKeyword(); // null if not parsing a kwarg\n    var value = scanArgValue();\n    return keyword ? value.concat(keyword) : value;\n  };\n\n  // scan an argument value (for keyword or positional arguments);\n  // succeeds or errors.  Result is an array of type, value.\n  var scanArgValue = function () {\n    var startPos = scanner.pos;\n    var result;\n    if ((result = BlazeTools.parseNumber(scanner))) {\n      return ['NUMBER', result.value];\n    } else if ((result = BlazeTools.parseStringLiteral(scanner))) {\n      return ['STRING', result.value];\n    } else if (/^[\\.\\[]/.test(scanner.peek())) {\n      return ['PATH', scanPath()];\n    } else if (run(/^\\(/)) {\n      return ['EXPR', scanExpr('EXPR')];\n    } else if ((result = BlazeTools.parseExtendedIdentifierName(scanner))) {\n      var id = result;\n      if (id === 'null') {\n        return ['NULL', null];\n      } else if (id === 'true' || id === 'false') {\n        return ['BOOLEAN', id === 'true'];\n      } else {\n        scanner.pos = startPos; // unconsume `id`\n        return ['PATH', scanPath()];\n      }\n    } else {\n      expected('identifier, number, string, boolean, null, or a sub expression enclosed in \"(\", \")\"');\n    }\n  };\n\n  var scanExpr = function (type) {\n    var endType = type;\n    if (type === 'INCLUSION' || type === 'BLOCKOPEN')\n      endType = 'DOUBLE';\n\n    var tag = new TemplateTag;\n    tag.type = type;\n    tag.path = scanPath();\n    tag.args = [];\n    var foundKwArg = false;\n    while (true) {\n      run(/^\\s*/);\n      if (run(ends[endType]))\n        break;\n      else if (/^[})]/.test(scanner.peek())) {\n        expected('`' + endsString[endType] + '`');\n      }\n      var newArg = scanArg();\n      if (newArg.length === 3) {\n        foundKwArg = true;\n      } else {\n        if (foundKwArg)\n          error(\"Can't have a non-keyword argument after a keyword argument\");\n      }\n      tag.args.push(newArg);\n\n      // expect a whitespace or a closing ')' or '}'\n      if (run(/^(?=[\\s})])/) !== '')\n        expected('space');\n    }\n\n    return tag;\n  };\n\n  var type;\n\n  var error = function (msg) {\n    scanner.fatal(msg);\n  };\n\n  var expected = function (what) {\n    error('Expected ' + what);\n  };\n\n  // must do ESCAPE first, immediately followed by ELSE\n  // order of others doesn't matter\n  if (run(starts.ESCAPE)) type = 'ESCAPE';\n  else if (run(starts.ELSE)) type = 'ELSE';\n  else if (run(starts.DOUBLE)) type = 'DOUBLE';\n  else if (run(starts.TRIPLE)) type = 'TRIPLE';\n  else if (run(starts.BLOCKCOMMENT)) type = 'BLOCKCOMMENT';\n  else if (run(starts.COMMENT)) type = 'COMMENT';\n  else if (run(starts.INCLUSION)) type = 'INCLUSION';\n  else if (run(starts.BLOCKOPEN)) type = 'BLOCKOPEN';\n  else if (run(starts.BLOCKCLOSE)) type = 'BLOCKCLOSE';\n  else\n    error('Unknown stache tag');\n\n  var tag = new TemplateTag;\n  tag.type = type;\n\n  if (type === 'BLOCKCOMMENT') {\n    var result = run(/^[\\s\\S]*?--\\s*?\\}\\}/);\n    if (! result)\n      error(\"Unclosed block comment\");\n    tag.value = result.slice(0, result.lastIndexOf('--'));\n  } else if (type === 'COMMENT') {\n    var result = run(/^[\\s\\S]*?\\}\\}/);\n    if (! result)\n      error(\"Unclosed comment\");\n    tag.value = result.slice(0, -2);\n  } else if (type === 'BLOCKCLOSE') {\n    tag.path = scanPath();\n    if (! run(ends.DOUBLE))\n      expected('`}}`');\n  } else if (type === 'ELSE') {\n    if (! run(ends.DOUBLE))\n      expected('`}}`');\n  } else if (type === 'ESCAPE') {\n    var result = run(/^\\{*\\|/);\n    tag.value = '{{' + result.slice(0, -1);\n  } else {\n    // DOUBLE, TRIPLE, BLOCKOPEN, INCLUSION\n    tag = scanExpr(type);\n  }\n\n  return tag;\n};\n\n// Returns a SpacebarsCompiler.TemplateTag parsed from `scanner`, leaving scanner\n// at its original position.\n//\n// An error will still be thrown if there is not a valid template tag at\n// the current position.\nTemplateTag.peek = function (scanner) {\n  var startPos = scanner.pos;\n  var result = TemplateTag.parse(scanner);\n  scanner.pos = startPos;\n  return result;\n};\n\n// Like `TemplateTag.parse`, but in the case of blocks, parse the complete\n// `{{#foo}}...{{/foo}}` with `content` and possible `elseContent`, rather\n// than just the BLOCKOPEN tag.\n//\n// In addition:\n//\n// - Throws an error if `{{else}}` or `{{/foo}}` tag is encountered.\n//\n// - Returns `null` for a COMMENT.  (This case is distinguishable from\n//   parsing no tag by the fact that the scanner is advanced.)\n//\n// - Takes an HTMLTools.TEMPLATE_TAG_POSITION `position` and sets it as the\n//   TemplateTag's `.position` property.\n//\n// - Validates the tag's well-formedness and legality at in its position.\nTemplateTag.parseCompleteTag = function (scannerOrString, position) {\n  var scanner = scannerOrString;\n  if (typeof scanner === 'string')\n    scanner = new HTMLTools.Scanner(scannerOrString);\n\n  var startPos = scanner.pos; // for error messages\n  var result = TemplateTag.parse(scannerOrString);\n  if (! result)\n    return result;\n\n  if (result.type === 'BLOCKCOMMENT')\n    return null;\n\n  if (result.type === 'COMMENT')\n    return null;\n\n  if (result.type === 'ELSE')\n    scanner.fatal(\"Unexpected {{else}}\");\n\n  if (result.type === 'BLOCKCLOSE')\n    scanner.fatal(\"Unexpected closing template tag\");\n\n  position = (position || TEMPLATE_TAG_POSITION.ELEMENT);\n  if (position !== TEMPLATE_TAG_POSITION.ELEMENT)\n    result.position = position;\n\n  if (result.type === 'BLOCKOPEN') {\n    // parse block contents\n\n    // Construct a string version of `.path` for comparing start and\n    // end tags.  For example, `foo/[0]` was parsed into `[\"foo\", \"0\"]`\n    // and now becomes `foo,0`.  This form may also show up in error\n    // messages.\n    var blockName = result.path.join(',');\n\n    var textMode = null;\n      if (blockName === 'markdown' ||\n          position === TEMPLATE_TAG_POSITION.IN_RAWTEXT) {\n        textMode = HTML.TEXTMODE.STRING;\n      } else if (position === TEMPLATE_TAG_POSITION.IN_RCDATA ||\n                 position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n        textMode = HTML.TEXTMODE.RCDATA;\n      }\n      var parserOptions = {\n        getTemplateTag: TemplateTag.parseCompleteTag,\n        shouldStop: isAtBlockCloseOrElse,\n        textMode: textMode\n      };\n    result.content = HTMLTools.parseFragment(scanner, parserOptions);\n\n    if (scanner.rest().slice(0, 2) !== '{{')\n      scanner.fatal(\"Expected {{else}} or block close for \" + blockName);\n\n    var lastPos = scanner.pos; // save for error messages\n    var tmplTag = TemplateTag.parse(scanner); // {{else}} or {{/foo}}\n\n    if (tmplTag.type === 'ELSE') {\n      // parse {{else}} and content up to close tag\n      result.elseContent = HTMLTools.parseFragment(scanner, parserOptions);\n\n      if (scanner.rest().slice(0, 2) !== '{{')\n        scanner.fatal(\"Expected block close for \" + blockName);\n\n      lastPos = scanner.pos;\n      tmplTag = TemplateTag.parse(scanner);\n    }\n\n    if (tmplTag.type === 'BLOCKCLOSE') {\n      var blockName2 = tmplTag.path.join(',');\n      if (blockName !== blockName2) {\n        scanner.pos = lastPos;\n        scanner.fatal('Expected tag to close ' + blockName + ', found ' +\n                      blockName2);\n      }\n    } else {\n      scanner.pos = lastPos;\n      scanner.fatal('Expected tag to close ' + blockName + ', found ' +\n                    tmplTag.type);\n    }\n  }\n\n  var finalPos = scanner.pos;\n  scanner.pos = startPos;\n  validateTag(result, scanner);\n  scanner.pos = finalPos;\n\n  return result;\n};\n\nvar isAtBlockCloseOrElse = function (scanner) {\n  // Detect `{{else}}` or `{{/foo}}`.\n  //\n  // We do as much work ourselves before deferring to `TemplateTag.peek`,\n  // for efficiency (we're called for every input token) and to be\n  // less obtrusive, because `TemplateTag.peek` will throw an error if it\n  // sees `{{` followed by a malformed tag.\n  var rest, type;\n  return (scanner.peek() === '{' &&\n          (rest = scanner.rest()).slice(0, 2) === '{{' &&\n          /^\\{\\{\\s*(\\/|else\\b)/.test(rest) &&\n          (type = TemplateTag.peek(scanner).type) &&\n          (type === 'BLOCKCLOSE' || type === 'ELSE'));\n};\n\n// Validate that `templateTag` is correctly formed and legal for its\n// HTML position.  Use `scanner` to report errors. On success, does\n// nothing.\nvar validateTag = function (ttag, scanner) {\n\n  if (ttag.type === 'INCLUSION' || ttag.type === 'BLOCKOPEN') {\n    var args = ttag.args;\n    if (ttag.path[0] === 'each' && args[1] && args[1][0] === 'PATH' &&\n        args[1][1][0] === 'in') {\n      // For slightly better error messages, we detect the each-in case\n      // here in order not to complain if the user writes `{{#each 3 in x}}`\n      // that \"3 is not a function\"\n    } else {\n      if (args.length > 1 && args[0].length === 2 && args[0][0] !== 'PATH') {\n        // we have a positional argument that is not a PATH followed by\n        // other arguments\n        scanner.fatal(\"First argument must be a function, to be called on \" +\n                      \"the rest of the arguments; found \" + args[0][0]);\n      }\n    }\n  }\n\n  var position = ttag.position || TEMPLATE_TAG_POSITION.ELEMENT;\n  if (position === TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n    if (ttag.type === 'DOUBLE' || ttag.type === 'ESCAPE') {\n      return;\n    } else if (ttag.type === 'BLOCKOPEN') {\n      var path = ttag.path;\n      var path0 = path[0];\n      if (! (path.length === 1 && (path0 === 'if' ||\n                                   path0 === 'unless' ||\n                                   path0 === 'with' ||\n                                   path0 === 'each'))) {\n        scanner.fatal(\"Custom block helpers are not allowed in an HTML attribute, only built-in ones like #each and #if\");\n      }\n    } else {\n      scanner.fatal(ttag.type + \" template tag is not allowed in an HTML attribute\");\n    }\n  } else if (position === TEMPLATE_TAG_POSITION.IN_START_TAG) {\n    if (! (ttag.type === 'DOUBLE')) {\n      scanner.fatal(\"Reactive HTML attributes must either have a constant name or consist of a single {{helper}} providing a dictionary of names and values.  A template tag of type \" + ttag.type + \" is not allowed here.\");\n    }\n    if (scanner.peek() === '=') {\n      scanner.fatal(\"Template tags are not allowed in attribute names, only in attribute values or in the form of a single {{helper}} that evaluates to a dictionary of name=value pairs.\");\n    }\n  }\n\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/spacebars-compiler/optimizer.js                                                            //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\n// Optimize parts of an HTMLjs tree into raw HTML strings when they don't\n// contain template tags.\n\nvar constant = function (value) {\n  return function () { return value; };\n};\n\nvar OPTIMIZABLE = {\n  NONE: 0,\n  PARTS: 1,\n  FULL: 2\n};\n\n// We can only turn content into an HTML string if it contains no template\n// tags and no \"tricky\" HTML tags.  If we can optimize the entire content\n// into a string, we return OPTIMIZABLE.FULL.  If the we are given an\n// unoptimizable node, we return OPTIMIZABLE.NONE.  If we are given a tree\n// that contains an unoptimizable node somewhere, we return OPTIMIZABLE.PARTS.\n//\n// For example, we always create SVG elements programmatically, since SVG\n// doesn't have innerHTML.  If we are given an SVG element, we return NONE.\n// However, if we are given a big tree that contains SVG somewhere, we\n// return PARTS so that the optimizer can descend into the tree and optimize\n// other parts of it.\nvar CanOptimizeVisitor = HTML.Visitor.extend();\nCanOptimizeVisitor.def({\n  visitNull: constant(OPTIMIZABLE.FULL),\n  visitPrimitive: constant(OPTIMIZABLE.FULL),\n  visitComment: constant(OPTIMIZABLE.FULL),\n  visitCharRef: constant(OPTIMIZABLE.FULL),\n  visitRaw: constant(OPTIMIZABLE.FULL),\n  visitObject: constant(OPTIMIZABLE.NONE),\n  visitFunction: constant(OPTIMIZABLE.NONE),\n  visitArray: function (x) {\n    for (var i = 0; i < x.length; i++)\n      if (this.visit(x[i]) !== OPTIMIZABLE.FULL)\n        return OPTIMIZABLE.PARTS;\n    return OPTIMIZABLE.FULL;\n  },\n  visitTag: function (tag) {\n    var tagName = tag.tagName;\n    if (tagName === 'textarea') {\n      // optimizing into a TEXTAREA's RCDATA would require being a little\n      // more clever.\n      return OPTIMIZABLE.NONE;\n    } else if (tagName === 'script') {\n      // script tags don't work when rendered from strings\n      return OPTIMIZABLE.NONE;\n    } else if (! (HTML.isKnownElement(tagName) &&\n                  ! HTML.isKnownSVGElement(tagName))) {\n      // foreign elements like SVG can't be stringified for innerHTML.\n      return OPTIMIZABLE.NONE;\n    } else if (tagName === 'table') {\n      // Avoid ever producing HTML containing `<table><tr>...`, because the\n      // browser will insert a TBODY.  If we just `createElement(\"table\")` and\n      // `createElement(\"tr\")`, on the other hand, no TBODY is necessary\n      // (assuming IE 8+).\n      return OPTIMIZABLE.NONE;\n    }\n\n    var children = tag.children;\n    for (var i = 0; i < children.length; i++)\n      if (this.visit(children[i]) !== OPTIMIZABLE.FULL)\n        return OPTIMIZABLE.PARTS;\n\n    if (this.visitAttributes(tag.attrs) !== OPTIMIZABLE.FULL)\n      return OPTIMIZABLE.PARTS;\n\n    return OPTIMIZABLE.FULL;\n  },\n  visitAttributes: function (attrs) {\n    if (attrs) {\n      var isArray = HTML.isArray(attrs);\n      for (var i = 0; i < (isArray ? attrs.length : 1); i++) {\n        var a = (isArray ? attrs[i] : attrs);\n        if ((typeof a !== 'object') || (a instanceof HTMLTools.TemplateTag))\n          return OPTIMIZABLE.PARTS;\n        for (var k in a)\n          if (this.visit(a[k]) !== OPTIMIZABLE.FULL)\n            return OPTIMIZABLE.PARTS;\n      }\n    }\n    return OPTIMIZABLE.FULL;\n  }\n});\n\nvar getOptimizability = function (content) {\n  return (new CanOptimizeVisitor).visit(content);\n};\n\nvar toRaw = function (x) {\n  return HTML.Raw(HTML.toHTML(x));\n};\n\nvar TreeTransformer = HTML.TransformingVisitor.extend();\nTreeTransformer.def({\n  visitAttributes: function (attrs/*, ...*/) {\n    // pass template tags through by default\n    if (attrs instanceof HTMLTools.TemplateTag)\n      return attrs;\n\n    return HTML.TransformingVisitor.prototype.visitAttributes.apply(\n      this, arguments);\n  }\n});\n\n// Replace parts of the HTMLjs tree that have no template tags (or\n// tricky HTML tags) with HTML.Raw objects containing raw HTML.\nvar OptimizingVisitor = TreeTransformer.extend();\nOptimizingVisitor.def({\n  visitNull: toRaw,\n  visitPrimitive: toRaw,\n  visitComment: toRaw,\n  visitCharRef: toRaw,\n  visitArray: function (array) {\n    var optimizability = getOptimizability(array);\n    if (optimizability === OPTIMIZABLE.FULL) {\n      return toRaw(array);\n    } else if (optimizability === OPTIMIZABLE.PARTS) {\n      return TreeTransformer.prototype.visitArray.call(this, array);\n    } else {\n      return array;\n    }\n  },\n  visitTag: function (tag) {\n    var optimizability = getOptimizability(tag);\n    if (optimizability === OPTIMIZABLE.FULL) {\n      return toRaw(tag);\n    } else if (optimizability === OPTIMIZABLE.PARTS) {\n      return TreeTransformer.prototype.visitTag.call(this, tag);\n    } else {\n      return tag;\n    }\n  },\n  visitChildren: function (children) {\n    // don't optimize the children array into a Raw object!\n    return TreeTransformer.prototype.visitArray.call(this, children);\n  },\n  visitAttributes: function (attrs) {\n    return attrs;\n  }\n});\n\n// Combine consecutive HTML.Raws.  Remove empty ones.\nvar RawCompactingVisitor = TreeTransformer.extend();\nRawCompactingVisitor.def({\n  visitArray: function (array) {\n    var result = [];\n    for (var i = 0; i < array.length; i++) {\n      var item = array[i];\n      if ((item instanceof HTML.Raw) &&\n          ((! item.value) ||\n           (result.length &&\n            (result[result.length - 1] instanceof HTML.Raw)))) {\n        // two cases: item is an empty Raw, or previous item is\n        // a Raw as well.  In the latter case, replace the previous\n        // Raw with a longer one that includes the new Raw.\n        if (item.value) {\n          result[result.length - 1] = HTML.Raw(\n            result[result.length - 1].value + item.value);\n        }\n      } else {\n        result.push(item);\n      }\n    }\n    return result;\n  }\n});\n\n// Replace pointless Raws like `HTMl.Raw('foo')` that contain no special\n// characters with simple strings.\nvar RawReplacingVisitor = TreeTransformer.extend();\nRawReplacingVisitor.def({\n  visitRaw: function (raw) {\n    var html = raw.value;\n    if (html.indexOf('&') < 0 && html.indexOf('<') < 0) {\n      return html;\n    } else {\n      return raw;\n    }\n  }\n});\n\nSpacebarsCompiler.optimize = function (tree) {\n  tree = (new OptimizingVisitor).visit(tree);\n  tree = (new RawCompactingVisitor).visit(tree);\n  tree = (new RawReplacingVisitor).visit(tree);\n  return tree;\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/spacebars-compiler/react.js                                                                //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\n// A visitor to ensure that React components included via the `{{>\n// React}}` template defined in the react-template-helper package are\n// the only child in their parent component. Otherwise `React.render`\n// would eliminate all of their sibling nodes.\n//\n// It's a little strange that this logic is in spacebars-compiler if\n// it's only relevant to a specific package but there's no way to have\n// a package hook into a build plugin.\nReactComponentSiblingForbidder = HTML.Visitor.extend();\nReactComponentSiblingForbidder.def({\n  visitArray: function (array, parentTag) {\n    for (var i = 0; i < array.length; i++) {\n      this.visit(array[i], parentTag);\n    }\n  },\n  visitObject: function (obj, parentTag) {\n    if (obj.type === \"INCLUSION\" && obj.path.length === 1 && obj.path[0] === \"React\") {\n      if (!parentTag) {\n        throw new Error(\n          \"{{> React}} must be used in a container element\"\n            + (this.sourceName ? (\" in \" + this.sourceName) : \"\")\n               + \". Learn more at https://github.com/meteor/meteor/wiki/React-components-must-be-the-only-thing-in-their-wrapper-element\");\n      }\n\n      var numSiblings = 0;\n      for (var i = 0; i < parentTag.children.length; i++) {\n        var child = parentTag.children[i];\n        if (child !== obj && !(typeof child === \"string\" && child.match(/^\\s*$/))) {\n          numSiblings++;\n        }\n      }\n\n      if (numSiblings > 0) {\n        throw new Error(\n          \"{{> React}} must be used as the only child in a container element\"\n            + (this.sourceName ? (\" in \" + this.sourceName) : \"\")\n               + \". Learn more at https://github.com/meteor/meteor/wiki/React-components-must-be-the-only-thing-in-their-wrapper-element\");\n      }\n    }\n  },\n  visitTag: function (tag) {\n    this.visitArray(tag.children, tag /*parentTag*/);\n  }\n});\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/spacebars-compiler/codegen.js                                                              //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\n// ============================================================\n// Code-generation of template tags\n\n// The `CodeGen` class currently has no instance state, but in theory\n// it could be useful to track per-function state, like whether we\n// need to emit `var self = this` or not.\nvar CodeGen = SpacebarsCompiler.CodeGen = function () {};\n\nvar builtInBlockHelpers = SpacebarsCompiler._builtInBlockHelpers = {\n  'if': 'Blaze.If',\n  'unless': 'Blaze.Unless',\n  'with': 'Spacebars.With',\n  'each': 'Blaze.Each',\n  'let': 'Blaze.Let'\n};\n\n\n// Mapping of \"macros\" which, when preceded by `Template.`, expand\n// to special code rather than following the lookup rules for dotted\n// symbols.\nvar builtInTemplateMacros = {\n  // `view` is a local variable defined in the generated render\n  // function for the template in which `Template.contentBlock` or\n  // `Template.elseBlock` is invoked.\n  'contentBlock': 'view.templateContentBlock',\n  'elseBlock': 'view.templateElseBlock',\n\n  // Confusingly, this makes `{{> Template.dynamic}}` an alias\n  // for `{{> __dynamic}}`, where \"__dynamic\" is the template that\n  // implements the dynamic template feature.\n  'dynamic': 'Template.__dynamic',\n\n  'subscriptionsReady': 'view.templateInstance().subscriptionsReady()'\n};\n\nvar additionalReservedNames = [\"body\", \"toString\", \"instance\",  \"constructor\",\n  \"toString\", \"toLocaleString\", \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\",\n  \"propertyIsEnumerable\", \"__defineGetter__\", \"__lookupGetter__\",\n  \"__defineSetter__\", \"__lookupSetter__\", \"__proto__\", \"dynamic\",\n  \"registerHelper\", \"currentData\", \"parentData\"];\n\n// A \"reserved name\" can't be used as a <template> name.  This\n// function is used by the template file scanner.\n//\n// Note that the runtime imposes additional restrictions, for example\n// banning the name \"body\" and names of built-in object properties\n// like \"toString\".\nSpacebarsCompiler.isReservedName = function (name) {\n  return builtInBlockHelpers.hasOwnProperty(name) ||\n    builtInTemplateMacros.hasOwnProperty(name) ||\n    _.indexOf(additionalReservedNames, name) > -1;\n};\n\nvar makeObjectLiteral = function (obj) {\n  var parts = [];\n  for (var k in obj)\n    parts.push(BlazeTools.toObjectLiteralKey(k) + ': ' + obj[k]);\n  return '{' + parts.join(', ') + '}';\n};\n\n_.extend(CodeGen.prototype, {\n  codeGenTemplateTag: function (tag) {\n    var self = this;\n    if (tag.position === HTMLTools.TEMPLATE_TAG_POSITION.IN_START_TAG) {\n      // Special dynamic attributes: `<div {{attrs}}>...`\n      // only `tag.type === 'DOUBLE'` allowed (by earlier validation)\n      return BlazeTools.EmitCode('function () { return ' +\n          self.codeGenMustache(tag.path, tag.args, 'attrMustache')\n          + '; }');\n    } else {\n      if (tag.type === 'DOUBLE' || tag.type === 'TRIPLE') {\n        var code = self.codeGenMustache(tag.path, tag.args);\n        if (tag.type === 'TRIPLE') {\n          code = 'Spacebars.makeRaw(' + code + ')';\n        }\n        if (tag.position !== HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {\n          // Reactive attributes are already wrapped in a function,\n          // and there's no fine-grained reactivity.\n          // Anywhere else, we need to create a View.\n          code = 'Blaze.View(' +\n            BlazeTools.toJSLiteral('lookup:' + tag.path.join('.')) + ', ' +\n            'function () { return ' + code + '; })';\n        }\n        return BlazeTools.EmitCode(code);\n      } else if (tag.type === 'INCLUSION' || tag.type === 'BLOCKOPEN') {\n        var path = tag.path;\n        var args = tag.args;\n\n        if (tag.type === 'BLOCKOPEN' &&\n            builtInBlockHelpers.hasOwnProperty(path[0])) {\n          // if, unless, with, each.\n          //\n          // If someone tries to do `{{> if}}`, we don't\n          // get here, but an error is thrown when we try to codegen the path.\n\n          // Note: If we caught these errors earlier, while scanning, we'd be able to\n          // provide nice line numbers.\n          if (path.length > 1)\n            throw new Error(\"Unexpected dotted path beginning with \" + path[0]);\n          if (! args.length)\n            throw new Error(\"#\" + path[0] + \" requires an argument\");\n\n          var dataCode = null;\n          // #each has a special treatment as it features two different forms:\n          // - {{#each people}}\n          // - {{#each person in people}}\n          if (path[0] === 'each' && args.length >= 2 && args[1][0] === 'PATH' &&\n              args[1][1].length && args[1][1][0] === 'in') {\n            // minimum conditions are met for each-in.  now validate this\n            // isn't some weird case.\n            var eachUsage = \"Use either {{#each items}} or \" +\n                  \"{{#each item in items}} form of #each.\";\n            var inArg = args[1];\n            if (! (args.length >= 3 && inArg[1].length === 1)) {\n              // we don't have at least 3 space-separated parts after #each, or\n              // inArg doesn't look like ['PATH',['in']]\n              throw new Error(\"Malformed #each. \" + eachUsage);\n            }\n            // split out the variable name and sequence arguments\n            var variableArg = args[0];\n            if (! (variableArg[0] === \"PATH\" && variableArg[1].length === 1 &&\n                   variableArg[1][0].replace(/\\./g, ''))) {\n              throw new Error(\"Bad variable name in #each\");\n            }\n            var variable = variableArg[1][0];\n            dataCode = 'function () { return { _sequence: ' +\n              self.codeGenInclusionData(args.slice(2)) +\n              ', _variable: ' + BlazeTools.toJSLiteral(variable) + ' }; }';\n          } else if (path[0] === 'let') {\n            var dataProps = {};\n            _.each(args, function (arg) {\n              if (arg.length !== 3) {\n                // not a keyword arg (x=y)\n                throw new Error(\"Incorrect form of #let\");\n              }\n              var argKey = arg[2];\n              dataProps[argKey] =\n                'function () { return Spacebars.call(' +\n                self.codeGenArgValue(arg) + '); }';\n            });\n            dataCode = makeObjectLiteral(dataProps);\n          }\n\n          if (! dataCode) {\n            // `args` must exist (tag.args.length > 0)\n            dataCode = self.codeGenInclusionDataFunc(args) || 'null';\n          }\n\n          // `content` must exist\n          var contentBlock = (('content' in tag) ?\n                              self.codeGenBlock(tag.content) : null);\n          // `elseContent` may not exist\n          var elseContentBlock = (('elseContent' in tag) ?\n                                  self.codeGenBlock(tag.elseContent) : null);\n\n          var callArgs = [dataCode, contentBlock];\n          if (elseContentBlock)\n            callArgs.push(elseContentBlock);\n\n          return BlazeTools.EmitCode(\n            builtInBlockHelpers[path[0]] + '(' + callArgs.join(', ') + ')');\n\n        } else {\n          var compCode = self.codeGenPath(path, {lookupTemplate: true});\n          if (path.length > 1) {\n            // capture reactivity\n            compCode = 'function () { return Spacebars.call(' + compCode +\n              '); }';\n          }\n\n          var dataCode = self.codeGenInclusionDataFunc(tag.args);\n          var content = (('content' in tag) ?\n                         self.codeGenBlock(tag.content) : null);\n          var elseContent = (('elseContent' in tag) ?\n                             self.codeGenBlock(tag.elseContent) : null);\n\n          var includeArgs = [compCode];\n          if (content) {\n            includeArgs.push(content);\n            if (elseContent)\n              includeArgs.push(elseContent);\n          }\n\n          var includeCode =\n                'Spacebars.include(' + includeArgs.join(', ') + ')';\n\n          // calling convention compat -- set the data context around the\n          // entire inclusion, so that if the name of the inclusion is\n          // a helper function, it gets the data context in `this`.\n          // This makes for a pretty confusing calling convention --\n          // In `{{#foo bar}}`, `foo` is evaluated in the context of `bar`\n          // -- but it's what we shipped for 0.8.0.  The rationale is that\n          // `{{#foo bar}}` is sugar for `{{#with bar}}{{#foo}}...`.\n          if (dataCode) {\n            includeCode =\n              'Blaze._TemplateWith(' + dataCode + ', function () { return ' +\n              includeCode + '; })';\n          }\n\n          // XXX BACK COMPAT - UI is the old name, Template is the new\n          if ((path[0] === 'UI' || path[0] === 'Template') &&\n              (path[1] === 'contentBlock' || path[1] === 'elseBlock')) {\n            // Call contentBlock and elseBlock in the appropriate scope\n            includeCode = 'Blaze._InOuterTemplateScope(view, function () { return '\n              + includeCode + '; })';\n          }\n\n          return BlazeTools.EmitCode(includeCode);\n        }\n      } else if (tag.type === 'ESCAPE') {\n        return tag.value;\n      } else {\n        // Can't get here; TemplateTag validation should catch any\n        // inappropriate tag types that might come out of the parser.\n        throw new Error(\"Unexpected template tag type: \" + tag.type);\n      }\n    }\n  },\n\n  // `path` is an array of at least one string.\n  //\n  // If `path.length > 1`, the generated code may be reactive\n  // (i.e. it may invalidate the current computation).\n  //\n  // No code is generated to call the result if it's a function.\n  //\n  // Options:\n  //\n  // - lookupTemplate {Boolean} If true, generated code also looks in\n  //   the list of templates. (After helpers, before data context).\n  //   Used when generating code for `{{> foo}}` or `{{#foo}}`. Only\n  //   used for non-dotted paths.\n  codeGenPath: function (path, opts) {\n    if (builtInBlockHelpers.hasOwnProperty(path[0]))\n      throw new Error(\"Can't use the built-in '\" + path[0] + \"' here\");\n    // Let `{{#if Template.contentBlock}}` check whether this template was\n    // invoked via inclusion or as a block helper, in addition to supporting\n    // `{{> Template.contentBlock}}`.\n    // XXX BACK COMPAT - UI is the old name, Template is the new\n    if (path.length >= 2 &&\n        (path[0] === 'UI' || path[0] === 'Template')\n        && builtInTemplateMacros.hasOwnProperty(path[1])) {\n      if (path.length > 2)\n        throw new Error(\"Unexpected dotted path beginning with \" +\n                        path[0] + '.' + path[1]);\n      return builtInTemplateMacros[path[1]];\n    }\n\n    var firstPathItem = BlazeTools.toJSLiteral(path[0]);\n    var lookupMethod = 'lookup';\n    if (opts && opts.lookupTemplate && path.length === 1)\n      lookupMethod = 'lookupTemplate';\n    var code = 'view.' + lookupMethod + '(' + firstPathItem + ')';\n\n    if (path.length > 1) {\n      code = 'Spacebars.dot(' + code + ', ' +\n        _.map(path.slice(1), BlazeTools.toJSLiteral).join(', ') + ')';\n    }\n\n    return code;\n  },\n\n  // Generates code for an `[argType, argValue]` argument spec,\n  // ignoring the third element (keyword argument name) if present.\n  //\n  // The resulting code may be reactive (in the case of a PATH of\n  // more than one element) and is not wrapped in a closure.\n  codeGenArgValue: function (arg) {\n    var self = this;\n\n    var argType = arg[0];\n    var argValue = arg[1];\n\n    var argCode;\n    switch (argType) {\n    case 'STRING':\n    case 'NUMBER':\n    case 'BOOLEAN':\n    case 'NULL':\n      argCode = BlazeTools.toJSLiteral(argValue);\n      break;\n    case 'PATH':\n      argCode = self.codeGenPath(argValue);\n      break;\n    case 'EXPR':\n      // The format of EXPR is ['EXPR', { type: 'EXPR', path: [...], args: { ... } }]\n      argCode = self.codeGenMustache(argValue.path, argValue.args, 'dataMustache');\n      break;\n    default:\n      // can't get here\n      throw new Error(\"Unexpected arg type: \" + argType);\n    }\n\n    return argCode;\n  },\n\n  // Generates a call to `Spacebars.fooMustache` on evaluated arguments.\n  // The resulting code has no function literals and must be wrapped in\n  // one for fine-grained reactivity.\n  codeGenMustache: function (path, args, mustacheType) {\n    var self = this;\n\n    var nameCode = self.codeGenPath(path);\n    var argCode = self.codeGenMustacheArgs(args);\n    var mustache = (mustacheType || 'mustache');\n\n    return 'Spacebars.' + mustache + '(' + nameCode +\n      (argCode ? ', ' + argCode.join(', ') : '') + ')';\n  },\n\n  // returns: array of source strings, or null if no\n  // args at all.\n  codeGenMustacheArgs: function (tagArgs) {\n    var self = this;\n\n    var kwArgs = null; // source -> source\n    var args = null; // [source]\n\n    // tagArgs may be null\n    _.each(tagArgs, function (arg) {\n      var argCode = self.codeGenArgValue(arg);\n\n      if (arg.length > 2) {\n        // keyword argument (represented as [type, value, name])\n        kwArgs = (kwArgs || {});\n        kwArgs[arg[2]] = argCode;\n      } else {\n        // positional argument\n        args = (args || []);\n        args.push(argCode);\n      }\n    });\n\n    // put kwArgs in options dictionary at end of args\n    if (kwArgs) {\n      args = (args || []);\n      args.push('Spacebars.kw(' + makeObjectLiteral(kwArgs) + ')');\n    }\n\n    return args;\n  },\n\n  codeGenBlock: function (content) {\n    return SpacebarsCompiler.codeGen(content);\n  },\n\n  codeGenInclusionData: function (args) {\n    var self = this;\n\n    if (! args.length) {\n      // e.g. `{{#foo}}`\n      return null;\n    } else if (args[0].length === 3) {\n      // keyword arguments only, e.g. `{{> point x=1 y=2}}`\n      var dataProps = {};\n      _.each(args, function (arg) {\n        var argKey = arg[2];\n        dataProps[argKey] = 'Spacebars.call(' + self.codeGenArgValue(arg) + ')';\n      });\n      return makeObjectLiteral(dataProps);\n    } else if (args[0][0] !== 'PATH') {\n      // literal first argument, e.g. `{{> foo \"blah\"}}`\n      //\n      // tag validation has confirmed, in this case, that there is only\n      // one argument (`args.length === 1`)\n      return self.codeGenArgValue(args[0]);\n    } else if (args.length === 1) {\n      // one argument, must be a PATH\n      return 'Spacebars.call(' + self.codeGenPath(args[0][1]) + ')';\n    } else {\n      // Multiple positional arguments; treat them as a nested\n      // \"data mustache\"\n      return self.codeGenMustache(args[0][1], args.slice(1),\n                                  'dataMustache');\n    }\n\n  },\n\n  codeGenInclusionDataFunc: function (args) {\n    var self = this;\n    var dataCode = self.codeGenInclusionData(args);\n    if (dataCode) {\n      return 'function () { return ' + dataCode + '; }';\n    } else {\n      return null;\n    }\n  }\n\n});\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                     //\n// packages/spacebars-compiler/compiler.js                                                             //\n//                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                       //\n\nSpacebarsCompiler.parse = function (input) {\n\n  var tree = HTMLTools.parseFragment(\n    input,\n    { getTemplateTag: TemplateTag.parseCompleteTag });\n\n  return tree;\n};\n\nSpacebarsCompiler.compile = function (input, options) {\n  var tree = SpacebarsCompiler.parse(input);\n  return SpacebarsCompiler.codeGen(tree, options);\n};\n\nSpacebarsCompiler._TemplateTagReplacer = HTML.TransformingVisitor.extend();\nSpacebarsCompiler._TemplateTagReplacer.def({\n  visitObject: function (x) {\n    if (x instanceof HTMLTools.TemplateTag) {\n\n      // Make sure all TemplateTags in attributes have the right\n      // `.position` set on them.  This is a bit of a hack\n      // (we shouldn't be mutating that here), but it allows\n      // cleaner codegen of \"synthetic\" attributes like TEXTAREA's\n      // \"value\", where the template tags were originally not\n      // in an attribute.\n      if (this.inAttributeValue)\n        x.position = HTMLTools.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE;\n\n      return this.codegen.codeGenTemplateTag(x);\n    }\n\n    return HTML.TransformingVisitor.prototype.visitObject.call(this, x);\n  },\n  visitAttributes: function (attrs) {\n    if (attrs instanceof HTMLTools.TemplateTag)\n      return this.codegen.codeGenTemplateTag(attrs);\n\n    // call super (e.g. for case where `attrs` is an array)\n    return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);\n  },\n  visitAttribute: function (name, value, tag) {\n    this.inAttributeValue = true;\n    var result = this.visit(value);\n    this.inAttributeValue = false;\n\n    if (result !== value) {\n      // some template tags must have been replaced, because otherwise\n      // we try to keep things `===` when transforming.  Wrap the code\n      // in a function as per the rules.  You can't have\n      // `{id: Blaze.View(...)}` as an attributes dict because the View\n      // would be rendered more than once; you need to wrap it in a function\n      // so that it's a different View each time.\n      return BlazeTools.EmitCode(this.codegen.codeGenBlock(result));\n    }\n    return result;\n  }\n});\n\nSpacebarsCompiler.codeGen = function (parseTree, options) {\n  // is this a template, rather than a block passed to\n  // a block helper, say\n  var isTemplate = (options && options.isTemplate);\n  var isBody = (options && options.isBody);\n  var sourceName = (options && options.sourceName);\n\n  var tree = parseTree;\n\n  // The flags `isTemplate` and `isBody` are kind of a hack.\n  if (isTemplate || isBody) {\n    // optimizing fragments would require being smarter about whether we are\n    // in a TEXTAREA, say.\n    tree = SpacebarsCompiler.optimize(tree);\n  }\n\n  // throws an error if using `{{> React}}` with siblings\n  new ReactComponentSiblingForbidder({sourceName: sourceName})\n    .visit(tree);\n\n  var codegen = new SpacebarsCompiler.CodeGen;\n  tree = (new SpacebarsCompiler._TemplateTagReplacer(\n    {codegen: codegen})).visit(tree);\n\n  var code = '(function () { ';\n  if (isTemplate || isBody) {\n    code += 'var view = this; ';\n  }\n  code += 'return ';\n  code += BlazeTools.toJS(tree);\n  code += '; })';\n\n  code = SpacebarsCompiler._beautify(code);\n\n  return code;\n};\n\nSpacebarsCompiler._beautify = function (code) {\n  if (Package['minifier-js'] && Package['minifier-js'].UglifyJSMinify) {\n    var result = Package['minifier-js'].UglifyJSMinify(\n      code,\n      { fromString: true,\n        mangle: false,\n        compress: false,\n        output: { beautify: true,\n                  indent_level: 2,\n                  width: 80 } });\n    var output = result.code;\n    // Uglify interprets our expression as a statement and may add a semicolon.\n    // Strip trailing semicolon.\n    output = output.replace(/;$/, '');\n    return output;\n  } else {\n    // don't actually beautify; no UglifyJS\n    return code;\n  }\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['spacebars-compiler'] = {}, {\n  SpacebarsCompiler: SpacebarsCompiler\n});\n\n})();\n\n//# sourceMappingURL=spacebars-compiler.js.map\n"]},"hash":"3b55f89e9333d8ad89cb516a7d1fa85d3b37301c"}

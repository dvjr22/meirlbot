{"metadata":{"usedHelpers":["typeof"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/promise.js","filenameRelative":"/bundle/programs/server/packages/promise.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/promise.js.map","sourceFileName":"/bundle/programs/server/packages/promise.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"promise"},"ignored":false,"code":"var _typeof;module.import(\"babel-runtime/helpers/typeof\",{\"default\":function(v){_typeof=v}});\n(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var meteorInstall = Package.modules.meteorInstall;\n  var Buffer = Package.modules.Buffer;\n  var process = Package.modules.process;\n\n  /* Package-scope variables */\n  var Promise;\n\n  var require = meteorInstall({ \"node_modules\": { \"meteor\": { \"promise\": { \"server.js\": [\"meteor-promise\", \"./common.js\", \"fibers\", function (require, exports) {\n\n            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                  //\n            // packages/promise/server.js                                                                                       //\n            //                                                                                                                  //\n            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            require(\"meteor-promise\").makeCompatible(exports.Promise = require(\"./common.js\").Promise,\n            // Allow every Promise callback to run in a Fiber drawn from a pool of\n            // reusable Fibers.\n            require(\"fibers\"));\n\n            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }], \"common.js\": [\"promise/lib/es6-extensions\", function (require, exports) {\n\n            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                  //\n            // packages/promise/common.js                                                                                       //\n            //                                                                                                                  //\n            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            var global = this;\n\n            if (typeof global.Promise === \"function\") {\n              exports.Promise = global.Promise;\n            } else {\n              exports.Promise = require(\"promise/lib/es6-extensions\");\n            }\n\n            exports.Promise.prototype.done = function (onFulfilled, onRejected) {\n              var self = this;\n\n              if (arguments.length > 0) {\n                self = this.then.apply(this, arguments);\n              }\n\n              self.then(null, function (err) {\n                Meteor._setImmediate(function () {\n                  throw err;\n                });\n              });\n            };\n\n            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }], \"node_modules\": { \"meteor-promise\": { \"package.json\": function packageJson(require, exports) {\n\n                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                //                                                                                                                  //\n                // ../npm/node_modules/meteor-promise/package.json                                                                  //\n                //                                                                                                                  //\n                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                //\n                exports.name = \"meteor-promise\";\n                exports.version = \"0.7.4\";\n                exports.main = \"promise_server.js\";\n\n                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n              }, \"promise_server.js\": [\"assert\", \"./fiber_pool.js\", function (require, exports) {\n\n                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                //                                                                                                                  //\n                // node_modules/meteor/promise/node_modules/meteor-promise/promise_server.js                                        //\n                //                                                                                                                  //\n                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                //\n                var assert = require(\"assert\");\n                var fiberPool = require(\"./fiber_pool.js\").makePool();\n\n                exports.makeCompatible = function (Promise, Fiber) {\n                  var es6PromiseThen = Promise.prototype.then;\n\n                  if (typeof Fiber === \"function\") {\n                    Promise.Fiber = Fiber;\n                  }\n\n                  // Replace Promise.prototype.then with a wrapper that ensures the\n                  // onResolved and onRejected callbacks always run in a Fiber.\n                  Promise.prototype.then = function (onResolved, onRejected) {\n                    var P = this.constructor;\n\n                    if (typeof P.Fiber === \"function\") {\n                      var fiber = P.Fiber.current;\n                      var dynamics = cloneFiberOwnProperties(fiber);\n\n                      return es6PromiseThen.call(this, wrapCallback(onResolved, P, dynamics), wrapCallback(onRejected, P, dynamics));\n                    }\n\n                    return es6PromiseThen.call(this, onResolved, onRejected);\n                  };\n\n                  Promise.awaitAll = function (args) {\n                    return awaitPromise(this.all(args));\n                  };\n\n                  Promise.await = function (arg) {\n                    return awaitPromise(this.resolve(arg));\n                  };\n\n                  Promise.prototype.await = function () {\n                    return awaitPromise(this);\n                  };\n\n                  // Yield the current Fiber until the given Promise has been fulfilled.\n                  function awaitPromise(promise) {\n                    var Promise = promise.constructor;\n                    var Fiber = Promise.Fiber;\n\n                    assert.strictEqual(typeof Fiber === \"undefined\" ? \"undefined\" : _typeof(Fiber), \"function\", \"Cannot await unless Promise.Fiber is defined\");\n\n                    var fiber = Fiber.current;\n\n                    assert.ok(fiber instanceof Fiber, \"Cannot await without a Fiber\");\n\n                    var run = fiber.run;\n                    var throwInto = fiber.throwInto;\n\n                    if (process.domain) {\n                      run = process.domain.bind(run);\n                      throwInto = process.domain.bind(throwInto);\n                    }\n\n                    // The overridden es6PromiseThen function is adequate here because these\n                    // two callbacks do not need to run in a Fiber.\n                    es6PromiseThen.call(promise, function (result) {\n                      tryCatchNextTick(fiber, run, [result]);\n                    }, function (error) {\n                      tryCatchNextTick(fiber, throwInto, [error]);\n                    });\n\n                    return Fiber[\"yield\"]();\n                  }\n\n                  // Return a wrapper function that returns a Promise for the eventual\n                  // result of the original function.\n                  Promise.async = function (fn, allowReuseOfCurrentFiber) {\n                    var Promise = this;\n                    return function () {\n                      return Promise.asyncApply(fn, this, arguments, allowReuseOfCurrentFiber);\n                    };\n                  };\n\n                  Promise.asyncApply = function (fn, context, args, allowReuseOfCurrentFiber) {\n                    var Promise = this;\n                    var Fiber = Promise.Fiber;\n                    var fiber = Fiber && Fiber.current;\n\n                    if (fiber && allowReuseOfCurrentFiber) {\n                      return this.resolve(fn.apply(context, args));\n                    }\n\n                    return fiberPool.run({\n                      callback: fn,\n                      context: context,\n                      args: args,\n                      dynamics: cloneFiberOwnProperties(fiber)\n                    }, Promise);\n                  };\n                };\n\n                function wrapCallback(callback, Promise, dynamics) {\n                  if (!callback) {\n                    return callback;\n                  }\n\n                  // Don't wrap callbacks that are flagged as not wanting to be called in a\n                  // fiber.\n                  if (callback._meteorPromiseAlreadyWrapped) {\n                    return callback;\n                  }\n\n                  var result = function result(arg) {\n                    return fiberPool.run({\n                      callback: callback,\n                      args: [arg], // Avoid dealing with arguments objects.\n                      dynamics: dynamics\n                    }, Promise);\n                  };\n\n                  // Flag this callback as not wanting to be called in a fiber because it is\n                  // already creating a fiber.\n                  result._meteorPromiseAlreadyWrapped = true;\n\n                  return result;\n                }\n\n                function cloneFiberOwnProperties(fiber) {\n                  if (fiber) {\n                    var dynamics = {};\n\n                    Object.keys(fiber).forEach(function (key) {\n                      dynamics[key] = shallowClone(fiber[key]);\n                    });\n\n                    return dynamics;\n                  }\n                }\n\n                function shallowClone(value) {\n                  if (Array.isArray(value)) {\n                    return value.slice(0);\n                  }\n\n                  if (value && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\") {\n                    var copy = Object.create(Object.getPrototypeOf(value));\n                    var keys = Object.keys(value);\n                    var keyCount = keys.length;\n\n                    for (var i = 0; i < keyCount; ++i) {\n                      var key = keys[i];\n                      copy[key] = value[key];\n                    }\n\n                    return copy;\n                  }\n\n                  return value;\n                }\n\n                // Invoke method with args against object in a try-catch block,\n                // re-throwing any exceptions in the next tick of the event loop, so that\n                // they won't get captured/swallowed by the caller.\n                function tryCatchNextTick(object, method, args) {\n                  try {\n                    return method.apply(object, args);\n                  } catch (error) {\n                    process.nextTick(function () {\n                      throw error;\n                    });\n                  }\n                }\n\n                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n              }], \"fiber_pool.js\": [\"assert\", function (require, exports) {\n\n                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                //                                                                                                                  //\n                // node_modules/meteor/promise/node_modules/meteor-promise/fiber_pool.js                                            //\n                //                                                                                                                  //\n                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                //\n                var assert = require(\"assert\");\n\n                function FiberPool(targetFiberCount) {\n                  assert.ok(this instanceof FiberPool);\n                  assert.strictEqual(typeof targetFiberCount === \"undefined\" ? \"undefined\" : _typeof(targetFiberCount), \"number\");\n\n                  var fiberStack = [];\n\n                  function makeNewFiber(Fiber) {\n                    // Just in case someone tampers with Fiber.yield, don't let that interfere\n                    // with our processing of the callback queue.\n                    var originalYield = Fiber[\"yield\"];\n\n                    var fiber = new Fiber(function () {\n                      while (true) {\n                        // Call Fiber.yield() to await further instructions.\n                        var entry = originalYield.call(Fiber);\n\n                        // Ensure this Fiber is no longer in the pool once it begins to\n                        // execute an entry.\n                        assert.strictEqual(fiberStack.indexOf(fiber), -1);\n\n                        if (entry.dynamics) {\n                          // Restore the dynamic environment of this fiber as if\n                          // entry.callback had been wrapped by Meteor.bindEnvironment.\n                          Object.keys(entry.dynamics).forEach(function (key) {\n                            fiber[key] = entry.dynamics[key];\n                          });\n                        }\n\n                        try {\n                          var result = entry.callback.apply(entry.context || null, entry.args || []);\n\n                          setImmediate(entry.resolve.bind(entry, result));\n                        } catch (error) {\n                          setImmediate(entry.reject.bind(entry, error));\n                        }\n\n                        // Remove all own properties of the fiber before returning it to\n                        // the pool.\n                        Object.keys(fiber).forEach(function (key) {\n                          delete fiber[key];\n                        });\n\n                        if (fiberStack.length < targetFiberCount) {\n                          fiberStack.push(fiber);\n                        } else {\n                          // If the pool has already reached the target maximum number of\n                          // Fibers, don't bother recycling this Fiber.\n                          break;\n                        }\n                      }\n                    });\n\n                    // Run the new Fiber up to the first yield point, so that it will be\n                    // ready to receive entries.\n                    fiber.run();\n\n                    return fiber;\n                  }\n\n                  // Run the entry.callback function in a Fiber either taken from the pool\n                  // or created anew if the pool is empty. This method returns a Promise\n                  // for the eventual result of the entry.callback function.\n                  this.run = function (entry, Promise) {\n                    assert.strictEqual(typeof entry === \"undefined\" ? \"undefined\" : _typeof(entry), \"object\");\n                    assert.strictEqual(_typeof(entry.callback), \"function\");\n\n                    if (typeof Promise.Fiber !== \"function\") {\n                      return new Promise(function (resolve) {\n                        resolve(entry.callback.apply(entry.context || null, entry.args));\n                      });\n                    }\n\n                    var fiber = fiberStack.pop() || makeNewFiber(Promise.Fiber);\n\n                    var promise = new Promise(function (resolve, reject) {\n                      entry.resolve = resolve;\n                      entry.reject = reject;\n                    });\n\n                    fiber.run(entry);\n\n                    return promise;\n                  };\n\n                  // Limit the maximum number of idle Fibers that may be kept in the\n                  // pool. Note that the run method will never refuse to create a new\n                  // Fiber if the pool is empty; it's just that excess Fibers might be\n                  // thrown away upon completion, if the pool is full.\n                  this.setTargetFiberCount = function (limit) {\n                    assert.strictEqual(typeof limit === \"undefined\" ? \"undefined\" : _typeof(limit), \"number\");\n\n                    targetFiberCount = Math.max(limit, 0);\n\n                    if (targetFiberCount < fiberStack.length) {\n                      // If the requested target count is less than the current length of\n                      // the stack, truncate the stack and terminate any surplus Fibers.\n                      fiberStack.splice(targetFiberCount).forEach(function (fiber) {\n                        fiber.reset();\n                      });\n                    }\n\n                    return this;\n                  };\n                }\n\n                // Call pool.drain() to terminate all Fibers waiting in the pool and\n                // signal to any outstanding Fibers that they should exit upon completion,\n                // instead of reinserting themselves into the pool.\n                FiberPool.prototype.drain = function () {\n                  return this.setTargetFiberCount(0);\n                };\n\n                exports.makePool = function (targetFiberCount) {\n                  return new FiberPool(targetFiberCount || 20);\n                };\n\n                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n              }] }, \"promise\": { \"lib\": { \"es6-extensions.js\": [\"./core.js\", function (require, exports, module) {\n\n                  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                  //                                                                                                                  //\n                  // node_modules/meteor/promise/node_modules/promise/lib/es6-extensions.js                                           //\n                  //                                                                                                                  //\n                  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                  //\n                  'use strict';\n\n                  //This file contains the ES6 extensions to the core Promises/A+ API\n\n                  var Promise = require('./core.js');\n\n                  module.exports = Promise;\n\n                  /* Static Functions */\n\n                  var TRUE = valuePromise(true);\n                  var FALSE = valuePromise(false);\n                  var NULL = valuePromise(null);\n                  var UNDEFINED = valuePromise(undefined);\n                  var ZERO = valuePromise(0);\n                  var EMPTYSTRING = valuePromise('');\n\n                  function valuePromise(value) {\n                    var p = new Promise(Promise._61);\n                    p._81 = 1;\n                    p._65 = value;\n                    return p;\n                  }\n                  Promise.resolve = function (value) {\n                    if (value instanceof Promise) return value;\n\n                    if (value === null) return NULL;\n                    if (value === undefined) return UNDEFINED;\n                    if (value === true) return TRUE;\n                    if (value === false) return FALSE;\n                    if (value === 0) return ZERO;\n                    if (value === '') return EMPTYSTRING;\n\n                    if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === 'object' || typeof value === 'function') {\n                      try {\n                        var then = value.then;\n                        if (typeof then === 'function') {\n                          return new Promise(then.bind(value));\n                        }\n                      } catch (ex) {\n                        return new Promise(function (resolve, reject) {\n                          reject(ex);\n                        });\n                      }\n                    }\n                    return valuePromise(value);\n                  };\n\n                  Promise.all = function (arr) {\n                    var args = Array.prototype.slice.call(arr);\n\n                    return new Promise(function (resolve, reject) {\n                      if (args.length === 0) return resolve([]);\n                      var remaining = args.length;\n                      function res(i, val) {\n                        if (val && ((typeof val === \"undefined\" ? \"undefined\" : _typeof(val)) === 'object' || typeof val === 'function')) {\n                          if (val instanceof Promise && val.then === Promise.prototype.then) {\n                            while (val._81 === 3) {\n                              val = val._65;\n                            }\n                            if (val._81 === 1) return res(i, val._65);\n                            if (val._81 === 2) reject(val._65);\n                            val.then(function (val) {\n                              res(i, val);\n                            }, reject);\n                            return;\n                          } else {\n                            var then = val.then;\n                            if (typeof then === 'function') {\n                              var p = new Promise(then.bind(val));\n                              p.then(function (val) {\n                                res(i, val);\n                              }, reject);\n                              return;\n                            }\n                          }\n                        }\n                        args[i] = val;\n                        if (--remaining === 0) {\n                          resolve(args);\n                        }\n                      }\n                      for (var i = 0; i < args.length; i++) {\n                        res(i, args[i]);\n                      }\n                    });\n                  };\n\n                  Promise.reject = function (value) {\n                    return new Promise(function (resolve, reject) {\n                      reject(value);\n                    });\n                  };\n\n                  Promise.race = function (values) {\n                    return new Promise(function (resolve, reject) {\n                      values.forEach(function (value) {\n                        Promise.resolve(value).then(resolve, reject);\n                      });\n                    });\n                  };\n\n                  /* Prototype Methods */\n\n                  Promise.prototype['catch'] = function (onRejected) {\n                    return this.then(null, onRejected);\n                  };\n\n                  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                }], \"core.js\": [\"asap/raw\", function (require, exports, module) {\n\n                  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                  //                                                                                                                  //\n                  // node_modules/meteor/promise/node_modules/promise/lib/core.js                                                     //\n                  //                                                                                                                  //\n                  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                  //\n                  'use strict';\n\n                  var asap = require('asap/raw');\n\n                  function noop() {}\n\n                  // States:\n                  //\n                  // 0 - pending\n                  // 1 - fulfilled with _value\n                  // 2 - rejected with _value\n                  // 3 - adopted the state of another promise, _value\n                  //\n                  // once the state is no longer pending (0) it is immutable\n\n                  // All `_` prefixed properties will be reduced to `_{random number}`\n                  // at build time to obfuscate them and discourage their use.\n                  // We don't use symbols or Object.defineProperty to fully hide them\n                  // because the performance isn't good enough.\n\n                  // to avoid using try/catch inside critical functions, we\n                  // extract them to here.\n                  var LAST_ERROR = null;\n                  var IS_ERROR = {};\n                  function getThen(obj) {\n                    try {\n                      return obj.then;\n                    } catch (ex) {\n                      LAST_ERROR = ex;\n                      return IS_ERROR;\n                    }\n                  }\n\n                  function tryCallOne(fn, a) {\n                    try {\n                      return fn(a);\n                    } catch (ex) {\n                      LAST_ERROR = ex;\n                      return IS_ERROR;\n                    }\n                  }\n                  function tryCallTwo(fn, a, b) {\n                    try {\n                      fn(a, b);\n                    } catch (ex) {\n                      LAST_ERROR = ex;\n                      return IS_ERROR;\n                    }\n                  }\n\n                  module.exports = Promise;\n\n                  function Promise(fn) {\n                    if (_typeof(this) !== 'object') {\n                      throw new TypeError('Promises must be constructed via new');\n                    }\n                    if (typeof fn !== 'function') {\n                      throw new TypeError('not a function');\n                    }\n                    this._45 = 0;\n                    this._81 = 0;\n                    this._65 = null;\n                    this._54 = null;\n                    if (fn === noop) return;\n                    doResolve(fn, this);\n                  }\n                  Promise._10 = null;\n                  Promise._97 = null;\n                  Promise._61 = noop;\n\n                  Promise.prototype.then = function (onFulfilled, onRejected) {\n                    if (this.constructor !== Promise) {\n                      return safeThen(this, onFulfilled, onRejected);\n                    }\n                    var res = new Promise(noop);\n                    handle(this, new Handler(onFulfilled, onRejected, res));\n                    return res;\n                  };\n\n                  function safeThen(self, onFulfilled, onRejected) {\n                    return new self.constructor(function (resolve, reject) {\n                      var res = new Promise(noop);\n                      res.then(resolve, reject);\n                      handle(self, new Handler(onFulfilled, onRejected, res));\n                    });\n                  };\n                  function handle(self, deferred) {\n                    while (self._81 === 3) {\n                      self = self._65;\n                    }\n                    if (Promise._10) {\n                      Promise._10(self);\n                    }\n                    if (self._81 === 0) {\n                      if (self._45 === 0) {\n                        self._45 = 1;\n                        self._54 = deferred;\n                        return;\n                      }\n                      if (self._45 === 1) {\n                        self._45 = 2;\n                        self._54 = [self._54, deferred];\n                        return;\n                      }\n                      self._54.push(deferred);\n                      return;\n                    }\n                    handleResolved(self, deferred);\n                  }\n\n                  function handleResolved(self, deferred) {\n                    asap(function () {\n                      var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n                      if (cb === null) {\n                        if (self._81 === 1) {\n                          resolve(deferred.promise, self._65);\n                        } else {\n                          reject(deferred.promise, self._65);\n                        }\n                        return;\n                      }\n                      var ret = tryCallOne(cb, self._65);\n                      if (ret === IS_ERROR) {\n                        reject(deferred.promise, LAST_ERROR);\n                      } else {\n                        resolve(deferred.promise, ret);\n                      }\n                    });\n                  }\n                  function resolve(self, newValue) {\n                    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n                    if (newValue === self) {\n                      return reject(self, new TypeError('A promise cannot be resolved with itself.'));\n                    }\n                    if (newValue && ((typeof newValue === \"undefined\" ? \"undefined\" : _typeof(newValue)) === 'object' || typeof newValue === 'function')) {\n                      var then = getThen(newValue);\n                      if (then === IS_ERROR) {\n                        return reject(self, LAST_ERROR);\n                      }\n                      if (then === self.then && newValue instanceof Promise) {\n                        self._81 = 3;\n                        self._65 = newValue;\n                        finale(self);\n                        return;\n                      } else if (typeof then === 'function') {\n                        doResolve(then.bind(newValue), self);\n                        return;\n                      }\n                    }\n                    self._81 = 1;\n                    self._65 = newValue;\n                    finale(self);\n                  }\n\n                  function reject(self, newValue) {\n                    self._81 = 2;\n                    self._65 = newValue;\n                    if (Promise._97) {\n                      Promise._97(self, newValue);\n                    }\n                    finale(self);\n                  }\n                  function finale(self) {\n                    if (self._45 === 1) {\n                      handle(self, self._54);\n                      self._54 = null;\n                    }\n                    if (self._45 === 2) {\n                      for (var i = 0; i < self._54.length; i++) {\n                        handle(self, self._54[i]);\n                      }\n                      self._54 = null;\n                    }\n                  }\n\n                  function Handler(onFulfilled, onRejected, promise) {\n                    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n                    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n                    this.promise = promise;\n                  }\n\n                  /**\n                   * Take a potentially misbehaving resolver function and make sure\n                   * onFulfilled and onRejected are only called once.\n                   *\n                   * Makes no guarantees about asynchrony.\n                   */\n                  function doResolve(fn, promise) {\n                    var done = false;\n                    var res = tryCallTwo(fn, function (value) {\n                      if (done) return;\n                      done = true;\n                      resolve(promise, value);\n                    }, function (reason) {\n                      if (done) return;\n                      done = true;\n                      reject(promise, reason);\n                    });\n                    if (!done && res === IS_ERROR) {\n                      done = true;\n                      reject(promise, LAST_ERROR);\n                    }\n                  }\n\n                  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                }] } }, \"asap\": { \"raw.js\": [\"domain\", function (require, exports, module) {\n\n                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                //                                                                                                                  //\n                // node_modules/meteor/promise/node_modules/asap/raw.js                                                             //\n                //                                                                                                                  //\n                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                //\n                \"use strict\";\n\n                var domain; // The domain module is executed on demand\n                var hasSetImmediate = typeof setImmediate === \"function\";\n\n                // Use the fastest means possible to execute a task in its own turn, with\n                // priority over other events including network IO events in Node.js.\n                //\n                // An exception thrown by a task will permanently interrupt the processing of\n                // subsequent tasks. The higher level `asap` function ensures that if an\n                // exception is thrown by a task, that the task queue will continue flushing as\n                // soon as possible, but if you use `rawAsap` directly, you are responsible to\n                // either ensure that no exceptions are thrown from your task, or to manually\n                // call `rawAsap.requestFlush` if an exception is thrown.\n                module.exports = rawAsap;\n                function rawAsap(task) {\n                  if (!queue.length) {\n                    requestFlush();\n                    flushing = true;\n                  }\n                  // Avoids a function call\n                  queue[queue.length] = task;\n                }\n\n                var queue = [];\n                // Once a flush has been requested, no further calls to `requestFlush` are\n                // necessary until the next `flush` completes.\n                var flushing = false;\n                // The position of the next task to execute in the task queue. This is\n                // preserved between calls to `flush` so that it can be resumed if\n                // a task throws an exception.\n                var index = 0;\n                // If a task schedules additional tasks recursively, the task queue can grow\n                // unbounded. To prevent memory excaustion, the task queue will periodically\n                // truncate already-completed tasks.\n                var capacity = 1024;\n\n                // The flush function processes all tasks that have been scheduled with\n                // `rawAsap` unless and until one of those tasks throws an exception.\n                // If a task throws an exception, `flush` ensures that its state will remain\n                // consistent and will resume where it left off when called again.\n                // However, `flush` does not make any arrangements to be called again if an\n                // exception is thrown.\n                function flush() {\n                  while (index < queue.length) {\n                    var currentIndex = index;\n                    // Advance the index before calling the task. This ensures that we will\n                    // begin flushing on the next task the task throws an error.\n                    index = index + 1;\n                    queue[currentIndex].call();\n                    // Prevent leaking memory for long chains of recursive calls to `asap`.\n                    // If we call `asap` within tasks scheduled by `asap`, the queue will\n                    // grow, but to avoid an O(n) walk for every task we execute, we don't\n                    // shift tasks off the queue after they have been executed.\n                    // Instead, we periodically shift 1024 tasks off the queue.\n                    if (index > capacity) {\n                      // Manually shift all values starting at the index back to the\n                      // beginning of the queue.\n                      for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                        queue[scan] = queue[scan + index];\n                      }\n                      queue.length -= index;\n                      index = 0;\n                    }\n                  }\n                  queue.length = 0;\n                  index = 0;\n                  flushing = false;\n                }\n\n                rawAsap.requestFlush = requestFlush;\n                function requestFlush() {\n                  // Ensure flushing is not bound to any domain.\n                  // It is not sufficient to exit the domain, because domains exist on a stack.\n                  // To execute code outside of any domain, the following dance is necessary.\n                  var parentDomain = process.domain;\n                  if (parentDomain) {\n                    if (!domain) {\n                      // Lazy execute the domain module.\n                      // Only employed if the user elects to use domains.\n                      domain = require(\"domain\");\n                    }\n                    domain.active = process.domain = null;\n                  }\n\n                  // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`\n                  // cannot handle recursion.\n                  // `requestFlush` will only be called recursively from `asap.js`, to resume\n                  // flushing after an error is thrown into a domain.\n                  // Conveniently, `setImmediate` was introduced in the same version\n                  // `process.nextTick` started throwing recursion errors.\n                  if (flushing && hasSetImmediate) {\n                    setImmediate(flush);\n                  } else {\n                    process.nextTick(flush);\n                  }\n\n                  if (parentDomain) {\n                    domain.active = process.domain = parentDomain;\n                  }\n                }\n\n                //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n              }] } } } } } }, { \"extensions\": [\".js\", \".json\"] });\n  var exports = require(\"./node_modules/meteor/promise/server.js\");\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package.promise = exports, {\n    Promise: Promise\n  });\n})();\n\n//# sourceMappingURL=promise.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/promise.js"],"names":[],"mappings":"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","file":"/bundle/programs/server/packages/promise.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Buffer = Package.modules.Buffer;\nvar process = Package.modules.process;\n\n/* Package-scope variables */\nvar Promise;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"promise\":{\"server.js\":[\"meteor-promise\",\"./common.js\",\"fibers\",function(require,exports){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// packages/promise/server.js                                                                                       //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nrequire(\"meteor-promise\").makeCompatible(\n  exports.Promise = require(\"./common.js\").Promise,\n  // Allow every Promise callback to run in a Fiber drawn from a pool of\n  // reusable Fibers.\n  require(\"fibers\")\n);\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"common.js\":[\"promise/lib/es6-extensions\",function(require,exports){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// packages/promise/common.js                                                                                       //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nvar global = this;\n\nif (typeof global.Promise === \"function\") {\n  exports.Promise = global.Promise;\n} else {\n  exports.Promise = require(\"promise/lib/es6-extensions\");\n}\n\nexports.Promise.prototype.done = function (onFulfilled, onRejected) {\n  var self = this;\n\n  if (arguments.length > 0) {\n    self = this.then.apply(this, arguments);\n  }\n\n  self.then(null, function (err) {\n    Meteor._setImmediate(function () {\n      throw err;\n    });\n  });\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"node_modules\":{\"meteor-promise\":{\"package.json\":function(require,exports){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// ../npm/node_modules/meteor-promise/package.json                                                                  //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nexports.name = \"meteor-promise\";\nexports.version = \"0.7.4\";\nexports.main = \"promise_server.js\";\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"promise_server.js\":[\"assert\",\"./fiber_pool.js\",function(require,exports){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/meteor-promise/promise_server.js                                        //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nvar assert = require(\"assert\");\nvar fiberPool = require(\"./fiber_pool.js\").makePool();\n\nexports.makeCompatible = function (Promise, Fiber) {\n  var es6PromiseThen = Promise.prototype.then;\n\n  if (typeof Fiber === \"function\") {\n    Promise.Fiber = Fiber;\n  }\n\n  // Replace Promise.prototype.then with a wrapper that ensures the\n  // onResolved and onRejected callbacks always run in a Fiber.\n  Promise.prototype.then = function (onResolved, onRejected) {\n    var P = this.constructor;\n\n    if (typeof P.Fiber === \"function\") {\n      var fiber = P.Fiber.current;\n      var dynamics = cloneFiberOwnProperties(fiber);\n\n      return es6PromiseThen.call(\n        this,\n        wrapCallback(onResolved, P, dynamics),\n        wrapCallback(onRejected, P, dynamics)\n      );\n    }\n\n    return es6PromiseThen.call(this, onResolved, onRejected);\n  };\n\n  Promise.awaitAll = function (args) {\n    return awaitPromise(this.all(args));\n  };\n\n  Promise.await = function (arg) {\n    return awaitPromise(this.resolve(arg));\n  };\n\n  Promise.prototype.await = function () {\n    return awaitPromise(this);\n  };\n\n  // Yield the current Fiber until the given Promise has been fulfilled.\n  function awaitPromise(promise) {\n    var Promise = promise.constructor;\n    var Fiber = Promise.Fiber;\n\n    assert.strictEqual(\n      typeof Fiber, \"function\",\n      \"Cannot await unless Promise.Fiber is defined\"\n    );\n\n    var fiber = Fiber.current;\n\n    assert.ok(\n      fiber instanceof Fiber,\n      \"Cannot await without a Fiber\"\n    );\n\n    var run = fiber.run;\n    var throwInto = fiber.throwInto;\n\n    if (process.domain) {\n      run = process.domain.bind(run);\n      throwInto = process.domain.bind(throwInto);\n    }\n\n    // The overridden es6PromiseThen function is adequate here because these\n    // two callbacks do not need to run in a Fiber.\n    es6PromiseThen.call(promise, function (result) {\n      tryCatchNextTick(fiber, run, [result]);\n    }, function (error) {\n      tryCatchNextTick(fiber, throwInto, [error]);\n    });\n\n    return Fiber.yield();\n  }\n\n  // Return a wrapper function that returns a Promise for the eventual\n  // result of the original function.\n  Promise.async = function (fn, allowReuseOfCurrentFiber) {\n    var Promise = this;\n    return function () {\n      return Promise.asyncApply(\n        fn, this, arguments,\n        allowReuseOfCurrentFiber\n      );\n    };\n  };\n\n  Promise.asyncApply = function (\n    fn, context, args, allowReuseOfCurrentFiber\n  ) {\n    var Promise = this;\n    var Fiber = Promise.Fiber;\n    var fiber = Fiber && Fiber.current;\n\n    if (fiber && allowReuseOfCurrentFiber) {\n      return this.resolve(fn.apply(context, args));\n    }\n\n    return fiberPool.run({\n      callback: fn,\n      context: context,\n      args: args,\n      dynamics: cloneFiberOwnProperties(fiber)\n    }, Promise);\n  };\n};\n\nfunction wrapCallback(callback, Promise, dynamics) {\n  if (! callback) {\n    return callback;\n  }\n\n  // Don't wrap callbacks that are flagged as not wanting to be called in a\n  // fiber.\n  if (callback._meteorPromiseAlreadyWrapped) {\n    return callback;\n  }\n\n  var result = function (arg) {\n    return fiberPool.run({\n      callback: callback,\n      args: [arg], // Avoid dealing with arguments objects.\n      dynamics: dynamics\n    }, Promise);\n  };\n\n  // Flag this callback as not wanting to be called in a fiber because it is\n  // already creating a fiber.\n  result._meteorPromiseAlreadyWrapped = true;\n\n  return result;\n}\n\nfunction cloneFiberOwnProperties(fiber) {\n  if (fiber) {\n    var dynamics = {};\n\n    Object.keys(fiber).forEach(function (key) {\n      dynamics[key] = shallowClone(fiber[key]);\n    });\n\n    return dynamics;\n  }\n}\n\nfunction shallowClone(value) {\n  if (Array.isArray(value)) {\n    return value.slice(0);\n  }\n\n  if (value && typeof value === \"object\") {\n    var copy = Object.create(Object.getPrototypeOf(value));\n    var keys = Object.keys(value);\n    var keyCount = keys.length;\n\n    for (var i = 0; i < keyCount; ++i) {\n      var key = keys[i];\n      copy[key] = value[key];\n    }\n\n    return copy;\n  }\n\n  return value;\n}\n\n// Invoke method with args against object in a try-catch block,\n// re-throwing any exceptions in the next tick of the event loop, so that\n// they won't get captured/swallowed by the caller.\nfunction tryCatchNextTick(object, method, args) {\n  try {\n    return method.apply(object, args);\n  } catch (error) {\n    process.nextTick(function () {\n      throw error;\n    });\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"fiber_pool.js\":[\"assert\",function(require,exports){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/meteor-promise/fiber_pool.js                                            //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\nvar assert = require(\"assert\");\n\nfunction FiberPool(targetFiberCount) {\n  assert.ok(this instanceof FiberPool);\n  assert.strictEqual(typeof targetFiberCount, \"number\");\n\n  var fiberStack = [];\n\n  function makeNewFiber(Fiber) {\n    // Just in case someone tampers with Fiber.yield, don't let that interfere\n    // with our processing of the callback queue.\n    var originalYield = Fiber.yield;\n\n    var fiber = new Fiber(function () {\n      while (true) {\n        // Call Fiber.yield() to await further instructions.\n        var entry = originalYield.call(Fiber);\n\n        // Ensure this Fiber is no longer in the pool once it begins to\n        // execute an entry.\n        assert.strictEqual(fiberStack.indexOf(fiber), -1);\n\n        if (entry.dynamics) {\n          // Restore the dynamic environment of this fiber as if\n          // entry.callback had been wrapped by Meteor.bindEnvironment.\n          Object.keys(entry.dynamics).forEach(function (key) {\n            fiber[key] = entry.dynamics[key];\n          });\n        }\n\n        try {\n          var result = entry.callback.apply(\n            entry.context || null,\n            entry.args || []\n          );\n\n          setImmediate(entry.resolve.bind(entry, result));\n\n        } catch (error) {\n          setImmediate(entry.reject.bind(entry, error));\n        }\n\n        // Remove all own properties of the fiber before returning it to\n        // the pool.\n        Object.keys(fiber).forEach(function (key) {\n          delete fiber[key];\n        });\n\n        if (fiberStack.length < targetFiberCount) {\n          fiberStack.push(fiber);\n        } else {\n          // If the pool has already reached the target maximum number of\n          // Fibers, don't bother recycling this Fiber.\n          break;\n        }\n      }\n    });\n\n    // Run the new Fiber up to the first yield point, so that it will be\n    // ready to receive entries.\n    fiber.run();\n\n    return fiber;\n  }\n\n  // Run the entry.callback function in a Fiber either taken from the pool\n  // or created anew if the pool is empty. This method returns a Promise\n  // for the eventual result of the entry.callback function.\n  this.run = function (entry, Promise) {\n    assert.strictEqual(typeof entry, \"object\");\n    assert.strictEqual(typeof entry.callback, \"function\");\n\n    if (typeof Promise.Fiber !== \"function\") {\n      return new Promise(function (resolve) {\n        resolve(entry.callback.apply(\n          entry.context || null,\n          entry.args\n        ));\n      });\n    }\n\n    var fiber = fiberStack.pop() || makeNewFiber(Promise.Fiber);\n\n    var promise = new Promise(function (resolve, reject) {\n      entry.resolve = resolve;\n      entry.reject = reject;\n    });\n\n    fiber.run(entry);\n\n    return promise;\n  };\n\n  // Limit the maximum number of idle Fibers that may be kept in the\n  // pool. Note that the run method will never refuse to create a new\n  // Fiber if the pool is empty; it's just that excess Fibers might be\n  // thrown away upon completion, if the pool is full.\n  this.setTargetFiberCount = function (limit) {\n    assert.strictEqual(typeof limit, \"number\");\n\n    targetFiberCount = Math.max(limit, 0);\n\n    if (targetFiberCount < fiberStack.length) {\n      // If the requested target count is less than the current length of\n      // the stack, truncate the stack and terminate any surplus Fibers.\n      fiberStack.splice(targetFiberCount).forEach(function (fiber) {\n        fiber.reset();\n      });\n    }\n\n    return this;\n  };\n}\n\n// Call pool.drain() to terminate all Fibers waiting in the pool and\n// signal to any outstanding Fibers that they should exit upon completion,\n// instead of reinserting themselves into the pool.\nFiberPool.prototype.drain = function () {\n  return this.setTargetFiberCount(0);\n};\n\nexports.makePool = function (targetFiberCount) {\n  return new FiberPool(targetFiberCount || 20);\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"promise\":{\"lib\":{\"es6-extensions.js\":[\"./core.js\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/promise/lib/es6-extensions.js                                           //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\n'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._81 = 1;\n  p._65 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._81 === 3) {\n            val = val._65;\n          }\n          if (val._81 === 1) return res(i, val._65);\n          if (val._81 === 2) reject(val._65);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"core.js\":[\"asap/raw\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/promise/lib/core.js                                                     //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\n'use strict';\n\nvar asap = require('asap/raw');\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._45 = 0;\n  this._81 = 0;\n  this._65 = null;\n  this._54 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._10 = null;\nPromise._97 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._81 === 3) {\n    self = self._65;\n  }\n  if (Promise._10) {\n    Promise._10(self);\n  }\n  if (self._81 === 0) {\n    if (self._45 === 0) {\n      self._45 = 1;\n      self._54 = deferred;\n      return;\n    }\n    if (self._45 === 1) {\n      self._45 = 2;\n      self._54 = [self._54, deferred];\n      return;\n    }\n    self._54.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._81 === 1) {\n        resolve(deferred.promise, self._65);\n      } else {\n        reject(deferred.promise, self._65);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._65);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._81 = 3;\n      self._65 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._81 = 1;\n  self._65 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._81 = 2;\n  self._65 = newValue;\n  if (Promise._97) {\n    Promise._97(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._45 === 1) {\n    handle(self, self._54);\n    self._54 = null;\n  }\n  if (self._45 === 2) {\n    for (var i = 0; i < self._54.length; i++) {\n      handle(self, self._54[i]);\n    }\n    self._54 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]}},\"asap\":{\"raw.js\":[\"domain\",function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                  //\n// node_modules/meteor/promise/node_modules/asap/raw.js                                                             //\n//                                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                    //\n\"use strict\";\n\nvar domain; // The domain module is executed on demand\nvar hasSetImmediate = typeof setImmediate === \"function\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including network IO events in Node.js.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Avoids a function call\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory excaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\nrawAsap.requestFlush = requestFlush;\nfunction requestFlush() {\n    // Ensure flushing is not bound to any domain.\n    // It is not sufficient to exit the domain, because domains exist on a stack.\n    // To execute code outside of any domain, the following dance is necessary.\n    var parentDomain = process.domain;\n    if (parentDomain) {\n        if (!domain) {\n            // Lazy execute the domain module.\n            // Only employed if the user elects to use domains.\n            domain = require(\"domain\");\n        }\n        domain.active = process.domain = null;\n    }\n\n    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`\n    // cannot handle recursion.\n    // `requestFlush` will only be called recursively from `asap.js`, to resume\n    // flushing after an error is thrown into a domain.\n    // Conveniently, `setImmediate` was introduced in the same version\n    // `process.nextTick` started throwing recursion errors.\n    if (flushing && hasSetImmediate) {\n        setImmediate(flush);\n    } else {\n        process.nextTick(flush);\n    }\n\n    if (parentDomain) {\n        domain.active = process.domain = parentDomain;\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]}}}}}},{\"extensions\":[\".js\",\".json\"]});\nvar exports = require(\"./node_modules/meteor/promise/server.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package.promise = exports, {\n  Promise: Promise\n});\n\n})();\n\n//# sourceMappingURL=promise.js.map\n"]},"hash":"b23352306a06eb7787b08c8f5ddcb6e3467db92c"}

{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/binary-heap.js","filenameRelative":"/bundle/programs/server/packages/binary-heap.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/binary-heap.js.map","sourceFileName":"/bundle/programs/server/packages/binary-heap.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"binary-heap"},"ignored":false,"code":"(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var _ = Package.underscore._;\n  var IdMap = Package['id-map'].IdMap;\n\n  /* Package-scope variables */\n  var MaxHeap, MinHeap, MinMaxHeap;\n\n  (function () {\n\n    ////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                    //\n    // packages/binary-heap/max-heap.js                                                   //\n    //                                                                                    //\n    ////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // Constructor of Heap\n    // - comparator - Function - given two items returns a number\n    // - options:\n    //   - initData - Array - Optional - the initial data in a format:\n    //        Object:\n    //          - id - String - unique id of the item\n    //          - value - Any - the data value\n    //      each value is retained\n    //   - IdMap - Constructor - Optional - custom IdMap class to store id->index\n    //       mappings internally. Standard IdMap is used by default.\n    MaxHeap = function MaxHeap(comparator, options) {\n      if (!_.isFunction(comparator)) throw new Error('Passed comparator is invalid, should be a comparison function');\n      var self = this;\n\n      // a C-style comparator that is given two values and returns a number,\n      // negative if the first value is less than the second, positive if the second\n      // value is greater than the first and zero if they are equal.\n      self._comparator = comparator;\n\n      options = _.defaults(options || {}, { IdMap: IdMap });\n\n      // _heapIdx maps an id to an index in the Heap array the corresponding value\n      // is located on.\n      self._heapIdx = new options.IdMap();\n\n      // The Heap data-structure implemented as a 0-based contiguous array where\n      // every item on index idx is a node in a complete binary tree. Every node can\n      // have children on indexes idx*2+1 and idx*2+2, except for the leaves. Every\n      // node has a parent on index (idx-1)/2;\n      self._heap = [];\n\n      // If the initial array is passed, we can build the heap in linear time\n      // complexity (O(N)) compared to linearithmic time complexity (O(nlogn)) if\n      // we push elements one by one.\n      if (_.isArray(options.initData)) self._initFromData(options.initData);\n    };\n\n    _.extend(MaxHeap.prototype, {\n      // Builds a new heap in-place in linear time based on passed data\n      _initFromData: function _initFromData(data) {\n        var self = this;\n\n        self._heap = _.map(data, function (o) {\n          return { id: o.id, value: o.value };\n        });\n\n        _.each(data, function (o, i) {\n          self._heapIdx.set(o.id, i);\n        });\n\n        if (!data.length) return;\n\n        // start from the first non-leaf - the parent of the last leaf\n        for (var i = parentIdx(data.length - 1); i >= 0; i--) {\n          self._downHeap(i);\n        }\n      },\n\n      _downHeap: function _downHeap(idx) {\n        var self = this;\n\n        while (leftChildIdx(idx) < self.size()) {\n          var left = leftChildIdx(idx);\n          var right = rightChildIdx(idx);\n          var largest = idx;\n\n          if (left < self.size()) {\n            largest = self._maxIndex(largest, left);\n          }\n          if (right < self.size()) {\n            largest = self._maxIndex(largest, right);\n          }\n\n          if (largest === idx) break;\n\n          self._swap(largest, idx);\n          idx = largest;\n        }\n      },\n\n      _upHeap: function _upHeap(idx) {\n        var self = this;\n\n        while (idx > 0) {\n          var parent = parentIdx(idx);\n          if (self._maxIndex(parent, idx) === idx) {\n            self._swap(parent, idx);\n            idx = parent;\n          } else {\n            break;\n          }\n        }\n      },\n\n      _maxIndex: function _maxIndex(idxA, idxB) {\n        var self = this;\n        var valueA = self._get(idxA);\n        var valueB = self._get(idxB);\n        return self._comparator(valueA, valueB) >= 0 ? idxA : idxB;\n      },\n\n      // Internal: gets raw data object placed on idxth place in heap\n      _get: function _get(idx) {\n        var self = this;\n        return self._heap[idx].value;\n      },\n\n      _swap: function _swap(idxA, idxB) {\n        var self = this;\n        var recA = self._heap[idxA];\n        var recB = self._heap[idxB];\n\n        self._heapIdx.set(recA.id, idxB);\n        self._heapIdx.set(recB.id, idxA);\n\n        self._heap[idxA] = recB;\n        self._heap[idxB] = recA;\n      },\n\n      get: function get(id) {\n        var self = this;\n        if (!self.has(id)) return null;\n        return self._get(self._heapIdx.get(id));\n      },\n      set: function set(id, value) {\n        var self = this;\n\n        if (self.has(id)) {\n          if (self.get(id) === value) return;\n\n          var idx = self._heapIdx.get(id);\n          self._heap[idx].value = value;\n\n          // Fix the new value's position\n          // Either bubble new value up if it is greater than its parent\n          self._upHeap(idx);\n          // or bubble it down if it is smaller than one of its children\n          self._downHeap(idx);\n        } else {\n          self._heapIdx.set(id, self._heap.length);\n          self._heap.push({ id: id, value: value });\n          self._upHeap(self._heap.length - 1);\n        }\n      },\n      remove: function remove(id) {\n        var self = this;\n\n        if (self.has(id)) {\n          var last = self._heap.length - 1;\n          var idx = self._heapIdx.get(id);\n\n          if (idx !== last) {\n            self._swap(idx, last);\n            self._heap.pop();\n            self._heapIdx.remove(id);\n\n            // Fix the swapped value's position\n            self._upHeap(idx);\n            self._downHeap(idx);\n          } else {\n            self._heap.pop();\n            self._heapIdx.remove(id);\n          }\n        }\n      },\n      has: function has(id) {\n        var self = this;\n        return self._heapIdx.has(id);\n      },\n      empty: function empty() {\n        var self = this;\n        return !self.size();\n      },\n      clear: function clear() {\n        var self = this;\n        self._heap = [];\n        self._heapIdx.clear();\n      },\n      // iterate over values in no particular order\n      forEach: function forEach(iterator) {\n        var self = this;\n        _.each(self._heap, function (obj) {\n          return iterator(obj.value, obj.id);\n        });\n      },\n      size: function size() {\n        var self = this;\n        return self._heap.length;\n      },\n      setDefault: function setDefault(id, def) {\n        var self = this;\n        if (self.has(id)) return self.get(id);\n        self.set(id, def);\n        return def;\n      },\n      clone: function clone() {\n        var self = this;\n        var clone = new MaxHeap(self._comparator, self._heap);\n        return clone;\n      },\n\n      maxElementId: function maxElementId() {\n        var self = this;\n        return self.size() ? self._heap[0].id : null;\n      },\n\n      _selfCheck: function _selfCheck() {\n        var self = this;\n        for (var i = 1; i < self._heap.length; i++) {\n          if (self._maxIndex(parentIdx(i), i) !== parentIdx(i)) throw new Error(\"An item with id \" + self._heap[i].id + \" has a parent younger than it: \" + self._heap[parentIdx(i)].id);\n        }\n      }\n    });\n\n    function leftChildIdx(i) {\n      return i * 2 + 1;\n    }\n    function rightChildIdx(i) {\n      return i * 2 + 2;\n    }\n    function parentIdx(i) {\n      return i - 1 >> 1;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  (function () {\n\n    ////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                    //\n    // packages/binary-heap/min-heap.js                                                   //\n    //                                                                                    //\n    ////////////////////////////////////////////////////////////////////////////////////////\n    //\n    MinHeap = function MinHeap(comparator, options) {\n      var self = this;\n      MaxHeap.call(self, function (a, b) {\n        return -comparator(a, b);\n      }, options);\n    };\n\n    Meteor._inherits(MinHeap, MaxHeap);\n\n    _.extend(MinHeap.prototype, {\n      maxElementId: function maxElementId() {\n        throw new Error(\"Cannot call maxElementId on MinHeap\");\n      },\n      minElementId: function minElementId() {\n        var self = this;\n        return MaxHeap.prototype.maxElementId.call(self);\n      }\n    });\n\n    ////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  (function () {\n\n    ////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                    //\n    // packages/binary-heap/min-max-heap.js                                               //\n    //                                                                                    //\n    ////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // This implementation of Min/Max-Heap is just a subclass of Max-Heap\n    // with a Min-Heap as an encapsulated property.\n    //\n    // Most of the operations are just proxy methods to call the same method on both\n    // heaps.\n    //\n    // This implementation takes 2*N memory but is fairly simple to write and\n    // understand. And the constant factor of a simple Heap is usually smaller\n    // compared to other two-way priority queues like Min/Max Heaps\n    // (http://www.cs.otago.ac.nz/staffpriv/mike/Papers/MinMaxHeaps/MinMaxHeaps.pdf)\n    // and Interval Heaps\n    // (http://www.cise.ufl.edu/~sahni/dsaac/enrich/c13/double.htm)\n    MinMaxHeap = function MinMaxHeap(comparator, options) {\n      var self = this;\n\n      MaxHeap.call(self, comparator, options);\n      self._minHeap = new MinHeap(comparator, options);\n    };\n\n    Meteor._inherits(MinMaxHeap, MaxHeap);\n\n    _.extend(MinMaxHeap.prototype, {\n      set: function set(id, value) {\n        var self = this;\n        MaxHeap.prototype.set.apply(self, arguments);\n        self._minHeap.set(id, value);\n      },\n      remove: function remove(id) {\n        var self = this;\n        MaxHeap.prototype.remove.apply(self, arguments);\n        self._minHeap.remove(id);\n      },\n      clear: function clear() {\n        var self = this;\n        MaxHeap.prototype.clear.apply(self, arguments);\n        self._minHeap.clear();\n      },\n      setDefault: function setDefault(id, def) {\n        var self = this;\n        MaxHeap.prototype.setDefault.apply(self, arguments);\n        return self._minHeap.setDefault(id, def);\n      },\n      clone: function clone() {\n        var self = this;\n        var clone = new MinMaxHeap(self._comparator, self._heap);\n        return clone;\n      },\n      minElementId: function minElementId() {\n        var self = this;\n        return self._minHeap.minElementId();\n      }\n    });\n\n    ////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package['binary-heap'] = {}, {\n    MaxHeap: MaxHeap,\n    MinHeap: MinHeap,\n    MinMaxHeap: MinMaxHeap\n  });\n})();\n\n//# sourceMappingURL=binary-heap.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/binary-heap.js"],"names":[],"mappings":"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","file":"/bundle/programs/server/packages/binary-heap.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar IdMap = Package['id-map'].IdMap;\n\n/* Package-scope variables */\nvar MaxHeap, MinHeap, MinMaxHeap;\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                    //\n// packages/binary-heap/max-heap.js                                                   //\n//                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////\n                                                                                      //\n// Constructor of Heap\n// - comparator - Function - given two items returns a number\n// - options:\n//   - initData - Array - Optional - the initial data in a format:\n//        Object:\n//          - id - String - unique id of the item\n//          - value - Any - the data value\n//      each value is retained\n//   - IdMap - Constructor - Optional - custom IdMap class to store id->index\n//       mappings internally. Standard IdMap is used by default.\nMaxHeap = function (comparator, options) {\n  if (! _.isFunction(comparator))\n    throw new Error('Passed comparator is invalid, should be a comparison function');\n  var self = this;\n\n  // a C-style comparator that is given two values and returns a number,\n  // negative if the first value is less than the second, positive if the second\n  // value is greater than the first and zero if they are equal.\n  self._comparator = comparator;\n\n  options = _.defaults(options || {}, { IdMap: IdMap });\n\n  // _heapIdx maps an id to an index in the Heap array the corresponding value\n  // is located on.\n  self._heapIdx = new options.IdMap;\n\n  // The Heap data-structure implemented as a 0-based contiguous array where\n  // every item on index idx is a node in a complete binary tree. Every node can\n  // have children on indexes idx*2+1 and idx*2+2, except for the leaves. Every\n  // node has a parent on index (idx-1)/2;\n  self._heap = [];\n\n  // If the initial array is passed, we can build the heap in linear time\n  // complexity (O(N)) compared to linearithmic time complexity (O(nlogn)) if\n  // we push elements one by one.\n  if (_.isArray(options.initData))\n    self._initFromData(options.initData);\n};\n\n_.extend(MaxHeap.prototype, {\n  // Builds a new heap in-place in linear time based on passed data\n  _initFromData: function (data) {\n    var self = this;\n\n    self._heap = _.map(data, function (o) {\n      return { id: o.id, value: o.value };\n    });\n\n    _.each(data, function (o, i) {\n      self._heapIdx.set(o.id, i);\n    });\n\n    if (! data.length)\n      return;\n\n    // start from the first non-leaf - the parent of the last leaf\n    for (var i = parentIdx(data.length - 1); i >= 0; i--)\n      self._downHeap(i);\n  },\n\n  _downHeap: function (idx) {\n    var self = this;\n\n    while (leftChildIdx(idx) < self.size()) {\n      var left = leftChildIdx(idx);\n      var right = rightChildIdx(idx);\n      var largest = idx;\n\n      if (left < self.size()) {\n        largest = self._maxIndex(largest, left);\n      }\n      if (right < self.size()) {\n        largest = self._maxIndex(largest, right);\n      }\n\n      if (largest === idx)\n        break;\n\n      self._swap(largest, idx);\n      idx = largest;\n    }\n  },\n\n  _upHeap: function (idx) {\n    var self = this;\n\n    while (idx > 0) {\n      var parent = parentIdx(idx);\n      if (self._maxIndex(parent, idx) === idx) {\n        self._swap(parent, idx)\n        idx = parent;\n      } else {\n        break;\n      }\n    }\n  },\n\n  _maxIndex: function (idxA, idxB) {\n    var self = this;\n    var valueA = self._get(idxA);\n    var valueB = self._get(idxB);\n    return self._comparator(valueA, valueB) >= 0 ? idxA : idxB;\n  },\n\n  // Internal: gets raw data object placed on idxth place in heap\n  _get: function (idx) {\n    var self = this;\n    return self._heap[idx].value;\n  },\n\n  _swap: function (idxA, idxB) {\n    var self = this;\n    var recA = self._heap[idxA];\n    var recB = self._heap[idxB];\n\n    self._heapIdx.set(recA.id, idxB);\n    self._heapIdx.set(recB.id, idxA);\n\n    self._heap[idxA] = recB;\n    self._heap[idxB] = recA;\n  },\n\n  get: function (id) {\n    var self = this;\n    if (! self.has(id))\n      return null;\n    return self._get(self._heapIdx.get(id));\n  },\n  set: function (id, value) {\n    var self = this;\n\n    if (self.has(id)) {\n      if (self.get(id) === value)\n        return;\n\n      var idx = self._heapIdx.get(id);\n      self._heap[idx].value = value;\n\n      // Fix the new value's position\n      // Either bubble new value up if it is greater than its parent\n      self._upHeap(idx);\n      // or bubble it down if it is smaller than one of its children\n      self._downHeap(idx);\n    } else {\n      self._heapIdx.set(id, self._heap.length);\n      self._heap.push({ id: id, value: value });\n      self._upHeap(self._heap.length - 1);\n    }\n  },\n  remove: function (id) {\n    var self = this;\n\n    if (self.has(id)) {\n      var last = self._heap.length - 1;\n      var idx = self._heapIdx.get(id);\n\n      if (idx !== last) {\n        self._swap(idx, last);\n        self._heap.pop();\n        self._heapIdx.remove(id);\n\n        // Fix the swapped value's position\n        self._upHeap(idx);\n        self._downHeap(idx);\n      } else {\n        self._heap.pop();\n        self._heapIdx.remove(id);\n      }\n    }\n  },\n  has: function (id) {\n    var self = this;\n    return self._heapIdx.has(id);\n  },\n  empty: function () {\n    var self = this;\n    return !self.size();\n  },\n  clear: function () {\n    var self = this;\n    self._heap = [];\n    self._heapIdx.clear();\n  },\n  // iterate over values in no particular order\n  forEach: function (iterator) {\n    var self = this;\n    _.each(self._heap, function (obj) {\n      return iterator(obj.value, obj.id);\n    });\n  },\n  size: function () {\n    var self = this;\n    return self._heap.length;\n  },\n  setDefault: function (id, def) {\n    var self = this;\n    if (self.has(id))\n      return self.get(id);\n    self.set(id, def);\n    return def;\n  },\n  clone: function () {\n    var self = this;\n    var clone = new MaxHeap(self._comparator, self._heap);\n    return clone;\n  },\n\n  maxElementId: function () {\n    var self = this;\n    return self.size() ? self._heap[0].id : null;\n  },\n\n  _selfCheck: function () {\n    var self = this;\n    for (var i = 1; i < self._heap.length; i++)\n      if (self._maxIndex(parentIdx(i), i) !== parentIdx(i))\n          throw new Error(\"An item with id \" + self._heap[i].id +\n                          \" has a parent younger than it: \" +\n                          self._heap[parentIdx(i)].id);\n  }\n});\n\nfunction leftChildIdx (i) { return i * 2 + 1; }\nfunction rightChildIdx (i) { return i * 2 + 2; }\nfunction parentIdx (i) { return (i - 1) >> 1; }\n\n\n////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                    //\n// packages/binary-heap/min-heap.js                                                   //\n//                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////\n                                                                                      //\nMinHeap = function (comparator, options) {\n  var self = this;\n  MaxHeap.call(self, function (a, b) {\n    return -comparator(a, b);\n  }, options);\n};\n\nMeteor._inherits(MinHeap, MaxHeap);\n\n_.extend(MinHeap.prototype, {\n  maxElementId: function () {\n    throw new Error(\"Cannot call maxElementId on MinHeap\");\n  },\n  minElementId: function () {\n    var self = this;\n    return MaxHeap.prototype.maxElementId.call(self);\n  }\n});\n\n\n////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                    //\n// packages/binary-heap/min-max-heap.js                                               //\n//                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////\n                                                                                      //\n// This implementation of Min/Max-Heap is just a subclass of Max-Heap\n// with a Min-Heap as an encapsulated property.\n//\n// Most of the operations are just proxy methods to call the same method on both\n// heaps.\n//\n// This implementation takes 2*N memory but is fairly simple to write and\n// understand. And the constant factor of a simple Heap is usually smaller\n// compared to other two-way priority queues like Min/Max Heaps\n// (http://www.cs.otago.ac.nz/staffpriv/mike/Papers/MinMaxHeaps/MinMaxHeaps.pdf)\n// and Interval Heaps\n// (http://www.cise.ufl.edu/~sahni/dsaac/enrich/c13/double.htm)\nMinMaxHeap = function (comparator, options) {\n  var self = this;\n\n  MaxHeap.call(self, comparator, options);\n  self._minHeap = new MinHeap(comparator, options);\n};\n\nMeteor._inherits(MinMaxHeap, MaxHeap);\n\n_.extend(MinMaxHeap.prototype, {\n  set: function (id, value) {\n    var self = this;\n    MaxHeap.prototype.set.apply(self, arguments);\n    self._minHeap.set(id, value);\n  },\n  remove: function (id) {\n    var self = this;\n    MaxHeap.prototype.remove.apply(self, arguments);\n    self._minHeap.remove(id);\n  },\n  clear: function () {\n    var self = this;\n    MaxHeap.prototype.clear.apply(self, arguments);\n    self._minHeap.clear();\n  },\n  setDefault: function (id, def) {\n    var self = this;\n    MaxHeap.prototype.setDefault.apply(self, arguments);\n    return self._minHeap.setDefault(id, def);\n  },\n  clone: function () {\n    var self = this;\n    var clone = new MinMaxHeap(self._comparator, self._heap);\n    return clone;\n  },\n  minElementId: function () {\n    var self = this;\n    return self._minHeap.minElementId();\n  }\n});\n\n\n////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['binary-heap'] = {}, {\n  MaxHeap: MaxHeap,\n  MinHeap: MinHeap,\n  MinMaxHeap: MinMaxHeap\n});\n\n})();\n\n//# sourceMappingURL=binary-heap.js.map\n"]},"hash":"b6ddc715265a7a4d18aa06c1a416d6bc6b23ba1e"}

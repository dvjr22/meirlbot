{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/boot.js","filenameRelative":"/bundle/programs/server/boot.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/boot.js.map","sourceFileName":"/bundle/programs/server/boot.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"boot"},"ignored":false,"code":"var Fiber = require(\"fibers\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar Future = require(\"fibers/future\");\nvar _ = require('underscore');\nvar sourcemap_support = require('source-map-support');\n\nvar bootUtils = require('./boot-utils.js');\nvar files = require('./mini-files.js');\nvar npmRequire = require('./npm-require.js').require;\n\n// This code is duplicated in tools/main.js.\nvar MIN_NODE_VERSION = 'v0.10.41';\n\nif (require('semver').lt(process.version, MIN_NODE_VERSION)) {\n  process.stderr.write('Meteor requires Node ' + MIN_NODE_VERSION + ' or later.\\n');\n  process.exit(1);\n}\n\n// read our control files\nvar serverJsonPath = path.resolve(process.argv[2]);\nvar serverDir = path.dirname(serverJsonPath);\nvar serverJson = require(\"./server-json.js\");\nvar configJson = JSON.parse(fs.readFileSync(path.resolve(serverDir, 'config.json'), 'utf8'));\n\n// Set up environment\n__meteor_bootstrap__ = {\n  startupHooks: [],\n  serverDir: serverDir,\n  configJson: configJson };\n__meteor_runtime_config__ = { meteorRelease: configJson.meteorRelease };\n\nif (!process.env.APP_ID) {\n  process.env.APP_ID = configJson.appId;\n}\n\n// Map from load path to its source map.\nvar parsedSourceMaps = {};\n\n// Read all the source maps into memory once.\n_.each(serverJson.load, function (fileInfo) {\n  if (fileInfo.sourceMap) {\n    var rawSourceMap = fs.readFileSync(path.resolve(serverDir, fileInfo.sourceMap), 'utf8');\n    // Parse the source map only once, not each time it's needed. Also remove\n    // the anti-XSSI header if it's there.\n    var parsedSourceMap = JSON.parse(rawSourceMap.replace(/^\\)\\]\\}'/, ''));\n    // source-map-support doesn't ever look at the sourcesContent field, so\n    // there's no point in keeping it in memory.\n    delete parsedSourceMap.sourcesContent;\n    var url;\n    if (fileInfo.sourceMapRoot) {\n      // Add the specified root to any root that may be in the file.\n      parsedSourceMap.sourceRoot = path.join(fileInfo.sourceMapRoot, parsedSourceMap.sourceRoot || '');\n    }\n    parsedSourceMaps[path.resolve(__dirname, fileInfo.path)] = parsedSourceMap;\n  }\n});\n\nvar retrieveSourceMap = function retrieveSourceMap(pathForSourceMap) {\n  if (_.has(parsedSourceMaps, pathForSourceMap)) return { map: parsedSourceMaps[pathForSourceMap] };\n  return null;\n};\n\nvar origWrapper = sourcemap_support.wrapCallSite;\nvar wrapCallSite = function wrapCallSite(frame) {\n  var frame = origWrapper(frame);\n  var wrapGetter = function wrapGetter(name) {\n    var origGetter = frame[name];\n    frame[name] = function (arg) {\n      // replace a custom location domain that we set for better UX in Chrome\n      // DevTools (separate domain group) in source maps.\n      var source = origGetter(arg);\n      if (!source) return source;\n      return source.replace(/(^|\\()meteor:\\/\\/..app\\//, '$1');\n    };\n  };\n  wrapGetter('getScriptNameOrSourceURL');\n  wrapGetter('getEvalOrigin');\n\n  return frame;\n};\nsourcemap_support.install({\n  // Use the source maps specified in program.json instead of parsing source\n  // code for them.\n  retrieveSourceMap: retrieveSourceMap,\n  // For now, don't fix the source line in uncaught exceptions, because we\n  // haven't fixed handleUncaughtExceptions in source-map-support to properly\n  // locate the source files.\n  handleUncaughtExceptions: false,\n  wrapCallSite: wrapCallSite\n});\n\n// As a replacement to the old keepalives mechanism, check for a running\n// parent every few seconds. Exit if the parent is not running.\n//\n// Two caveats to this strategy:\n// * Doesn't catch the case where the parent is CPU-hogging (but maybe we\n//   don't want to catch that case anyway, since the bundler not yielding\n//   is what caused #2536).\n// * Could be fooled by pid re-use, i.e. if another process comes up and\n//   takes the parent process's place before the child process dies.\nvar startCheckForLiveParent = function startCheckForLiveParent(parentPid) {\n  if (parentPid) {\n    if (!bootUtils.validPid(parentPid)) {\n      console.error(\"METEOR_PARENT_PID must be a valid process ID.\");\n      process.exit(1);\n    }\n\n    setInterval(function () {\n      try {\n        process.kill(parentPid, 0);\n      } catch (err) {\n        console.error(\"Parent process is dead! Exiting.\");\n        process.exit(1);\n      }\n    }, 3000);\n  }\n};\n\nFiber(function () {\n  _.each(serverJson.load, function (fileInfo) {\n    var code = fs.readFileSync(path.resolve(serverDir, fileInfo.path));\n    var nonLocalNodeModulesPaths = [];\n\n    function addNodeModulesPath(path) {\n      nonLocalNodeModulesPaths.push(files.pathResolve(serverDir, path));\n    }\n\n    if (typeof fileInfo.node_modules === \"string\") {\n      addNodeModulesPath(fileInfo.node_modules);\n    } else if (fileInfo.node_modules) {\n      _.each(fileInfo.node_modules, function (info, path) {\n        if (!info.local) {\n          addNodeModulesPath(path);\n        }\n      });\n    }\n\n    function statOrNull(path) {\n      try {\n        return fs.statSync(path);\n      } catch (e) {\n        return null;\n      }\n    }\n\n    var Npm = {\n      /**\n       * @summary Require a package that was specified using\n       * `Npm.depends()`.\n       * @param  {String} name The name of the package to require.\n       * @locus Server\n       * @memberOf Npm\n       */\n      require: function (_require) {\n        function require(_x) {\n          return _require.apply(this, arguments);\n        }\n\n        require.toString = function () {\n          return _require.toString();\n        };\n\n        return require;\n      }(function (name) {\n        if (nonLocalNodeModulesPaths.length === 0) {\n          return require(name);\n        }\n\n        var fullPath;\n\n        nonLocalNodeModulesPaths.some(function (nodeModuleBase) {\n          var packageBase = files.convertToOSPath(files.pathResolve(nodeModuleBase, name.split(\"/\", 1)[0]));\n\n          if (statOrNull(packageBase)) {\n            return fullPath = files.convertToOSPath(files.pathResolve(nodeModuleBase, name));\n          }\n        });\n\n        if (fullPath) {\n          return require(fullPath);\n        }\n\n        try {\n          return require(name);\n        } catch (e) {\n          // Try to guess the package name so we can print a nice\n          // error message\n          // fileInfo.path is a standard path, use files.pathSep\n          var filePathParts = fileInfo.path.split(files.pathSep);\n          var packageName = filePathParts[1].replace(/\\.js$/, '');\n\n          // XXX better message\n          throw new Error(\"Can't find npm module '\" + name + \"'. Did you forget to call 'Npm.depends' in package.js \" + \"within the '\" + packageName + \"' package?\");\n        }\n      })\n    };\n    var getAsset = function getAsset(assetPath, encoding, callback) {\n      var fut;\n      if (!callback) {\n        fut = new Future();\n        callback = fut.resolver();\n      }\n      // This assumes that we've already loaded the meteor package, so meteor\n      // itself can't call Assets.get*. (We could change this function so that\n      // it doesn't call bindEnvironment if you don't pass a callback if we need\n      // to.)\n      var _callback = Package.meteor.Meteor.bindEnvironment(function (err, result) {\n        if (result && !encoding)\n          // Sadly, this copies in Node 0.10.\n          result = new Uint8Array(result);\n        callback(err, result);\n      }, function (e) {\n        console.log(\"Exception in callback of getAsset\", e.stack);\n      });\n\n      // Convert a DOS-style path to Unix-style in case the application code was\n      // written on Windows.\n      assetPath = files.convertToStandardPath(assetPath);\n\n      if (!fileInfo.assets || !_.has(fileInfo.assets, assetPath)) {\n        _callback(new Error(\"Unknown asset: \" + assetPath));\n      } else {\n        var filePath = path.join(serverDir, fileInfo.assets[assetPath]);\n        fs.readFile(files.convertToOSPath(filePath), encoding, _callback);\n      }\n      if (fut) return fut.wait();\n    };\n\n    var Assets = {\n      getText: function getText(assetPath, callback) {\n        return getAsset(assetPath, \"utf8\", callback);\n      },\n      getBinary: function getBinary(assetPath, callback) {\n        return getAsset(assetPath, undefined, callback);\n      },\n      /**\n       * @summary Get the absolute path to the static server asset. Note that assets are read-only.\n       * @locus Server [Not in build plugins]\n       * @memberOf Assets\n       * @param {String} assetPath The path of the asset, relative to the application's `private` subdirectory.\n       */\n      absoluteFilePath: function absoluteFilePath(assetPath) {\n        if (!fileInfo.assets || !_.has(fileInfo.assets, assetPath)) {\n          throw new Error(\"Unknown asset: \" + assetPath);\n        }\n\n        assetPath = files.convertToStandardPath(assetPath);\n        var filePath = path.join(serverDir, fileInfo.assets[assetPath]);\n        return files.convertToOSPath(filePath);\n      }\n    };\n\n    var isModulesRuntime = fileInfo.path === \"packages/modules-runtime.js\";\n\n    var wrapParts = [\"(function(Npm,Assets\"];\n    if (isModulesRuntime) {\n      wrapParts.push(\",npmRequire\");\n    }\n    // \\n is necessary in case final line is a //-comment\n    wrapParts.push(\"){\", code, \"\\n})\");\n    var wrapped = wrapParts.join(\"\");\n\n    // It is safer to use the absolute path when source map is present as\n    // different tooling, such as node-inspector, can get confused on relative\n    // urls.\n\n    // fileInfo.path is a standard path, convert it to OS path to join with\n    // __dirname\n    var fileInfoOSPath = files.convertToOSPath(fileInfo.path);\n    var absoluteFilePath = path.resolve(__dirname, fileInfoOSPath);\n\n    var scriptPath = parsedSourceMaps[absoluteFilePath] ? absoluteFilePath : fileInfoOSPath;\n    // The final 'true' is an undocumented argument to runIn[Foo]Context that\n    // causes it to print out a descriptive error message on parse error. It's\n    // what require() uses to generate its errors.\n    var func = require('vm').runInThisContext(wrapped, scriptPath, true);\n    var args = [Npm, Assets];\n    if (isModulesRuntime) {\n      args.push(npmRequire);\n    }\n    func.apply(global, args);\n  });\n\n  // run the user startup hooks.  other calls to startup() during this can still\n  // add hooks to the end.\n  while (__meteor_bootstrap__.startupHooks.length) {\n    var hook = __meteor_bootstrap__.startupHooks.shift();\n    hook();\n  }\n  // Setting this to null tells Meteor.startup to call hooks immediately.\n  __meteor_bootstrap__.startupHooks = null;\n\n  // find and run main()\n  // XXX hack. we should know the package that contains main.\n  var mains = [];\n  var globalMain;\n  if ('main' in global) {\n    mains.push(main);\n    globalMain = main;\n  }\n  typeof Package !== 'undefined' && _.each(Package, function (p, n) {\n    if ('main' in p && p.main !== globalMain) {\n      mains.push(p.main);\n    }\n  });\n  if (!mains.length) {\n    process.stderr.write(\"Program has no main() function.\\n\");\n    process.exit(1);\n  }\n  if (mains.length > 1) {\n    process.stderr.write(\"Program has more than one main() function?\\n\");\n    process.exit(1);\n  }\n  var exitCode = mains[0].call({}, process.argv.slice(3));\n  // XXX hack, needs a better way to keep alive\n  if (exitCode !== 'DAEMON') process.exit(exitCode);\n\n  if (process.env.METEOR_PARENT_PID) {\n    startCheckForLiveParent(process.env.METEOR_PARENT_PID);\n  }\n}).run();","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/boot.js"],"names":[],"mappings":"AAAA,IAAI,QAAQ,QAAQ,QAAR,CAAZ;AACA,IAAI,KAAK,QAAQ,IAAR,CAAT;AACA,IAAI,OAAO,QAAQ,MAAR,CAAX;AACA,IAAI,SAAS,QAAQ,eAAR,CAAb;AACA,IAAI,IAAI,QAAQ,YAAR,CAAR;AACA,IAAI,oBAAoB,QAAQ,oBAAR,CAAxB;;AAEA,IAAI,YAAY,QAAQ,iBAAR,CAAhB;AACA,IAAI,QAAQ,QAAQ,iBAAR,CAAZ;AACA,IAAI,aAAa,QAAQ,kBAAR,EAA4B,OAA7C;;;AAGA,IAAI,mBAAmB,UAAvB;;AAEA,IAAI,QAAQ,QAAR,EAAkB,EAAlB,CAAqB,QAAQ,OAA7B,EAAsC,gBAAtC,CAAJ,EAA6D;AAC3D,UAAQ,MAAR,CAAe,KAAf,CACE,0BAA0B,gBAA1B,GAA6C,cAD/C;AAEA,UAAQ,IAAR,CAAa,CAAb;AACD;;;AAGD,IAAI,iBAAiB,KAAK,OAAL,CAAa,QAAQ,IAAR,CAAa,CAAb,CAAb,CAArB;AACA,IAAI,YAAY,KAAK,OAAL,CAAa,cAAb,CAAhB;AACA,IAAI,aAAa,QAAQ,kBAAR,CAAjB;AACA,IAAI,aACF,KAAK,KAAL,CAAW,GAAG,YAAH,CAAgB,KAAK,OAAL,CAAa,SAAb,EAAwB,aAAxB,CAAhB,EAAwD,MAAxD,CAAX,CADF;;;AAIA,uBAAuB;AACrB,gBAAc,EADO;AAErB,aAAW,SAFU;AAGrB,cAAY,UAHS,EAAvB;AAIA,4BAA4B,EAAE,eAAe,WAAW,aAA5B,EAA5B;;AAEA,IAAI,CAAC,QAAQ,GAAR,CAAY,MAAjB,EAAyB;AACvB,UAAQ,GAAR,CAAY,MAAZ,GAAqB,WAAW,KAAhC;AACD;;;AAGD,IAAI,mBAAmB,EAAvB;;;AAGA,EAAE,IAAF,CAAO,WAAW,IAAlB,EAAwB,UAAU,QAAV,EAAoB;AAC1C,MAAI,SAAS,SAAb,EAAwB;AACtB,QAAI,eAAe,GAAG,YAAH,CACjB,KAAK,OAAL,CAAa,SAAb,EAAwB,SAAS,SAAjC,CADiB,EAC4B,MAD5B,CAAnB;;;AAIA,QAAI,kBAAkB,KAAK,KAAL,CAAW,aAAa,OAAb,CAAqB,UAArB,EAAiC,EAAjC,CAAX,CAAtB;;;AAGA,WAAO,gBAAgB,cAAvB;AACA,QAAI,GAAJ;AACA,QAAI,SAAS,aAAb,EAA4B;;AAE1B,sBAAgB,UAAhB,GAA6B,KAAK,IAAL,CAC3B,SAAS,aADkB,EACH,gBAAgB,UAAhB,IAA8B,EAD3B,CAA7B;AAED;AACD,qBAAiB,KAAK,OAAL,CAAa,SAAb,EAAwB,SAAS,IAAjC,CAAjB,IAA2D,eAA3D;AACD;AACF,CAlBD;;AAoBA,IAAI,oBAAoB,SAApB,iBAAoB,CAAU,gBAAV,EAA4B;AAClD,MAAI,EAAE,GAAF,CAAM,gBAAN,EAAwB,gBAAxB,CAAJ,EACE,OAAO,EAAE,KAAK,iBAAiB,gBAAjB,CAAP,EAAP;AACF,SAAO,IAAP;AACD,CAJD;;AAMA,IAAI,cAAc,kBAAkB,YAApC;AACA,IAAI,eAAe,SAAf,YAAe,CAAU,KAAV,EAAiB;AAClC,MAAI,QAAQ,YAAY,KAAZ,CAAZ;AACA,MAAI,aAAa,SAAb,UAAa,CAAU,IAAV,EAAgB;AAC/B,QAAI,aAAa,MAAM,IAAN,CAAjB;AACA,UAAM,IAAN,IAAc,UAAU,GAAV,EAAe;;;AAG3B,UAAI,SAAS,WAAW,GAAX,CAAb;AACA,UAAI,CAAE,MAAN,EACE,OAAO,MAAP;AACF,aAAO,OAAO,OAAP,CAAe,0BAAf,EAA2C,IAA3C,CAAP;AACD,KAPD;AAQD,GAVD;AAWA,aAAW,0BAAX;AACA,aAAW,eAAX;;AAEA,SAAO,KAAP;AACD,CAjBD;AAkBA,kBAAkB,OAAlB,CAA0B;;;AAGxB,qBAAmB,iBAHK;;;;AAOxB,4BAA0B,KAPF;AAQxB,gBAAc;AARU,CAA1B;;;;;;;;;;;AAoBA,IAAI,0BAA0B,SAA1B,uBAA0B,CAAU,SAAV,EAAqB;AACjD,MAAI,SAAJ,EAAe;AACb,QAAI,CAAE,UAAU,QAAV,CAAmB,SAAnB,CAAN,EAAqC;AACnC,cAAQ,KAAR,CAAc,+CAAd;AACA,cAAQ,IAAR,CAAa,CAAb;AACD;;AAED,gBAAY,YAAY;AACtB,UAAI;AACF,gBAAQ,IAAR,CAAa,SAAb,EAAwB,CAAxB;AACD,OAFD,CAEE,OAAO,GAAP,EAAY;AACZ,gBAAQ,KAAR,CAAc,kCAAd;AACA,gBAAQ,IAAR,CAAa,CAAb;AACD;AACF,KAPD,EAOG,IAPH;AAQD;AACF,CAhBD;;AAmBA,MAAM,YAAY;AAChB,IAAE,IAAF,CAAO,WAAW,IAAlB,EAAwB,UAAU,QAAV,EAAoB;AAC1C,QAAI,OAAO,GAAG,YAAH,CAAgB,KAAK,OAAL,CAAa,SAAb,EAAwB,SAAS,IAAjC,CAAhB,CAAX;AACA,QAAI,2BAA2B,EAA/B;;AAEA,aAAS,kBAAT,CAA4B,IAA5B,EAAkC;AAChC,+BAAyB,IAAzB,CACE,MAAM,WAAN,CAAkB,SAAlB,EAA6B,IAA7B,CADF;AAGD;;AAED,QAAI,OAAO,SAAS,YAAhB,KAAiC,QAArC,EAA+C;AAC7C,yBAAmB,SAAS,YAA5B;AACD,KAFD,MAEO,IAAI,SAAS,YAAb,EAA2B;AAChC,QAAE,IAAF,CAAO,SAAS,YAAhB,EAA8B,UAAU,IAAV,EAAgB,IAAhB,EAAsB;AAClD,YAAI,CAAE,KAAK,KAAX,EAAkB;AAChB,6BAAmB,IAAnB;AACD;AACF,OAJD;AAKD;;AAED,aAAS,UAAT,CAAoB,IAApB,EAA0B;AACxB,UAAI;AACF,eAAO,GAAG,QAAH,CAAY,IAAZ,CAAP;AACD,OAFD,CAEE,OAAO,CAAP,EAAU;AACV,eAAO,IAAP;AACD;AACF;;AAED,QAAI,MAAM;;;;;;;;AAQR;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,QAAS,UAAU,IAAV,EAAgB;AACvB,YAAI,yBAAyB,MAAzB,KAAoC,CAAxC,EAA2C;AACzC,iBAAO,QAAQ,IAAR,CAAP;AACD;;AAED,YAAI,QAAJ;;AAEA,iCAAyB,IAAzB,CAA8B,UAAU,cAAV,EAA0B;AACtD,cAAI,cAAc,MAAM,eAAN,CAAsB,MAAM,WAAN,CACtC,cADsC,EAEtC,KAAK,KAAL,CAAW,GAAX,EAAgB,CAAhB,EAAmB,CAAnB,CAFsC,CAAtB,CAAlB;;AAKA,cAAI,WAAW,WAAX,CAAJ,EAA6B;AAC3B,mBAAO,WAAW,MAAM,eAAN,CAChB,MAAM,WAAN,CAAkB,cAAlB,EAAkC,IAAlC,CADgB,CAAlB;AAGD;AACF,SAXD;;AAaA,YAAI,QAAJ,EAAc;AACZ,iBAAO,QAAQ,QAAR,CAAP;AACD;;AAED,YAAI;AACF,iBAAO,QAAQ,IAAR,CAAP;AACD,SAFD,CAEE,OAAO,CAAP,EAAU;;;;AAIV,cAAI,gBAAgB,SAAS,IAAT,CAAc,KAAd,CAAoB,MAAM,OAA1B,CAApB;AACA,cAAI,cAAc,cAAc,CAAd,EAAiB,OAAjB,CAAyB,OAAzB,EAAkC,EAAlC,CAAlB;;;AAGA,gBAAM,IAAI,KAAJ,CACJ,4BAA4B,IAA5B,GACE,wDADF,GAEE,cAFF,GAEmB,WAFnB,GAEiC,YAH7B,CAAN;AAIC;AACJ,OAvCD;AARQ,KAAV;AAiDA,QAAI,WAAW,SAAX,QAAW,CAAU,SAAV,EAAqB,QAArB,EAA+B,QAA/B,EAAyC;AACtD,UAAI,GAAJ;AACA,UAAI,CAAE,QAAN,EAAgB;AACd,cAAM,IAAI,MAAJ,EAAN;AACA,mBAAW,IAAI,QAAJ,EAAX;AACD;;;;;AAKD,UAAI,YAAY,QAAQ,MAAR,CAAe,MAAf,CAAsB,eAAtB,CAAsC,UAAU,GAAV,EAAe,MAAf,EAAuB;AAC3E,YAAI,UAAU,CAAE,QAAhB;;AAEE,mBAAS,IAAI,UAAJ,CAAe,MAAf,CAAT;AACF,iBAAS,GAAT,EAAc,MAAd;AACD,OALe,EAKb,UAAU,CAAV,EAAa;AACd,gBAAQ,GAAR,CAAY,mCAAZ,EAAiD,EAAE,KAAnD;AACD,OAPe,CAAhB;;;;AAWA,kBAAY,MAAM,qBAAN,CAA4B,SAA5B,CAAZ;;AAEA,UAAI,CAAC,SAAS,MAAV,IAAoB,CAAC,EAAE,GAAF,CAAM,SAAS,MAAf,EAAuB,SAAvB,CAAzB,EAA4D;AAC1D,kBAAU,IAAI,KAAJ,CAAU,oBAAoB,SAA9B,CAAV;AACD,OAFD,MAEO;AACL,YAAI,WAAW,KAAK,IAAL,CAAU,SAAV,EAAqB,SAAS,MAAT,CAAgB,SAAhB,CAArB,CAAf;AACA,WAAG,QAAH,CAAY,MAAM,eAAN,CAAsB,QAAtB,CAAZ,EAA6C,QAA7C,EAAuD,SAAvD;AACD;AACD,UAAI,GAAJ,EACE,OAAO,IAAI,IAAJ,EAAP;AACH,KA/BD;;AAiCA,QAAI,SAAS;AACX,eAAS,iBAAU,SAAV,EAAqB,QAArB,EAA+B;AACtC,eAAO,SAAS,SAAT,EAAoB,MAApB,EAA4B,QAA5B,CAAP;AACD,OAHU;AAIX,iBAAW,mBAAU,SAAV,EAAqB,QAArB,EAA+B;AACxC,eAAO,SAAS,SAAT,EAAoB,SAApB,EAA+B,QAA/B,CAAP;AACD,OANU;;;;;;;AAaX,wBAAkB,0BAAU,SAAV,EAAqB;AACrC,YAAI,CAAC,SAAS,MAAV,IAAoB,CAAC,EAAE,GAAF,CAAM,SAAS,MAAf,EAAuB,SAAvB,CAAzB,EAA4D;AAC1D,gBAAM,IAAI,KAAJ,CAAU,oBAAoB,SAA9B,CAAN;AACD;;AAED,oBAAY,MAAM,qBAAN,CAA4B,SAA5B,CAAZ;AACA,YAAI,WAAW,KAAK,IAAL,CAAU,SAAV,EAAqB,SAAS,MAAT,CAAgB,SAAhB,CAArB,CAAf;AACA,eAAO,MAAM,eAAN,CAAsB,QAAtB,CAAP;AACD;AArBU,KAAb;;AAwBA,QAAI,mBACF,SAAS,IAAT,KAAkB,6BADpB;;AAGA,QAAI,YAAY,CAAC,sBAAD,CAAhB;AACA,QAAI,gBAAJ,EAAsB;AACpB,gBAAU,IAAV,CAAe,aAAf;AACD;;AAED,cAAU,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2B,MAA3B;AACA,QAAI,UAAU,UAAU,IAAV,CAAe,EAAf,CAAd;;;;;;;;AAQA,QAAI,iBAAiB,MAAM,eAAN,CAAsB,SAAS,IAA/B,CAArB;AACA,QAAI,mBAAmB,KAAK,OAAL,CAAa,SAAb,EAAwB,cAAxB,CAAvB;;AAEA,QAAI,aACF,iBAAiB,gBAAjB,IAAqC,gBAArC,GAAwD,cAD1D;;;;AAKA,QAAI,OAAO,QAAQ,IAAR,EAAc,gBAAd,CAA+B,OAA/B,EAAwC,UAAxC,EAAoD,IAApD,CAAX;AACA,QAAI,OAAO,CAAC,GAAD,EAAM,MAAN,CAAX;AACA,QAAI,gBAAJ,EAAsB;AACpB,WAAK,IAAL,CAAU,UAAV;AACD;AACD,SAAK,KAAL,CAAW,MAAX,EAAmB,IAAnB;AACD,GArKD;;;;AAyKA,SAAO,qBAAqB,YAArB,CAAkC,MAAzC,EAAiD;AAC/C,QAAI,OAAO,qBAAqB,YAArB,CAAkC,KAAlC,EAAX;AACA;AACD;;AAED,uBAAqB,YAArB,GAAoC,IAApC;;;;AAIA,MAAI,QAAQ,EAAZ;AACA,MAAI,UAAJ;AACA,MAAI,UAAU,MAAd,EAAsB;AACpB,UAAM,IAAN,CAAW,IAAX;AACA,iBAAa,IAAb;AACD;AACD,SAAO,OAAP,KAAmB,WAAnB,IAAkC,EAAE,IAAF,CAAO,OAAP,EAAgB,UAAU,CAAV,EAAa,CAAb,EAAgB;AAChE,QAAI,UAAU,CAAV,IAAe,EAAE,IAAF,KAAW,UAA9B,EAA0C;AACxC,YAAM,IAAN,CAAW,EAAE,IAAb;AACD;AACF,GAJiC,CAAlC;AAKA,MAAI,CAAE,MAAM,MAAZ,EAAoB;AAClB,YAAQ,MAAR,CAAe,KAAf,CAAqB,mCAArB;AACA,YAAQ,IAAR,CAAa,CAAb;AACD;AACD,MAAI,MAAM,MAAN,GAAe,CAAnB,EAAsB;AACpB,YAAQ,MAAR,CAAe,KAAf,CAAqB,8CAArB;AACA,YAAQ,IAAR,CAAa,CAAb;AACD;AACD,MAAI,WAAW,MAAM,CAAN,EAAS,IAAT,CAAc,EAAd,EAAkB,QAAQ,IAAR,CAAa,KAAb,CAAmB,CAAnB,CAAlB,CAAf;;AAEA,MAAI,aAAa,QAAjB,EACE,QAAQ,IAAR,CAAa,QAAb;;AAEF,MAAI,QAAQ,GAAR,CAAY,iBAAhB,EAAmC;AACjC,4BAAwB,QAAQ,GAAR,CAAY,iBAApC;AACD;AACF,CA9MD,EA8MG,GA9MH","file":"/bundle/programs/server/boot.js.map","sourcesContent":["var Fiber = require(\"fibers\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar Future = require(\"fibers/future\");\nvar _ = require('underscore');\nvar sourcemap_support = require('source-map-support');\n\nvar bootUtils = require('./boot-utils.js');\nvar files = require('./mini-files.js');\nvar npmRequire = require('./npm-require.js').require;\n\n// This code is duplicated in tools/main.js.\nvar MIN_NODE_VERSION = 'v0.10.41';\n\nif (require('semver').lt(process.version, MIN_NODE_VERSION)) {\n  process.stderr.write(\n    'Meteor requires Node ' + MIN_NODE_VERSION + ' or later.\\n');\n  process.exit(1);\n}\n\n// read our control files\nvar serverJsonPath = path.resolve(process.argv[2]);\nvar serverDir = path.dirname(serverJsonPath);\nvar serverJson = require(\"./server-json.js\");\nvar configJson =\n  JSON.parse(fs.readFileSync(path.resolve(serverDir, 'config.json'), 'utf8'));\n\n// Set up environment\n__meteor_bootstrap__ = {\n  startupHooks: [],\n  serverDir: serverDir,\n  configJson: configJson };\n__meteor_runtime_config__ = { meteorRelease: configJson.meteorRelease };\n\nif (!process.env.APP_ID) {\n  process.env.APP_ID = configJson.appId;\n}\n\n// Map from load path to its source map.\nvar parsedSourceMaps = {};\n\n// Read all the source maps into memory once.\n_.each(serverJson.load, function (fileInfo) {\n  if (fileInfo.sourceMap) {\n    var rawSourceMap = fs.readFileSync(\n      path.resolve(serverDir, fileInfo.sourceMap), 'utf8');\n    // Parse the source map only once, not each time it's needed. Also remove\n    // the anti-XSSI header if it's there.\n    var parsedSourceMap = JSON.parse(rawSourceMap.replace(/^\\)\\]\\}'/, ''));\n    // source-map-support doesn't ever look at the sourcesContent field, so\n    // there's no point in keeping it in memory.\n    delete parsedSourceMap.sourcesContent;\n    var url;\n    if (fileInfo.sourceMapRoot) {\n      // Add the specified root to any root that may be in the file.\n      parsedSourceMap.sourceRoot = path.join(\n        fileInfo.sourceMapRoot, parsedSourceMap.sourceRoot || '');\n    }\n    parsedSourceMaps[path.resolve(__dirname, fileInfo.path)] = parsedSourceMap;\n  }\n});\n\nvar retrieveSourceMap = function (pathForSourceMap) {\n  if (_.has(parsedSourceMaps, pathForSourceMap))\n    return { map: parsedSourceMaps[pathForSourceMap] };\n  return null;\n};\n\nvar origWrapper = sourcemap_support.wrapCallSite;\nvar wrapCallSite = function (frame) {\n  var frame = origWrapper(frame);\n  var wrapGetter = function (name) {\n    var origGetter = frame[name];\n    frame[name] = function (arg) {\n      // replace a custom location domain that we set for better UX in Chrome\n      // DevTools (separate domain group) in source maps.\n      var source = origGetter(arg);\n      if (! source)\n        return source;\n      return source.replace(/(^|\\()meteor:\\/\\/..app\\//, '$1');\n    };\n  };\n  wrapGetter('getScriptNameOrSourceURL');\n  wrapGetter('getEvalOrigin');\n\n  return frame;\n};\nsourcemap_support.install({\n  // Use the source maps specified in program.json instead of parsing source\n  // code for them.\n  retrieveSourceMap: retrieveSourceMap,\n  // For now, don't fix the source line in uncaught exceptions, because we\n  // haven't fixed handleUncaughtExceptions in source-map-support to properly\n  // locate the source files.\n  handleUncaughtExceptions: false,\n  wrapCallSite: wrapCallSite\n});\n\n// As a replacement to the old keepalives mechanism, check for a running\n// parent every few seconds. Exit if the parent is not running.\n//\n// Two caveats to this strategy:\n// * Doesn't catch the case where the parent is CPU-hogging (but maybe we\n//   don't want to catch that case anyway, since the bundler not yielding\n//   is what caused #2536).\n// * Could be fooled by pid re-use, i.e. if another process comes up and\n//   takes the parent process's place before the child process dies.\nvar startCheckForLiveParent = function (parentPid) {\n  if (parentPid) {\n    if (! bootUtils.validPid(parentPid)) {\n      console.error(\"METEOR_PARENT_PID must be a valid process ID.\");\n      process.exit(1);\n    }\n\n    setInterval(function () {\n      try {\n        process.kill(parentPid, 0);\n      } catch (err) {\n        console.error(\"Parent process is dead! Exiting.\");\n        process.exit(1);\n      }\n    }, 3000);\n  }\n};\n\n\nFiber(function () {\n  _.each(serverJson.load, function (fileInfo) {\n    var code = fs.readFileSync(path.resolve(serverDir, fileInfo.path));\n    var nonLocalNodeModulesPaths = [];\n\n    function addNodeModulesPath(path) {\n      nonLocalNodeModulesPaths.push(\n        files.pathResolve(serverDir, path)\n      );\n    }\n\n    if (typeof fileInfo.node_modules === \"string\") {\n      addNodeModulesPath(fileInfo.node_modules);\n    } else if (fileInfo.node_modules) {\n      _.each(fileInfo.node_modules, function (info, path) {\n        if (! info.local) {\n          addNodeModulesPath(path);\n        }\n      });\n    }\n\n    function statOrNull(path) {\n      try {\n        return fs.statSync(path);\n      } catch (e) {\n        return null;\n      }\n    }\n\n    var Npm = {\n      /**\n       * @summary Require a package that was specified using\n       * `Npm.depends()`.\n       * @param  {String} name The name of the package to require.\n       * @locus Server\n       * @memberOf Npm\n       */\n      require: function (name) {\n        if (nonLocalNodeModulesPaths.length === 0) {\n          return require(name);\n        }\n\n        var fullPath;\n\n        nonLocalNodeModulesPaths.some(function (nodeModuleBase) {\n          var packageBase = files.convertToOSPath(files.pathResolve(\n            nodeModuleBase,\n            name.split(\"/\", 1)[0]\n          ));\n\n          if (statOrNull(packageBase)) {\n            return fullPath = files.convertToOSPath(\n              files.pathResolve(nodeModuleBase, name)\n            );\n          }\n        });\n\n        if (fullPath) {\n          return require(fullPath);\n        }\n\n        try {\n          return require(name);\n        } catch (e) {\n          // Try to guess the package name so we can print a nice\n          // error message\n          // fileInfo.path is a standard path, use files.pathSep\n          var filePathParts = fileInfo.path.split(files.pathSep);\n          var packageName = filePathParts[1].replace(/\\.js$/, '');\n\n          // XXX better message\n          throw new Error(\n            \"Can't find npm module '\" + name +\n              \"'. Did you forget to call 'Npm.depends' in package.js \" +\n              \"within the '\" + packageName + \"' package?\");\n          }\n      }\n    };\n    var getAsset = function (assetPath, encoding, callback) {\n      var fut;\n      if (! callback) {\n        fut = new Future();\n        callback = fut.resolver();\n      }\n      // This assumes that we've already loaded the meteor package, so meteor\n      // itself can't call Assets.get*. (We could change this function so that\n      // it doesn't call bindEnvironment if you don't pass a callback if we need\n      // to.)\n      var _callback = Package.meteor.Meteor.bindEnvironment(function (err, result) {\n        if (result && ! encoding)\n          // Sadly, this copies in Node 0.10.\n          result = new Uint8Array(result);\n        callback(err, result);\n      }, function (e) {\n        console.log(\"Exception in callback of getAsset\", e.stack);\n      });\n\n      // Convert a DOS-style path to Unix-style in case the application code was\n      // written on Windows.\n      assetPath = files.convertToStandardPath(assetPath);\n\n      if (!fileInfo.assets || !_.has(fileInfo.assets, assetPath)) {\n        _callback(new Error(\"Unknown asset: \" + assetPath));\n      } else {\n        var filePath = path.join(serverDir, fileInfo.assets[assetPath]);\n        fs.readFile(files.convertToOSPath(filePath), encoding, _callback);\n      }\n      if (fut)\n        return fut.wait();\n    };\n\n    var Assets = {\n      getText: function (assetPath, callback) {\n        return getAsset(assetPath, \"utf8\", callback);\n      },\n      getBinary: function (assetPath, callback) {\n        return getAsset(assetPath, undefined, callback);\n      },\n      /**\n       * @summary Get the absolute path to the static server asset. Note that assets are read-only.\n       * @locus Server [Not in build plugins]\n       * @memberOf Assets\n       * @param {String} assetPath The path of the asset, relative to the application's `private` subdirectory.\n       */\n      absoluteFilePath: function (assetPath) {\n        if (!fileInfo.assets || !_.has(fileInfo.assets, assetPath)) {\n          throw new Error(\"Unknown asset: \" + assetPath);\n        }\n\n        assetPath = files.convertToStandardPath(assetPath);\n        var filePath = path.join(serverDir, fileInfo.assets[assetPath]);\n        return files.convertToOSPath(filePath);\n      },\n    };\n\n    var isModulesRuntime =\n      fileInfo.path === \"packages/modules-runtime.js\";\n\n    var wrapParts = [\"(function(Npm,Assets\"];\n    if (isModulesRuntime) {\n      wrapParts.push(\",npmRequire\");\n    }\n    // \\n is necessary in case final line is a //-comment\n    wrapParts.push(\"){\", code, \"\\n})\");\n    var wrapped = wrapParts.join(\"\");\n\n    // It is safer to use the absolute path when source map is present as\n    // different tooling, such as node-inspector, can get confused on relative\n    // urls.\n\n    // fileInfo.path is a standard path, convert it to OS path to join with\n    // __dirname\n    var fileInfoOSPath = files.convertToOSPath(fileInfo.path);\n    var absoluteFilePath = path.resolve(__dirname, fileInfoOSPath);\n\n    var scriptPath =\n      parsedSourceMaps[absoluteFilePath] ? absoluteFilePath : fileInfoOSPath;\n    // The final 'true' is an undocumented argument to runIn[Foo]Context that\n    // causes it to print out a descriptive error message on parse error. It's\n    // what require() uses to generate its errors.\n    var func = require('vm').runInThisContext(wrapped, scriptPath, true);\n    var args = [Npm, Assets];\n    if (isModulesRuntime) {\n      args.push(npmRequire);\n    }\n    func.apply(global, args);\n  });\n\n  // run the user startup hooks.  other calls to startup() during this can still\n  // add hooks to the end.\n  while (__meteor_bootstrap__.startupHooks.length) {\n    var hook = __meteor_bootstrap__.startupHooks.shift();\n    hook();\n  }\n  // Setting this to null tells Meteor.startup to call hooks immediately.\n  __meteor_bootstrap__.startupHooks = null;\n\n  // find and run main()\n  // XXX hack. we should know the package that contains main.\n  var mains = [];\n  var globalMain;\n  if ('main' in global) {\n    mains.push(main);\n    globalMain = main;\n  }\n  typeof Package !== 'undefined' && _.each(Package, function (p, n) {\n    if ('main' in p && p.main !== globalMain) {\n      mains.push(p.main);\n    }\n  });\n  if (! mains.length) {\n    process.stderr.write(\"Program has no main() function.\\n\");\n    process.exit(1);\n  }\n  if (mains.length > 1) {\n    process.stderr.write(\"Program has more than one main() function?\\n\");\n    process.exit(1);\n  }\n  var exitCode = mains[0].call({}, process.argv.slice(3));\n  // XXX hack, needs a better way to keep alive\n  if (exitCode !== 'DAEMON')\n    process.exit(exitCode);\n\n  if (process.env.METEOR_PARENT_PID) {\n    startCheckForLiveParent(process.env.METEOR_PARENT_PID);\n  }\n}).run();\n"]},"hash":"bd59ec674e4eb2cfcf93dc51e6968afd9fe39291"}

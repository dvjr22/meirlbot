{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/autoupdate.js","filenameRelative":"/bundle/programs/server/packages/autoupdate.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/autoupdate.js.map","sourceFileName":"/bundle/programs/server/packages/autoupdate.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"autoupdate"},"ignored":false,"code":"(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var WebApp = Package.webapp.WebApp;\n  var main = Package.webapp.main;\n  var WebAppInternals = Package.webapp.WebAppInternals;\n  var check = Package.check.check;\n  var Match = Package.check.Match;\n  var DDP = Package['ddp-client'].DDP;\n  var DDPServer = Package['ddp-server'].DDPServer;\n  var MongoInternals = Package.mongo.MongoInternals;\n  var Mongo = Package.mongo.Mongo;\n  var _ = Package.underscore._;\n\n  /* Package-scope variables */\n  var Autoupdate, ClientVersions;\n\n  (function () {\n\n    //////////////////////////////////////////////////////////////////////////////////\n    //                                                                              //\n    // packages/autoupdate/autoupdate_server.js                                     //\n    //                                                                              //\n    //////////////////////////////////////////////////////////////////////////////////\n    //\n    // Publish the current client versions to the client.  When a client\n    // sees the subscription change and that there is a new version of the\n    // client available on the server, it can reload.\n    //\n    // By default there are two current client versions. The refreshable client\n    // version is identified by a hash of the client resources seen by the browser\n    // that are refreshable, such as CSS, while the non refreshable client version\n    // is identified by a hash of the rest of the client assets\n    // (the HTML, code, and static files in the `public` directory).\n    //\n    // If the environment variable `AUTOUPDATE_VERSION` is set it will be\n    // used as the client id instead.  You can use this to control when\n    // the client reloads.  For example, if you want to only force a\n    // reload on major changes, you can use a custom AUTOUPDATE_VERSION\n    // which you only change when something worth pushing to clients\n    // immediately happens.\n    //\n    // The server publishes a `meteor_autoupdate_clientVersions`\n    // collection. There are two documents in this collection, a document\n    // with _id 'version' which represents the non refreshable client assets,\n    // and a document with _id 'version-refreshable' which represents the\n    // refreshable client assets. Each document has a 'version' field\n    // which is equivalent to the hash of the relevant assets. The refreshable\n    // document also contains a list of the refreshable assets, so that the client\n    // can swap in the new assets without forcing a page refresh. Clients can\n    // observe changes on these documents to detect when there is a new\n    // version available.\n    //\n    // In this implementation only two documents are present in the collection\n    // the current refreshable client version and the current nonRefreshable client\n    // version.  Developers can easily experiment with different versioning and\n    // updating models by forking this package.\n\n    var Future = Npm.require(\"fibers/future\");\n\n    Autoupdate = {};\n\n    // The collection of acceptable client versions.\n    ClientVersions = new Mongo.Collection(\"meteor_autoupdate_clientVersions\", { connection: null });\n\n    // The client hash includes __meteor_runtime_config__, so wait until\n    // all packages have loaded and have had a chance to populate the\n    // runtime config before using the client hash as our default auto\n    // update version id.\n\n    // Note: Tests allow people to override Autoupdate.autoupdateVersion before\n    // startup.\n    Autoupdate.autoupdateVersion = null;\n    Autoupdate.autoupdateVersionRefreshable = null;\n    Autoupdate.autoupdateVersionCordova = null;\n    Autoupdate.appId = __meteor_runtime_config__.appId = process.env.APP_ID;\n\n    var syncQueue = new Meteor._SynchronousQueue();\n\n    // updateVersions can only be called after the server has fully loaded.\n    var updateVersions = function updateVersions(shouldReloadClientProgram) {\n      // Step 1: load the current client program on the server and update the\n      // hash values in __meteor_runtime_config__.\n      if (shouldReloadClientProgram) {\n        WebAppInternals.reloadClientPrograms();\n      }\n\n      // If we just re-read the client program, or if we don't have an autoupdate\n      // version, calculate it.\n      if (shouldReloadClientProgram || Autoupdate.autoupdateVersion === null) {\n        Autoupdate.autoupdateVersion = process.env.AUTOUPDATE_VERSION || WebApp.calculateClientHashNonRefreshable();\n      }\n      // If we just recalculated it OR if it was set by (eg) test-in-browser,\n      // ensure it ends up in __meteor_runtime_config__.\n      __meteor_runtime_config__.autoupdateVersion = Autoupdate.autoupdateVersion;\n\n      Autoupdate.autoupdateVersionRefreshable = __meteor_runtime_config__.autoupdateVersionRefreshable = process.env.AUTOUPDATE_VERSION || WebApp.calculateClientHashRefreshable();\n\n      Autoupdate.autoupdateVersionCordova = __meteor_runtime_config__.autoupdateVersionCordova = process.env.AUTOUPDATE_VERSION || WebApp.calculateClientHashCordova();\n\n      // Step 2: form the new client boilerplate which contains the updated\n      // assets and __meteor_runtime_config__.\n      if (shouldReloadClientProgram) {\n        WebAppInternals.generateBoilerplate();\n      }\n\n      // XXX COMPAT WITH 0.8.3\n      if (!ClientVersions.findOne({ current: true })) {\n        // To ensure apps with version of Meteor prior to 0.9.0 (in\n        // which the structure of documents in `ClientVersions` was\n        // different) also reload.\n        ClientVersions.insert({ current: true });\n      }\n\n      if (!ClientVersions.findOne({ _id: \"version\" })) {\n        ClientVersions.insert({\n          _id: \"version\",\n          version: Autoupdate.autoupdateVersion\n        });\n      } else {\n        ClientVersions.update(\"version\", { $set: {\n            version: Autoupdate.autoupdateVersion\n          } });\n      }\n\n      if (!ClientVersions.findOne({ _id: \"version-cordova\" })) {\n        ClientVersions.insert({\n          _id: \"version-cordova\",\n          version: Autoupdate.autoupdateVersionCordova,\n          refreshable: false\n        });\n      } else {\n        ClientVersions.update(\"version-cordova\", { $set: {\n            version: Autoupdate.autoupdateVersionCordova\n          } });\n      }\n\n      // Use `onListening` here because we need to use\n      // `WebAppInternals.refreshableAssets`, which is only set after\n      // `WebApp.generateBoilerplate` is called by `main` in webapp.\n      WebApp.onListening(function () {\n        if (!ClientVersions.findOne({ _id: \"version-refreshable\" })) {\n          ClientVersions.insert({\n            _id: \"version-refreshable\",\n            version: Autoupdate.autoupdateVersionRefreshable,\n            assets: WebAppInternals.refreshableAssets\n          });\n        } else {\n          ClientVersions.update(\"version-refreshable\", { $set: {\n              version: Autoupdate.autoupdateVersionRefreshable,\n              assets: WebAppInternals.refreshableAssets\n            } });\n        }\n      });\n    };\n\n    Meteor.publish(\"meteor_autoupdate_clientVersions\", function (appId) {\n      // `null` happens when a client doesn't have an appId and passes\n      // `undefined` to `Meteor.subscribe`. `undefined` is translated to\n      // `null` as JSON doesn't have `undefined.\n      check(appId, Match.OneOf(String, undefined, null));\n\n      // Don't notify clients using wrong appId such as mobile apps built with a\n      // different server but pointing at the same local url\n      if (Autoupdate.appId && appId && Autoupdate.appId !== appId) return [];\n\n      return ClientVersions.find();\n    }, { is_auto: true });\n\n    Meteor.startup(function () {\n      updateVersions(false);\n    });\n\n    var fut = new Future();\n\n    // We only want 'refresh' to trigger 'updateVersions' AFTER onListen,\n    // so we add a queued task that waits for onListen before 'refresh' can queue\n    // tasks. Note that the `onListening` callbacks do not fire until after\n    // Meteor.startup, so there is no concern that the 'updateVersions' calls from\n    // 'refresh' will overlap with the `updateVersions` call from Meteor.startup.\n\n    syncQueue.queueTask(function () {\n      fut.wait();\n    });\n\n    WebApp.onListening(function () {\n      fut['return']();\n    });\n\n    var enqueueVersionsRefresh = function enqueueVersionsRefresh() {\n      syncQueue.queueTask(function () {\n        updateVersions(true);\n      });\n    };\n\n    // Listen for the special {refresh: 'client'} message, which signals that a\n    // client asset has changed.\n    process.on('message', Meteor.bindEnvironment(function (m) {\n      if (m && m.refresh === 'client') {\n        enqueueVersionsRefresh();\n      }\n    }, \"handling client refresh message\"));\n\n    // Another way to tell the process to refresh: send SIGHUP signal\n    process.on('SIGHUP', Meteor.bindEnvironment(function () {\n      enqueueVersionsRefresh();\n    }, \"handling SIGHUP signal for refresh\"));\n\n    //////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package.autoupdate = {}, {\n    Autoupdate: Autoupdate\n  });\n})();\n\n//# sourceMappingURL=autoupdate.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/autoupdate.js"],"names":[],"mappings":"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","file":"/bundle/programs/server/packages/autoupdate.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar WebApp = Package.webapp.WebApp;\nvar main = Package.webapp.main;\nvar WebAppInternals = Package.webapp.WebAppInternals;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar DDP = Package['ddp-client'].DDP;\nvar DDPServer = Package['ddp-server'].DDPServer;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar _ = Package.underscore._;\n\n/* Package-scope variables */\nvar Autoupdate, ClientVersions;\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////\n//                                                                              //\n// packages/autoupdate/autoupdate_server.js                                     //\n//                                                                              //\n//////////////////////////////////////////////////////////////////////////////////\n                                                                                //\n// Publish the current client versions to the client.  When a client\n// sees the subscription change and that there is a new version of the\n// client available on the server, it can reload.\n//\n// By default there are two current client versions. The refreshable client\n// version is identified by a hash of the client resources seen by the browser\n// that are refreshable, such as CSS, while the non refreshable client version\n// is identified by a hash of the rest of the client assets\n// (the HTML, code, and static files in the `public` directory).\n//\n// If the environment variable `AUTOUPDATE_VERSION` is set it will be\n// used as the client id instead.  You can use this to control when\n// the client reloads.  For example, if you want to only force a\n// reload on major changes, you can use a custom AUTOUPDATE_VERSION\n// which you only change when something worth pushing to clients\n// immediately happens.\n//\n// The server publishes a `meteor_autoupdate_clientVersions`\n// collection. There are two documents in this collection, a document\n// with _id 'version' which represents the non refreshable client assets,\n// and a document with _id 'version-refreshable' which represents the\n// refreshable client assets. Each document has a 'version' field\n// which is equivalent to the hash of the relevant assets. The refreshable\n// document also contains a list of the refreshable assets, so that the client\n// can swap in the new assets without forcing a page refresh. Clients can\n// observe changes on these documents to detect when there is a new\n// version available.\n//\n// In this implementation only two documents are present in the collection\n// the current refreshable client version and the current nonRefreshable client\n// version.  Developers can easily experiment with different versioning and\n// updating models by forking this package.\n\nvar Future = Npm.require(\"fibers/future\");\n\nAutoupdate = {};\n\n// The collection of acceptable client versions.\nClientVersions = new Mongo.Collection(\"meteor_autoupdate_clientVersions\",\n  { connection: null });\n\n// The client hash includes __meteor_runtime_config__, so wait until\n// all packages have loaded and have had a chance to populate the\n// runtime config before using the client hash as our default auto\n// update version id.\n\n// Note: Tests allow people to override Autoupdate.autoupdateVersion before\n// startup.\nAutoupdate.autoupdateVersion = null;\nAutoupdate.autoupdateVersionRefreshable = null;\nAutoupdate.autoupdateVersionCordova = null;\nAutoupdate.appId = __meteor_runtime_config__.appId = process.env.APP_ID;\n\nvar syncQueue = new Meteor._SynchronousQueue();\n\n// updateVersions can only be called after the server has fully loaded.\nvar updateVersions = function (shouldReloadClientProgram) {\n  // Step 1: load the current client program on the server and update the\n  // hash values in __meteor_runtime_config__.\n  if (shouldReloadClientProgram) {\n    WebAppInternals.reloadClientPrograms();\n  }\n\n  // If we just re-read the client program, or if we don't have an autoupdate\n  // version, calculate it.\n  if (shouldReloadClientProgram || Autoupdate.autoupdateVersion === null) {\n    Autoupdate.autoupdateVersion =\n      process.env.AUTOUPDATE_VERSION ||\n      WebApp.calculateClientHashNonRefreshable();\n  }\n  // If we just recalculated it OR if it was set by (eg) test-in-browser,\n  // ensure it ends up in __meteor_runtime_config__.\n  __meteor_runtime_config__.autoupdateVersion =\n    Autoupdate.autoupdateVersion;\n\n  Autoupdate.autoupdateVersionRefreshable =\n    __meteor_runtime_config__.autoupdateVersionRefreshable =\n      process.env.AUTOUPDATE_VERSION ||\n      WebApp.calculateClientHashRefreshable();\n\n  Autoupdate.autoupdateVersionCordova =\n    __meteor_runtime_config__.autoupdateVersionCordova =\n      process.env.AUTOUPDATE_VERSION ||\n      WebApp.calculateClientHashCordova();\n\n  // Step 2: form the new client boilerplate which contains the updated\n  // assets and __meteor_runtime_config__.\n  if (shouldReloadClientProgram) {\n    WebAppInternals.generateBoilerplate();\n  }\n\n  // XXX COMPAT WITH 0.8.3\n  if (! ClientVersions.findOne({current: true})) {\n    // To ensure apps with version of Meteor prior to 0.9.0 (in\n    // which the structure of documents in `ClientVersions` was\n    // different) also reload.\n    ClientVersions.insert({current: true});\n  }\n\n  if (! ClientVersions.findOne({_id: \"version\"})) {\n    ClientVersions.insert({\n      _id: \"version\",\n      version: Autoupdate.autoupdateVersion\n    });\n  } else {\n    ClientVersions.update(\"version\", { $set: {\n      version: Autoupdate.autoupdateVersion\n    }});\n  }\n\n  if (! ClientVersions.findOne({_id: \"version-cordova\"})) {\n    ClientVersions.insert({\n      _id: \"version-cordova\",\n      version: Autoupdate.autoupdateVersionCordova,\n      refreshable: false\n    });\n  } else {\n    ClientVersions.update(\"version-cordova\", { $set: {\n      version: Autoupdate.autoupdateVersionCordova\n    }});\n  }\n\n  // Use `onListening` here because we need to use\n  // `WebAppInternals.refreshableAssets`, which is only set after\n  // `WebApp.generateBoilerplate` is called by `main` in webapp.\n  WebApp.onListening(function () {\n    if (! ClientVersions.findOne({_id: \"version-refreshable\"})) {\n      ClientVersions.insert({\n        _id: \"version-refreshable\",\n        version: Autoupdate.autoupdateVersionRefreshable,\n        assets: WebAppInternals.refreshableAssets\n      });\n    } else {\n      ClientVersions.update(\"version-refreshable\", { $set: {\n        version: Autoupdate.autoupdateVersionRefreshable,\n        assets: WebAppInternals.refreshableAssets\n      }});\n    }\n  });\n};\n\nMeteor.publish(\n  \"meteor_autoupdate_clientVersions\",\n  function (appId) {\n    // `null` happens when a client doesn't have an appId and passes\n    // `undefined` to `Meteor.subscribe`. `undefined` is translated to\n    // `null` as JSON doesn't have `undefined.\n    check(appId, Match.OneOf(String, undefined, null));\n\n    // Don't notify clients using wrong appId such as mobile apps built with a\n    // different server but pointing at the same local url\n    if (Autoupdate.appId && appId && Autoupdate.appId !== appId)\n      return [];\n\n    return ClientVersions.find();\n  },\n  {is_auto: true}\n);\n\nMeteor.startup(function () {\n  updateVersions(false);\n});\n\nvar fut = new Future();\n\n// We only want 'refresh' to trigger 'updateVersions' AFTER onListen,\n// so we add a queued task that waits for onListen before 'refresh' can queue\n// tasks. Note that the `onListening` callbacks do not fire until after\n// Meteor.startup, so there is no concern that the 'updateVersions' calls from\n// 'refresh' will overlap with the `updateVersions` call from Meteor.startup.\n\nsyncQueue.queueTask(function () {\n  fut.wait();\n});\n\nWebApp.onListening(function () {\n  fut.return();\n});\n\nvar enqueueVersionsRefresh = function () {\n  syncQueue.queueTask(function () {\n    updateVersions(true);\n  });\n};\n\n// Listen for the special {refresh: 'client'} message, which signals that a\n// client asset has changed.\nprocess.on('message', Meteor.bindEnvironment(function (m) {\n  if (m && m.refresh === 'client') {\n    enqueueVersionsRefresh();\n  }\n}, \"handling client refresh message\"));\n\n// Another way to tell the process to refresh: send SIGHUP signal\nprocess.on('SIGHUP', Meteor.bindEnvironment(function () {\n  enqueueVersionsRefresh();\n}, \"handling SIGHUP signal for refresh\"));\n\n\n//////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package.autoupdate = {}, {\n  Autoupdate: Autoupdate\n});\n\n})();\n\n//# sourceMappingURL=autoupdate.js.map\n"]},"hash":"1ff16a8133250266b697af63d6c73986f1438f53"}

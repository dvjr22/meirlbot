{"metadata":{"usedHelpers":["typeof"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/check.js","filenameRelative":"/bundle/programs/server/packages/check.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/check.js.map","sourceFileName":"/bundle/programs/server/packages/check.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"check"},"ignored":false,"code":"var _typeof;module.import(\"babel-runtime/helpers/typeof\",{\"default\":function(v){_typeof=v}});\n(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var meteorInstall = Package.modules.meteorInstall;\n  var Buffer = Package.modules.Buffer;\n  var process = Package.modules.process;\n  var _ = Package.underscore._;\n  var EJSON = Package.ejson.EJSON;\n\n  /* Package-scope variables */\n  var check, Match;\n\n  var require = meteorInstall({ \"node_modules\": { \"meteor\": { \"check\": { \"match.js\": [\"./isPlainObject.js\", function (require, exports) {\n\n            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                   //\n            // packages/check/match.js                                                                                           //\n            //                                                                                                                   //\n            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            // XXX docs\n\n            // Things we explicitly do NOT support:\n            //    - heterogenous arrays\n\n            var currentArgumentChecker = new Meteor.EnvironmentVariable();\n            var isPlainObject = require(\"./isPlainObject.js\").isPlainObject;\n\n            /**\n             * @summary Check that a value matches a [pattern](#matchpatterns).\n             * If the value does not match the pattern, throw a `Match.Error`.\n             *\n             * Particularly useful to assert that arguments to a function have the right\n             * types and structure.\n             * @locus Anywhere\n             * @param {Any} value The value to check\n             * @param {MatchPattern} pattern The pattern to match\n             * `value` against\n             */\n            var check = exports.check = function (value, pattern) {\n              // Record that check got called, if somebody cared.\n              //\n              // We use getOrNullIfOutsideFiber so that it's OK to call check()\n              // from non-Fiber server contexts; the downside is that if you forget to\n              // bindEnvironment on some random callback in your method/publisher,\n              // it might not find the argumentChecker and you'll get an error about\n              // not checking an argument that it looks like you're checking (instead\n              // of just getting a \"Node code must run in a Fiber\" error).\n              var argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();\n              if (argChecker) argChecker.checking(value);\n              var result = testSubtree(value, pattern);\n              if (result) {\n                var err = new Match.Error(result.message);\n                if (result.path) {\n                  err.message += \" in field \" + result.path;\n                  err.path = result.path;\n                }\n                throw err;\n              }\n            };\n\n            /**\n             * @namespace Match\n             * @summary The namespace for all Match types and methods.\n             */\n            var Match = exports.Match = {\n              Optional: function Optional(pattern) {\n                return new _Optional(pattern);\n              },\n              Maybe: function Maybe(pattern) {\n                return new _Maybe(pattern);\n              },\n              OneOf: function OneOf() /*arguments*/{\n                return new _OneOf(_.toArray(arguments));\n              },\n              Any: ['__any__'],\n              Where: function Where(condition) {\n                return new _Where(condition);\n              },\n              ObjectIncluding: function ObjectIncluding(pattern) {\n                return new _ObjectIncluding(pattern);\n              },\n              ObjectWithValues: function ObjectWithValues(pattern) {\n                return new _ObjectWithValues(pattern);\n              },\n              // Matches only signed 32-bit integers\n              Integer: ['__integer__'],\n\n              // XXX matchers should know how to describe themselves for errors\n              Error: Meteor.makeErrorType(\"Match.Error\", function (msg) {\n                this.message = \"Match error: \" + msg;\n                // The path of the value that failed to match. Initially empty, this gets\n                // populated by catching and rethrowing the exception as it goes back up the\n                // stack.\n                // E.g.: \"vals[3].entity.created\"\n                this.path = \"\";\n                // If this gets sent over DDP, don't give full internal details but at least\n                // provide something better than 500 Internal server error.\n                this.sanitizedError = new Meteor.Error(400, \"Match failed\");\n              }),\n\n              // Tests to see if value matches pattern. Unlike check, it merely returns true\n              // or false (unless an error other than Match.Error was thrown). It does not\n              // interact with _failIfArgumentsAreNotAllChecked.\n              // XXX maybe also implement a Match.match which returns more information about\n              //     failures but without using exception handling or doing what check()\n              //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion\n\n              /**\n               * @summary Returns true if the value matches the pattern.\n               * @locus Anywhere\n               * @param {Any} value The value to check\n               * @param {MatchPattern} pattern The pattern to match `value` against\n               */\n              test: function test(value, pattern) {\n                return !testSubtree(value, pattern);\n              },\n\n              // Runs `f.apply(context, args)`. If check() is not called on every element of\n              // `args` (either directly or in the first level of an array), throws an error\n              // (using `description` in the message).\n              //\n              _failIfArgumentsAreNotAllChecked: function _failIfArgumentsAreNotAllChecked(f, context, args, description) {\n                var argChecker = new ArgumentChecker(args, description);\n                var result = currentArgumentChecker.withValue(argChecker, function () {\n                  return f.apply(context, args);\n                });\n                // If f didn't itself throw, make sure it checked all of its arguments.\n                argChecker.throwUnlessAllArgumentsHaveBeenChecked();\n                return result;\n              }\n            };\n\n            var _Optional = function _Optional(pattern) {\n              this.pattern = pattern;\n            };\n\n            var _Maybe = function _Maybe(pattern) {\n              this.pattern = pattern;\n            };\n\n            var _OneOf = function _OneOf(choices) {\n              if (_.isEmpty(choices)) throw new Error(\"Must provide at least one choice to Match.OneOf\");\n              this.choices = choices;\n            };\n\n            var _Where = function _Where(condition) {\n              this.condition = condition;\n            };\n\n            var _ObjectIncluding = function _ObjectIncluding(pattern) {\n              this.pattern = pattern;\n            };\n\n            var _ObjectWithValues = function _ObjectWithValues(pattern) {\n              this.pattern = pattern;\n            };\n\n            var stringForErrorMessage = function stringForErrorMessage(value, options) {\n              options = options || {};\n\n              if (value === null) return \"null\";\n\n              if (options.onlyShowType) {\n                return typeof value === \"undefined\" ? \"undefined\" : _typeof(value);\n              }\n\n              // Your average non-object things.  Saves from doing the try/catch below for.\n              if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") {\n                return EJSON.stringify(value);\n              }\n\n              try {\n                // Find objects with circular references since EJSON doesn't support them yet (Issue #4778 + Unaccepted PR)\n                // If the native stringify is going to choke, EJSON.stringify is going to choke too.\n                JSON.stringify(value);\n              } catch (stringifyError) {\n                if (stringifyError.name === \"TypeError\") {\n                  return typeof value === \"undefined\" ? \"undefined\" : _typeof(value);\n                }\n              }\n\n              return EJSON.stringify(value);\n            };\n\n            var typeofChecks = [[String, \"string\"], [Number, \"number\"], [Boolean, \"boolean\"],\n            // While we don't allow undefined/function in EJSON, this is good for optional\n            // arguments with OneOf.\n            [Function, \"function\"], [undefined, \"undefined\"]];\n\n            // Return `false` if it matches. Otherwise, return an object with a `message` and a `path` field.\n            var testSubtree = function testSubtree(value, pattern) {\n              // Match anything!\n              if (pattern === Match.Any) return false;\n\n              // Basic atomic types.\n              // Do not match boxed objects (e.g. String, Boolean)\n              for (var i = 0; i < typeofChecks.length; ++i) {\n                if (pattern === typeofChecks[i][0]) {\n                  if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === typeofChecks[i][1]) return false;\n                  return {\n                    message: \"Expected \" + typeofChecks[i][1] + \", got \" + stringForErrorMessage(value, { onlyShowType: true }),\n                    path: \"\"\n                  };\n                }\n              }\n\n              if (pattern === null) {\n                if (value === null) {\n                  return false;\n                }\n                return {\n                  message: \"Expected null, got \" + stringForErrorMessage(value),\n                  path: \"\"\n                };\n              }\n\n              // Strings, numbers, and booleans match literally. Goes well with Match.OneOf.\n              if (typeof pattern === \"string\" || typeof pattern === \"number\" || typeof pattern === \"boolean\") {\n                if (value === pattern) return false;\n                return {\n                  message: \"Expected \" + pattern + \", got \" + stringForErrorMessage(value),\n                  path: \"\"\n                };\n              }\n\n              // Match.Integer is special type encoded with array\n              if (pattern === Match.Integer) {\n                // There is no consistent and reliable way to check if variable is a 64-bit\n                // integer. One of the popular solutions is to get reminder of division by 1\n                // but this method fails on really large floats with big precision.\n                // E.g.: 1.348192308491824e+23 % 1 === 0 in V8\n                // Bitwise operators work consistantly but always cast variable to 32-bit\n                // signed integer according to JavaScript specs.\n                if (typeof value === \"number\" && (value | 0) === value) return false;\n                return {\n                  message: \"Expected Integer, got \" + stringForErrorMessage(value),\n                  path: \"\"\n                };\n              }\n\n              // \"Object\" is shorthand for Match.ObjectIncluding({});\n              if (pattern === Object) pattern = Match.ObjectIncluding({});\n\n              // Array (checked AFTER Any, which is implemented as an Array).\n              if (pattern instanceof Array) {\n                if (pattern.length !== 1) {\n                  return {\n                    message: \"Bad pattern: arrays must have one type element\" + stringForErrorMessage(pattern),\n                    path: \"\"\n                  };\n                }\n                if (!_.isArray(value) && !_.isArguments(value)) {\n                  return {\n                    message: \"Expected array, got \" + stringForErrorMessage(value),\n                    path: \"\"\n                  };\n                }\n\n                for (var i = 0, length = value.length; i < length; i++) {\n                  var result = testSubtree(value[i], pattern[0]);\n                  if (result) {\n                    result.path = _prependPath(i, result.path);\n                    return result;\n                  }\n                }\n                return false;\n              }\n\n              // Arbitrary validation checks. The condition can return false or throw a\n              // Match.Error (ie, it can internally use check()) to fail.\n              if (pattern instanceof _Where) {\n                var result;\n                try {\n                  result = pattern.condition(value);\n                } catch (err) {\n                  if (!(err instanceof Match.Error)) throw err;\n                  return {\n                    message: err.message,\n                    path: err.path\n                  };\n                }\n                if (result) return false;\n                // XXX this error is terrible\n                return {\n                  message: \"Failed Match.Where validation\",\n                  path: \"\"\n                };\n              }\n\n              if (pattern instanceof _Maybe) {\n                pattern = Match.OneOf(undefined, null, pattern.pattern);\n              } else if (pattern instanceof _Optional) {\n                pattern = Match.OneOf(undefined, pattern.pattern);\n              }\n\n              if (pattern instanceof _OneOf) {\n                for (var i = 0; i < pattern.choices.length; ++i) {\n                  var result = testSubtree(value, pattern.choices[i]);\n                  if (!result) {\n                    // No error? Yay, return.\n                    return false;\n                  }\n                  // Match errors just mean try another choice.\n                }\n                // XXX this error is terrible\n                return {\n                  message: \"Failed Match.OneOf, Match.Maybe or Match.Optional validation\",\n                  path: \"\"\n                };\n              }\n\n              // A function that isn't something we special-case is assumed to be a\n              // constructor.\n              if (pattern instanceof Function) {\n                if (value instanceof pattern) return false;\n                return {\n                  message: \"Expected \" + (pattern.name || \"particular constructor\"),\n                  path: \"\"\n                };\n              }\n\n              var unknownKeysAllowed = false;\n              var unknownKeyPattern;\n              if (pattern instanceof _ObjectIncluding) {\n                unknownKeysAllowed = true;\n                pattern = pattern.pattern;\n              }\n              if (pattern instanceof _ObjectWithValues) {\n                unknownKeysAllowed = true;\n                unknownKeyPattern = [pattern.pattern];\n                pattern = {}; // no required keys\n              }\n\n              if ((typeof pattern === \"undefined\" ? \"undefined\" : _typeof(pattern)) !== \"object\") {\n                return {\n                  message: \"Bad pattern: unknown pattern type\",\n                  path: \"\"\n                };\n              }\n\n              // An object, with required and optional keys. Note that this does NOT do\n              // structural matches against objects of special types that happen to match\n              // the pattern: this really needs to be a plain old {Object}!\n              if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== 'object') {\n                return {\n                  message: \"Expected object, got \" + (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)),\n                  path: \"\"\n                };\n              }\n              if (value === null) {\n                return {\n                  message: \"Expected object, got null\",\n                  path: \"\"\n                };\n              }\n              if (!isPlainObject(value)) {\n                return {\n                  message: \"Expected plain object\",\n                  path: \"\"\n                };\n              }\n\n              var requiredPatterns = {};\n              var optionalPatterns = {};\n              _.each(pattern, function (subPattern, key) {\n                if (subPattern instanceof _Optional || subPattern instanceof _Maybe) optionalPatterns[key] = subPattern.pattern;else requiredPatterns[key] = subPattern;\n              });\n\n              //XXX: replace with underscore's _.allKeys if Meteor updates underscore to 1.8+ (or lodash)\n              var allKeys = function allKeys(obj) {\n                var keys = [];\n                if (_.isObject(obj)) {\n                  for (var key in obj) {\n                    keys.push(key);\n                  }\n                }\n                return keys;\n              };\n\n              for (var keys = allKeys(value), i = 0, length = keys.length; i < length; i++) {\n                var key = keys[i];\n                var subValue = value[key];\n                if (_.has(requiredPatterns, key)) {\n                  var result = testSubtree(subValue, requiredPatterns[key]);\n                  if (result) {\n                    result.path = _prependPath(key, result.path);\n                    return result;\n                  }\n                  delete requiredPatterns[key];\n                } else if (_.has(optionalPatterns, key)) {\n                  var result = testSubtree(subValue, optionalPatterns[key]);\n                  if (result) {\n                    result.path = _prependPath(key, result.path);\n                    return result;\n                  }\n                } else {\n                  if (!unknownKeysAllowed) {\n                    return {\n                      message: \"Unknown key\",\n                      path: key\n                    };\n                  }\n                  if (unknownKeyPattern) {\n                    var result = testSubtree(subValue, unknownKeyPattern[0]);\n                    if (result) {\n                      result.path = _prependPath(key, result.path);\n                      return result;\n                    }\n                  }\n                }\n              }\n\n              var keys = _.keys(requiredPatterns);\n              if (keys.length) {\n                return {\n                  message: \"Missing key '\" + keys[0] + \"'\",\n                  path: \"\"\n                };\n              }\n            };\n\n            var ArgumentChecker = function ArgumentChecker(args, description) {\n              var self = this;\n              // Make a SHALLOW copy of the arguments. (We'll be doing identity checks\n              // against its contents.)\n              self.args = _.clone(args);\n              // Since the common case will be to check arguments in order, and we splice\n              // out arguments when we check them, make it so we splice out from the end\n              // rather than the beginning.\n              self.args.reverse();\n              self.description = description;\n            };\n\n            _.extend(ArgumentChecker.prototype, {\n              checking: function checking(value) {\n                var self = this;\n                if (self._checkingOneValue(value)) return;\n                // Allow check(arguments, [String]) or check(arguments.slice(1), [String])\n                // or check([foo, bar], [String]) to count... but only if value wasn't\n                // itself an argument.\n                if (_.isArray(value) || _.isArguments(value)) {\n                  _.each(value, _.bind(self._checkingOneValue, self));\n                }\n              },\n              _checkingOneValue: function _checkingOneValue(value) {\n                var self = this;\n                for (var i = 0; i < self.args.length; ++i) {\n                  // Is this value one of the arguments? (This can have a false positive if\n                  // the argument is an interned primitive, but it's still a good enough\n                  // check.)\n                  // (NaN is not === to itself, so we have to check specially.)\n                  if (value === self.args[i] || _.isNaN(value) && _.isNaN(self.args[i])) {\n                    self.args.splice(i, 1);\n                    return true;\n                  }\n                }\n                return false;\n              },\n              throwUnlessAllArgumentsHaveBeenChecked: function throwUnlessAllArgumentsHaveBeenChecked() {\n                var self = this;\n                if (!_.isEmpty(self.args)) throw new Error(\"Did not check() all arguments during \" + self.description);\n              }\n            });\n\n            var _jsKeywords = [\"do\", \"if\", \"in\", \"for\", \"let\", \"new\", \"try\", \"var\", \"case\", \"else\", \"enum\", \"eval\", \"false\", \"null\", \"this\", \"true\", \"void\", \"with\", \"break\", \"catch\", \"class\", \"const\", \"super\", \"throw\", \"while\", \"yield\", \"delete\", \"export\", \"import\", \"public\", \"return\", \"static\", \"switch\", \"typeof\", \"default\", \"extends\", \"finally\", \"package\", \"private\", \"continue\", \"debugger\", \"function\", \"arguments\", \"interface\", \"protected\", \"implements\", \"instanceof\"];\n\n            // Assumes the base of path is already escaped properly\n            // returns key + base\n            var _prependPath = function _prependPath(key, base) {\n              if (typeof key === \"number\" || key.match(/^[0-9]+$/)) key = \"[\" + key + \"]\";else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) || _.contains(_jsKeywords, key)) key = JSON.stringify([key]);\n\n              if (base && base[0] !== \"[\") return key + '.' + base;\n              return key + base;\n            };\n\n            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }], \"isPlainObject.js\": function isPlainObjectJs(require, exports) {\n\n            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                   //\n            // packages/check/isPlainObject.js                                                                                   //\n            //                                                                                                                   //\n            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            // Copy of jQuery.isPlainObject for the server side from jQuery v1.11.2.\n\n            var class2type = {};\n\n            var toString = class2type.toString;\n\n            var hasOwn = class2type.hasOwnProperty;\n\n            var support = {};\n\n            // Populate the class2type map\n            _.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function (name, i) {\n              class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n            });\n\n            function type(obj) {\n              if (obj == null) {\n                return obj + \"\";\n              }\n              return (typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\" || typeof obj === \"function\" ? class2type[toString.call(obj)] || \"object\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n            }\n\n            function isWindow(obj) {\n              /* jshint eqeqeq: false */\n              return obj != null && obj == obj.window;\n            }\n\n            exports.isPlainObject = function (obj) {\n              var key;\n\n              // Must be an Object.\n              // Because of IE, we also have to check the presence of the constructor property.\n              // Make sure that DOM nodes and window objects don't pass through, as well\n              if (!obj || type(obj) !== \"object\" || obj.nodeType || isWindow(obj)) {\n                return false;\n              }\n\n              try {\n                // Not own constructor property must be Object\n                if (obj.constructor && !hasOwn.call(obj, \"constructor\") && !hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n                  return false;\n                }\n              } catch (e) {\n                // IE8,9 Will throw exceptions on certain host objects #9897\n                return false;\n              }\n\n              // Support: IE<9\n              // Handle iteration over inherited properties before own properties.\n              if (support.ownLast) {\n                for (key in obj) {\n                  return hasOwn.call(obj, key);\n                }\n              }\n\n              // Own properties are enumerated firstly, so to speed up,\n              // if last one is own, then all properties are own.\n              for (key in obj) {}\n\n              return key === undefined || hasOwn.call(obj, key);\n            };\n\n            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          } } } } }, { \"extensions\": [\".js\", \".json\"] });\n  var exports = require(\"./node_modules/meteor/check/match.js\");\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package.check = exports, {\n    check: check,\n    Match: Match\n  });\n})();\n\n//# sourceMappingURL=check.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/check.js"],"names":[],"mappings":"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","file":"/bundle/programs/server/packages/check.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Buffer = Package.modules.Buffer;\nvar process = Package.modules.process;\nvar _ = Package.underscore._;\nvar EJSON = Package.ejson.EJSON;\n\n/* Package-scope variables */\nvar check, Match;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"check\":{\"match.js\":[\"./isPlainObject.js\",function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/check/match.js                                                                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// XXX docs\n\n// Things we explicitly do NOT support:\n//    - heterogenous arrays\n\nvar currentArgumentChecker = new Meteor.EnvironmentVariable;\nvar isPlainObject = require(\"./isPlainObject.js\").isPlainObject;\n\n/**\n * @summary Check that a value matches a [pattern](#matchpatterns).\n * If the value does not match the pattern, throw a `Match.Error`.\n *\n * Particularly useful to assert that arguments to a function have the right\n * types and structure.\n * @locus Anywhere\n * @param {Any} value The value to check\n * @param {MatchPattern} pattern The pattern to match\n * `value` against\n */\nvar check = exports.check = function (value, pattern) {\n  // Record that check got called, if somebody cared.\n  //\n  // We use getOrNullIfOutsideFiber so that it's OK to call check()\n  // from non-Fiber server contexts; the downside is that if you forget to\n  // bindEnvironment on some random callback in your method/publisher,\n  // it might not find the argumentChecker and you'll get an error about\n  // not checking an argument that it looks like you're checking (instead\n  // of just getting a \"Node code must run in a Fiber\" error).\n  var argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();\n  if (argChecker)\n    argChecker.checking(value);\n  var result = testSubtree(value, pattern);\n  if (result) {\n    var err = new Match.Error(result.message);\n    if (result.path) {\n      err.message += \" in field \" + result.path;\n      err.path = result.path;\n    }\n    throw err;\n  }\n};\n\n/**\n * @namespace Match\n * @summary The namespace for all Match types and methods.\n */\nvar Match = exports.Match = {\n  Optional: function (pattern) {\n    return new Optional(pattern);\n  },\n  Maybe: function (pattern) {\n    return new Maybe(pattern);\n  },\n  OneOf: function (/*arguments*/) {\n    return new OneOf(_.toArray(arguments));\n  },\n  Any: ['__any__'],\n  Where: function (condition) {\n    return new Where(condition);\n  },\n  ObjectIncluding: function (pattern) {\n    return new ObjectIncluding(pattern);\n  },\n  ObjectWithValues: function (pattern) {\n    return new ObjectWithValues(pattern);\n  },\n  // Matches only signed 32-bit integers\n  Integer: ['__integer__'],\n\n  // XXX matchers should know how to describe themselves for errors\n  Error: Meteor.makeErrorType(\"Match.Error\", function (msg) {\n    this.message = \"Match error: \" + msg;\n    // The path of the value that failed to match. Initially empty, this gets\n    // populated by catching and rethrowing the exception as it goes back up the\n    // stack.\n    // E.g.: \"vals[3].entity.created\"\n    this.path = \"\";\n    // If this gets sent over DDP, don't give full internal details but at least\n    // provide something better than 500 Internal server error.\n    this.sanitizedError = new Meteor.Error(400, \"Match failed\");\n  }),\n\n  // Tests to see if value matches pattern. Unlike check, it merely returns true\n  // or false (unless an error other than Match.Error was thrown). It does not\n  // interact with _failIfArgumentsAreNotAllChecked.\n  // XXX maybe also implement a Match.match which returns more information about\n  //     failures but without using exception handling or doing what check()\n  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion\n\n  /**\n   * @summary Returns true if the value matches the pattern.\n   * @locus Anywhere\n   * @param {Any} value The value to check\n   * @param {MatchPattern} pattern The pattern to match `value` against\n   */\n  test: function (value, pattern) {\n    return !testSubtree(value, pattern);\n  },\n\n  // Runs `f.apply(context, args)`. If check() is not called on every element of\n  // `args` (either directly or in the first level of an array), throws an error\n  // (using `description` in the message).\n  //\n  _failIfArgumentsAreNotAllChecked: function (f, context, args, description) {\n    var argChecker = new ArgumentChecker(args, description);\n    var result = currentArgumentChecker.withValue(argChecker, function () {\n      return f.apply(context, args);\n    });\n    // If f didn't itself throw, make sure it checked all of its arguments.\n    argChecker.throwUnlessAllArgumentsHaveBeenChecked();\n    return result;\n  }\n};\n\nvar Optional = function (pattern) {\n  this.pattern = pattern;\n};\n\nvar Maybe = function (pattern) {\n  this.pattern = pattern;\n};\n\nvar OneOf = function (choices) {\n  if (_.isEmpty(choices))\n    throw new Error(\"Must provide at least one choice to Match.OneOf\");\n  this.choices = choices;\n};\n\nvar Where = function (condition) {\n  this.condition = condition;\n};\n\nvar ObjectIncluding = function (pattern) {\n  this.pattern = pattern;\n};\n\nvar ObjectWithValues = function (pattern) {\n  this.pattern = pattern;\n};\n\nvar stringForErrorMessage = function (value, options) {\n  options = options || {};\n\n  if ( value === null ) return \"null\";\n\n  if ( options.onlyShowType ) {\n    return typeof value;\n  }\n\n  // Your average non-object things.  Saves from doing the try/catch below for.\n  if ( typeof value !== \"object\" ) {\n    return EJSON.stringify(value)\n  }\n\n  try {\n    // Find objects with circular references since EJSON doesn't support them yet (Issue #4778 + Unaccepted PR)\n    // If the native stringify is going to choke, EJSON.stringify is going to choke too.\n    JSON.stringify(value);\n  } catch (stringifyError) {\n    if ( stringifyError.name === \"TypeError\" ) {\n      return typeof value;\n    }\n  }\n\n  return EJSON.stringify(value);\n};\n\nvar typeofChecks = [\n  [String, \"string\"],\n  [Number, \"number\"],\n  [Boolean, \"boolean\"],\n  // While we don't allow undefined/function in EJSON, this is good for optional\n  // arguments with OneOf.\n  [Function, \"function\"],\n  [undefined, \"undefined\"]\n];\n\n// Return `false` if it matches. Otherwise, return an object with a `message` and a `path` field.\nvar testSubtree = function (value, pattern) {\n  // Match anything!\n  if (pattern === Match.Any)\n    return false;\n\n  // Basic atomic types.\n  // Do not match boxed objects (e.g. String, Boolean)\n  for (var i = 0; i < typeofChecks.length; ++i) {\n    if (pattern === typeofChecks[i][0]) {\n      if (typeof value === typeofChecks[i][1])\n        return false;\n      return {\n        message: \"Expected \" + typeofChecks[i][1] + \", got \" + stringForErrorMessage(value, { onlyShowType: true }),\n        path: \"\"\n      };\n    }\n  }\n\n  if (pattern === null) {\n    if (value === null) {\n      return false;\n    }\n    return {\n      message: \"Expected null, got \" + stringForErrorMessage(value),\n      path: \"\"\n    };\n  }\n\n  // Strings, numbers, and booleans match literally. Goes well with Match.OneOf.\n  if (typeof pattern === \"string\" || typeof pattern === \"number\" || typeof pattern === \"boolean\") {\n    if (value === pattern)\n      return false;\n    return {\n      message: \"Expected \" + pattern + \", got \" + stringForErrorMessage(value),\n      path: \"\"\n    };\n  }\n\n  // Match.Integer is special type encoded with array\n  if (pattern === Match.Integer) {\n    // There is no consistent and reliable way to check if variable is a 64-bit\n    // integer. One of the popular solutions is to get reminder of division by 1\n    // but this method fails on really large floats with big precision.\n    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8\n    // Bitwise operators work consistantly but always cast variable to 32-bit\n    // signed integer according to JavaScript specs.\n    if (typeof value === \"number\" && (value | 0) === value)\n      return false;\n    return {\n      message: \"Expected Integer, got \" + stringForErrorMessage(value),\n      path: \"\"\n    };\n  }\n\n  // \"Object\" is shorthand for Match.ObjectIncluding({});\n  if (pattern === Object)\n    pattern = Match.ObjectIncluding({});\n\n  // Array (checked AFTER Any, which is implemented as an Array).\n  if (pattern instanceof Array) {\n    if (pattern.length !== 1) {\n      return {\n        message: \"Bad pattern: arrays must have one type element\" + stringForErrorMessage(pattern),\n        path: \"\"\n      };\n    }\n    if (!_.isArray(value) && !_.isArguments(value)) {\n      return {\n        message: \"Expected array, got \" + stringForErrorMessage(value),\n        path: \"\"\n      };\n    }\n\n    for (var i = 0, length = value.length; i < length; i++) {\n      var result = testSubtree(value[i], pattern[0]);\n      if (result) {\n        result.path = _prependPath(i, result.path);\n        return result;\n      }\n    }\n    return false;\n  }\n\n  // Arbitrary validation checks. The condition can return false or throw a\n  // Match.Error (ie, it can internally use check()) to fail.\n  if (pattern instanceof Where) {\n    var result;\n    try {\n      result = pattern.condition(value);\n    } catch (err) {\n      if (!(err instanceof Match.Error))\n        throw err;\n      return {\n        message: err.message,\n        path: err.path\n      };\n    }\n    if (result)\n      return false;\n    // XXX this error is terrible\n    return {\n      message: \"Failed Match.Where validation\",\n      path: \"\"\n    };\n  }\n\n\n  if (pattern instanceof Maybe) {\n    pattern = Match.OneOf(undefined, null, pattern.pattern);\n  }\n  else if (pattern instanceof Optional) {\n    pattern = Match.OneOf(undefined, pattern.pattern);\n  }\n\n  if (pattern instanceof OneOf) {\n    for (var i = 0; i < pattern.choices.length; ++i) {\n      var result = testSubtree(value, pattern.choices[i]);\n      if (!result) {\n        // No error? Yay, return.\n        return false;\n      }\n      // Match errors just mean try another choice.\n    }\n    // XXX this error is terrible\n    return {\n      message: \"Failed Match.OneOf, Match.Maybe or Match.Optional validation\",\n      path: \"\"\n    };\n  }\n\n  // A function that isn't something we special-case is assumed to be a\n  // constructor.\n  if (pattern instanceof Function) {\n    if (value instanceof pattern)\n      return false;\n    return {\n      message: \"Expected \" + (pattern.name ||\"particular constructor\"),\n      path: \"\"\n    };\n  }\n\n  var unknownKeysAllowed = false;\n  var unknownKeyPattern;\n  if (pattern instanceof ObjectIncluding) {\n    unknownKeysAllowed = true;\n    pattern = pattern.pattern;\n  }\n  if (pattern instanceof ObjectWithValues) {\n    unknownKeysAllowed = true;\n    unknownKeyPattern = [pattern.pattern];\n    pattern = {};  // no required keys\n  }\n\n  if (typeof pattern !== \"object\") {\n    return {\n      message: \"Bad pattern: unknown pattern type\",\n      path: \"\"\n    };\n  }\n\n  // An object, with required and optional keys. Note that this does NOT do\n  // structural matches against objects of special types that happen to match\n  // the pattern: this really needs to be a plain old {Object}!\n  if (typeof value !== 'object') {\n    return {\n      message: \"Expected object, got \" + typeof value,\n      path: \"\"\n    };\n  }\n  if (value === null) {\n    return {\n      message: \"Expected object, got null\",\n      path: \"\"\n    };\n  }\n  if (! isPlainObject(value)) {\n    return {\n      message: \"Expected plain object\",\n      path: \"\"\n    };\n  }\n\n  var requiredPatterns = {};\n  var optionalPatterns = {};\n  _.each(pattern, function (subPattern, key) {\n    if (subPattern instanceof Optional || subPattern instanceof Maybe)\n      optionalPatterns[key] = subPattern.pattern;\n    else\n      requiredPatterns[key] = subPattern;\n  });\n\n  //XXX: replace with underscore's _.allKeys if Meteor updates underscore to 1.8+ (or lodash)\n  var allKeys = function(obj){\n    var keys = [];\n    if (_.isObject(obj)){\n      for (var key in obj) keys.push(key);\n    }\n    return keys;\n  }\n\n  for (var keys = allKeys(value), i = 0, length = keys.length; i < length; i++) {\n    var key = keys[i];\n    var subValue = value[key];\n    if (_.has(requiredPatterns, key)) {\n      var result = testSubtree(subValue, requiredPatterns[key]);\n      if (result) {\n        result.path = _prependPath(key, result.path);\n        return result;\n      }\n      delete requiredPatterns[key];\n    } else if (_.has(optionalPatterns, key)) {\n      var result = testSubtree(subValue, optionalPatterns[key]);\n      if (result) {\n        result.path = _prependPath(key, result.path);\n        return result;\n      }\n    } else {\n      if (!unknownKeysAllowed) {\n        return {\n          message: \"Unknown key\",\n          path: key\n        };\n      }\n      if (unknownKeyPattern) {\n        var result = testSubtree(subValue, unknownKeyPattern[0]);\n        if (result) {\n          result.path = _prependPath(key, result.path);\n          return result;\n        }\n      }\n    }\n  }\n\n  var keys = _.keys(requiredPatterns);\n  if (keys.length) {\n    return {\n      message: \"Missing key '\" + keys[0] + \"'\",\n      path: \"\"\n    };\n  }\n};\n\nvar ArgumentChecker = function (args, description) {\n  var self = this;\n  // Make a SHALLOW copy of the arguments. (We'll be doing identity checks\n  // against its contents.)\n  self.args = _.clone(args);\n  // Since the common case will be to check arguments in order, and we splice\n  // out arguments when we check them, make it so we splice out from the end\n  // rather than the beginning.\n  self.args.reverse();\n  self.description = description;\n};\n\n_.extend(ArgumentChecker.prototype, {\n  checking: function (value) {\n    var self = this;\n    if (self._checkingOneValue(value))\n      return;\n    // Allow check(arguments, [String]) or check(arguments.slice(1), [String])\n    // or check([foo, bar], [String]) to count... but only if value wasn't\n    // itself an argument.\n    if (_.isArray(value) || _.isArguments(value)) {\n      _.each(value, _.bind(self._checkingOneValue, self));\n    }\n  },\n  _checkingOneValue: function (value) {\n    var self = this;\n    for (var i = 0; i < self.args.length; ++i) {\n      // Is this value one of the arguments? (This can have a false positive if\n      // the argument is an interned primitive, but it's still a good enough\n      // check.)\n      // (NaN is not === to itself, so we have to check specially.)\n      if (value === self.args[i] || (_.isNaN(value) && _.isNaN(self.args[i]))) {\n        self.args.splice(i, 1);\n        return true;\n      }\n    }\n    return false;\n  },\n  throwUnlessAllArgumentsHaveBeenChecked: function () {\n    var self = this;\n    if (!_.isEmpty(self.args))\n      throw new Error(\"Did not check() all arguments during \" +\n                      self.description);\n  }\n});\n\nvar _jsKeywords = [\"do\", \"if\", \"in\", \"for\", \"let\", \"new\", \"try\", \"var\", \"case\",\n  \"else\", \"enum\", \"eval\", \"false\", \"null\", \"this\", \"true\", \"void\", \"with\",\n  \"break\", \"catch\", \"class\", \"const\", \"super\", \"throw\", \"while\", \"yield\",\n  \"delete\", \"export\", \"import\", \"public\", \"return\", \"static\", \"switch\",\n  \"typeof\", \"default\", \"extends\", \"finally\", \"package\", \"private\", \"continue\",\n  \"debugger\", \"function\", \"arguments\", \"interface\", \"protected\", \"implements\",\n  \"instanceof\"];\n\n// Assumes the base of path is already escaped properly\n// returns key + base\nvar _prependPath = function (key, base) {\n  if ((typeof key) === \"number\" || key.match(/^[0-9]+$/))\n    key = \"[\" + key + \"]\";\n  else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) || _.contains(_jsKeywords, key))\n    key = JSON.stringify([key]);\n\n  if (base && base[0] !== \"[\")\n    return key + '.' + base;\n  return key + base;\n};\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"isPlainObject.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/check/isPlainObject.js                                                                                   //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copy of jQuery.isPlainObject for the server side from jQuery v1.11.2.\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar support = {};\n\n// Populate the class2type map\n_.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(name, i) {\n  class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction type( obj ) {\n  if ( obj == null ) {\n    return obj + \"\";\n  }\n  return typeof obj === \"object\" || typeof obj === \"function\" ?\n    class2type[ toString.call(obj) ] || \"object\" :\n    typeof obj;\n}\n\nfunction isWindow( obj ) {\n  /* jshint eqeqeq: false */\n  return obj != null && obj == obj.window;\n}\n\nexports.isPlainObject = function( obj ) {\n  var key;\n\n  // Must be an Object.\n  // Because of IE, we also have to check the presence of the constructor property.\n  // Make sure that DOM nodes and window objects don't pass through, as well\n  if ( !obj || type(obj) !== \"object\" || obj.nodeType || isWindow( obj ) ) {\n    return false;\n  }\n\n  try {\n    // Not own constructor property must be Object\n    if ( obj.constructor &&\n         !hasOwn.call(obj, \"constructor\") &&\n         !hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n      return false;\n    }\n  } catch ( e ) {\n    // IE8,9 Will throw exceptions on certain host objects #9897\n    return false;\n  }\n\n  // Support: IE<9\n  // Handle iteration over inherited properties before own properties.\n  if ( support.ownLast ) {\n    for ( key in obj ) {\n      return hasOwn.call( obj, key );\n    }\n  }\n\n  // Own properties are enumerated firstly, so to speed up,\n  // if last one is own, then all properties are own.\n  for ( key in obj ) {}\n\n  return key === undefined || hasOwn.call( obj, key );\n};\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\"extensions\":[\".js\",\".json\"]});\nvar exports = require(\"./node_modules/meteor/check/match.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package.check = exports, {\n  check: check,\n  Match: Match\n});\n\n})();\n\n//# sourceMappingURL=check.js.map\n"]},"hash":"f7d354189e32e489a06695cca30d16bfc086587b"}

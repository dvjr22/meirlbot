{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/startbootstrap-sb-admin-gh-pages/js/plugins/flot/jquery.flot.pie.js","filenameRelative":"/startbootstrap-sb-admin-gh-pages/js/plugins/flot/jquery.flot.pie.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/startbootstrap-sb-admin-gh-pages/js/plugins/flot/jquery.flot.pie.js.map","sourceFileName":"/startbootstrap-sb-admin-gh-pages/js/plugins/flot/jquery.flot.pie.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"jquery.flot.pie"},"ignored":false,"code":"/* Flot plugin for rendering pie charts.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nThe plugin assumes that each series has a single data value, and that each\nvalue is a positive integer or zero.  Negative numbers don't make sense for a\npie chart, and have unpredictable results.  The values do NOT need to be\npassed in as percentages; the plugin will calculate the total and per-slice\npercentages internally.\n\n* Created by Brian Medendorp\n\n* Updated with contributions from btburnett3, Anthony Aragues and Xavi Ivars\n\nThe plugin supports these options:\n\n\tseries: {\n\t\tpie: {\n\t\t\tshow: true/false\n\t\t\tradius: 0-1 for percentage of fullsize, or a specified pixel length, or 'auto'\n\t\t\tinnerRadius: 0-1 for percentage of fullsize or a specified pixel length, for creating a donut effect\n\t\t\tstartAngle: 0-2 factor of PI used for starting angle (in radians) i.e 3/2 starts at the top, 0 and 2 have the same result\n\t\t\ttilt: 0-1 for percentage to tilt the pie, where 1 is no tilt, and 0 is completely flat (nothing will show)\n\t\t\toffset: {\n\t\t\t\ttop: integer value to move the pie up or down\n\t\t\t\tleft: integer value to move the pie left or right, or 'auto'\n\t\t\t},\n\t\t\tstroke: {\n\t\t\t\tcolor: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#FFF')\n\t\t\t\twidth: integer pixel width of the stroke\n\t\t\t},\n\t\t\tlabel: {\n\t\t\t\tshow: true/false, or 'auto'\n\t\t\t\tformatter:  a user-defined function that modifies the text/style of the label text\n\t\t\t\tradius: 0-1 for percentage of fullsize, or a specified pixel length\n\t\t\t\tbackground: {\n\t\t\t\t\tcolor: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#000')\n\t\t\t\t\topacity: 0-1\n\t\t\t\t},\n\t\t\t\tthreshold: 0-1 for the percentage value at which to hide labels (if they're too small)\n\t\t\t},\n\t\t\tcombine: {\n\t\t\t\tthreshold: 0-1 for the percentage value at which to combine slices (if they're too small)\n\t\t\t\tcolor: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#CCC'), if null, the plugin will automatically use the color of the first slice to be combined\n\t\t\t\tlabel: any text value of what the combined slice should be labeled\n\t\t\t}\n\t\t\thighlight: {\n\t\t\t\topacity: 0-1\n\t\t\t}\n\t\t}\n\t}\n\nMore detail and specific examples can be found in the included HTML file.\n\n*/\n\n(function ($) {\n\n\t// Maximum redraw attempts when fitting labels within the plot\n\n\tvar REDRAW_ATTEMPTS = 10;\n\n\t// Factor by which to shrink the pie when fitting labels within the plot\n\n\tvar REDRAW_SHRINK = 0.95;\n\n\tfunction init(plot) {\n\n\t\tvar canvas = null,\n\t\t    target = null,\n\t\t    options = null,\n\t\t    maxRadius = null,\n\t\t    centerLeft = null,\n\t\t    centerTop = null,\n\t\t    processed = false,\n\t\t    ctx = null;\n\n\t\t// interactive variables\n\n\t\tvar highlights = [];\n\n\t\t// add hook to determine if pie plugin in enabled, and then perform necessary operations\n\n\t\tplot.hooks.processOptions.push(function (plot, options) {\n\t\t\tif (options.series.pie.show) {\n\n\t\t\t\toptions.grid.show = false;\n\n\t\t\t\t// set labels.show\n\n\t\t\t\tif (options.series.pie.label.show == \"auto\") {\n\t\t\t\t\tif (options.legend.show) {\n\t\t\t\t\t\toptions.series.pie.label.show = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toptions.series.pie.label.show = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// set radius\n\n\t\t\t\tif (options.series.pie.radius == \"auto\") {\n\t\t\t\t\tif (options.series.pie.label.show) {\n\t\t\t\t\t\toptions.series.pie.radius = 3 / 4;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toptions.series.pie.radius = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ensure sane tilt\n\n\t\t\t\tif (options.series.pie.tilt > 1) {\n\t\t\t\t\toptions.series.pie.tilt = 1;\n\t\t\t\t} else if (options.series.pie.tilt < 0) {\n\t\t\t\t\toptions.series.pie.tilt = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tplot.hooks.bindEvents.push(function (plot, eventHolder) {\n\t\t\tvar options = plot.getOptions();\n\t\t\tif (options.series.pie.show) {\n\t\t\t\tif (options.grid.hoverable) {\n\t\t\t\t\teventHolder.unbind(\"mousemove\").mousemove(onMouseMove);\n\t\t\t\t}\n\t\t\t\tif (options.grid.clickable) {\n\t\t\t\t\teventHolder.unbind(\"click\").click(onClick);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tplot.hooks.processDatapoints.push(function (plot, series, data, datapoints) {\n\t\t\tvar options = plot.getOptions();\n\t\t\tif (options.series.pie.show) {\n\t\t\t\tprocessDatapoints(plot, series, data, datapoints);\n\t\t\t}\n\t\t});\n\n\t\tplot.hooks.drawOverlay.push(function (plot, octx) {\n\t\t\tvar options = plot.getOptions();\n\t\t\tif (options.series.pie.show) {\n\t\t\t\tdrawOverlay(plot, octx);\n\t\t\t}\n\t\t});\n\n\t\tplot.hooks.draw.push(function (plot, newCtx) {\n\t\t\tvar options = plot.getOptions();\n\t\t\tif (options.series.pie.show) {\n\t\t\t\tdraw(plot, newCtx);\n\t\t\t}\n\t\t});\n\n\t\tfunction processDatapoints(plot, series, datapoints) {\n\t\t\tif (!processed) {\n\t\t\t\tprocessed = true;\n\t\t\t\tcanvas = plot.getCanvas();\n\t\t\t\ttarget = $(canvas).parent();\n\t\t\t\toptions = plot.getOptions();\n\t\t\t\tplot.setData(combine(plot.getData()));\n\t\t\t}\n\t\t}\n\n\t\tfunction combine(data) {\n\n\t\t\tvar total = 0,\n\t\t\t    combined = 0,\n\t\t\t    numCombined = 0,\n\t\t\t    color = options.series.pie.combine.color,\n\t\t\t    newdata = [];\n\n\t\t\t// Fix up the raw data from Flot, ensuring the data is numeric\n\n\t\t\tfor (var i = 0; i < data.length; ++i) {\n\n\t\t\t\tvar value = data[i].data;\n\n\t\t\t\t// If the data is an array, we'll assume that it's a standard\n\t\t\t\t// Flot x-y pair, and are concerned only with the second value.\n\n\t\t\t\t// Note how we use the original array, rather than creating a\n\t\t\t\t// new one; this is more efficient and preserves any extra data\n\t\t\t\t// that the user may have stored in higher indexes.\n\n\t\t\t\tif ($.isArray(value) && value.length == 1) {\n\t\t\t\t\tvalue = value[0];\n\t\t\t\t}\n\n\t\t\t\tif ($.isArray(value)) {\n\t\t\t\t\t// Equivalent to $.isNumeric() but compatible with jQuery < 1.7\n\t\t\t\t\tif (!isNaN(parseFloat(value[1])) && isFinite(value[1])) {\n\t\t\t\t\t\tvalue[1] = +value[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue[1] = 0;\n\t\t\t\t\t}\n\t\t\t\t} else if (!isNaN(parseFloat(value)) && isFinite(value)) {\n\t\t\t\t\tvalue = [1, +value];\n\t\t\t\t} else {\n\t\t\t\t\tvalue = [1, 0];\n\t\t\t\t}\n\n\t\t\t\tdata[i].data = [value];\n\t\t\t}\n\n\t\t\t// Sum up all the slices, so we can calculate percentages for each\n\n\t\t\tfor (var i = 0; i < data.length; ++i) {\n\t\t\t\ttotal += data[i].data[0][1];\n\t\t\t}\n\n\t\t\t// Count the number of slices with percentages below the combine\n\t\t\t// threshold; if it turns out to be just one, we won't combine.\n\n\t\t\tfor (var i = 0; i < data.length; ++i) {\n\t\t\t\tvar value = data[i].data[0][1];\n\t\t\t\tif (value / total <= options.series.pie.combine.threshold) {\n\t\t\t\t\tcombined += value;\n\t\t\t\t\tnumCombined++;\n\t\t\t\t\tif (!color) {\n\t\t\t\t\t\tcolor = data[i].color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < data.length; ++i) {\n\t\t\t\tvar value = data[i].data[0][1];\n\t\t\t\tif (numCombined < 2 || value / total > options.series.pie.combine.threshold) {\n\t\t\t\t\tnewdata.push($.extend(data[i], { /* extend to allow keeping all other original data values\n                                         and using them e.g. in labelFormatter. */\n\t\t\t\t\t\tdata: [[1, value]],\n\t\t\t\t\t\tcolor: data[i].color,\n\t\t\t\t\t\tlabel: data[i].label,\n\t\t\t\t\t\tangle: value * Math.PI * 2 / total,\n\t\t\t\t\t\tpercent: value / (total / 100)\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (numCombined > 1) {\n\t\t\t\tnewdata.push({\n\t\t\t\t\tdata: [[1, combined]],\n\t\t\t\t\tcolor: color,\n\t\t\t\t\tlabel: options.series.pie.combine.label,\n\t\t\t\t\tangle: combined * Math.PI * 2 / total,\n\t\t\t\t\tpercent: combined / (total / 100)\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn newdata;\n\t\t}\n\n\t\tfunction draw(plot, newCtx) {\n\n\t\t\tif (!target) {\n\t\t\t\treturn; // if no series were passed\n\t\t\t}\n\n\t\t\tvar canvasWidth = plot.getPlaceholder().width(),\n\t\t\t    canvasHeight = plot.getPlaceholder().height(),\n\t\t\t    legendWidth = target.children().filter(\".legend\").children().width() || 0;\n\n\t\t\tctx = newCtx;\n\n\t\t\t// WARNING: HACK! REWRITE THIS CODE AS SOON AS POSSIBLE!\n\n\t\t\t// When combining smaller slices into an 'other' slice, we need to\n\t\t\t// add a new series.  Since Flot gives plugins no way to modify the\n\t\t\t// list of series, the pie plugin uses a hack where the first call\n\t\t\t// to processDatapoints results in a call to setData with the new\n\t\t\t// list of series, then subsequent processDatapoints do nothing.\n\n\t\t\t// The plugin-global 'processed' flag is used to control this hack;\n\t\t\t// it starts out false, and is set to true after the first call to\n\t\t\t// processDatapoints.\n\n\t\t\t// Unfortunately this turns future setData calls into no-ops; they\n\t\t\t// call processDatapoints, the flag is true, and nothing happens.\n\n\t\t\t// To fix this we'll set the flag back to false here in draw, when\n\t\t\t// all series have been processed, so the next sequence of calls to\n\t\t\t// processDatapoints once again starts out with a slice-combine.\n\t\t\t// This is really a hack; in 0.9 we need to give plugins a proper\n\t\t\t// way to modify series before any processing begins.\n\n\t\t\tprocessed = false;\n\n\t\t\t// calculate maximum radius and center point\n\n\t\t\tmaxRadius = Math.min(canvasWidth, canvasHeight / options.series.pie.tilt) / 2;\n\t\t\tcenterTop = canvasHeight / 2 + options.series.pie.offset.top;\n\t\t\tcenterLeft = canvasWidth / 2;\n\n\t\t\tif (options.series.pie.offset.left == \"auto\") {\n\t\t\t\tif (options.legend.position.match(\"w\")) {\n\t\t\t\t\tcenterLeft += legendWidth / 2;\n\t\t\t\t} else {\n\t\t\t\t\tcenterLeft -= legendWidth / 2;\n\t\t\t\t}\n\t\t\t\tif (centerLeft < maxRadius) {\n\t\t\t\t\tcenterLeft = maxRadius;\n\t\t\t\t} else if (centerLeft > canvasWidth - maxRadius) {\n\t\t\t\t\tcenterLeft = canvasWidth - maxRadius;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcenterLeft += options.series.pie.offset.left;\n\t\t\t}\n\n\t\t\tvar slices = plot.getData(),\n\t\t\t    attempts = 0;\n\n\t\t\t// Keep shrinking the pie's radius until drawPie returns true,\n\t\t\t// indicating that all the labels fit, or we try too many times.\n\n\t\t\tdo {\n\t\t\t\tif (attempts > 0) {\n\t\t\t\t\tmaxRadius *= REDRAW_SHRINK;\n\t\t\t\t}\n\t\t\t\tattempts += 1;\n\t\t\t\tclear();\n\t\t\t\tif (options.series.pie.tilt <= 0.8) {\n\t\t\t\t\tdrawShadow();\n\t\t\t\t}\n\t\t\t} while (!drawPie() && attempts < REDRAW_ATTEMPTS);\n\n\t\t\tif (attempts >= REDRAW_ATTEMPTS) {\n\t\t\t\tclear();\n\t\t\t\ttarget.prepend(\"<div class='error'>Could not draw pie with labels contained inside canvas</div>\");\n\t\t\t}\n\n\t\t\tif (plot.setSeries && plot.insertLegend) {\n\t\t\t\tplot.setSeries(slices);\n\t\t\t\tplot.insertLegend();\n\t\t\t}\n\n\t\t\t// we're actually done at this point, just defining internal functions at this point\n\n\t\t\tfunction clear() {\n\t\t\t\tctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\t\t\t\ttarget.children().filter(\".pieLabel, .pieLabelBackground\").remove();\n\t\t\t}\n\n\t\t\tfunction drawShadow() {\n\n\t\t\t\tvar shadowLeft = options.series.pie.shadow.left;\n\t\t\t\tvar shadowTop = options.series.pie.shadow.top;\n\t\t\t\tvar edge = 10;\n\t\t\t\tvar alpha = options.series.pie.shadow.alpha;\n\t\t\t\tvar radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n\n\t\t\t\tif (radius >= canvasWidth / 2 - shadowLeft || radius * options.series.pie.tilt >= canvasHeight / 2 - shadowTop || radius <= edge) {\n\t\t\t\t\treturn; // shadow would be outside canvas, so don't draw it\n\t\t\t\t}\n\n\t\t\t\tctx.save();\n\t\t\t\tctx.translate(shadowLeft, shadowTop);\n\t\t\t\tctx.globalAlpha = alpha;\n\t\t\t\tctx.fillStyle = \"#000\";\n\n\t\t\t\t// center and rotate to starting position\n\n\t\t\t\tctx.translate(centerLeft, centerTop);\n\t\t\t\tctx.scale(1, options.series.pie.tilt);\n\n\t\t\t\t//radius -= edge;\n\n\t\t\t\tfor (var i = 1; i <= edge; i++) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(0, 0, radius, 0, Math.PI * 2, false);\n\t\t\t\t\tctx.fill();\n\t\t\t\t\tradius -= i;\n\t\t\t\t}\n\n\t\t\t\tctx.restore();\n\t\t\t}\n\n\t\t\tfunction drawPie() {\n\n\t\t\t\tvar startAngle = Math.PI * options.series.pie.startAngle;\n\t\t\t\tvar radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n\n\t\t\t\t// center and rotate to starting position\n\n\t\t\t\tctx.save();\n\t\t\t\tctx.translate(centerLeft, centerTop);\n\t\t\t\tctx.scale(1, options.series.pie.tilt);\n\t\t\t\t//ctx.rotate(startAngle); // start at top; -- This doesn't work properly in Opera\n\n\t\t\t\t// draw slices\n\n\t\t\t\tctx.save();\n\t\t\t\tvar currentAngle = startAngle;\n\t\t\t\tfor (var i = 0; i < slices.length; ++i) {\n\t\t\t\t\tslices[i].startAngle = currentAngle;\n\t\t\t\t\tdrawSlice(slices[i].angle, slices[i].color, true);\n\t\t\t\t}\n\t\t\t\tctx.restore();\n\n\t\t\t\t// draw slice outlines\n\n\t\t\t\tif (options.series.pie.stroke.width > 0) {\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.lineWidth = options.series.pie.stroke.width;\n\t\t\t\t\tcurrentAngle = startAngle;\n\t\t\t\t\tfor (var i = 0; i < slices.length; ++i) {\n\t\t\t\t\t\tdrawSlice(slices[i].angle, options.series.pie.stroke.color, false);\n\t\t\t\t\t}\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\n\t\t\t\t// draw donut hole\n\n\t\t\t\tdrawDonutHole(ctx);\n\n\t\t\t\tctx.restore();\n\n\t\t\t\t// Draw the labels, returning true if they fit within the plot\n\n\t\t\t\tif (options.series.pie.label.show) {\n\t\t\t\t\treturn drawLabels();\n\t\t\t\t} else return true;\n\n\t\t\t\tfunction drawSlice(angle, color, fill) {\n\n\t\t\t\t\tif (angle <= 0 || isNaN(angle)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (fill) {\n\t\t\t\t\t\tctx.fillStyle = color;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.strokeStyle = color;\n\t\t\t\t\t\tctx.lineJoin = \"round\";\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tif (Math.abs(angle - Math.PI * 2) > 0.000000001) {\n\t\t\t\t\t\tctx.moveTo(0, 0); // Center of the pie\n\t\t\t\t\t}\n\n\t\t\t\t\t//ctx.arc(0, 0, radius, 0, angle, false); // This doesn't work properly in Opera\n\t\t\t\t\tctx.arc(0, 0, radius, currentAngle, currentAngle + angle / 2, false);\n\t\t\t\t\tctx.arc(0, 0, radius, currentAngle + angle / 2, currentAngle + angle, false);\n\t\t\t\t\tctx.closePath();\n\t\t\t\t\t//ctx.rotate(angle); // This doesn't work properly in Opera\n\t\t\t\t\tcurrentAngle += angle;\n\n\t\t\t\t\tif (fill) {\n\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction drawLabels() {\n\n\t\t\t\t\tvar currentAngle = startAngle;\n\t\t\t\t\tvar radius = options.series.pie.label.radius > 1 ? options.series.pie.label.radius : maxRadius * options.series.pie.label.radius;\n\n\t\t\t\t\tfor (var i = 0; i < slices.length; ++i) {\n\t\t\t\t\t\tif (slices[i].percent >= options.series.pie.label.threshold * 100) {\n\t\t\t\t\t\t\tif (!drawLabel(slices[i], currentAngle, i)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrentAngle += slices[i].angle;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t\tfunction drawLabel(slice, startAngle, index) {\n\n\t\t\t\t\t\tif (slice.data[0][1] == 0) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// format label text\n\n\t\t\t\t\t\tvar lf = options.legend.labelFormatter,\n\t\t\t\t\t\t    text,\n\t\t\t\t\t\t    plf = options.series.pie.label.formatter;\n\n\t\t\t\t\t\tif (lf) {\n\t\t\t\t\t\t\ttext = lf(slice.label, slice);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttext = slice.label;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (plf) {\n\t\t\t\t\t\t\ttext = plf(text, slice);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar halfAngle = (startAngle + slice.angle + startAngle) / 2;\n\t\t\t\t\t\tvar x = centerLeft + Math.round(Math.cos(halfAngle) * radius);\n\t\t\t\t\t\tvar y = centerTop + Math.round(Math.sin(halfAngle) * radius) * options.series.pie.tilt;\n\n\t\t\t\t\t\tvar html = \"<span class='pieLabel' id='pieLabel\" + index + \"' style='position:absolute;top:\" + y + \"px;left:\" + x + \"px;'>\" + text + \"</span>\";\n\t\t\t\t\t\ttarget.append(html);\n\n\t\t\t\t\t\tvar label = target.children(\"#pieLabel\" + index);\n\t\t\t\t\t\tvar labelTop = y - label.height() / 2;\n\t\t\t\t\t\tvar labelLeft = x - label.width() / 2;\n\n\t\t\t\t\t\tlabel.css(\"top\", labelTop);\n\t\t\t\t\t\tlabel.css(\"left\", labelLeft);\n\n\t\t\t\t\t\t// check to make sure that the label is not outside the canvas\n\n\t\t\t\t\t\tif (0 - labelTop > 0 || 0 - labelLeft > 0 || canvasHeight - (labelTop + label.height()) < 0 || canvasWidth - (labelLeft + label.width()) < 0) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (options.series.pie.label.background.opacity != 0) {\n\n\t\t\t\t\t\t\t// put in the transparent background separately to avoid blended labels and label boxes\n\n\t\t\t\t\t\t\tvar c = options.series.pie.label.background.color;\n\n\t\t\t\t\t\t\tif (c == null) {\n\t\t\t\t\t\t\t\tc = slice.color;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar pos = \"top:\" + labelTop + \"px;left:\" + labelLeft + \"px;\";\n\t\t\t\t\t\t\t$(\"<div class='pieLabelBackground' style='position:absolute;width:\" + label.width() + \"px;height:\" + label.height() + \"px;\" + pos + \"background-color:\" + c + \";'></div>\").css(\"opacity\", options.series.pie.label.background.opacity).insertBefore(label);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} // end individual label function\n\t\t\t\t} // end drawLabels function\n\t\t\t} // end drawPie function\n\t\t} // end draw function\n\n\t\t// Placed here because it needs to be accessed from multiple locations\n\n\t\tfunction drawDonutHole(layer) {\n\t\t\tif (options.series.pie.innerRadius > 0) {\n\n\t\t\t\t// subtract the center\n\n\t\t\t\tlayer.save();\n\t\t\t\tvar innerRadius = options.series.pie.innerRadius > 1 ? options.series.pie.innerRadius : maxRadius * options.series.pie.innerRadius;\n\t\t\t\tlayer.globalCompositeOperation = \"destination-out\"; // this does not work with excanvas, but it will fall back to using the stroke color\n\t\t\t\tlayer.beginPath();\n\t\t\t\tlayer.fillStyle = options.series.pie.stroke.color;\n\t\t\t\tlayer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);\n\t\t\t\tlayer.fill();\n\t\t\t\tlayer.closePath();\n\t\t\t\tlayer.restore();\n\n\t\t\t\t// add inner stroke\n\n\t\t\t\tlayer.save();\n\t\t\t\tlayer.beginPath();\n\t\t\t\tlayer.strokeStyle = options.series.pie.stroke.color;\n\t\t\t\tlayer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);\n\t\t\t\tlayer.stroke();\n\t\t\t\tlayer.closePath();\n\t\t\t\tlayer.restore();\n\n\t\t\t\t// TODO: add extra shadow inside hole (with a mask) if the pie is tilted.\n\t\t\t}\n\t\t}\n\n\t\t//-- Additional Interactive related functions --\n\n\t\tfunction isPointInPoly(poly, pt) {\n\t\t\tfor (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i) {\n\t\t\t\t(poly[i][1] <= pt[1] && pt[1] < poly[j][1] || poly[j][1] <= pt[1] && pt[1] < poly[i][1]) && pt[0] < (poly[j][0] - poly[i][0]) * (pt[1] - poly[i][1]) / (poly[j][1] - poly[i][1]) + poly[i][0] && (c = !c);\n\t\t\t}return c;\n\t\t}\n\n\t\tfunction findNearbySlice(mouseX, mouseY) {\n\n\t\t\tvar slices = plot.getData(),\n\t\t\t    options = plot.getOptions(),\n\t\t\t    radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius,\n\t\t\t    x,\n\t\t\t    y;\n\n\t\t\tfor (var i = 0; i < slices.length; ++i) {\n\n\t\t\t\tvar s = slices[i];\n\n\t\t\t\tif (s.pie.show) {\n\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(0, 0); // Center of the pie\n\t\t\t\t\t//ctx.scale(1, options.series.pie.tilt);\t// this actually seems to break everything when here.\n\t\t\t\t\tctx.arc(0, 0, radius, s.startAngle, s.startAngle + s.angle / 2, false);\n\t\t\t\t\tctx.arc(0, 0, radius, s.startAngle + s.angle / 2, s.startAngle + s.angle, false);\n\t\t\t\t\tctx.closePath();\n\t\t\t\t\tx = mouseX - centerLeft;\n\t\t\t\t\ty = mouseY - centerTop;\n\n\t\t\t\t\tif (ctx.isPointInPath) {\n\t\t\t\t\t\tif (ctx.isPointInPath(mouseX - centerLeft, mouseY - centerTop)) {\n\t\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdatapoint: [s.percent, s.data],\n\t\t\t\t\t\t\t\tdataIndex: 0,\n\t\t\t\t\t\t\t\tseries: s,\n\t\t\t\t\t\t\t\tseriesIndex: i\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// excanvas for IE doesn;t support isPointInPath, this is a workaround.\n\n\t\t\t\t\t\tvar p1X = radius * Math.cos(s.startAngle),\n\t\t\t\t\t\t    p1Y = radius * Math.sin(s.startAngle),\n\t\t\t\t\t\t    p2X = radius * Math.cos(s.startAngle + s.angle / 4),\n\t\t\t\t\t\t    p2Y = radius * Math.sin(s.startAngle + s.angle / 4),\n\t\t\t\t\t\t    p3X = radius * Math.cos(s.startAngle + s.angle / 2),\n\t\t\t\t\t\t    p3Y = radius * Math.sin(s.startAngle + s.angle / 2),\n\t\t\t\t\t\t    p4X = radius * Math.cos(s.startAngle + s.angle / 1.5),\n\t\t\t\t\t\t    p4Y = radius * Math.sin(s.startAngle + s.angle / 1.5),\n\t\t\t\t\t\t    p5X = radius * Math.cos(s.startAngle + s.angle),\n\t\t\t\t\t\t    p5Y = radius * Math.sin(s.startAngle + s.angle),\n\t\t\t\t\t\t    arrPoly = [[0, 0], [p1X, p1Y], [p2X, p2Y], [p3X, p3Y], [p4X, p4Y], [p5X, p5Y]],\n\t\t\t\t\t\t    arrPoint = [x, y];\n\n\t\t\t\t\t\t// TODO: perhaps do some mathmatical trickery here with the Y-coordinate to compensate for pie tilt?\n\n\t\t\t\t\t\tif (isPointInPoly(arrPoly, arrPoint)) {\n\t\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdatapoint: [s.percent, s.data],\n\t\t\t\t\t\t\t\tdataIndex: 0,\n\t\t\t\t\t\t\t\tseries: s,\n\t\t\t\t\t\t\t\tseriesIndex: i\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction onMouseMove(e) {\n\t\t\ttriggerClickHoverEvent(\"plothover\", e);\n\t\t}\n\n\t\tfunction onClick(e) {\n\t\t\ttriggerClickHoverEvent(\"plotclick\", e);\n\t\t}\n\n\t\t// trigger click or hover event (they send the same parameters so we share their code)\n\n\t\tfunction triggerClickHoverEvent(eventname, e) {\n\n\t\t\tvar offset = plot.offset();\n\t\t\tvar canvasX = parseInt(e.pageX - offset.left);\n\t\t\tvar canvasY = parseInt(e.pageY - offset.top);\n\t\t\tvar item = findNearbySlice(canvasX, canvasY);\n\n\t\t\tif (options.grid.autoHighlight) {\n\n\t\t\t\t// clear auto-highlights\n\n\t\t\t\tfor (var i = 0; i < highlights.length; ++i) {\n\t\t\t\t\tvar h = highlights[i];\n\t\t\t\t\tif (h.auto == eventname && !(item && h.series == item.series)) {\n\t\t\t\t\t\tunhighlight(h.series);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// highlight the slice\n\n\t\t\tif (item) {\n\t\t\t\thighlight(item.series, eventname);\n\t\t\t}\n\n\t\t\t// trigger any hover bind events\n\n\t\t\tvar pos = { pageX: e.pageX, pageY: e.pageY };\n\t\t\ttarget.trigger(eventname, [pos, item]);\n\t\t}\n\n\t\tfunction highlight(s, auto) {\n\t\t\t//if (typeof s == \"number\") {\n\t\t\t//\ts = series[s];\n\t\t\t//}\n\n\t\t\tvar i = indexOfHighlight(s);\n\n\t\t\tif (i == -1) {\n\t\t\t\thighlights.push({ series: s, auto: auto });\n\t\t\t\tplot.triggerRedrawOverlay();\n\t\t\t} else if (!auto) {\n\t\t\t\thighlights[i].auto = false;\n\t\t\t}\n\t\t}\n\n\t\tfunction unhighlight(s) {\n\t\t\tif (s == null) {\n\t\t\t\thighlights = [];\n\t\t\t\tplot.triggerRedrawOverlay();\n\t\t\t}\n\n\t\t\t//if (typeof s == \"number\") {\n\t\t\t//\ts = series[s];\n\t\t\t//}\n\n\t\t\tvar i = indexOfHighlight(s);\n\n\t\t\tif (i != -1) {\n\t\t\t\thighlights.splice(i, 1);\n\t\t\t\tplot.triggerRedrawOverlay();\n\t\t\t}\n\t\t}\n\n\t\tfunction indexOfHighlight(s) {\n\t\t\tfor (var i = 0; i < highlights.length; ++i) {\n\t\t\t\tvar h = highlights[i];\n\t\t\t\tif (h.series == s) return i;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tfunction drawOverlay(plot, octx) {\n\n\t\t\tvar options = plot.getOptions();\n\n\t\t\tvar radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n\n\t\t\toctx.save();\n\t\t\toctx.translate(centerLeft, centerTop);\n\t\t\toctx.scale(1, options.series.pie.tilt);\n\n\t\t\tfor (var i = 0; i < highlights.length; ++i) {\n\t\t\t\tdrawHighlight(highlights[i].series);\n\t\t\t}\n\n\t\t\tdrawDonutHole(octx);\n\n\t\t\toctx.restore();\n\n\t\t\tfunction drawHighlight(series) {\n\n\t\t\t\tif (series.angle <= 0 || isNaN(series.angle)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//octx.fillStyle = parseColor(options.series.pie.highlight.color).scale(null, null, null, options.series.pie.highlight.opacity).toString();\n\t\t\t\toctx.fillStyle = \"rgba(255, 255, 255, \" + options.series.pie.highlight.opacity + \")\"; // this is temporary until we have access to parseColor\n\t\t\t\toctx.beginPath();\n\t\t\t\tif (Math.abs(series.angle - Math.PI * 2) > 0.000000001) {\n\t\t\t\t\toctx.moveTo(0, 0); // Center of the pie\n\t\t\t\t}\n\t\t\t\toctx.arc(0, 0, radius, series.startAngle, series.startAngle + series.angle / 2, false);\n\t\t\t\toctx.arc(0, 0, radius, series.startAngle + series.angle / 2, series.startAngle + series.angle, false);\n\t\t\t\toctx.closePath();\n\t\t\t\toctx.fill();\n\t\t\t}\n\t\t}\n\t} // end init (plugin body)\n\n\t// define pie specific options and their default values\n\n\tvar options = {\n\t\tseries: {\n\t\t\tpie: {\n\t\t\t\tshow: false,\n\t\t\t\tradius: \"auto\", // actual radius of the visible pie (based on full calculated radius if <=1, or hard pixel value)\n\t\t\t\tinnerRadius: 0, /* for donut */\n\t\t\t\tstartAngle: 3 / 2,\n\t\t\t\ttilt: 1,\n\t\t\t\tshadow: {\n\t\t\t\t\tleft: 5, // shadow left offset\n\t\t\t\t\ttop: 15, // shadow top offset\n\t\t\t\t\talpha: 0.02 // shadow alpha\n\t\t\t\t},\n\t\t\t\toffset: {\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tleft: \"auto\"\n\t\t\t\t},\n\t\t\t\tstroke: {\n\t\t\t\t\tcolor: \"#fff\",\n\t\t\t\t\twidth: 1\n\t\t\t\t},\n\t\t\t\tlabel: {\n\t\t\t\t\tshow: \"auto\",\n\t\t\t\t\tformatter: function formatter(label, slice) {\n\t\t\t\t\t\treturn \"<div style='font-size:x-small;text-align:center;padding:2px;color:\" + slice.color + \";'>\" + label + \"<br/>\" + Math.round(slice.percent) + \"%</div>\";\n\t\t\t\t\t}, // formatter function\n\t\t\t\t\tradius: 1, // radius at which to place the labels (based on full calculated radius if <=1, or hard pixel value)\n\t\t\t\t\tbackground: {\n\t\t\t\t\t\tcolor: null,\n\t\t\t\t\t\topacity: 0\n\t\t\t\t\t},\n\t\t\t\t\tthreshold: 0 // percentage at which to hide the label (i.e. the slice is too narrow)\n\t\t\t\t},\n\t\t\t\tcombine: {\n\t\t\t\t\tthreshold: -1, // percentage at which to combine little slices into one larger slice\n\t\t\t\t\tcolor: null, // color to give the new slice (auto-generated if null)\n\t\t\t\t\tlabel: \"Other\" // label to give the new slice\n\t\t\t\t},\n\t\t\t\thighlight: {\n\t\t\t\t\t//color: \"#fff\",\t\t// will add this functionality once parseColor is available\n\t\t\t\t\topacity: 0.5\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t$.plot.plugins.push({\n\t\tinit: init,\n\t\toptions: options,\n\t\tname: \"pie\",\n\t\tversion: \"1.1\"\n\t});\n})(jQuery);","ast":null,"map":{"version":3,"sources":["/startbootstrap-sb-admin-gh-pages/js/plugins/flot/jquery.flot.pie.js"],"names":[],"mappings":"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","file":"/startbootstrap-sb-admin-gh-pages/js/plugins/flot/jquery.flot.pie.js.map","sourcesContent":["/* Flot plugin for rendering pie charts.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nThe plugin assumes that each series has a single data value, and that each\nvalue is a positive integer or zero.  Negative numbers don't make sense for a\npie chart, and have unpredictable results.  The values do NOT need to be\npassed in as percentages; the plugin will calculate the total and per-slice\npercentages internally.\n\n* Created by Brian Medendorp\n\n* Updated with contributions from btburnett3, Anthony Aragues and Xavi Ivars\n\nThe plugin supports these options:\n\n\tseries: {\n\t\tpie: {\n\t\t\tshow: true/false\n\t\t\tradius: 0-1 for percentage of fullsize, or a specified pixel length, or 'auto'\n\t\t\tinnerRadius: 0-1 for percentage of fullsize or a specified pixel length, for creating a donut effect\n\t\t\tstartAngle: 0-2 factor of PI used for starting angle (in radians) i.e 3/2 starts at the top, 0 and 2 have the same result\n\t\t\ttilt: 0-1 for percentage to tilt the pie, where 1 is no tilt, and 0 is completely flat (nothing will show)\n\t\t\toffset: {\n\t\t\t\ttop: integer value to move the pie up or down\n\t\t\t\tleft: integer value to move the pie left or right, or 'auto'\n\t\t\t},\n\t\t\tstroke: {\n\t\t\t\tcolor: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#FFF')\n\t\t\t\twidth: integer pixel width of the stroke\n\t\t\t},\n\t\t\tlabel: {\n\t\t\t\tshow: true/false, or 'auto'\n\t\t\t\tformatter:  a user-defined function that modifies the text/style of the label text\n\t\t\t\tradius: 0-1 for percentage of fullsize, or a specified pixel length\n\t\t\t\tbackground: {\n\t\t\t\t\tcolor: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#000')\n\t\t\t\t\topacity: 0-1\n\t\t\t\t},\n\t\t\t\tthreshold: 0-1 for the percentage value at which to hide labels (if they're too small)\n\t\t\t},\n\t\t\tcombine: {\n\t\t\t\tthreshold: 0-1 for the percentage value at which to combine slices (if they're too small)\n\t\t\t\tcolor: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#CCC'), if null, the plugin will automatically use the color of the first slice to be combined\n\t\t\t\tlabel: any text value of what the combined slice should be labeled\n\t\t\t}\n\t\t\thighlight: {\n\t\t\t\topacity: 0-1\n\t\t\t}\n\t\t}\n\t}\n\nMore detail and specific examples can be found in the included HTML file.\n\n*/\n\n(function($) {\n\n\t// Maximum redraw attempts when fitting labels within the plot\n\n\tvar REDRAW_ATTEMPTS = 10;\n\n\t// Factor by which to shrink the pie when fitting labels within the plot\n\n\tvar REDRAW_SHRINK = 0.95;\n\n\tfunction init(plot) {\n\n\t\tvar canvas = null,\n\t\t\ttarget = null,\n\t\t\toptions = null,\n\t\t\tmaxRadius = null,\n\t\t\tcenterLeft = null,\n\t\t\tcenterTop = null,\n\t\t\tprocessed = false,\n\t\t\tctx = null;\n\n\t\t// interactive variables\n\n\t\tvar highlights = [];\n\n\t\t// add hook to determine if pie plugin in enabled, and then perform necessary operations\n\n\t\tplot.hooks.processOptions.push(function(plot, options) {\n\t\t\tif (options.series.pie.show) {\n\n\t\t\t\toptions.grid.show = false;\n\n\t\t\t\t// set labels.show\n\n\t\t\t\tif (options.series.pie.label.show == \"auto\") {\n\t\t\t\t\tif (options.legend.show) {\n\t\t\t\t\t\toptions.series.pie.label.show = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toptions.series.pie.label.show = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// set radius\n\n\t\t\t\tif (options.series.pie.radius == \"auto\") {\n\t\t\t\t\tif (options.series.pie.label.show) {\n\t\t\t\t\t\toptions.series.pie.radius = 3/4;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toptions.series.pie.radius = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ensure sane tilt\n\n\t\t\t\tif (options.series.pie.tilt > 1) {\n\t\t\t\t\toptions.series.pie.tilt = 1;\n\t\t\t\t} else if (options.series.pie.tilt < 0) {\n\t\t\t\t\toptions.series.pie.tilt = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tplot.hooks.bindEvents.push(function(plot, eventHolder) {\n\t\t\tvar options = plot.getOptions();\n\t\t\tif (options.series.pie.show) {\n\t\t\t\tif (options.grid.hoverable) {\n\t\t\t\t\teventHolder.unbind(\"mousemove\").mousemove(onMouseMove);\n\t\t\t\t}\n\t\t\t\tif (options.grid.clickable) {\n\t\t\t\t\teventHolder.unbind(\"click\").click(onClick);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tplot.hooks.processDatapoints.push(function(plot, series, data, datapoints) {\n\t\t\tvar options = plot.getOptions();\n\t\t\tif (options.series.pie.show) {\n\t\t\t\tprocessDatapoints(plot, series, data, datapoints);\n\t\t\t}\n\t\t});\n\n\t\tplot.hooks.drawOverlay.push(function(plot, octx) {\n\t\t\tvar options = plot.getOptions();\n\t\t\tif (options.series.pie.show) {\n\t\t\t\tdrawOverlay(plot, octx);\n\t\t\t}\n\t\t});\n\n\t\tplot.hooks.draw.push(function(plot, newCtx) {\n\t\t\tvar options = plot.getOptions();\n\t\t\tif (options.series.pie.show) {\n\t\t\t\tdraw(plot, newCtx);\n\t\t\t}\n\t\t});\n\n\t\tfunction processDatapoints(plot, series, datapoints) {\n\t\t\tif (!processed)\t{\n\t\t\t\tprocessed = true;\n\t\t\t\tcanvas = plot.getCanvas();\n\t\t\t\ttarget = $(canvas).parent();\n\t\t\t\toptions = plot.getOptions();\n\t\t\t\tplot.setData(combine(plot.getData()));\n\t\t\t}\n\t\t}\n\n\t\tfunction combine(data) {\n\n\t\t\tvar total = 0,\n\t\t\t\tcombined = 0,\n\t\t\t\tnumCombined = 0,\n\t\t\t\tcolor = options.series.pie.combine.color,\n\t\t\t\tnewdata = [];\n\n\t\t\t// Fix up the raw data from Flot, ensuring the data is numeric\n\n\t\t\tfor (var i = 0; i < data.length; ++i) {\n\n\t\t\t\tvar value = data[i].data;\n\n\t\t\t\t// If the data is an array, we'll assume that it's a standard\n\t\t\t\t// Flot x-y pair, and are concerned only with the second value.\n\n\t\t\t\t// Note how we use the original array, rather than creating a\n\t\t\t\t// new one; this is more efficient and preserves any extra data\n\t\t\t\t// that the user may have stored in higher indexes.\n\n\t\t\t\tif ($.isArray(value) && value.length == 1) {\n    \t\t\t\tvalue = value[0];\n\t\t\t\t}\n\n\t\t\t\tif ($.isArray(value)) {\n\t\t\t\t\t// Equivalent to $.isNumeric() but compatible with jQuery < 1.7\n\t\t\t\t\tif (!isNaN(parseFloat(value[1])) && isFinite(value[1])) {\n\t\t\t\t\t\tvalue[1] = +value[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue[1] = 0;\n\t\t\t\t\t}\n\t\t\t\t} else if (!isNaN(parseFloat(value)) && isFinite(value)) {\n\t\t\t\t\tvalue = [1, +value];\n\t\t\t\t} else {\n\t\t\t\t\tvalue = [1, 0];\n\t\t\t\t}\n\n\t\t\t\tdata[i].data = [value];\n\t\t\t}\n\n\t\t\t// Sum up all the slices, so we can calculate percentages for each\n\n\t\t\tfor (var i = 0; i < data.length; ++i) {\n\t\t\t\ttotal += data[i].data[0][1];\n\t\t\t}\n\n\t\t\t// Count the number of slices with percentages below the combine\n\t\t\t// threshold; if it turns out to be just one, we won't combine.\n\n\t\t\tfor (var i = 0; i < data.length; ++i) {\n\t\t\t\tvar value = data[i].data[0][1];\n\t\t\t\tif (value / total <= options.series.pie.combine.threshold) {\n\t\t\t\t\tcombined += value;\n\t\t\t\t\tnumCombined++;\n\t\t\t\t\tif (!color) {\n\t\t\t\t\t\tcolor = data[i].color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < data.length; ++i) {\n\t\t\t\tvar value = data[i].data[0][1];\n\t\t\t\tif (numCombined < 2 || value / total > options.series.pie.combine.threshold) {\n\t\t\t\t\tnewdata.push(\n\t\t\t\t\t\t$.extend(data[i], {     /* extend to allow keeping all other original data values\n\t\t\t\t\t\t                           and using them e.g. in labelFormatter. */\n\t\t\t\t\t\t\tdata: [[1, value]],\n\t\t\t\t\t\t\tcolor: data[i].color,\n\t\t\t\t\t\t\tlabel: data[i].label,\n\t\t\t\t\t\t\tangle: value * Math.PI * 2 / total,\n\t\t\t\t\t\t\tpercent: value / (total / 100)\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (numCombined > 1) {\n\t\t\t\tnewdata.push({\n\t\t\t\t\tdata: [[1, combined]],\n\t\t\t\t\tcolor: color,\n\t\t\t\t\tlabel: options.series.pie.combine.label,\n\t\t\t\t\tangle: combined * Math.PI * 2 / total,\n\t\t\t\t\tpercent: combined / (total / 100)\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn newdata;\n\t\t}\n\n\t\tfunction draw(plot, newCtx) {\n\n\t\t\tif (!target) {\n\t\t\t\treturn; // if no series were passed\n\t\t\t}\n\n\t\t\tvar canvasWidth = plot.getPlaceholder().width(),\n\t\t\t\tcanvasHeight = plot.getPlaceholder().height(),\n\t\t\t\tlegendWidth = target.children().filter(\".legend\").children().width() || 0;\n\n\t\t\tctx = newCtx;\n\n\t\t\t// WARNING: HACK! REWRITE THIS CODE AS SOON AS POSSIBLE!\n\n\t\t\t// When combining smaller slices into an 'other' slice, we need to\n\t\t\t// add a new series.  Since Flot gives plugins no way to modify the\n\t\t\t// list of series, the pie plugin uses a hack where the first call\n\t\t\t// to processDatapoints results in a call to setData with the new\n\t\t\t// list of series, then subsequent processDatapoints do nothing.\n\n\t\t\t// The plugin-global 'processed' flag is used to control this hack;\n\t\t\t// it starts out false, and is set to true after the first call to\n\t\t\t// processDatapoints.\n\n\t\t\t// Unfortunately this turns future setData calls into no-ops; they\n\t\t\t// call processDatapoints, the flag is true, and nothing happens.\n\n\t\t\t// To fix this we'll set the flag back to false here in draw, when\n\t\t\t// all series have been processed, so the next sequence of calls to\n\t\t\t// processDatapoints once again starts out with a slice-combine.\n\t\t\t// This is really a hack; in 0.9 we need to give plugins a proper\n\t\t\t// way to modify series before any processing begins.\n\n\t\t\tprocessed = false;\n\n\t\t\t// calculate maximum radius and center point\n\n\t\t\tmaxRadius =  Math.min(canvasWidth, canvasHeight / options.series.pie.tilt) / 2;\n\t\t\tcenterTop = canvasHeight / 2 + options.series.pie.offset.top;\n\t\t\tcenterLeft = canvasWidth / 2;\n\n\t\t\tif (options.series.pie.offset.left == \"auto\") {\n\t\t\t\tif (options.legend.position.match(\"w\")) {\n\t\t\t\t\tcenterLeft += legendWidth / 2;\n\t\t\t\t} else {\n\t\t\t\t\tcenterLeft -= legendWidth / 2;\n\t\t\t\t}\n\t\t\t\tif (centerLeft < maxRadius) {\n\t\t\t\t\tcenterLeft = maxRadius;\n\t\t\t\t} else if (centerLeft > canvasWidth - maxRadius) {\n\t\t\t\t\tcenterLeft = canvasWidth - maxRadius;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcenterLeft += options.series.pie.offset.left;\n\t\t\t}\n\n\t\t\tvar slices = plot.getData(),\n\t\t\t\tattempts = 0;\n\n\t\t\t// Keep shrinking the pie's radius until drawPie returns true,\n\t\t\t// indicating that all the labels fit, or we try too many times.\n\n\t\t\tdo {\n\t\t\t\tif (attempts > 0) {\n\t\t\t\t\tmaxRadius *= REDRAW_SHRINK;\n\t\t\t\t}\n\t\t\t\tattempts += 1;\n\t\t\t\tclear();\n\t\t\t\tif (options.series.pie.tilt <= 0.8) {\n\t\t\t\t\tdrawShadow();\n\t\t\t\t}\n\t\t\t} while (!drawPie() && attempts < REDRAW_ATTEMPTS)\n\n\t\t\tif (attempts >= REDRAW_ATTEMPTS) {\n\t\t\t\tclear();\n\t\t\t\ttarget.prepend(\"<div class='error'>Could not draw pie with labels contained inside canvas</div>\");\n\t\t\t}\n\n\t\t\tif (plot.setSeries && plot.insertLegend) {\n\t\t\t\tplot.setSeries(slices);\n\t\t\t\tplot.insertLegend();\n\t\t\t}\n\n\t\t\t// we're actually done at this point, just defining internal functions at this point\n\n\t\t\tfunction clear() {\n\t\t\t\tctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\t\t\t\ttarget.children().filter(\".pieLabel, .pieLabelBackground\").remove();\n\t\t\t}\n\n\t\t\tfunction drawShadow() {\n\n\t\t\t\tvar shadowLeft = options.series.pie.shadow.left;\n\t\t\t\tvar shadowTop = options.series.pie.shadow.top;\n\t\t\t\tvar edge = 10;\n\t\t\t\tvar alpha = options.series.pie.shadow.alpha;\n\t\t\t\tvar radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n\n\t\t\t\tif (radius >= canvasWidth / 2 - shadowLeft || radius * options.series.pie.tilt >= canvasHeight / 2 - shadowTop || radius <= edge) {\n\t\t\t\t\treturn;\t// shadow would be outside canvas, so don't draw it\n\t\t\t\t}\n\n\t\t\t\tctx.save();\n\t\t\t\tctx.translate(shadowLeft,shadowTop);\n\t\t\t\tctx.globalAlpha = alpha;\n\t\t\t\tctx.fillStyle = \"#000\";\n\n\t\t\t\t// center and rotate to starting position\n\n\t\t\t\tctx.translate(centerLeft,centerTop);\n\t\t\t\tctx.scale(1, options.series.pie.tilt);\n\n\t\t\t\t//radius -= edge;\n\n\t\t\t\tfor (var i = 1; i <= edge; i++) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(0, 0, radius, 0, Math.PI * 2, false);\n\t\t\t\t\tctx.fill();\n\t\t\t\t\tradius -= i;\n\t\t\t\t}\n\n\t\t\t\tctx.restore();\n\t\t\t}\n\n\t\t\tfunction drawPie() {\n\n\t\t\t\tvar startAngle = Math.PI * options.series.pie.startAngle;\n\t\t\t\tvar radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n\n\t\t\t\t// center and rotate to starting position\n\n\t\t\t\tctx.save();\n\t\t\t\tctx.translate(centerLeft,centerTop);\n\t\t\t\tctx.scale(1, options.series.pie.tilt);\n\t\t\t\t//ctx.rotate(startAngle); // start at top; -- This doesn't work properly in Opera\n\n\t\t\t\t// draw slices\n\n\t\t\t\tctx.save();\n\t\t\t\tvar currentAngle = startAngle;\n\t\t\t\tfor (var i = 0; i < slices.length; ++i) {\n\t\t\t\t\tslices[i].startAngle = currentAngle;\n\t\t\t\t\tdrawSlice(slices[i].angle, slices[i].color, true);\n\t\t\t\t}\n\t\t\t\tctx.restore();\n\n\t\t\t\t// draw slice outlines\n\n\t\t\t\tif (options.series.pie.stroke.width > 0) {\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.lineWidth = options.series.pie.stroke.width;\n\t\t\t\t\tcurrentAngle = startAngle;\n\t\t\t\t\tfor (var i = 0; i < slices.length; ++i) {\n\t\t\t\t\t\tdrawSlice(slices[i].angle, options.series.pie.stroke.color, false);\n\t\t\t\t\t}\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\n\t\t\t\t// draw donut hole\n\n\t\t\t\tdrawDonutHole(ctx);\n\n\t\t\t\tctx.restore();\n\n\t\t\t\t// Draw the labels, returning true if they fit within the plot\n\n\t\t\t\tif (options.series.pie.label.show) {\n\t\t\t\t\treturn drawLabels();\n\t\t\t\t} else return true;\n\n\t\t\t\tfunction drawSlice(angle, color, fill) {\n\n\t\t\t\t\tif (angle <= 0 || isNaN(angle)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (fill) {\n\t\t\t\t\t\tctx.fillStyle = color;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.strokeStyle = color;\n\t\t\t\t\t\tctx.lineJoin = \"round\";\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tif (Math.abs(angle - Math.PI * 2) > 0.000000001) {\n\t\t\t\t\t\tctx.moveTo(0, 0); // Center of the pie\n\t\t\t\t\t}\n\n\t\t\t\t\t//ctx.arc(0, 0, radius, 0, angle, false); // This doesn't work properly in Opera\n\t\t\t\t\tctx.arc(0, 0, radius,currentAngle, currentAngle + angle / 2, false);\n\t\t\t\t\tctx.arc(0, 0, radius,currentAngle + angle / 2, currentAngle + angle, false);\n\t\t\t\t\tctx.closePath();\n\t\t\t\t\t//ctx.rotate(angle); // This doesn't work properly in Opera\n\t\t\t\t\tcurrentAngle += angle;\n\n\t\t\t\t\tif (fill) {\n\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction drawLabels() {\n\n\t\t\t\t\tvar currentAngle = startAngle;\n\t\t\t\t\tvar radius = options.series.pie.label.radius > 1 ? options.series.pie.label.radius : maxRadius * options.series.pie.label.radius;\n\n\t\t\t\t\tfor (var i = 0; i < slices.length; ++i) {\n\t\t\t\t\t\tif (slices[i].percent >= options.series.pie.label.threshold * 100) {\n\t\t\t\t\t\t\tif (!drawLabel(slices[i], currentAngle, i)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrentAngle += slices[i].angle;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t\tfunction drawLabel(slice, startAngle, index) {\n\n\t\t\t\t\t\tif (slice.data[0][1] == 0) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// format label text\n\n\t\t\t\t\t\tvar lf = options.legend.labelFormatter, text, plf = options.series.pie.label.formatter;\n\n\t\t\t\t\t\tif (lf) {\n\t\t\t\t\t\t\ttext = lf(slice.label, slice);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttext = slice.label;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (plf) {\n\t\t\t\t\t\t\ttext = plf(text, slice);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar halfAngle = ((startAngle + slice.angle) + startAngle) / 2;\n\t\t\t\t\t\tvar x = centerLeft + Math.round(Math.cos(halfAngle) * radius);\n\t\t\t\t\t\tvar y = centerTop + Math.round(Math.sin(halfAngle) * radius) * options.series.pie.tilt;\n\n\t\t\t\t\t\tvar html = \"<span class='pieLabel' id='pieLabel\" + index + \"' style='position:absolute;top:\" + y + \"px;left:\" + x + \"px;'>\" + text + \"</span>\";\n\t\t\t\t\t\ttarget.append(html);\n\n\t\t\t\t\t\tvar label = target.children(\"#pieLabel\" + index);\n\t\t\t\t\t\tvar labelTop = (y - label.height() / 2);\n\t\t\t\t\t\tvar labelLeft = (x - label.width() / 2);\n\n\t\t\t\t\t\tlabel.css(\"top\", labelTop);\n\t\t\t\t\t\tlabel.css(\"left\", labelLeft);\n\n\t\t\t\t\t\t// check to make sure that the label is not outside the canvas\n\n\t\t\t\t\t\tif (0 - labelTop > 0 || 0 - labelLeft > 0 || canvasHeight - (labelTop + label.height()) < 0 || canvasWidth - (labelLeft + label.width()) < 0) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (options.series.pie.label.background.opacity != 0) {\n\n\t\t\t\t\t\t\t// put in the transparent background separately to avoid blended labels and label boxes\n\n\t\t\t\t\t\t\tvar c = options.series.pie.label.background.color;\n\n\t\t\t\t\t\t\tif (c == null) {\n\t\t\t\t\t\t\t\tc = slice.color;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar pos = \"top:\" + labelTop + \"px;left:\" + labelLeft + \"px;\";\n\t\t\t\t\t\t\t$(\"<div class='pieLabelBackground' style='position:absolute;width:\" + label.width() + \"px;height:\" + label.height() + \"px;\" + pos + \"background-color:\" + c + \";'></div>\")\n\t\t\t\t\t\t\t\t.css(\"opacity\", options.series.pie.label.background.opacity)\n\t\t\t\t\t\t\t\t.insertBefore(label);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} // end individual label function\n\t\t\t\t} // end drawLabels function\n\t\t\t} // end drawPie function\n\t\t} // end draw function\n\n\t\t// Placed here because it needs to be accessed from multiple locations\n\n\t\tfunction drawDonutHole(layer) {\n\t\t\tif (options.series.pie.innerRadius > 0) {\n\n\t\t\t\t// subtract the center\n\n\t\t\t\tlayer.save();\n\t\t\t\tvar innerRadius = options.series.pie.innerRadius > 1 ? options.series.pie.innerRadius : maxRadius * options.series.pie.innerRadius;\n\t\t\t\tlayer.globalCompositeOperation = \"destination-out\"; // this does not work with excanvas, but it will fall back to using the stroke color\n\t\t\t\tlayer.beginPath();\n\t\t\t\tlayer.fillStyle = options.series.pie.stroke.color;\n\t\t\t\tlayer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);\n\t\t\t\tlayer.fill();\n\t\t\t\tlayer.closePath();\n\t\t\t\tlayer.restore();\n\n\t\t\t\t// add inner stroke\n\n\t\t\t\tlayer.save();\n\t\t\t\tlayer.beginPath();\n\t\t\t\tlayer.strokeStyle = options.series.pie.stroke.color;\n\t\t\t\tlayer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);\n\t\t\t\tlayer.stroke();\n\t\t\t\tlayer.closePath();\n\t\t\t\tlayer.restore();\n\n\t\t\t\t// TODO: add extra shadow inside hole (with a mask) if the pie is tilted.\n\t\t\t}\n\t\t}\n\n\t\t//-- Additional Interactive related functions --\n\n\t\tfunction isPointInPoly(poly, pt) {\n\t\t\tfor(var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)\n\t\t\t\t((poly[i][1] <= pt[1] && pt[1] < poly[j][1]) || (poly[j][1] <= pt[1] && pt[1]< poly[i][1]))\n\t\t\t\t&& (pt[0] < (poly[j][0] - poly[i][0]) * (pt[1] - poly[i][1]) / (poly[j][1] - poly[i][1]) + poly[i][0])\n\t\t\t\t&& (c = !c);\n\t\t\treturn c;\n\t\t}\n\n\t\tfunction findNearbySlice(mouseX, mouseY) {\n\n\t\t\tvar slices = plot.getData(),\n\t\t\t\toptions = plot.getOptions(),\n\t\t\t\tradius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius,\n\t\t\t\tx, y;\n\n\t\t\tfor (var i = 0; i < slices.length; ++i) {\n\n\t\t\t\tvar s = slices[i];\n\n\t\t\t\tif (s.pie.show) {\n\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(0, 0); // Center of the pie\n\t\t\t\t\t//ctx.scale(1, options.series.pie.tilt);\t// this actually seems to break everything when here.\n\t\t\t\t\tctx.arc(0, 0, radius, s.startAngle, s.startAngle + s.angle / 2, false);\n\t\t\t\t\tctx.arc(0, 0, radius, s.startAngle + s.angle / 2, s.startAngle + s.angle, false);\n\t\t\t\t\tctx.closePath();\n\t\t\t\t\tx = mouseX - centerLeft;\n\t\t\t\t\ty = mouseY - centerTop;\n\n\t\t\t\t\tif (ctx.isPointInPath) {\n\t\t\t\t\t\tif (ctx.isPointInPath(mouseX - centerLeft, mouseY - centerTop)) {\n\t\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdatapoint: [s.percent, s.data],\n\t\t\t\t\t\t\t\tdataIndex: 0,\n\t\t\t\t\t\t\t\tseries: s,\n\t\t\t\t\t\t\t\tseriesIndex: i\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// excanvas for IE doesn;t support isPointInPath, this is a workaround.\n\n\t\t\t\t\t\tvar p1X = radius * Math.cos(s.startAngle),\n\t\t\t\t\t\t\tp1Y = radius * Math.sin(s.startAngle),\n\t\t\t\t\t\t\tp2X = radius * Math.cos(s.startAngle + s.angle / 4),\n\t\t\t\t\t\t\tp2Y = radius * Math.sin(s.startAngle + s.angle / 4),\n\t\t\t\t\t\t\tp3X = radius * Math.cos(s.startAngle + s.angle / 2),\n\t\t\t\t\t\t\tp3Y = radius * Math.sin(s.startAngle + s.angle / 2),\n\t\t\t\t\t\t\tp4X = radius * Math.cos(s.startAngle + s.angle / 1.5),\n\t\t\t\t\t\t\tp4Y = radius * Math.sin(s.startAngle + s.angle / 1.5),\n\t\t\t\t\t\t\tp5X = radius * Math.cos(s.startAngle + s.angle),\n\t\t\t\t\t\t\tp5Y = radius * Math.sin(s.startAngle + s.angle),\n\t\t\t\t\t\t\tarrPoly = [[0, 0], [p1X, p1Y], [p2X, p2Y], [p3X, p3Y], [p4X, p4Y], [p5X, p5Y]],\n\t\t\t\t\t\t\tarrPoint = [x, y];\n\n\t\t\t\t\t\t// TODO: perhaps do some mathmatical trickery here with the Y-coordinate to compensate for pie tilt?\n\n\t\t\t\t\t\tif (isPointInPoly(arrPoly, arrPoint)) {\n\t\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdatapoint: [s.percent, s.data],\n\t\t\t\t\t\t\t\tdataIndex: 0,\n\t\t\t\t\t\t\t\tseries: s,\n\t\t\t\t\t\t\t\tseriesIndex: i\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction onMouseMove(e) {\n\t\t\ttriggerClickHoverEvent(\"plothover\", e);\n\t\t}\n\n\t\tfunction onClick(e) {\n\t\t\ttriggerClickHoverEvent(\"plotclick\", e);\n\t\t}\n\n\t\t// trigger click or hover event (they send the same parameters so we share their code)\n\n\t\tfunction triggerClickHoverEvent(eventname, e) {\n\n\t\t\tvar offset = plot.offset();\n\t\t\tvar canvasX = parseInt(e.pageX - offset.left);\n\t\t\tvar canvasY =  parseInt(e.pageY - offset.top);\n\t\t\tvar item = findNearbySlice(canvasX, canvasY);\n\n\t\t\tif (options.grid.autoHighlight) {\n\n\t\t\t\t// clear auto-highlights\n\n\t\t\t\tfor (var i = 0; i < highlights.length; ++i) {\n\t\t\t\t\tvar h = highlights[i];\n\t\t\t\t\tif (h.auto == eventname && !(item && h.series == item.series)) {\n\t\t\t\t\t\tunhighlight(h.series);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// highlight the slice\n\n\t\t\tif (item) {\n\t\t\t\thighlight(item.series, eventname);\n\t\t\t}\n\n\t\t\t// trigger any hover bind events\n\n\t\t\tvar pos = { pageX: e.pageX, pageY: e.pageY };\n\t\t\ttarget.trigger(eventname, [pos, item]);\n\t\t}\n\n\t\tfunction highlight(s, auto) {\n\t\t\t//if (typeof s == \"number\") {\n\t\t\t//\ts = series[s];\n\t\t\t//}\n\n\t\t\tvar i = indexOfHighlight(s);\n\n\t\t\tif (i == -1) {\n\t\t\t\thighlights.push({ series: s, auto: auto });\n\t\t\t\tplot.triggerRedrawOverlay();\n\t\t\t} else if (!auto) {\n\t\t\t\thighlights[i].auto = false;\n\t\t\t}\n\t\t}\n\n\t\tfunction unhighlight(s) {\n\t\t\tif (s == null) {\n\t\t\t\thighlights = [];\n\t\t\t\tplot.triggerRedrawOverlay();\n\t\t\t}\n\n\t\t\t//if (typeof s == \"number\") {\n\t\t\t//\ts = series[s];\n\t\t\t//}\n\n\t\t\tvar i = indexOfHighlight(s);\n\n\t\t\tif (i != -1) {\n\t\t\t\thighlights.splice(i, 1);\n\t\t\t\tplot.triggerRedrawOverlay();\n\t\t\t}\n\t\t}\n\n\t\tfunction indexOfHighlight(s) {\n\t\t\tfor (var i = 0; i < highlights.length; ++i) {\n\t\t\t\tvar h = highlights[i];\n\t\t\t\tif (h.series == s)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tfunction drawOverlay(plot, octx) {\n\n\t\t\tvar options = plot.getOptions();\n\n\t\t\tvar radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n\n\t\t\toctx.save();\n\t\t\toctx.translate(centerLeft, centerTop);\n\t\t\toctx.scale(1, options.series.pie.tilt);\n\n\t\t\tfor (var i = 0; i < highlights.length; ++i) {\n\t\t\t\tdrawHighlight(highlights[i].series);\n\t\t\t}\n\n\t\t\tdrawDonutHole(octx);\n\n\t\t\toctx.restore();\n\n\t\t\tfunction drawHighlight(series) {\n\n\t\t\t\tif (series.angle <= 0 || isNaN(series.angle)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//octx.fillStyle = parseColor(options.series.pie.highlight.color).scale(null, null, null, options.series.pie.highlight.opacity).toString();\n\t\t\t\toctx.fillStyle = \"rgba(255, 255, 255, \" + options.series.pie.highlight.opacity + \")\"; // this is temporary until we have access to parseColor\n\t\t\t\toctx.beginPath();\n\t\t\t\tif (Math.abs(series.angle - Math.PI * 2) > 0.000000001) {\n\t\t\t\t\toctx.moveTo(0, 0); // Center of the pie\n\t\t\t\t}\n\t\t\t\toctx.arc(0, 0, radius, series.startAngle, series.startAngle + series.angle / 2, false);\n\t\t\t\toctx.arc(0, 0, radius, series.startAngle + series.angle / 2, series.startAngle + series.angle, false);\n\t\t\t\toctx.closePath();\n\t\t\t\toctx.fill();\n\t\t\t}\n\t\t}\n\t} // end init (plugin body)\n\n\t// define pie specific options and their default values\n\n\tvar options = {\n\t\tseries: {\n\t\t\tpie: {\n\t\t\t\tshow: false,\n\t\t\t\tradius: \"auto\",\t// actual radius of the visible pie (based on full calculated radius if <=1, or hard pixel value)\n\t\t\t\tinnerRadius: 0, /* for donut */\n\t\t\t\tstartAngle: 3/2,\n\t\t\t\ttilt: 1,\n\t\t\t\tshadow: {\n\t\t\t\t\tleft: 5,\t// shadow left offset\n\t\t\t\t\ttop: 15,\t// shadow top offset\n\t\t\t\t\talpha: 0.02\t// shadow alpha\n\t\t\t\t},\n\t\t\t\toffset: {\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tleft: \"auto\"\n\t\t\t\t},\n\t\t\t\tstroke: {\n\t\t\t\t\tcolor: \"#fff\",\n\t\t\t\t\twidth: 1\n\t\t\t\t},\n\t\t\t\tlabel: {\n\t\t\t\t\tshow: \"auto\",\n\t\t\t\t\tformatter: function(label, slice) {\n\t\t\t\t\t\treturn \"<div style='font-size:x-small;text-align:center;padding:2px;color:\" + slice.color + \";'>\" + label + \"<br/>\" + Math.round(slice.percent) + \"%</div>\";\n\t\t\t\t\t},\t// formatter function\n\t\t\t\t\tradius: 1,\t// radius at which to place the labels (based on full calculated radius if <=1, or hard pixel value)\n\t\t\t\t\tbackground: {\n\t\t\t\t\t\tcolor: null,\n\t\t\t\t\t\topacity: 0\n\t\t\t\t\t},\n\t\t\t\t\tthreshold: 0\t// percentage at which to hide the label (i.e. the slice is too narrow)\n\t\t\t\t},\n\t\t\t\tcombine: {\n\t\t\t\t\tthreshold: -1,\t// percentage at which to combine little slices into one larger slice\n\t\t\t\t\tcolor: null,\t// color to give the new slice (auto-generated if null)\n\t\t\t\t\tlabel: \"Other\"\t// label to give the new slice\n\t\t\t\t},\n\t\t\t\thighlight: {\n\t\t\t\t\t//color: \"#fff\",\t\t// will add this functionality once parseColor is available\n\t\t\t\t\topacity: 0.5\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t$.plot.plugins.push({\n\t\tinit: init,\n\t\toptions: options,\n\t\tname: \"pie\",\n\t\tversion: \"1.1\"\n\t});\n\n})(jQuery);\n"]},"hash":"8a68087d9067d6dd32320bd29e3a5787397dffcf"}

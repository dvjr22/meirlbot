{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/routepolicy.js","filenameRelative":"/bundle/programs/server/packages/routepolicy.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/routepolicy.js.map","sourceFileName":"/bundle/programs/server/packages/routepolicy.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"routepolicy"},"ignored":false,"code":"(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var _ = Package.underscore._;\n\n  /* Package-scope variables */\n  var RoutePolicyTest, RoutePolicy;\n\n  (function () {\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                             //\n    // packages/routepolicy/routepolicy.js                                                                         //\n    //                                                                                                             //\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // In addition to listing specific files to be cached, the browser\n    // application cache manifest allows URLs to be designated as NETWORK\n    // (always fetched from the Internet) and FALLBACK (which we use to\n    // serve app HTML on arbitrary URLs).\n    //\n    // The limitation of the manifest file format is that the designations\n    // are by prefix only: if \"/foo\" is declared NETWORK then \"/foobar\"\n    // will also be treated as a network route.\n    //\n    // RoutePolicy is a low-level API for declaring the route type of URL prefixes:\n    //\n    // \"network\": for network routes that should not conflict with static\n    // resources.  (For example, if \"/sockjs/\" is a network route, we\n    // shouldn't have \"/sockjs/red-sock.jpg\" as a static resource).\n    //\n    // \"static-online\": for static resources which should not be cached in\n    // the app cache.  This is implemented by also adding them to the\n    // NETWORK section (as otherwise the browser would receive app HTML\n    // for them because of the FALLBACK section), but static-online routes\n    // don't need to be checked for conflict with static resources.\n\n    // The route policy is a singleton in a running application, but we\n    // can't unit test the real singleton because messing with the real\n    // routes would break tinytest... so allow policy instances to be\n    // constructed for testing.\n\n    RoutePolicyTest = {};\n\n    var RoutePolicyConstructor = RoutePolicyTest.Constructor = function () {\n      var self = this;\n      self.urlPrefixTypes = {};\n    };\n\n    _.extend(RoutePolicyConstructor.prototype, {\n\n      urlPrefixMatches: function urlPrefixMatches(urlPrefix, url) {\n        return url.substr(0, urlPrefix.length) === urlPrefix;\n      },\n\n      checkType: function checkType(type) {\n        if (!_.contains(['network', 'static-online'], type)) return 'the route type must be \"network\" or \"static-online\"';\n        return null;\n      },\n\n      checkUrlPrefix: function checkUrlPrefix(urlPrefix, type) {\n        var self = this;\n\n        if (urlPrefix.charAt(0) !== '/') return 'a route URL prefix must begin with a slash';\n\n        if (urlPrefix === '/') return 'a route URL prefix cannot be /';\n\n        var existingType = self.urlPrefixTypes[urlPrefix];\n        if (existingType && existingType !== type) return 'the route URL prefix ' + urlPrefix + ' has already been declared to be of type ' + existingType;\n\n        return null;\n      },\n\n      checkForConflictWithStatic: function checkForConflictWithStatic(urlPrefix, type, _testManifest) {\n        var self = this;\n        if (type === 'static-online') return null;\n        if (!Package.webapp || !Package.webapp.WebApp || !Package.webapp.WebApp.clientPrograms || !Package.webapp.WebApp.clientPrograms[Package.webapp.WebApp.defaultArch].manifest) {\n          // Hack: If we don't have a manifest, deal with it\n          // gracefully. This lets us load livedata into a nodejs\n          // environment that doesn't have a HTTP server (eg, a\n          // command-line tool).\n          return null;\n        }\n        var manifest = _testManifest || Package.webapp.WebApp.clientPrograms[Package.webapp.WebApp.defaultArch].manifest;\n        var conflict = _.find(manifest, function (resource) {\n          return resource.type === 'static' && resource.where === 'client' && self.urlPrefixMatches(urlPrefix, resource.url);\n        });\n        if (conflict) return 'static resource ' + conflict.url + ' conflicts with ' + type + ' route ' + urlPrefix;else return null;\n      },\n\n      declare: function declare(urlPrefix, type) {\n        var self = this;\n        var problem = self.checkType(type) || self.checkUrlPrefix(urlPrefix, type) || self.checkForConflictWithStatic(urlPrefix, type);\n        if (problem) throw new Error(problem);\n        // TODO overlapping prefixes, e.g. /foo/ and /foo/bar/\n        self.urlPrefixTypes[urlPrefix] = type;\n      },\n\n      isValidUrl: function isValidUrl(url) {\n        return url.charAt(0) === '/';\n      },\n\n      classify: function classify(url) {\n        var self = this;\n        if (url.charAt(0) !== '/') throw new Error('url must be a relative URL: ' + url);\n        var prefix = _.find(_.keys(self.urlPrefixTypes), function (_prefix) {\n          return self.urlPrefixMatches(_prefix, url);\n        });\n        if (prefix) return self.urlPrefixTypes[prefix];else return null;\n      },\n\n      urlPrefixesFor: function urlPrefixesFor(type) {\n        var self = this;\n        var prefixes = [];\n        _.each(self.urlPrefixTypes, function (_type, _prefix) {\n          if (_type === type) prefixes.push(_prefix);\n        });\n        return prefixes.sort();\n      }\n    });\n\n    RoutePolicy = new RoutePolicyConstructor();\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package.routepolicy = {}, {\n    RoutePolicy: RoutePolicy,\n    RoutePolicyTest: RoutePolicyTest\n  });\n})();\n\n//# sourceMappingURL=routepolicy.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/routepolicy.js"],"names":[],"mappings":"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","file":"/bundle/programs/server/packages/routepolicy.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\n\n/* Package-scope variables */\nvar RoutePolicyTest, RoutePolicy;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                             //\n// packages/routepolicy/routepolicy.js                                                                         //\n//                                                                                                             //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                               //\n// In addition to listing specific files to be cached, the browser\n// application cache manifest allows URLs to be designated as NETWORK\n// (always fetched from the Internet) and FALLBACK (which we use to\n// serve app HTML on arbitrary URLs).\n//\n// The limitation of the manifest file format is that the designations\n// are by prefix only: if \"/foo\" is declared NETWORK then \"/foobar\"\n// will also be treated as a network route.\n//\n// RoutePolicy is a low-level API for declaring the route type of URL prefixes:\n//\n// \"network\": for network routes that should not conflict with static\n// resources.  (For example, if \"/sockjs/\" is a network route, we\n// shouldn't have \"/sockjs/red-sock.jpg\" as a static resource).\n//\n// \"static-online\": for static resources which should not be cached in\n// the app cache.  This is implemented by also adding them to the\n// NETWORK section (as otherwise the browser would receive app HTML\n// for them because of the FALLBACK section), but static-online routes\n// don't need to be checked for conflict with static resources.\n\n// The route policy is a singleton in a running application, but we\n// can't unit test the real singleton because messing with the real\n// routes would break tinytest... so allow policy instances to be\n// constructed for testing.\n\nRoutePolicyTest = {};\n\nvar RoutePolicyConstructor = RoutePolicyTest.Constructor = function () {\n  var self = this;\n  self.urlPrefixTypes = {};\n};\n\n_.extend(RoutePolicyConstructor.prototype, {\n\n  urlPrefixMatches: function (urlPrefix, url) {\n    return url.substr(0, urlPrefix.length) === urlPrefix;\n  },\n\n  checkType: function (type) {\n    if (! _.contains(['network', 'static-online'], type))\n      return 'the route type must be \"network\" or \"static-online\"';\n    return null;\n  },\n\n  checkUrlPrefix: function (urlPrefix, type) {\n    var self = this;\n\n    if (urlPrefix.charAt(0) !== '/')\n      return 'a route URL prefix must begin with a slash';\n\n    if (urlPrefix === '/')\n      return 'a route URL prefix cannot be /';\n\n    var existingType = self.urlPrefixTypes[urlPrefix];\n    if (existingType && existingType !== type)\n      return 'the route URL prefix ' + urlPrefix + ' has already been declared to be of type ' + existingType;\n\n    return null;\n  },\n\n  checkForConflictWithStatic: function (urlPrefix, type, _testManifest) {\n    var self = this;\n    if (type === 'static-online')\n      return null;\n    if (!Package.webapp || !Package.webapp.WebApp\n        || !Package.webapp.WebApp.clientPrograms\n        || !Package.webapp.WebApp.clientPrograms[Package.webapp.WebApp.defaultArch].manifest) {\n      // Hack: If we don't have a manifest, deal with it\n      // gracefully. This lets us load livedata into a nodejs\n      // environment that doesn't have a HTTP server (eg, a\n      // command-line tool).\n      return null;\n    }\n    var manifest = _testManifest ||\n      Package.webapp.WebApp.clientPrograms[Package.webapp.WebApp.defaultArch].manifest;\n    var conflict = _.find(manifest, function (resource) {\n      return (resource.type === 'static' &&\n              resource.where === 'client' &&\n              self.urlPrefixMatches(urlPrefix, resource.url));\n    });\n    if (conflict)\n      return ('static resource ' + conflict.url + ' conflicts with ' +\n              type + ' route ' + urlPrefix);\n    else\n      return null;\n  },\n\n  declare: function (urlPrefix, type) {\n    var self = this;\n    var problem = self.checkType(type) ||\n                  self.checkUrlPrefix(urlPrefix, type) ||\n                  self.checkForConflictWithStatic(urlPrefix, type);\n    if (problem)\n      throw new Error(problem);\n    // TODO overlapping prefixes, e.g. /foo/ and /foo/bar/\n    self.urlPrefixTypes[urlPrefix] = type;\n  },\n\n  isValidUrl: function (url) {\n    return url.charAt(0) === '/';\n  },\n\n  classify: function (url) {\n    var self = this;\n    if (url.charAt(0) !== '/')\n      throw new Error('url must be a relative URL: ' + url);\n    var prefix = _.find(_.keys(self.urlPrefixTypes), function (_prefix) {\n      return self.urlPrefixMatches(_prefix, url);\n    });\n    if (prefix)\n      return self.urlPrefixTypes[prefix];\n    else\n      return null;\n  },\n\n  urlPrefixesFor: function (type) {\n    var self = this;\n    var prefixes = [];\n    _.each(self.urlPrefixTypes, function (_type, _prefix) {\n      if (_type === type)\n        prefixes.push(_prefix);\n    });\n    return prefixes.sort();\n  }\n});\n\nRoutePolicy = new RoutePolicyConstructor();\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package.routepolicy = {}, {\n  RoutePolicy: RoutePolicy,\n  RoutePolicyTest: RoutePolicyTest\n});\n\n})();\n\n//# sourceMappingURL=routepolicy.js.map\n"]},"hash":"4b9133cd3f6e4034a512f2580f4157c59d1a1b5e"}

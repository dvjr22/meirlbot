{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/allow-deny.js","filenameRelative":"/bundle/programs/server/packages/allow-deny.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/allow-deny.js.map","sourceFileName":"/bundle/programs/server/packages/allow-deny.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"allow-deny"},"ignored":false,"code":"(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var ECMAScript = Package.ecmascript.ECMAScript;\n  var _ = Package.underscore._;\n  var LocalCollection = Package.minimongo.LocalCollection;\n  var Minimongo = Package.minimongo.Minimongo;\n  var check = Package.check.check;\n  var Match = Package.check.Match;\n  var EJSON = Package.ejson.EJSON;\n  var DDP = Package['ddp-client'].DDP;\n  var DDPServer = Package['ddp-server'].DDPServer;\n  var meteorInstall = Package.modules.meteorInstall;\n  var Buffer = Package.modules.Buffer;\n  var process = Package.modules.process;\n  var _Symbol = Package['ecmascript-runtime'].Symbol;\n  var Map = Package['ecmascript-runtime'].Map;\n  var Set = Package['ecmascript-runtime'].Set;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n\n  /* Package-scope variables */\n  var AllowDeny;\n\n  var require = meteorInstall({ \"node_modules\": { \"meteor\": { \"allow-deny\": { \"allow-deny.js\": function allowDenyJs() {\n\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                //\n            // packages/allow-deny/allow-deny.js                                                                              //\n            //                                                                                                                //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            ///                                                                                                               //\n            /// Remote methods and access control.                                                                            //\n            ///                                                                                                               //\n            //\n            // Restrict default mutators on collection. allow() and deny() take the                                           //\n            // same options:                                                                                                  //\n            //                                                                                                                //\n            // options.insert {Function(userId, doc)}                                                                         //\n            //   return true to allow/deny adding this document                                                               //\n            //                                                                                                                //\n            // options.update {Function(userId, docs, fields, modifier)}                                                      //\n            //   return true to allow/deny updating these documents.                                                          //\n            //   `fields` is passed as an array of fields that are to be modified                                             //\n            //                                                                                                                //\n            // options.remove {Function(userId, docs)}                                                                        //\n            //   return true to allow/deny removing these documents                                                           //\n            //                                                                                                                //\n            // options.fetch {Array}                                                                                          //\n            //   Fields to fetch for these validators. If any call to allow or deny                                           //\n            //   does not have this option then all fields are loaded.                                                        //\n            //                                                                                                                //\n            // allow and deny can be called multiple times. The validators are                                                //\n            // evaluated as follows:                                                                                          //\n            // - If neither deny() nor allow() has been called on the collection,                                             //\n            //   then the request is allowed if and only if the \"insecure\" smart                                              //\n            //   package is in use.                                                                                           //\n            // - Otherwise, if any deny() function returns true, the request is denied.                                       //\n            // - Otherwise, if any allow() function returns true, the request is allowed.                                     //\n            // - Otherwise, the request is denied.                                                                            //\n            //                                                                                                                //\n            // Meteor may call your deny() and allow() functions in any order, and may not                                    //\n            // call all of them if it is able to make a decision without calling them all                                     //\n            // (so don't include side effects).                                                                               //\n            //\n            AllowDeny = { // 35\n              CollectionPrototype: {} // 36\n            }; // 35\n            //\n            // In the `mongo` package, we will extend Mongo.Collection.prototype with these                                   //\n            // methods                                                                                                        //\n            var CollectionPrototype = AllowDeny.CollectionPrototype; // 41\n            //\n            /**                                                                                                               //\n             * @summary Allow users to write directly to this collection from client code, subject to limitations you define.\n             * @locus Server                                                                                                  //\n             * @method allow                                                                                                  //\n             * @memberOf Mongo.Collection                                                                                     //\n             * @instance                                                                                                      //\n             * @param {Object} options                                                                                        //\n             * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be allowed.\n             * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n             * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n             */ //\n            CollectionPrototype.allow = function (options) {\n              // 54\n              addValidator(this, 'allow', options); // 55\n            }; // 56\n            //\n            /**                                                                                                               //\n             * @summary Override `allow` rules.                                                                               //\n             * @locus Server                                                                                                  //\n             * @method deny                                                                                                   //\n             * @memberOf Mongo.Collection                                                                                     //\n             * @instance                                                                                                      //\n             * @param {Object} options                                                                                        //\n             * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be denied, even if an [allow](#allow) rule says otherwise.\n             * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n             * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n             */ //\n            CollectionPrototype.deny = function (options) {\n              // 69\n              addValidator(this, 'deny', options); // 70\n            }; // 71\n            //\n            CollectionPrototype._defineMutationMethods = function (options) {\n              // 73\n              var self = this; // 74\n              options = options || {}; // 75\n              //\n              // set to true once we call any allow or deny methods. If true, use                                             //\n              // allow/deny semantics. If false, use insecure mode semantics.                                                 //\n              self._restricted = false; // 79\n              //\n              // Insecure mode (default to allowing writes). Defaults to 'undefined' which                                    //\n              // means insecure iff the insecure package is loaded. This property can be                                      //\n              // overriden by tests or packages wishing to change insecure mode behavior of                                   //\n              // their collections.                                                                                           //\n              self._insecure = undefined; // 85\n              //\n              self._validators = { // 87\n                insert: { allow: [], deny: [] }, // 88\n                update: { allow: [], deny: [] }, // 89\n                remove: { allow: [], deny: [] }, // 90\n                upsert: { allow: [], deny: [] }, // dummy arrays; can't set these!                                            // 91\n                fetch: [], // 92\n                fetchAllFields: false // 93\n              }; // 87\n              //\n              if (!self._name) return; // anonymous collection                                                                // 96\n              //\n              // XXX Think about method namespacing. Maybe methods should be                                                  //\n              // \"Meteor:Mongo:insert/NAME\"?                                                                                  //\n              self._prefix = '/' + self._name + '/'; // 101\n              //\n              // Mutation Methods                                                                                             //\n              // Minimongo on the server gets no stubs; instead, by default                                                   //\n              // it wait()s until its result is ready, yielding.                                                              //\n              // This matches the behavior of macromongo on the server better.                                                //\n              // XXX see #MeteorServerNull                                                                                    //\n              if (self._connection && (self._connection === Meteor.server || Meteor.isClient)) {\n                // 108\n                (function () {\n                  // 108\n                  var m = {}; // 109\n                  //\n                  _.each(['insert', 'update', 'remove'], function (method) {\n                    // 111\n                    var methodName = self._prefix + method; // 112\n                    //\n                    if (options.useExisting) {\n                      // 114\n                      var handlerPropName = Meteor.isClient ? '_methodHandlers' : 'method_handlers'; // 115\n                      // Do not try to create additional methods if this has already been called.                             //\n                      // (Otherwise the .methods() call below will throw an error.)                                           //\n                      if (self._connection[handlerPropName] && typeof self._connection[handlerPropName][methodName] === 'function') return;\n                    } // 120\n                    //\n                    m[methodName] = function () /* ... */{\n                      // 122\n                      // All the methods do their own validation, instead of using check().                                   //\n                      check(arguments, [Match.Any]); // 124\n                      var args = _.toArray(arguments); // 125\n                      try {\n                        // 126\n                        // For an insert, if the client didn't specify an _id, generate one                                   //\n                        // now; because this uses DDP.randomStream, it will be consistent with                                //\n                        // what the client generated. We generate it now rather than later so                                 //\n                        // that if (eg) an allow/deny rule does an insert to the same                                         //\n                        // collection (not that it really should), the generated _id will                                     //\n                        // still be the first use of the stream and will be consistent.                                       //\n                        //                                                                                                    //\n                        // However, we don't actually stick the _id onto the document yet,                                    //\n                        // because we want allow/deny rules to be able to differentiate                                       //\n                        // between arbitrary client-specified _id fields and merely                                           //\n                        // client-controlled-via-randomSeed fields.                                                           //\n                        var generatedId = null; // 138\n                        if (method === \"insert\" && !_.has(args[0], '_id')) {\n                          // 139\n                          generatedId = self._makeNewID(); // 140\n                        } // 141\n                        //\n                        if (this.isSimulation) {\n                          // 143\n                          // In a client simulation, you can do any mutation (even with a                                     //\n                          // complex selector).                                                                               //\n                          if (generatedId !== null) args[0]._id = generatedId; // 146\n                          return self._collection[method].apply(self._collection, args); // 148\n                        } // 150\n                        //\n                        // This is the server receiving a method call from the client.                                        //\n                        //\n                        // We don't allow arbitrary selectors in mutations from the client: only                              //\n                        // single-ID selectors.                                                                               //\n                        if (method !== 'insert') throwIfSelectorIsNotId(args[0], method); // 156\n                        //\n                        if (self._restricted) {\n                          // 159\n                          // short circuit if there is no way it will pass.                                                   //\n                          if (self._validators[method].allow.length === 0) {\n                            // 161\n                            throw new Meteor.Error(403, \"Access denied. No allow validators set on restricted \" + \"collection for method '\" + method + \"'.\");\n                          } // 165\n                          //\n                          var validatedMethodName = '_validated' + method.charAt(0).toUpperCase() + method.slice(1); // 167\n                          args.unshift(this.userId); // 169\n                          method === 'insert' && args.push(generatedId); // 170\n                          return self[validatedMethodName].apply(self, args); // 171\n                        } else if (self._isInsecure()) {\n                            // 172\n                            if (generatedId !== null) args[0]._id = generatedId; // 173\n                            // In insecure mode, allow any mutation (with a simple selector).                                   //\n                            // XXX This is kind of bogus.  Instead of blindly passing whatever                                  //\n                            //     we get from the network to this function, we should actually                                 //\n                            //     know the correct arguments for the function and pass just                                    //\n                            //     them.  For example, if you have an extraneous extra null                                     //\n                            //     argument and this is Mongo on the server, the .wrapAsync'd                                   //\n                            //     functions like update will get confused and pass the                                         //\n                            //     \"fut.resolver()\" in the wrong slot, where _update will never                                 //\n                            //     invoke it. Bam, broken DDP connection.  Probably should just                                 //\n                            //     take this whole method and write it three times, invoking                                    //\n                            //     helpers for the common code.                                                                 //\n                            return self._collection[method].apply(self._collection, args); // 186\n                          } else {\n                              // 187\n                              // In secure mode, if we haven't called allow or deny, then nothing                                 //\n                              // is permitted.                                                                                    //\n                              throw new Meteor.Error(403, \"Access denied\"); // 190\n                            } // 191\n                      } catch (e) {\n                        // 192\n                        if (e.name === 'MongoError' || e.name === 'MinimongoError') {\n                          // 193\n                          throw new Meteor.Error(409, e.toString()); // 194\n                        } else {\n                            // 195\n                            throw e; // 196\n                          } // 197\n                      } // 198\n                    }; // 199\n                  }); // 200\n                  //\n                  self._connection.methods(m); // 202\n                })(); // 108\n              } // 203\n            }; // 204\n            //\n            CollectionPrototype._updateFetch = function (fields) {\n              // 206\n              var self = this; // 207\n              //\n              if (!self._validators.fetchAllFields) {\n                // 209\n                if (fields) {\n                  // 210\n                  self._validators.fetch = _.union(self._validators.fetch, fields); // 211\n                } else {\n                    // 212\n                    self._validators.fetchAllFields = true; // 213\n                    // clear fetch just to make sure we don't accidentally read it                                              //\n                    self._validators.fetch = null; // 215\n                  } // 216\n              } // 217\n            }; // 218\n            //\n            CollectionPrototype._isInsecure = function () {\n              // 220\n              var self = this; // 221\n              if (self._insecure === undefined) return !!Package.insecure; // 222\n              return self._insecure; // 224\n            }; // 225\n            //\n            CollectionPrototype._validatedInsert = function (userId, doc, generatedId) {\n              // 227\n              var self = this; // 229\n              //\n              // call user validators.                                                                                        //\n              // Any deny returns true means denied.                                                                          //\n              if (_.any(self._validators.insert.deny, function (validator) {\n                // 233\n                return validator(userId, docToValidate(validator, doc, generatedId)); // 234\n              })) {\n                  // 235\n                  throw new Meteor.Error(403, \"Access denied\"); // 236\n                } // 237\n              // Any allow returns true means proceed. Throw error if they all fail.                                          //\n              if (_.all(self._validators.insert.allow, function (validator) {\n                // 239\n                return !validator(userId, docToValidate(validator, doc, generatedId)); // 240\n              })) {\n                  // 241\n                  throw new Meteor.Error(403, \"Access denied\"); // 242\n                } // 243\n              //\n              // If we generated an ID above, insert it now: after the validation, but                                        //\n              // before actually inserting.                                                                                   //\n              if (generatedId !== null) doc._id = generatedId; // 247\n              //\n              self._collection.insert.call(self._collection, doc); // 250\n            }; // 251\n            //\n            // Simulate a mongo `update` operation while validating that the access                                           //\n            // control rules set by calls to `allow/deny` are satisfied. If all                                               //\n            // pass, rewrite the mongo operation to use $in to set the list of                                                //\n            // document ids to change ##ValidatedChange                                                                       //\n            CollectionPrototype._validatedUpdate = function (userId, selector, mutator, options) {\n              // 257\n              var self = this; // 259\n              //\n              check(mutator, Object); // 261\n              //\n              options = _.clone(options) || {}; // 263\n              //\n              if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) throw new Error(\"validated update should be of a single ID\");\n              //\n              // We don't support upserts because they don't fit nicely into allow/deny                                       //\n              // rules.                                                                                                       //\n              if (options.upsert) throw new Meteor.Error(403, \"Access denied. Upserts not \" + \"allowed in a restricted collection.\");\n              //\n              var noReplaceError = \"Access denied. In a restricted collection you can only\" + \" update documents, not replace them. Use a Mongo update operator, such \" + \"as '$set'.\";\n              //\n              // compute modified fields                                                                                      //\n              var fields = []; // 279\n              if (_.isEmpty(mutator)) {\n                // 280\n                throw new Meteor.Error(403, noReplaceError); // 281\n              } // 282\n              _.each(mutator, function (params, op) {\n                // 283\n                if (op.charAt(0) !== '$') {\n                  // 284\n                  throw new Meteor.Error(403, noReplaceError); // 285\n                } else if (!_.has(ALLOWED_UPDATE_OPERATIONS, op)) {\n                    // 286\n                    throw new Meteor.Error(403, \"Access denied. Operator \" + op + \" not allowed in a restricted collection.\"); // 287\n                  } else {\n                      // 289\n                      _.each(_.keys(params), function (field) {\n                        // 290\n                        // treat dotted fields as if they are replacing their                                                     //\n                        // top-level part                                                                                         //\n                        if (field.indexOf('.') !== -1) field = field.substring(0, field.indexOf('.')); // 293\n                        //\n                        // record the field we are trying to change                                                               //\n                        if (!_.contains(fields, field)) fields.push(field); // 297\n                      }); // 299\n                    } // 300\n              }); // 301\n              //\n              var findOptions = { transform: null }; // 303\n              if (!self._validators.fetchAllFields) {\n                // 304\n                findOptions.fields = {}; // 305\n                _.each(self._validators.fetch, function (fieldName) {\n                  // 306\n                  findOptions.fields[fieldName] = 1; // 307\n                }); // 308\n              } // 309\n              //\n              var doc = self._collection.findOne(selector, findOptions); // 311\n              if (!doc) // none satisfied!                                                                                    // 312\n                return 0; // 313\n              //\n              // call user validators.                                                                                        //\n              // Any deny returns true means denied.                                                                          //\n              if (_.any(self._validators.update.deny, function (validator) {\n                // 317\n                var factoriedDoc = transformDoc(validator, doc); // 318\n                return validator(userId, factoriedDoc, fields, mutator); // 319\n              })) {\n                  // 323\n                  throw new Meteor.Error(403, \"Access denied\"); // 324\n                } // 325\n              // Any allow returns true means proceed. Throw error if they all fail.                                          //\n              if (_.all(self._validators.update.allow, function (validator) {\n                // 327\n                var factoriedDoc = transformDoc(validator, doc); // 328\n                return !validator(userId, factoriedDoc, fields, mutator); // 329\n              })) {\n                  // 333\n                  throw new Meteor.Error(403, \"Access denied\"); // 334\n                } // 335\n              //\n              options._forbidReplace = true; // 337\n              //\n              // Back when we supported arbitrary client-provided selectors, we actually                                      //\n              // rewrote the selector to include an _id clause before passing to Mongo to                                     //\n              // avoid races, but since selector is guaranteed to already just be an ID, we                                   //\n              // don't have to any more.                                                                                      //\n              //\n              return self._collection.update.call(self._collection, selector, mutator, options); // 344\n            }; // 346\n            //\n            // Only allow these operations in validated updates. Specifically                                                 //\n            // whitelist operations, rather than blacklist, so new complex                                                    //\n            // operations that are added aren't automatically allowed. A complex                                              //\n            // operation is one that does more than just modify its target                                                    //\n            // field. For now this contains all update operations except '$rename'.                                           //\n            // http://docs.mongodb.org/manual/reference/operators/#update                                                     //\n            var ALLOWED_UPDATE_OPERATIONS = { // 354\n              $inc: 1, $set: 1, $unset: 1, $addToSet: 1, $pop: 1, $pullAll: 1, $pull: 1, // 355\n              $pushAll: 1, $push: 1, $bit: 1 // 356\n            }; // 354\n            //\n            // Simulate a mongo `remove` operation while validating access control                                            //\n            // rules. See #ValidatedChange                                                                                    //\n            CollectionPrototype._validatedRemove = function (userId, selector) {\n              // 361\n              var self = this; // 362\n              //\n              var findOptions = { transform: null }; // 364\n              if (!self._validators.fetchAllFields) {\n                // 365\n                findOptions.fields = {}; // 366\n                _.each(self._validators.fetch, function (fieldName) {\n                  // 367\n                  findOptions.fields[fieldName] = 1; // 368\n                }); // 369\n              } // 370\n              //\n              var doc = self._collection.findOne(selector, findOptions); // 372\n              if (!doc) return 0; // 373\n              //\n              // call user validators.                                                                                        //\n              // Any deny returns true means denied.                                                                          //\n              if (_.any(self._validators.remove.deny, function (validator) {\n                // 378\n                return validator(userId, transformDoc(validator, doc)); // 379\n              })) {\n                  // 380\n                  throw new Meteor.Error(403, \"Access denied\"); // 381\n                } // 382\n              // Any allow returns true means proceed. Throw error if they all fail.                                          //\n              if (_.all(self._validators.remove.allow, function (validator) {\n                // 384\n                return !validator(userId, transformDoc(validator, doc)); // 385\n              })) {\n                  // 386\n                  throw new Meteor.Error(403, \"Access denied\"); // 387\n                } // 388\n              //\n              // Back when we supported arbitrary client-provided selectors, we actually                                      //\n              // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to                                  //\n              // Mongo to avoid races, but since selector is guaranteed to already just be                                    //\n              // an ID, we don't have to any more.                                                                            //\n              //\n              return self._collection.remove.call(self._collection, selector); // 395\n            }; // 396\n            //\n            CollectionPrototype._callMutatorMethod = function _callMutatorMethod(name, args, callback) {\n              // 398\n              if (Meteor.isClient && !callback && !alreadyInSimulation()) {\n                // 399\n                // Client can't block, so it can't report errors by exception,                                                //\n                // only by callback. If they forget the callback, give them a                                                 //\n                // default one that logs the error, so they aren't totally                                                    //\n                // baffled if their writes don't work because their database is                                               //\n                // down.                                                                                                      //\n                // Don't give a default callback in simulation, because inside stubs we                                       //\n                // want to return the results from the local collection immediately and                                       //\n                // not force a callback.                                                                                      //\n                callback = function callback(err) {\n                  // 408\n                  if (err) Meteor._debug(name + \" failed: \" + (err.reason || err.stack)); // 409\n                }; // 411\n              } // 412\n              //\n              // For two out of three mutator methods, the first argument is a selector                                       //\n              var firstArgIsSelector = name === \"update\" || name === \"remove\"; // 415\n              if (firstArgIsSelector && !alreadyInSimulation()) {\n                // 416\n                // If we're about to actually send an RPC, we should throw an error if                                        //\n                // this is a non-ID selector, because the mutation methods only allow                                         //\n                // single-ID selectors. (If we don't throw here, we'll see flicker.)                                          //\n                throwIfSelectorIsNotId(args[0], name); // 420\n              } // 421\n              //\n              var mutatorMethodName = this._prefix + name; // 423\n              return this._connection.apply(mutatorMethodName, args, { returnStubValue: true }, callback); // 424\n            }; // 426\n            //\n            function transformDoc(validator, doc) {\n              // 428\n              if (validator.transform) return validator.transform(doc); // 429\n              return doc; // 431\n            } // 432\n            //\n            function docToValidate(validator, doc, generatedId) {\n              // 434\n              var ret = doc; // 435\n              if (validator.transform) {\n                // 436\n                ret = EJSON.clone(doc); // 437\n                // If you set a server-side transform on your collection, then you don't get                                  //\n                // to tell the difference between \"client specified the ID\" and \"server                                       //\n                // generated the ID\", because transforms expect to get _id.  If you want to                                   //\n                // do that check, you can do it with a specific                                                               //\n                // `C.allow({insert: f, transform: null})` validator.                                                         //\n                if (generatedId !== null) {\n                  // 443\n                  ret._id = generatedId; // 444\n                } // 445\n                ret = validator.transform(ret); // 446\n              } // 447\n              return ret; // 448\n            } // 449\n            //\n            function addValidator(collection, allowOrDeny, options) {\n              // 451\n              // validate keys                                                                                                //\n              var VALID_KEYS = ['insert', 'update', 'remove', 'fetch', 'transform']; // 453\n              _.each(_.keys(options), function (key) {\n                // 454\n                if (!_.contains(VALID_KEYS, key)) throw new Error(allowOrDeny + \": Invalid key: \" + key); // 455\n              }); // 457\n              //\n              collection._restricted = true; // 459\n              //\n              _.each(['insert', 'update', 'remove'], function (name) {\n                // 461\n                if (options.hasOwnProperty(name)) {\n                  // 462\n                  if (!(options[name] instanceof Function)) {\n                    // 463\n                    throw new Error(allowOrDeny + \": Value for `\" + name + \"` must be a function\"); // 464\n                  } // 465\n                  //\n                  // If the transform is specified at all (including as 'null') in this                                       //\n                  // call, then take that; otherwise, take the transform from the                                             //\n                  // collection.                                                                                              //\n                  if (options.transform === undefined) {\n                    // 470\n                    options[name].transform = collection._transform; // already wrapped                                       // 471\n                  } else {\n                      // 472\n                      options[name].transform = LocalCollection.wrapTransform(options.transform); // 473\n                    } // 475\n                  //\n                  collection._validators[name][allowOrDeny].push(options[name]); // 477\n                } // 478\n              }); // 479\n              //\n              // Only update the fetch fields if we're passed things that affect                                              //\n              // fetching. This way allow({}) and allow({insert: f}) don't result in                                          //\n              // setting fetchAllFields                                                                                       //\n              if (options.update || options.remove || options.fetch) {\n                // 484\n                if (options.fetch && !(options.fetch instanceof Array)) {\n                  // 485\n                  throw new Error(allowOrDeny + \": Value for `fetch` must be an array\"); // 486\n                } // 487\n                collection._updateFetch(options.fetch); // 488\n              } // 489\n            } // 490\n            //\n            function throwIfSelectorIsNotId(selector, methodName) {\n              // 492\n              if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n                // 493\n                throw new Meteor.Error(403, \"Not permitted. Untrusted code may only \" + methodName + \" documents by ID.\"); // 494\n              } // 497\n            }; // 498\n            //\n            // Determine if we are in a DDP method simulation                                                                 //\n            function alreadyInSimulation() {\n              // 501\n              var enclosing = DDP._CurrentInvocation.get(); // 502\n              return enclosing && enclosing.isSimulation; // 503\n            } // 504\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          } } } } }, { \"extensions\": [\".js\", \".json\"] });\n  require(\"./node_modules/meteor/allow-deny/allow-deny.js\");\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package['allow-deny'] = {}, {\n    AllowDeny: AllowDeny\n  });\n})();\n\n//# sourceMappingURL=allow-deny.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/allow-deny.js"],"names":[],"mappings":"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","file":"/bundle/programs/server/packages/allow-deny.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar _ = Package.underscore._;\nvar LocalCollection = Package.minimongo.LocalCollection;\nvar Minimongo = Package.minimongo.Minimongo;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar EJSON = Package.ejson.EJSON;\nvar DDP = Package['ddp-client'].DDP;\nvar DDPServer = Package['ddp-server'].DDPServer;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Buffer = Package.modules.Buffer;\nvar process = Package.modules.process;\nvar Symbol = Package['ecmascript-runtime'].Symbol;\nvar Map = Package['ecmascript-runtime'].Map;\nvar Set = Package['ecmascript-runtime'].Set;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar AllowDeny;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"allow-deny\":{\"allow-deny.js\":function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// packages/allow-deny/allow-deny.js                                                                              //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\n///                                                                                                               //\n/// Remote methods and access control.                                                                            //\n///                                                                                                               //\n                                                                                                                  //\n// Restrict default mutators on collection. allow() and deny() take the                                           //\n// same options:                                                                                                  //\n//                                                                                                                //\n// options.insert {Function(userId, doc)}                                                                         //\n//   return true to allow/deny adding this document                                                               //\n//                                                                                                                //\n// options.update {Function(userId, docs, fields, modifier)}                                                      //\n//   return true to allow/deny updating these documents.                                                          //\n//   `fields` is passed as an array of fields that are to be modified                                             //\n//                                                                                                                //\n// options.remove {Function(userId, docs)}                                                                        //\n//   return true to allow/deny removing these documents                                                           //\n//                                                                                                                //\n// options.fetch {Array}                                                                                          //\n//   Fields to fetch for these validators. If any call to allow or deny                                           //\n//   does not have this option then all fields are loaded.                                                        //\n//                                                                                                                //\n// allow and deny can be called multiple times. The validators are                                                //\n// evaluated as follows:                                                                                          //\n// - If neither deny() nor allow() has been called on the collection,                                             //\n//   then the request is allowed if and only if the \"insecure\" smart                                              //\n//   package is in use.                                                                                           //\n// - Otherwise, if any deny() function returns true, the request is denied.                                       //\n// - Otherwise, if any allow() function returns true, the request is allowed.                                     //\n// - Otherwise, the request is denied.                                                                            //\n//                                                                                                                //\n// Meteor may call your deny() and allow() functions in any order, and may not                                    //\n// call all of them if it is able to make a decision without calling them all                                     //\n// (so don't include side effects).                                                                               //\n                                                                                                                  //\nAllowDeny = {                                                                                                     // 35\n  CollectionPrototype: {}                                                                                         // 36\n};                                                                                                                // 35\n                                                                                                                  //\n// In the `mongo` package, we will extend Mongo.Collection.prototype with these                                   //\n// methods                                                                                                        //\nvar CollectionPrototype = AllowDeny.CollectionPrototype;                                                          // 41\n                                                                                                                  //\n/**                                                                                                               //\n * @summary Allow users to write directly to this collection from client code, subject to limitations you define.\n * @locus Server                                                                                                  //\n * @method allow                                                                                                  //\n * @memberOf Mongo.Collection                                                                                     //\n * @instance                                                                                                      //\n * @param {Object} options                                                                                        //\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be allowed.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */                                                                                                               //\nCollectionPrototype.allow = function (options) {                                                                  // 54\n  addValidator(this, 'allow', options);                                                                           // 55\n};                                                                                                                // 56\n                                                                                                                  //\n/**                                                                                                               //\n * @summary Override `allow` rules.                                                                               //\n * @locus Server                                                                                                  //\n * @method deny                                                                                                   //\n * @memberOf Mongo.Collection                                                                                     //\n * @instance                                                                                                      //\n * @param {Object} options                                                                                        //\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be denied, even if an [allow](#allow) rule says otherwise.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */                                                                                                               //\nCollectionPrototype.deny = function (options) {                                                                   // 69\n  addValidator(this, 'deny', options);                                                                            // 70\n};                                                                                                                // 71\n                                                                                                                  //\nCollectionPrototype._defineMutationMethods = function (options) {                                                 // 73\n  var self = this;                                                                                                // 74\n  options = options || {};                                                                                        // 75\n                                                                                                                  //\n  // set to true once we call any allow or deny methods. If true, use                                             //\n  // allow/deny semantics. If false, use insecure mode semantics.                                                 //\n  self._restricted = false;                                                                                       // 79\n                                                                                                                  //\n  // Insecure mode (default to allowing writes). Defaults to 'undefined' which                                    //\n  // means insecure iff the insecure package is loaded. This property can be                                      //\n  // overriden by tests or packages wishing to change insecure mode behavior of                                   //\n  // their collections.                                                                                           //\n  self._insecure = undefined;                                                                                     // 85\n                                                                                                                  //\n  self._validators = {                                                                                            // 87\n    insert: { allow: [], deny: [] },                                                                              // 88\n    update: { allow: [], deny: [] },                                                                              // 89\n    remove: { allow: [], deny: [] },                                                                              // 90\n    upsert: { allow: [], deny: [] }, // dummy arrays; can't set these!                                            // 91\n    fetch: [],                                                                                                    // 92\n    fetchAllFields: false                                                                                         // 93\n  };                                                                                                              // 87\n                                                                                                                  //\n  if (!self._name) return; // anonymous collection                                                                // 96\n                                                                                                                  //\n  // XXX Think about method namespacing. Maybe methods should be                                                  //\n  // \"Meteor:Mongo:insert/NAME\"?                                                                                  //\n  self._prefix = '/' + self._name + '/';                                                                          // 101\n                                                                                                                  //\n  // Mutation Methods                                                                                             //\n  // Minimongo on the server gets no stubs; instead, by default                                                   //\n  // it wait()s until its result is ready, yielding.                                                              //\n  // This matches the behavior of macromongo on the server better.                                                //\n  // XXX see #MeteorServerNull                                                                                    //\n  if (self._connection && (self._connection === Meteor.server || Meteor.isClient)) {                              // 108\n    (function () {                                                                                                // 108\n      var m = {};                                                                                                 // 109\n                                                                                                                  //\n      _.each(['insert', 'update', 'remove'], function (method) {                                                  // 111\n        var methodName = self._prefix + method;                                                                   // 112\n                                                                                                                  //\n        if (options.useExisting) {                                                                                // 114\n          var handlerPropName = Meteor.isClient ? '_methodHandlers' : 'method_handlers';                          // 115\n          // Do not try to create additional methods if this has already been called.                             //\n          // (Otherwise the .methods() call below will throw an error.)                                           //\n          if (self._connection[handlerPropName] && typeof self._connection[handlerPropName][methodName] === 'function') return;\n        }                                                                                                         // 120\n                                                                                                                  //\n        m[methodName] = function () /* ... */{                                                                    // 122\n          // All the methods do their own validation, instead of using check().                                   //\n          check(arguments, [Match.Any]);                                                                          // 124\n          var args = _.toArray(arguments);                                                                        // 125\n          try {                                                                                                   // 126\n            // For an insert, if the client didn't specify an _id, generate one                                   //\n            // now; because this uses DDP.randomStream, it will be consistent with                                //\n            // what the client generated. We generate it now rather than later so                                 //\n            // that if (eg) an allow/deny rule does an insert to the same                                         //\n            // collection (not that it really should), the generated _id will                                     //\n            // still be the first use of the stream and will be consistent.                                       //\n            //                                                                                                    //\n            // However, we don't actually stick the _id onto the document yet,                                    //\n            // because we want allow/deny rules to be able to differentiate                                       //\n            // between arbitrary client-specified _id fields and merely                                           //\n            // client-controlled-via-randomSeed fields.                                                           //\n            var generatedId = null;                                                                               // 138\n            if (method === \"insert\" && !_.has(args[0], '_id')) {                                                  // 139\n              generatedId = self._makeNewID();                                                                    // 140\n            }                                                                                                     // 141\n                                                                                                                  //\n            if (this.isSimulation) {                                                                              // 143\n              // In a client simulation, you can do any mutation (even with a                                     //\n              // complex selector).                                                                               //\n              if (generatedId !== null) args[0]._id = generatedId;                                                // 146\n              return self._collection[method].apply(self._collection, args);                                      // 148\n            }                                                                                                     // 150\n                                                                                                                  //\n            // This is the server receiving a method call from the client.                                        //\n                                                                                                                  //\n            // We don't allow arbitrary selectors in mutations from the client: only                              //\n            // single-ID selectors.                                                                               //\n            if (method !== 'insert') throwIfSelectorIsNotId(args[0], method);                                     // 156\n                                                                                                                  //\n            if (self._restricted) {                                                                               // 159\n              // short circuit if there is no way it will pass.                                                   //\n              if (self._validators[method].allow.length === 0) {                                                  // 161\n                throw new Meteor.Error(403, \"Access denied. No allow validators set on restricted \" + \"collection for method '\" + method + \"'.\");\n              }                                                                                                   // 165\n                                                                                                                  //\n              var validatedMethodName = '_validated' + method.charAt(0).toUpperCase() + method.slice(1);          // 167\n              args.unshift(this.userId);                                                                          // 169\n              method === 'insert' && args.push(generatedId);                                                      // 170\n              return self[validatedMethodName].apply(self, args);                                                 // 171\n            } else if (self._isInsecure()) {                                                                      // 172\n              if (generatedId !== null) args[0]._id = generatedId;                                                // 173\n              // In insecure mode, allow any mutation (with a simple selector).                                   //\n              // XXX This is kind of bogus.  Instead of blindly passing whatever                                  //\n              //     we get from the network to this function, we should actually                                 //\n              //     know the correct arguments for the function and pass just                                    //\n              //     them.  For example, if you have an extraneous extra null                                     //\n              //     argument and this is Mongo on the server, the .wrapAsync'd                                   //\n              //     functions like update will get confused and pass the                                         //\n              //     \"fut.resolver()\" in the wrong slot, where _update will never                                 //\n              //     invoke it. Bam, broken DDP connection.  Probably should just                                 //\n              //     take this whole method and write it three times, invoking                                    //\n              //     helpers for the common code.                                                                 //\n              return self._collection[method].apply(self._collection, args);                                      // 186\n            } else {                                                                                              // 187\n              // In secure mode, if we haven't called allow or deny, then nothing                                 //\n              // is permitted.                                                                                    //\n              throw new Meteor.Error(403, \"Access denied\");                                                       // 190\n            }                                                                                                     // 191\n          } catch (e) {                                                                                           // 192\n            if (e.name === 'MongoError' || e.name === 'MinimongoError') {                                         // 193\n              throw new Meteor.Error(409, e.toString());                                                          // 194\n            } else {                                                                                              // 195\n              throw e;                                                                                            // 196\n            }                                                                                                     // 197\n          }                                                                                                       // 198\n        };                                                                                                        // 199\n      });                                                                                                         // 200\n                                                                                                                  //\n      self._connection.methods(m);                                                                                // 202\n    })();                                                                                                         // 108\n  }                                                                                                               // 203\n};                                                                                                                // 204\n                                                                                                                  //\nCollectionPrototype._updateFetch = function (fields) {                                                            // 206\n  var self = this;                                                                                                // 207\n                                                                                                                  //\n  if (!self._validators.fetchAllFields) {                                                                         // 209\n    if (fields) {                                                                                                 // 210\n      self._validators.fetch = _.union(self._validators.fetch, fields);                                           // 211\n    } else {                                                                                                      // 212\n      self._validators.fetchAllFields = true;                                                                     // 213\n      // clear fetch just to make sure we don't accidentally read it                                              //\n      self._validators.fetch = null;                                                                              // 215\n    }                                                                                                             // 216\n  }                                                                                                               // 217\n};                                                                                                                // 218\n                                                                                                                  //\nCollectionPrototype._isInsecure = function () {                                                                   // 220\n  var self = this;                                                                                                // 221\n  if (self._insecure === undefined) return !!Package.insecure;                                                    // 222\n  return self._insecure;                                                                                          // 224\n};                                                                                                                // 225\n                                                                                                                  //\nCollectionPrototype._validatedInsert = function (userId, doc, generatedId) {                                      // 227\n  var self = this;                                                                                                // 229\n                                                                                                                  //\n  // call user validators.                                                                                        //\n  // Any deny returns true means denied.                                                                          //\n  if (_.any(self._validators.insert.deny, function (validator) {                                                  // 233\n    return validator(userId, docToValidate(validator, doc, generatedId));                                         // 234\n  })) {                                                                                                           // 235\n    throw new Meteor.Error(403, \"Access denied\");                                                                 // 236\n  }                                                                                                               // 237\n  // Any allow returns true means proceed. Throw error if they all fail.                                          //\n  if (_.all(self._validators.insert.allow, function (validator) {                                                 // 239\n    return !validator(userId, docToValidate(validator, doc, generatedId));                                        // 240\n  })) {                                                                                                           // 241\n    throw new Meteor.Error(403, \"Access denied\");                                                                 // 242\n  }                                                                                                               // 243\n                                                                                                                  //\n  // If we generated an ID above, insert it now: after the validation, but                                        //\n  // before actually inserting.                                                                                   //\n  if (generatedId !== null) doc._id = generatedId;                                                                // 247\n                                                                                                                  //\n  self._collection.insert.call(self._collection, doc);                                                            // 250\n};                                                                                                                // 251\n                                                                                                                  //\n// Simulate a mongo `update` operation while validating that the access                                           //\n// control rules set by calls to `allow/deny` are satisfied. If all                                               //\n// pass, rewrite the mongo operation to use $in to set the list of                                                //\n// document ids to change ##ValidatedChange                                                                       //\nCollectionPrototype._validatedUpdate = function (userId, selector, mutator, options) {                            // 257\n  var self = this;                                                                                                // 259\n                                                                                                                  //\n  check(mutator, Object);                                                                                         // 261\n                                                                                                                  //\n  options = _.clone(options) || {};                                                                               // 263\n                                                                                                                  //\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) throw new Error(\"validated update should be of a single ID\");\n                                                                                                                  //\n  // We don't support upserts because they don't fit nicely into allow/deny                                       //\n  // rules.                                                                                                       //\n  if (options.upsert) throw new Meteor.Error(403, \"Access denied. Upserts not \" + \"allowed in a restricted collection.\");\n                                                                                                                  //\n  var noReplaceError = \"Access denied. In a restricted collection you can only\" + \" update documents, not replace them. Use a Mongo update operator, such \" + \"as '$set'.\";\n                                                                                                                  //\n  // compute modified fields                                                                                      //\n  var fields = [];                                                                                                // 279\n  if (_.isEmpty(mutator)) {                                                                                       // 280\n    throw new Meteor.Error(403, noReplaceError);                                                                  // 281\n  }                                                                                                               // 282\n  _.each(mutator, function (params, op) {                                                                         // 283\n    if (op.charAt(0) !== '$') {                                                                                   // 284\n      throw new Meteor.Error(403, noReplaceError);                                                                // 285\n    } else if (!_.has(ALLOWED_UPDATE_OPERATIONS, op)) {                                                           // 286\n      throw new Meteor.Error(403, \"Access denied. Operator \" + op + \" not allowed in a restricted collection.\");  // 287\n    } else {                                                                                                      // 289\n      _.each(_.keys(params), function (field) {                                                                   // 290\n        // treat dotted fields as if they are replacing their                                                     //\n        // top-level part                                                                                         //\n        if (field.indexOf('.') !== -1) field = field.substring(0, field.indexOf('.'));                            // 293\n                                                                                                                  //\n        // record the field we are trying to change                                                               //\n        if (!_.contains(fields, field)) fields.push(field);                                                       // 297\n      });                                                                                                         // 299\n    }                                                                                                             // 300\n  });                                                                                                             // 301\n                                                                                                                  //\n  var findOptions = { transform: null };                                                                          // 303\n  if (!self._validators.fetchAllFields) {                                                                         // 304\n    findOptions.fields = {};                                                                                      // 305\n    _.each(self._validators.fetch, function (fieldName) {                                                         // 306\n      findOptions.fields[fieldName] = 1;                                                                          // 307\n    });                                                                                                           // 308\n  }                                                                                                               // 309\n                                                                                                                  //\n  var doc = self._collection.findOne(selector, findOptions);                                                      // 311\n  if (!doc) // none satisfied!                                                                                    // 312\n    return 0;                                                                                                     // 313\n                                                                                                                  //\n  // call user validators.                                                                                        //\n  // Any deny returns true means denied.                                                                          //\n  if (_.any(self._validators.update.deny, function (validator) {                                                  // 317\n    var factoriedDoc = transformDoc(validator, doc);                                                              // 318\n    return validator(userId, factoriedDoc, fields, mutator);                                                      // 319\n  })) {                                                                                                           // 323\n    throw new Meteor.Error(403, \"Access denied\");                                                                 // 324\n  }                                                                                                               // 325\n  // Any allow returns true means proceed. Throw error if they all fail.                                          //\n  if (_.all(self._validators.update.allow, function (validator) {                                                 // 327\n    var factoriedDoc = transformDoc(validator, doc);                                                              // 328\n    return !validator(userId, factoriedDoc, fields, mutator);                                                     // 329\n  })) {                                                                                                           // 333\n    throw new Meteor.Error(403, \"Access denied\");                                                                 // 334\n  }                                                                                                               // 335\n                                                                                                                  //\n  options._forbidReplace = true;                                                                                  // 337\n                                                                                                                  //\n  // Back when we supported arbitrary client-provided selectors, we actually                                      //\n  // rewrote the selector to include an _id clause before passing to Mongo to                                     //\n  // avoid races, but since selector is guaranteed to already just be an ID, we                                   //\n  // don't have to any more.                                                                                      //\n                                                                                                                  //\n  return self._collection.update.call(self._collection, selector, mutator, options);                              // 344\n};                                                                                                                // 346\n                                                                                                                  //\n// Only allow these operations in validated updates. Specifically                                                 //\n// whitelist operations, rather than blacklist, so new complex                                                    //\n// operations that are added aren't automatically allowed. A complex                                              //\n// operation is one that does more than just modify its target                                                    //\n// field. For now this contains all update operations except '$rename'.                                           //\n// http://docs.mongodb.org/manual/reference/operators/#update                                                     //\nvar ALLOWED_UPDATE_OPERATIONS = {                                                                                 // 354\n  $inc: 1, $set: 1, $unset: 1, $addToSet: 1, $pop: 1, $pullAll: 1, $pull: 1,                                      // 355\n  $pushAll: 1, $push: 1, $bit: 1                                                                                  // 356\n};                                                                                                                // 354\n                                                                                                                  //\n// Simulate a mongo `remove` operation while validating access control                                            //\n// rules. See #ValidatedChange                                                                                    //\nCollectionPrototype._validatedRemove = function (userId, selector) {                                              // 361\n  var self = this;                                                                                                // 362\n                                                                                                                  //\n  var findOptions = { transform: null };                                                                          // 364\n  if (!self._validators.fetchAllFields) {                                                                         // 365\n    findOptions.fields = {};                                                                                      // 366\n    _.each(self._validators.fetch, function (fieldName) {                                                         // 367\n      findOptions.fields[fieldName] = 1;                                                                          // 368\n    });                                                                                                           // 369\n  }                                                                                                               // 370\n                                                                                                                  //\n  var doc = self._collection.findOne(selector, findOptions);                                                      // 372\n  if (!doc) return 0;                                                                                             // 373\n                                                                                                                  //\n  // call user validators.                                                                                        //\n  // Any deny returns true means denied.                                                                          //\n  if (_.any(self._validators.remove.deny, function (validator) {                                                  // 378\n    return validator(userId, transformDoc(validator, doc));                                                       // 379\n  })) {                                                                                                           // 380\n    throw new Meteor.Error(403, \"Access denied\");                                                                 // 381\n  }                                                                                                               // 382\n  // Any allow returns true means proceed. Throw error if they all fail.                                          //\n  if (_.all(self._validators.remove.allow, function (validator) {                                                 // 384\n    return !validator(userId, transformDoc(validator, doc));                                                      // 385\n  })) {                                                                                                           // 386\n    throw new Meteor.Error(403, \"Access denied\");                                                                 // 387\n  }                                                                                                               // 388\n                                                                                                                  //\n  // Back when we supported arbitrary client-provided selectors, we actually                                      //\n  // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to                                  //\n  // Mongo to avoid races, but since selector is guaranteed to already just be                                    //\n  // an ID, we don't have to any more.                                                                            //\n                                                                                                                  //\n  return self._collection.remove.call(self._collection, selector);                                                // 395\n};                                                                                                                // 396\n                                                                                                                  //\nCollectionPrototype._callMutatorMethod = function _callMutatorMethod(name, args, callback) {                      // 398\n  if (Meteor.isClient && !callback && !alreadyInSimulation()) {                                                   // 399\n    // Client can't block, so it can't report errors by exception,                                                //\n    // only by callback. If they forget the callback, give them a                                                 //\n    // default one that logs the error, so they aren't totally                                                    //\n    // baffled if their writes don't work because their database is                                               //\n    // down.                                                                                                      //\n    // Don't give a default callback in simulation, because inside stubs we                                       //\n    // want to return the results from the local collection immediately and                                       //\n    // not force a callback.                                                                                      //\n    callback = function callback(err) {                                                                           // 408\n      if (err) Meteor._debug(name + \" failed: \" + (err.reason || err.stack));                                     // 409\n    };                                                                                                            // 411\n  }                                                                                                               // 412\n                                                                                                                  //\n  // For two out of three mutator methods, the first argument is a selector                                       //\n  var firstArgIsSelector = name === \"update\" || name === \"remove\";                                                // 415\n  if (firstArgIsSelector && !alreadyInSimulation()) {                                                             // 416\n    // If we're about to actually send an RPC, we should throw an error if                                        //\n    // this is a non-ID selector, because the mutation methods only allow                                         //\n    // single-ID selectors. (If we don't throw here, we'll see flicker.)                                          //\n    throwIfSelectorIsNotId(args[0], name);                                                                        // 420\n  }                                                                                                               // 421\n                                                                                                                  //\n  var mutatorMethodName = this._prefix + name;                                                                    // 423\n  return this._connection.apply(mutatorMethodName, args, { returnStubValue: true }, callback);                    // 424\n};                                                                                                                // 426\n                                                                                                                  //\nfunction transformDoc(validator, doc) {                                                                           // 428\n  if (validator.transform) return validator.transform(doc);                                                       // 429\n  return doc;                                                                                                     // 431\n}                                                                                                                 // 432\n                                                                                                                  //\nfunction docToValidate(validator, doc, generatedId) {                                                             // 434\n  var ret = doc;                                                                                                  // 435\n  if (validator.transform) {                                                                                      // 436\n    ret = EJSON.clone(doc);                                                                                       // 437\n    // If you set a server-side transform on your collection, then you don't get                                  //\n    // to tell the difference between \"client specified the ID\" and \"server                                       //\n    // generated the ID\", because transforms expect to get _id.  If you want to                                   //\n    // do that check, you can do it with a specific                                                               //\n    // `C.allow({insert: f, transform: null})` validator.                                                         //\n    if (generatedId !== null) {                                                                                   // 443\n      ret._id = generatedId;                                                                                      // 444\n    }                                                                                                             // 445\n    ret = validator.transform(ret);                                                                               // 446\n  }                                                                                                               // 447\n  return ret;                                                                                                     // 448\n}                                                                                                                 // 449\n                                                                                                                  //\nfunction addValidator(collection, allowOrDeny, options) {                                                         // 451\n  // validate keys                                                                                                //\n  var VALID_KEYS = ['insert', 'update', 'remove', 'fetch', 'transform'];                                          // 453\n  _.each(_.keys(options), function (key) {                                                                        // 454\n    if (!_.contains(VALID_KEYS, key)) throw new Error(allowOrDeny + \": Invalid key: \" + key);                     // 455\n  });                                                                                                             // 457\n                                                                                                                  //\n  collection._restricted = true;                                                                                  // 459\n                                                                                                                  //\n  _.each(['insert', 'update', 'remove'], function (name) {                                                        // 461\n    if (options.hasOwnProperty(name)) {                                                                           // 462\n      if (!(options[name] instanceof Function)) {                                                                 // 463\n        throw new Error(allowOrDeny + \": Value for `\" + name + \"` must be a function\");                           // 464\n      }                                                                                                           // 465\n                                                                                                                  //\n      // If the transform is specified at all (including as 'null') in this                                       //\n      // call, then take that; otherwise, take the transform from the                                             //\n      // collection.                                                                                              //\n      if (options.transform === undefined) {                                                                      // 470\n        options[name].transform = collection._transform; // already wrapped                                       // 471\n      } else {                                                                                                    // 472\n          options[name].transform = LocalCollection.wrapTransform(options.transform);                             // 473\n        }                                                                                                         // 475\n                                                                                                                  //\n      collection._validators[name][allowOrDeny].push(options[name]);                                              // 477\n    }                                                                                                             // 478\n  });                                                                                                             // 479\n                                                                                                                  //\n  // Only update the fetch fields if we're passed things that affect                                              //\n  // fetching. This way allow({}) and allow({insert: f}) don't result in                                          //\n  // setting fetchAllFields                                                                                       //\n  if (options.update || options.remove || options.fetch) {                                                        // 484\n    if (options.fetch && !(options.fetch instanceof Array)) {                                                     // 485\n      throw new Error(allowOrDeny + \": Value for `fetch` must be an array\");                                      // 486\n    }                                                                                                             // 487\n    collection._updateFetch(options.fetch);                                                                       // 488\n  }                                                                                                               // 489\n}                                                                                                                 // 490\n                                                                                                                  //\nfunction throwIfSelectorIsNotId(selector, methodName) {                                                           // 492\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {                                                  // 493\n    throw new Meteor.Error(403, \"Not permitted. Untrusted code may only \" + methodName + \" documents by ID.\");    // 494\n  }                                                                                                               // 497\n};                                                                                                                // 498\n                                                                                                                  //\n// Determine if we are in a DDP method simulation                                                                 //\nfunction alreadyInSimulation() {                                                                                  // 501\n  var enclosing = DDP._CurrentInvocation.get();                                                                   // 502\n  return enclosing && enclosing.isSimulation;                                                                     // 503\n}                                                                                                                 // 504\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\"extensions\":[\".js\",\".json\"]});\nrequire(\"./node_modules/meteor/allow-deny/allow-deny.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['allow-deny'] = {}, {\n  AllowDeny: AllowDeny\n});\n\n})();\n\n//# sourceMappingURL=allow-deny.js.map\n"]},"hash":"810d80cef08cf6284ec155990e7335d0a3b5aff3"}

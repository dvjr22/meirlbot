{"metadata":{"usedHelpers":["typeof"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/ejson.js","filenameRelative":"/bundle/programs/server/packages/ejson.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/ejson.js.map","sourceFileName":"/bundle/programs/server/packages/ejson.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"ejson"},"ignored":false,"code":"var _typeof;module.import(\"babel-runtime/helpers/typeof\",{\"default\":function(v){_typeof=v}});\n(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var _ = Package.underscore._;\n  var Base64 = Package.base64.Base64;\n\n  /* Package-scope variables */\n  var EJSON, EJSONTest;\n\n  (function () {\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                                   //\n    // packages/ejson/ejson.js                                                                                           //\n    //                                                                                                                   //\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    /**\n     * @namespace\n     * @summary Namespace for EJSON functions\n     */\n    EJSON = {};\n    EJSONTest = {};\n\n    // Custom type interface definition\n    /**\n     * @class CustomType\n     * @instanceName customType\n     * @memberOf EJSON\n     * @summary The interface that a class must satisfy to be able to become an\n     * EJSON custom type via EJSON.addType.\n     */\n\n    /**\n     * @function typeName\n     * @memberOf EJSON.CustomType\n     * @summary Return the tag used to identify this type.  This must match the tag used to register this type with [`EJSON.addType`](#ejson_add_type).\n     * @locus Anywhere\n     * @instance\n     */\n\n    /**\n     * @function toJSONValue\n     * @memberOf EJSON.CustomType\n     * @summary Serialize this instance into a JSON-compatible value.\n     * @locus Anywhere\n     * @instance\n     */\n\n    /**\n     * @function clone\n     * @memberOf EJSON.CustomType\n     * @summary Return a value `r` such that `this.equals(r)` is true, and modifications to `r` do not affect `this` and vice versa.\n     * @locus Anywhere\n     * @instance\n     */\n\n    /**\n     * @function equals\n     * @memberOf EJSON.CustomType\n     * @summary Return `true` if `other` has a value equal to `this`; `false` otherwise.\n     * @locus Anywhere\n     * @param {Object} other Another object to compare this to.\n     * @instance\n     */\n\n    var customTypes = {};\n    // Add a custom type, using a method of your choice to get to and\n    // from a basic JSON-able representation.  The factory argument\n    // is a function of JSON-able --> your object\n    // The type you add must have:\n    // - A toJSONValue() method, so that Meteor can serialize it\n    // - a typeName() method, to show how to look it up in our type table.\n    // It is okay if these methods are monkey-patched on.\n    // EJSON.clone will use toJSONValue and the given factory to produce\n    // a clone, but you may specify a method clone() that will be\n    // used instead.\n    // Similarly, EJSON.equals will use toJSONValue to make comparisons,\n    // but you may provide a method equals() instead.\n    /**\n     * @summary Add a custom datatype to EJSON.\n     * @locus Anywhere\n     * @param {String} name A tag for your custom type; must be unique among custom data types defined in your project, and must match the result of your type's `typeName` method.\n     * @param {Function} factory A function that deserializes a JSON-compatible value into an instance of your type.  This should match the serialization performed by your type's `toJSONValue` method.\n     */\n    EJSON.addType = function (name, factory) {\n      if (_.has(customTypes, name)) throw new Error(\"Type \" + name + \" already present\");\n      customTypes[name] = factory;\n    };\n\n    var isInfOrNan = function isInfOrNan(obj) {\n      return _.isNaN(obj) || obj === Infinity || obj === -Infinity;\n    };\n\n    var builtinConverters = [{ // Date\n      matchJSONValue: function matchJSONValue(obj) {\n        return _.has(obj, '$date') && _.size(obj) === 1;\n      },\n      matchObject: function matchObject(obj) {\n        return obj instanceof Date;\n      },\n      toJSONValue: function toJSONValue(obj) {\n        return { $date: obj.getTime() };\n      },\n      fromJSONValue: function fromJSONValue(obj) {\n        return new Date(obj.$date);\n      }\n    }, { // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'\n      // which we match.)\n      matchJSONValue: function matchJSONValue(obj) {\n        return _.has(obj, '$InfNaN') && _.size(obj) === 1;\n      },\n      matchObject: isInfOrNan,\n      toJSONValue: function toJSONValue(obj) {\n        var sign;\n        if (_.isNaN(obj)) sign = 0;else if (obj === Infinity) sign = 1;else sign = -1;\n        return { $InfNaN: sign };\n      },\n      fromJSONValue: function fromJSONValue(obj) {\n        return obj.$InfNaN / 0;\n      }\n    }, { // Binary\n      matchJSONValue: function matchJSONValue(obj) {\n        return _.has(obj, '$binary') && _.size(obj) === 1;\n      },\n      matchObject: function matchObject(obj) {\n        return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array || obj && _.has(obj, '$Uint8ArrayPolyfill');\n      },\n      toJSONValue: function toJSONValue(obj) {\n        return { $binary: Base64.encode(obj) };\n      },\n      fromJSONValue: function fromJSONValue(obj) {\n        return Base64.decode(obj.$binary);\n      }\n    }, { // Escaping one level\n      matchJSONValue: function matchJSONValue(obj) {\n        return _.has(obj, '$escape') && _.size(obj) === 1;\n      },\n      matchObject: function matchObject(obj) {\n        if (_.isEmpty(obj) || _.size(obj) > 2) {\n          return false;\n        }\n        return _.any(builtinConverters, function (converter) {\n          return converter.matchJSONValue(obj);\n        });\n      },\n      toJSONValue: function toJSONValue(obj) {\n        var newObj = {};\n        _.each(obj, function (value, key) {\n          newObj[key] = EJSON.toJSONValue(value);\n        });\n        return { $escape: newObj };\n      },\n      fromJSONValue: function fromJSONValue(obj) {\n        var newObj = {};\n        _.each(obj.$escape, function (value, key) {\n          newObj[key] = EJSON.fromJSONValue(value);\n        });\n        return newObj;\n      }\n    }, { // Custom\n      matchJSONValue: function matchJSONValue(obj) {\n        return _.has(obj, '$type') && _.has(obj, '$value') && _.size(obj) === 2;\n      },\n      matchObject: function matchObject(obj) {\n        return EJSON._isCustomType(obj);\n      },\n      toJSONValue: function toJSONValue(obj) {\n        var jsonValue = Meteor._noYieldsAllowed(function () {\n          return obj.toJSONValue();\n        });\n        return { $type: obj.typeName(), $value: jsonValue };\n      },\n      fromJSONValue: function fromJSONValue(obj) {\n        var typeName = obj.$type;\n        if (!_.has(customTypes, typeName)) throw new Error(\"Custom EJSON type \" + typeName + \" is not defined\");\n        var converter = customTypes[typeName];\n        return Meteor._noYieldsAllowed(function () {\n          return converter(obj.$value);\n        });\n      }\n    }];\n\n    EJSON._isCustomType = function (obj) {\n      return obj && typeof obj.toJSONValue === 'function' && typeof obj.typeName === 'function' && _.has(customTypes, obj.typeName());\n    };\n\n    EJSON._getTypes = function () {\n      return customTypes;\n    };\n\n    EJSON._getConverters = function () {\n      return builtinConverters;\n    };\n\n    // for both arrays and objects, in-place modification.\n    var adjustTypesToJSONValue = EJSON._adjustTypesToJSONValue = function (obj) {\n      // Is it an atom that we need to adjust?\n      if (obj === null) return null;\n      var maybeChanged = toJSONValueHelper(obj);\n      if (maybeChanged !== undefined) return maybeChanged;\n\n      // Other atoms are unchanged.\n      if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) !== 'object') return obj;\n\n      // Iterate over array or object structure.\n      _.each(obj, function (value, key) {\n        if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== 'object' && value !== undefined && !isInfOrNan(value)) return; // continue\n\n        var changed = toJSONValueHelper(value);\n        if (changed) {\n          obj[key] = changed;\n          return; // on to the next key\n        }\n        // if we get here, value is an object but not adjustable\n        // at this level.  recurse.\n        adjustTypesToJSONValue(value);\n      });\n      return obj;\n    };\n\n    // Either return the JSON-compatible version of the argument, or undefined (if\n    // the item isn't itself replaceable, but maybe some fields in it are)\n    var toJSONValueHelper = function toJSONValueHelper(item) {\n      for (var i = 0; i < builtinConverters.length; i++) {\n        var converter = builtinConverters[i];\n        if (converter.matchObject(item)) {\n          return converter.toJSONValue(item);\n        }\n      }\n      return undefined;\n    };\n\n    /**\n     * @summary Serialize an EJSON-compatible value into its plain JSON representation.\n     * @locus Anywhere\n     * @param {EJSON} val A value to serialize to plain JSON.\n     */\n    EJSON.toJSONValue = function (item) {\n      var changed = toJSONValueHelper(item);\n      if (changed !== undefined) return changed;\n      if ((typeof item === \"undefined\" ? \"undefined\" : _typeof(item)) === 'object') {\n        item = EJSON.clone(item);\n        adjustTypesToJSONValue(item);\n      }\n      return item;\n    };\n\n    // for both arrays and objects. Tries its best to just\n    // use the object you hand it, but may return something\n    // different if the object you hand it itself needs changing.\n    //\n    var adjustTypesFromJSONValue = EJSON._adjustTypesFromJSONValue = function (obj) {\n      if (obj === null) return null;\n      var maybeChanged = fromJSONValueHelper(obj);\n      if (maybeChanged !== obj) return maybeChanged;\n\n      // Other atoms are unchanged.\n      if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) !== 'object') return obj;\n\n      _.each(obj, function (value, key) {\n        if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === 'object') {\n          var changed = fromJSONValueHelper(value);\n          if (value !== changed) {\n            obj[key] = changed;\n            return;\n          }\n          // if we get here, value is an object but not adjustable\n          // at this level.  recurse.\n          adjustTypesFromJSONValue(value);\n        }\n      });\n      return obj;\n    };\n\n    // Either return the argument changed to have the non-json\n    // rep of itself (the Object version) or the argument itself.\n\n    // DOES NOT RECURSE.  For actually getting the fully-changed value, use\n    // EJSON.fromJSONValue\n    var fromJSONValueHelper = function fromJSONValueHelper(value) {\n      if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === 'object' && value !== null) {\n        if (_.size(value) <= 2 && _.all(value, function (v, k) {\n          return typeof k === 'string' && k.substr(0, 1) === '$';\n        })) {\n          for (var i = 0; i < builtinConverters.length; i++) {\n            var converter = builtinConverters[i];\n            if (converter.matchJSONValue(value)) {\n              return converter.fromJSONValue(value);\n            }\n          }\n        }\n      }\n      return value;\n    };\n\n    /**\n     * @summary Deserialize an EJSON value from its plain JSON representation.\n     * @locus Anywhere\n     * @param {JSONCompatible} val A value to deserialize into EJSON.\n     */\n    EJSON.fromJSONValue = function (item) {\n      var changed = fromJSONValueHelper(item);\n      if (changed === item && (typeof item === \"undefined\" ? \"undefined\" : _typeof(item)) === 'object') {\n        item = EJSON.clone(item);\n        adjustTypesFromJSONValue(item);\n        return item;\n      } else {\n        return changed;\n      }\n    };\n\n    /**\n     * @summary Serialize a value to a string.\n    \n    For EJSON values, the serialization fully represents the value. For non-EJSON values, serializes the same way as `JSON.stringify`.\n     * @locus Anywhere\n     * @param {EJSON} val A value to stringify.\n     * @param {Object} [options]\n     * @param {Boolean | Integer | String} options.indent Indents objects and arrays for easy readability.  When `true`, indents by 2 spaces; when an integer, indents by that number of spaces; and when a string, uses the string as the indentation pattern.\n     * @param {Boolean} options.canonical When `true`, stringifies keys in an object in sorted order.\n     */\n    EJSON.stringify = function (item, options) {\n      var json = EJSON.toJSONValue(item);\n      if (options && (options.canonical || options.indent)) {\n        return EJSON._canonicalStringify(json, options);\n      } else {\n        return JSON.stringify(json);\n      }\n    };\n\n    /**\n     * @summary Parse a string into an EJSON value. Throws an error if the string is not valid EJSON.\n     * @locus Anywhere\n     * @param {String} str A string to parse into an EJSON value.\n     */\n    EJSON.parse = function (item) {\n      if (typeof item !== 'string') throw new Error(\"EJSON.parse argument should be a string\");\n      return EJSON.fromJSONValue(JSON.parse(item));\n    };\n\n    /**\n     * @summary Returns true if `x` is a buffer of binary data, as returned from [`EJSON.newBinary`](#ejson_new_binary).\n     * @param {Object} x The variable to check.\n     * @locus Anywhere\n     */\n    EJSON.isBinary = function (obj) {\n      return !!(typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array || obj && obj.$Uint8ArrayPolyfill);\n    };\n\n    /**\n     * @summary Return true if `a` and `b` are equal to each other.  Return false otherwise.  Uses the `equals` method on `a` if present, otherwise performs a deep comparison.\n     * @locus Anywhere\n     * @param {EJSON} a\n     * @param {EJSON} b\n     * @param {Object} [options]\n     * @param {Boolean} options.keyOrderSensitive Compare in key sensitive order, if supported by the JavaScript implementation.  For example, `{a: 1, b: 2}` is equal to `{b: 2, a: 1}` only when `keyOrderSensitive` is `false`.  The default is `false`.\n     */\n    EJSON.equals = function (a, b, options) {\n      var i;\n      var keyOrderSensitive = !!(options && options.keyOrderSensitive);\n      if (a === b) return true;\n      if (_.isNaN(a) && _.isNaN(b)) return true; // This differs from the IEEE spec for NaN equality, b/c we don't want\n      // anything ever with a NaN to be poisoned from becoming equal to anything.\n      if (!a || !b) // if either one is falsy, they'd have to be === to be equal\n        return false;\n      if (!((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === 'object' && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === 'object')) return false;\n      if (a instanceof Date && b instanceof Date) return a.valueOf() === b.valueOf();\n      if (EJSON.isBinary(a) && EJSON.isBinary(b)) {\n        if (a.length !== b.length) return false;\n        for (i = 0; i < a.length; i++) {\n          if (a[i] !== b[i]) return false;\n        }\n        return true;\n      }\n      if (typeof a.equals === 'function') return a.equals(b, options);\n      if (typeof b.equals === 'function') return b.equals(a, options);\n      if (a instanceof Array) {\n        if (!(b instanceof Array)) return false;\n        if (a.length !== b.length) return false;\n        for (i = 0; i < a.length; i++) {\n          if (!EJSON.equals(a[i], b[i], options)) return false;\n        }\n        return true;\n      }\n      // fallback for custom types that don't implement their own equals\n      switch (EJSON._isCustomType(a) + EJSON._isCustomType(b)) {\n        case 1:\n          return false;\n        case 2:\n          return EJSON.equals(EJSON.toJSONValue(a), EJSON.toJSONValue(b));\n      }\n      // fall back to structural equality of objects\n      var ret;\n      if (keyOrderSensitive) {\n        var bKeys = [];\n        _.each(b, function (val, x) {\n          bKeys.push(x);\n        });\n        i = 0;\n        ret = _.all(a, function (val, x) {\n          if (i >= bKeys.length) {\n            return false;\n          }\n          if (x !== bKeys[i]) {\n            return false;\n          }\n          if (!EJSON.equals(val, b[bKeys[i]], options)) {\n            return false;\n          }\n          i++;\n          return true;\n        });\n        return ret && i === bKeys.length;\n      } else {\n        i = 0;\n        ret = _.all(a, function (val, key) {\n          if (!_.has(b, key)) {\n            return false;\n          }\n          if (!EJSON.equals(val, b[key], options)) {\n            return false;\n          }\n          i++;\n          return true;\n        });\n        return ret && _.size(b) === i;\n      }\n    };\n\n    /**\n     * @summary Return a deep copy of `val`.\n     * @locus Anywhere\n     * @param {EJSON} val A value to copy.\n     */\n    EJSON.clone = function (v) {\n      var ret;\n      if ((typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) !== \"object\") return v;\n      if (v === null) return null; // null has typeof \"object\"\n      if (v instanceof Date) return new Date(v.getTime());\n      // RegExps are not really EJSON elements (eg we don't define a serialization\n      // for them), but they're immutable anyway, so we can support them in clone.\n      if (v instanceof RegExp) return v;\n      if (EJSON.isBinary(v)) {\n        ret = EJSON.newBinary(v.length);\n        for (var i = 0; i < v.length; i++) {\n          ret[i] = v[i];\n        }\n        return ret;\n      }\n      // XXX: Use something better than underscore's isArray\n      if (_.isArray(v) || _.isArguments(v)) {\n        // For some reason, _.map doesn't work in this context on Opera (weird test\n        // failures).\n        ret = [];\n        for (i = 0; i < v.length; i++) {\n          ret[i] = EJSON.clone(v[i]);\n        }return ret;\n      }\n      // handle general user-defined typed Objects if they have a clone method\n      if (typeof v.clone === 'function') {\n        return v.clone();\n      }\n      // handle other custom types\n      if (EJSON._isCustomType(v)) {\n        return EJSON.fromJSONValue(EJSON.clone(EJSON.toJSONValue(v)), true);\n      }\n      // handle other objects\n      ret = {};\n      _.each(v, function (value, key) {\n        ret[key] = EJSON.clone(value);\n      });\n      return ret;\n    };\n\n    /**\n     * @summary Allocate a new buffer of binary data that EJSON can serialize.\n     * @locus Anywhere\n     * @param {Number} size The number of bytes of binary data to allocate.\n     */\n    // EJSON.newBinary is the public documented API for this functionality,\n    // but the implementation is in the 'base64' package to avoid\n    // introducing a circular dependency. (If the implementation were here,\n    // then 'base64' would have to use EJSON.newBinary, and 'ejson' would\n    // also have to use 'base64'.)\n    EJSON.newBinary = Base64.newBinary;\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  (function () {\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                                   //\n    // packages/ejson/stringify.js                                                                                       //\n    //                                                                                                                   //\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // Based on json2.js from https://github.com/douglascrockford/JSON-js\n    //\n    //    json2.js\n    //    2012-10-08\n    //\n    //    Public Domain.\n    //\n    //    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    function quote(string) {\n      return JSON.stringify(string);\n    }\n\n    var str = function str(key, holder, singleIndent, outerIndent, canonical) {\n\n      // Produce a string from holder[key].\n\n      var i; // The loop counter.\n      var k; // The member key.\n      var v; // The member value.\n      var length;\n      var innerIndent = outerIndent;\n      var partial;\n      var value = holder[key];\n\n      // What happens next depends on the value's type.\n\n      switch (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) {\n        case 'string':\n          return quote(value);\n        case 'number':\n          // JSON numbers must be finite. Encode non-finite numbers as null.\n          return isFinite(value) ? String(value) : 'null';\n        case 'boolean':\n          return String(value);\n        // If the type is 'object', we might be dealing with an object or an array or\n        // null.\n        case 'object':\n          // Due to a specification blunder in ECMAScript, typeof null is 'object',\n          // so watch out for that case.\n          if (!value) {\n            return 'null';\n          }\n          // Make an array to hold the partial results of stringifying this object value.\n          innerIndent = outerIndent + singleIndent;\n          partial = [];\n\n          // Is the value an array?\n          if (_.isArray(value) || _.isArguments(value)) {\n\n            // The value is an array. Stringify every element. Use null as a placeholder\n            // for non-JSON values.\n\n            length = value.length;\n            for (i = 0; i < length; i += 1) {\n              partial[i] = str(i, value, singleIndent, innerIndent, canonical) || 'null';\n            }\n\n            // Join all of the elements together, separated with commas, and wrap them in\n            // brackets.\n\n            if (partial.length === 0) {\n              v = '[]';\n            } else if (innerIndent) {\n              v = '[\\n' + innerIndent + partial.join(',\\n' + innerIndent) + '\\n' + outerIndent + ']';\n            } else {\n              v = '[' + partial.join(',') + ']';\n            }\n            return v;\n          }\n\n          // Iterate through all of the keys in the object.\n          var keys = _.keys(value);\n          if (canonical) keys = keys.sort();\n          _.each(keys, function (k) {\n            v = str(k, value, singleIndent, innerIndent, canonical);\n            if (v) {\n              partial.push(quote(k) + (innerIndent ? ': ' : ':') + v);\n            }\n          });\n\n          // Join all of the member texts together, separated with commas,\n          // and wrap them in braces.\n\n          if (partial.length === 0) {\n            v = '{}';\n          } else if (innerIndent) {\n            v = '{\\n' + innerIndent + partial.join(',\\n' + innerIndent) + '\\n' + outerIndent + '}';\n          } else {\n            v = '{' + partial.join(',') + '}';\n          }\n          return v;\n      }\n    };\n\n    // If the JSON object does not yet have a stringify method, give it one.\n\n    EJSON._canonicalStringify = function (value, options) {\n      // Make a fake root object containing our value under the key of ''.\n      // Return the result of stringifying the value.\n      options = _.extend({\n        indent: \"\",\n        canonical: false\n      }, options);\n      if (options.indent === true) {\n        options.indent = \"  \";\n      } else if (typeof options.indent === 'number') {\n        var newIndent = \"\";\n        for (var i = 0; i < options.indent; i++) {\n          newIndent += ' ';\n        }\n        options.indent = newIndent;\n      }\n      return str('', { '': value }, options.indent, \"\", options.canonical);\n    };\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package.ejson = {}, {\n    EJSON: EJSON,\n    EJSONTest: EJSONTest\n  });\n})();\n\n//# sourceMappingURL=ejson.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/ejson.js"],"names":[],"mappings":"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","file":"/bundle/programs/server/packages/ejson.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar Base64 = Package.base64.Base64;\n\n/* Package-scope variables */\nvar EJSON, EJSONTest;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ejson/ejson.js                                                                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n/**\n * @namespace\n * @summary Namespace for EJSON functions\n */\nEJSON = {};\nEJSONTest = {};\n\n\n\n// Custom type interface definition\n/**\n * @class CustomType\n * @instanceName customType\n * @memberOf EJSON\n * @summary The interface that a class must satisfy to be able to become an\n * EJSON custom type via EJSON.addType.\n */\n\n/**\n * @function typeName\n * @memberOf EJSON.CustomType\n * @summary Return the tag used to identify this type.  This must match the tag used to register this type with [`EJSON.addType`](#ejson_add_type).\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function toJSONValue\n * @memberOf EJSON.CustomType\n * @summary Serialize this instance into a JSON-compatible value.\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function clone\n * @memberOf EJSON.CustomType\n * @summary Return a value `r` such that `this.equals(r)` is true, and modifications to `r` do not affect `this` and vice versa.\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function equals\n * @memberOf EJSON.CustomType\n * @summary Return `true` if `other` has a value equal to `this`; `false` otherwise.\n * @locus Anywhere\n * @param {Object} other Another object to compare this to.\n * @instance\n */\n\n\nvar customTypes = {};\n// Add a custom type, using a method of your choice to get to and\n// from a basic JSON-able representation.  The factory argument\n// is a function of JSON-able --> your object\n// The type you add must have:\n// - A toJSONValue() method, so that Meteor can serialize it\n// - a typeName() method, to show how to look it up in our type table.\n// It is okay if these methods are monkey-patched on.\n// EJSON.clone will use toJSONValue and the given factory to produce\n// a clone, but you may specify a method clone() that will be\n// used instead.\n// Similarly, EJSON.equals will use toJSONValue to make comparisons,\n// but you may provide a method equals() instead.\n/**\n * @summary Add a custom datatype to EJSON.\n * @locus Anywhere\n * @param {String} name A tag for your custom type; must be unique among custom data types defined in your project, and must match the result of your type's `typeName` method.\n * @param {Function} factory A function that deserializes a JSON-compatible value into an instance of your type.  This should match the serialization performed by your type's `toJSONValue` method.\n */\nEJSON.addType = function (name, factory) {\n  if (_.has(customTypes, name))\n    throw new Error(\"Type \" + name + \" already present\");\n  customTypes[name] = factory;\n};\n\nvar isInfOrNan = function (obj) {\n  return _.isNaN(obj) || obj === Infinity || obj === -Infinity;\n};\n\nvar builtinConverters = [\n  { // Date\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$date') && _.size(obj) === 1;\n    },\n    matchObject: function (obj) {\n      return obj instanceof Date;\n    },\n    toJSONValue: function (obj) {\n      return {$date: obj.getTime()};\n    },\n    fromJSONValue: function (obj) {\n      return new Date(obj.$date);\n    }\n  },\n  { // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'\n    // which we match.)\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$InfNaN') && _.size(obj) === 1;\n    },\n    matchObject: isInfOrNan,\n    toJSONValue: function (obj) {\n      var sign;\n      if (_.isNaN(obj))\n        sign = 0;\n      else if (obj === Infinity)\n        sign = 1;\n      else\n        sign = -1;\n      return {$InfNaN: sign};\n    },\n    fromJSONValue: function (obj) {\n      return obj.$InfNaN/0;\n    }\n  },\n  { // Binary\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$binary') && _.size(obj) === 1;\n    },\n    matchObject: function (obj) {\n      return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array\n        || (obj && _.has(obj, '$Uint8ArrayPolyfill'));\n    },\n    toJSONValue: function (obj) {\n      return {$binary: Base64.encode(obj)};\n    },\n    fromJSONValue: function (obj) {\n      return Base64.decode(obj.$binary);\n    }\n  },\n  { // Escaping one level\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$escape') && _.size(obj) === 1;\n    },\n    matchObject: function (obj) {\n      if (_.isEmpty(obj) || _.size(obj) > 2) {\n        return false;\n      }\n      return _.any(builtinConverters, function (converter) {\n        return converter.matchJSONValue(obj);\n      });\n    },\n    toJSONValue: function (obj) {\n      var newObj = {};\n      _.each(obj, function (value, key) {\n        newObj[key] = EJSON.toJSONValue(value);\n      });\n      return {$escape: newObj};\n    },\n    fromJSONValue: function (obj) {\n      var newObj = {};\n      _.each(obj.$escape, function (value, key) {\n        newObj[key] = EJSON.fromJSONValue(value);\n      });\n      return newObj;\n    }\n  },\n  { // Custom\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$type') && _.has(obj, '$value') && _.size(obj) === 2;\n    },\n    matchObject: function (obj) {\n      return EJSON._isCustomType(obj);\n    },\n    toJSONValue: function (obj) {\n      var jsonValue = Meteor._noYieldsAllowed(function () {\n        return obj.toJSONValue();\n      });\n      return {$type: obj.typeName(), $value: jsonValue};\n    },\n    fromJSONValue: function (obj) {\n      var typeName = obj.$type;\n      if (!_.has(customTypes, typeName))\n        throw new Error(\"Custom EJSON type \" + typeName + \" is not defined\");\n      var converter = customTypes[typeName];\n      return Meteor._noYieldsAllowed(function () {\n        return converter(obj.$value);\n      });\n    }\n  }\n];\n\nEJSON._isCustomType = function (obj) {\n  return obj &&\n    typeof obj.toJSONValue === 'function' &&\n    typeof obj.typeName === 'function' &&\n    _.has(customTypes, obj.typeName());\n};\n\nEJSON._getTypes = function () {\n  return customTypes;\n};\n\nEJSON._getConverters = function () {\n  return builtinConverters;\n};\n\n// for both arrays and objects, in-place modification.\nvar adjustTypesToJSONValue =\nEJSON._adjustTypesToJSONValue = function (obj) {\n  // Is it an atom that we need to adjust?\n  if (obj === null)\n    return null;\n  var maybeChanged = toJSONValueHelper(obj);\n  if (maybeChanged !== undefined)\n    return maybeChanged;\n\n  // Other atoms are unchanged.\n  if (typeof obj !== 'object')\n    return obj;\n\n  // Iterate over array or object structure.\n  _.each(obj, function (value, key) {\n    if (typeof value !== 'object' && value !== undefined &&\n        !isInfOrNan(value))\n      return; // continue\n\n    var changed = toJSONValueHelper(value);\n    if (changed) {\n      obj[key] = changed;\n      return; // on to the next key\n    }\n    // if we get here, value is an object but not adjustable\n    // at this level.  recurse.\n    adjustTypesToJSONValue(value);\n  });\n  return obj;\n};\n\n// Either return the JSON-compatible version of the argument, or undefined (if\n// the item isn't itself replaceable, but maybe some fields in it are)\nvar toJSONValueHelper = function (item) {\n  for (var i = 0; i < builtinConverters.length; i++) {\n    var converter = builtinConverters[i];\n    if (converter.matchObject(item)) {\n      return converter.toJSONValue(item);\n    }\n  }\n  return undefined;\n};\n\n/**\n * @summary Serialize an EJSON-compatible value into its plain JSON representation.\n * @locus Anywhere\n * @param {EJSON} val A value to serialize to plain JSON.\n */\nEJSON.toJSONValue = function (item) {\n  var changed = toJSONValueHelper(item);\n  if (changed !== undefined)\n    return changed;\n  if (typeof item === 'object') {\n    item = EJSON.clone(item);\n    adjustTypesToJSONValue(item);\n  }\n  return item;\n};\n\n// for both arrays and objects. Tries its best to just\n// use the object you hand it, but may return something\n// different if the object you hand it itself needs changing.\n//\nvar adjustTypesFromJSONValue =\nEJSON._adjustTypesFromJSONValue = function (obj) {\n  if (obj === null)\n    return null;\n  var maybeChanged = fromJSONValueHelper(obj);\n  if (maybeChanged !== obj)\n    return maybeChanged;\n\n  // Other atoms are unchanged.\n  if (typeof obj !== 'object')\n    return obj;\n\n  _.each(obj, function (value, key) {\n    if (typeof value === 'object') {\n      var changed = fromJSONValueHelper(value);\n      if (value !== changed) {\n        obj[key] = changed;\n        return;\n      }\n      // if we get here, value is an object but not adjustable\n      // at this level.  recurse.\n      adjustTypesFromJSONValue(value);\n    }\n  });\n  return obj;\n};\n\n// Either return the argument changed to have the non-json\n// rep of itself (the Object version) or the argument itself.\n\n// DOES NOT RECURSE.  For actually getting the fully-changed value, use\n// EJSON.fromJSONValue\nvar fromJSONValueHelper = function (value) {\n  if (typeof value === 'object' && value !== null) {\n    if (_.size(value) <= 2\n        && _.all(value, function (v, k) {\n          return typeof k === 'string' && k.substr(0, 1) === '$';\n        })) {\n      for (var i = 0; i < builtinConverters.length; i++) {\n        var converter = builtinConverters[i];\n        if (converter.matchJSONValue(value)) {\n          return converter.fromJSONValue(value);\n        }\n      }\n    }\n  }\n  return value;\n};\n\n/**\n * @summary Deserialize an EJSON value from its plain JSON representation.\n * @locus Anywhere\n * @param {JSONCompatible} val A value to deserialize into EJSON.\n */\nEJSON.fromJSONValue = function (item) {\n  var changed = fromJSONValueHelper(item);\n  if (changed === item && typeof item === 'object') {\n    item = EJSON.clone(item);\n    adjustTypesFromJSONValue(item);\n    return item;\n  } else {\n    return changed;\n  }\n};\n\n/**\n * @summary Serialize a value to a string.\n\nFor EJSON values, the serialization fully represents the value. For non-EJSON values, serializes the same way as `JSON.stringify`.\n * @locus Anywhere\n * @param {EJSON} val A value to stringify.\n * @param {Object} [options]\n * @param {Boolean | Integer | String} options.indent Indents objects and arrays for easy readability.  When `true`, indents by 2 spaces; when an integer, indents by that number of spaces; and when a string, uses the string as the indentation pattern.\n * @param {Boolean} options.canonical When `true`, stringifies keys in an object in sorted order.\n */\nEJSON.stringify = function (item, options) {\n  var json = EJSON.toJSONValue(item);\n  if (options && (options.canonical || options.indent)) {\n    return EJSON._canonicalStringify(json, options);\n  } else {\n    return JSON.stringify(json);\n  }\n};\n\n/**\n * @summary Parse a string into an EJSON value. Throws an error if the string is not valid EJSON.\n * @locus Anywhere\n * @param {String} str A string to parse into an EJSON value.\n */\nEJSON.parse = function (item) {\n  if (typeof item !== 'string')\n    throw new Error(\"EJSON.parse argument should be a string\");\n  return EJSON.fromJSONValue(JSON.parse(item));\n};\n\n/**\n * @summary Returns true if `x` is a buffer of binary data, as returned from [`EJSON.newBinary`](#ejson_new_binary).\n * @param {Object} x The variable to check.\n * @locus Anywhere\n */\nEJSON.isBinary = function (obj) {\n  return !!((typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array) ||\n    (obj && obj.$Uint8ArrayPolyfill));\n};\n\n/**\n * @summary Return true if `a` and `b` are equal to each other.  Return false otherwise.  Uses the `equals` method on `a` if present, otherwise performs a deep comparison.\n * @locus Anywhere\n * @param {EJSON} a\n * @param {EJSON} b\n * @param {Object} [options]\n * @param {Boolean} options.keyOrderSensitive Compare in key sensitive order, if supported by the JavaScript implementation.  For example, `{a: 1, b: 2}` is equal to `{b: 2, a: 1}` only when `keyOrderSensitive` is `false`.  The default is `false`.\n */\nEJSON.equals = function (a, b, options) {\n  var i;\n  var keyOrderSensitive = !!(options && options.keyOrderSensitive);\n  if (a === b)\n    return true;\n  if (_.isNaN(a) && _.isNaN(b))\n    return true; // This differs from the IEEE spec for NaN equality, b/c we don't want\n                 // anything ever with a NaN to be poisoned from becoming equal to anything.\n  if (!a || !b) // if either one is falsy, they'd have to be === to be equal\n    return false;\n  if (!(typeof a === 'object' && typeof b === 'object'))\n    return false;\n  if (a instanceof Date && b instanceof Date)\n    return a.valueOf() === b.valueOf();\n  if (EJSON.isBinary(a) && EJSON.isBinary(b)) {\n    if (a.length !== b.length)\n      return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i])\n        return false;\n    }\n    return true;\n  }\n  if (typeof (a.equals) === 'function')\n    return a.equals(b, options);\n  if (typeof (b.equals) === 'function')\n    return b.equals(a, options);\n  if (a instanceof Array) {\n    if (!(b instanceof Array))\n      return false;\n    if (a.length !== b.length)\n      return false;\n    for (i = 0; i < a.length; i++) {\n      if (!EJSON.equals(a[i], b[i], options))\n        return false;\n    }\n    return true;\n  }\n  // fallback for custom types that don't implement their own equals\n  switch (EJSON._isCustomType(a) + EJSON._isCustomType(b)) {\n    case 1: return false;\n    case 2: return EJSON.equals(EJSON.toJSONValue(a), EJSON.toJSONValue(b));\n  }\n  // fall back to structural equality of objects\n  var ret;\n  if (keyOrderSensitive) {\n    var bKeys = [];\n    _.each(b, function (val, x) {\n        bKeys.push(x);\n    });\n    i = 0;\n    ret = _.all(a, function (val, x) {\n      if (i >= bKeys.length) {\n        return false;\n      }\n      if (x !== bKeys[i]) {\n        return false;\n      }\n      if (!EJSON.equals(val, b[bKeys[i]], options)) {\n        return false;\n      }\n      i++;\n      return true;\n    });\n    return ret && i === bKeys.length;\n  } else {\n    i = 0;\n    ret = _.all(a, function (val, key) {\n      if (!_.has(b, key)) {\n        return false;\n      }\n      if (!EJSON.equals(val, b[key], options)) {\n        return false;\n      }\n      i++;\n      return true;\n    });\n    return ret && _.size(b) === i;\n  }\n};\n\n/**\n * @summary Return a deep copy of `val`.\n * @locus Anywhere\n * @param {EJSON} val A value to copy.\n */\nEJSON.clone = function (v) {\n  var ret;\n  if (typeof v !== \"object\")\n    return v;\n  if (v === null)\n    return null; // null has typeof \"object\"\n  if (v instanceof Date)\n    return new Date(v.getTime());\n  // RegExps are not really EJSON elements (eg we don't define a serialization\n  // for them), but they're immutable anyway, so we can support them in clone.\n  if (v instanceof RegExp)\n    return v;\n  if (EJSON.isBinary(v)) {\n    ret = EJSON.newBinary(v.length);\n    for (var i = 0; i < v.length; i++) {\n      ret[i] = v[i];\n    }\n    return ret;\n  }\n  // XXX: Use something better than underscore's isArray\n  if (_.isArray(v) || _.isArguments(v)) {\n    // For some reason, _.map doesn't work in this context on Opera (weird test\n    // failures).\n    ret = [];\n    for (i = 0; i < v.length; i++)\n      ret[i] = EJSON.clone(v[i]);\n    return ret;\n  }\n  // handle general user-defined typed Objects if they have a clone method\n  if (typeof v.clone === 'function') {\n    return v.clone();\n  }\n  // handle other custom types\n  if (EJSON._isCustomType(v)) {\n    return EJSON.fromJSONValue(EJSON.clone(EJSON.toJSONValue(v)), true);\n  }\n  // handle other objects\n  ret = {};\n  _.each(v, function (value, key) {\n    ret[key] = EJSON.clone(value);\n  });\n  return ret;\n};\n\n/**\n * @summary Allocate a new buffer of binary data that EJSON can serialize.\n * @locus Anywhere\n * @param {Number} size The number of bytes of binary data to allocate.\n */\n// EJSON.newBinary is the public documented API for this functionality,\n// but the implementation is in the 'base64' package to avoid\n// introducing a circular dependency. (If the implementation were here,\n// then 'base64' would have to use EJSON.newBinary, and 'ejson' would\n// also have to use 'base64'.)\nEJSON.newBinary = Base64.newBinary;\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ejson/stringify.js                                                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Based on json2.js from https://github.com/douglascrockford/JSON-js\n//\n//    json2.js\n//    2012-10-08\n//\n//    Public Domain.\n//\n//    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\nfunction quote(string) {\n  return JSON.stringify(string);\n}\n\nvar str = function (key, holder, singleIndent, outerIndent, canonical) {\n\n  // Produce a string from holder[key].\n\n  var i;          // The loop counter.\n  var k;          // The member key.\n  var v;          // The member value.\n  var length;\n  var innerIndent = outerIndent;\n  var partial;\n  var value = holder[key];\n\n  // What happens next depends on the value's type.\n\n  switch (typeof value) {\n  case 'string':\n    return quote(value);\n  case 'number':\n    // JSON numbers must be finite. Encode non-finite numbers as null.\n    return isFinite(value) ? String(value) : 'null';\n  case 'boolean':\n    return String(value);\n  // If the type is 'object', we might be dealing with an object or an array or\n  // null.\n  case 'object':\n    // Due to a specification blunder in ECMAScript, typeof null is 'object',\n    // so watch out for that case.\n    if (!value) {\n      return 'null';\n    }\n    // Make an array to hold the partial results of stringifying this object value.\n    innerIndent = outerIndent + singleIndent;\n    partial = [];\n\n    // Is the value an array?\n    if (_.isArray(value) || _.isArguments(value)) {\n\n      // The value is an array. Stringify every element. Use null as a placeholder\n      // for non-JSON values.\n\n      length = value.length;\n      for (i = 0; i < length; i += 1) {\n        partial[i] = str(i, value, singleIndent, innerIndent, canonical) || 'null';\n      }\n\n      // Join all of the elements together, separated with commas, and wrap them in\n      // brackets.\n\n      if (partial.length === 0) {\n        v = '[]';\n      } else if (innerIndent) {\n        v = '[\\n' + innerIndent + partial.join(',\\n' + innerIndent) + '\\n' + outerIndent + ']';\n      } else {\n        v = '[' + partial.join(',') + ']';\n      }\n      return v;\n    }\n\n\n    // Iterate through all of the keys in the object.\n    var keys = _.keys(value);\n    if (canonical)\n      keys = keys.sort();\n    _.each(keys, function (k) {\n      v = str(k, value, singleIndent, innerIndent, canonical);\n      if (v) {\n        partial.push(quote(k) + (innerIndent ? ': ' : ':') + v);\n      }\n    });\n\n\n    // Join all of the member texts together, separated with commas,\n    // and wrap them in braces.\n\n    if (partial.length === 0) {\n      v = '{}';\n    } else if (innerIndent) {\n      v = '{\\n' + innerIndent + partial.join(',\\n' + innerIndent) + '\\n' + outerIndent + '}';\n    } else {\n      v = '{' + partial.join(',') + '}';\n    }\n    return v;\n  }\n}\n\n// If the JSON object does not yet have a stringify method, give it one.\n\nEJSON._canonicalStringify = function (value, options) {\n  // Make a fake root object containing our value under the key of ''.\n  // Return the result of stringifying the value.\n  options = _.extend({\n    indent: \"\",\n    canonical: false\n  }, options);\n  if (options.indent === true) {\n    options.indent = \"  \";\n  } else if (typeof options.indent === 'number') {\n    var newIndent = \"\";\n    for (var i = 0; i < options.indent; i++) {\n      newIndent += ' ';\n    }\n    options.indent = newIndent;\n  }\n  return str('', {'': value}, options.indent, \"\", options.canonical);\n};\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package.ejson = {}, {\n  EJSON: EJSON,\n  EJSONTest: EJSONTest\n});\n\n})();\n\n//# sourceMappingURL=ejson.js.map\n"]},"hash":"1fe61a9a1b9871ffcc2a639bbdb84b5c8feeef9a"}

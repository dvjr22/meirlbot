{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/retry.js","filenameRelative":"/bundle/programs/server/packages/retry.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/retry.js.map","sourceFileName":"/bundle/programs/server/packages/retry.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"retry"},"ignored":false,"code":"(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var _ = Package.underscore._;\n  var Random = Package.random.Random;\n\n  /* Package-scope variables */\n  var Retry;\n\n  (function () {\n\n    /////////////////////////////////////////////////////////////////////////////\n    //                                                                         //\n    // packages/retry/retry.js                                                 //\n    //                                                                         //\n    /////////////////////////////////////////////////////////////////////////////\n    //\n    // Retry logic with an exponential backoff.\n    //\n    // options:\n    //  baseTimeout: time for initial reconnect attempt (ms).\n    //  exponent: exponential factor to increase timeout each attempt.\n    //  maxTimeout: maximum time between retries (ms).\n    //  minCount: how many times to reconnect \"instantly\".\n    //  minTimeout: time to wait for the first `minCount` retries (ms).\n    //  fuzz: factor to randomize retry times by (to avoid retry storms).\n\n    Retry = function Retry(options) {\n      var self = this;\n      _.extend(self, _.defaults(_.clone(options || {}), {\n        baseTimeout: 1000, // 1 second\n        exponent: 2.2,\n        // The default is high-ish to ensure a server can recover from a\n        // failure caused by load.\n        maxTimeout: 5 * 60000, // 5 minutes\n        minTimeout: 10,\n        minCount: 2,\n        fuzz: 0.5 // +- 25%\n      }));\n      self.retryTimer = null;\n    };\n\n    _.extend(Retry.prototype, {\n\n      // Reset a pending retry, if any.\n      clear: function clear() {\n        var self = this;\n        if (self.retryTimer) clearTimeout(self.retryTimer);\n        self.retryTimer = null;\n      },\n\n      // Calculate how long to wait in milliseconds to retry, based on the\n      // `count` of which retry this is.\n      _timeout: function _timeout(count) {\n        var self = this;\n\n        if (count < self.minCount) return self.minTimeout;\n\n        var timeout = Math.min(self.maxTimeout, self.baseTimeout * Math.pow(self.exponent, count));\n        // fuzz the timeout randomly, to avoid reconnect storms when a\n        // server goes down.\n        timeout = timeout * (Random.fraction() * self.fuzz + (1 - self.fuzz / 2));\n        return timeout;\n      },\n\n      // Call `fn` after a delay, based on the `count` of which retry this is.\n      retryLater: function retryLater(count, fn) {\n        var self = this;\n        var timeout = self._timeout(count);\n        if (self.retryTimer) clearTimeout(self.retryTimer);\n        self.retryTimer = Meteor.setTimeout(fn, timeout);\n        return timeout;\n      }\n\n    });\n\n    /////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package.retry = {}, {\n    Retry: Retry\n  });\n})();\n\n//# sourceMappingURL=retry.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/retry.js"],"names":[],"mappings":"AAAA,CAAC,YAAY;;;AAGb,MAAI,SAAS,QAAQ,MAAR,CAAe,MAA5B;AACA,MAAI,SAAS,QAAQ,MAAR,CAAe,MAA5B;AACA,MAAI,YAAY,QAAQ,MAAR,CAAe,SAA/B;AACA,MAAI,IAAI,QAAQ,UAAR,CAAmB,CAA3B;AACA,MAAI,SAAS,QAAQ,MAAR,CAAe,MAA5B;;;AAGA,MAAI,KAAJ;;AAEA,GAAC,YAAU;;;;;;;;;;;;;;;;;;AAkBX,YAAQ,eAAU,OAAV,EAAmB;AACzB,UAAI,OAAO,IAAX;AACA,QAAE,MAAF,CAAS,IAAT,EAAe,EAAE,QAAF,CAAW,EAAE,KAAF,CAAQ,WAAW,EAAnB,CAAX,EAAmC;AAChD,qBAAa,IADmC,E;AAEhD,kBAAU,GAFsC;;;AAKhD,oBAAY,IAAI,KALgC,E;AAMhD,oBAAY,EANoC;AAOhD,kBAAU,CAPsC;AAQhD,cAAM,G;AAR0C,OAAnC,CAAf;AAUA,WAAK,UAAL,GAAkB,IAAlB;AACD,KAbD;;AAeA,MAAE,MAAF,CAAS,MAAM,SAAf,EAA0B;;;AAGxB,aAAO,iBAAY;AACjB,YAAI,OAAO,IAAX;AACA,YAAI,KAAK,UAAT,EACE,aAAa,KAAK,UAAlB;AACF,aAAK,UAAL,GAAkB,IAAlB;AACD,OARuB;;;;AAYxB,gBAAU,kBAAU,KAAV,EAAiB;AACzB,YAAI,OAAO,IAAX;;AAEA,YAAI,QAAQ,KAAK,QAAjB,EACE,OAAO,KAAK,UAAZ;;AAEF,YAAI,UAAU,KAAK,GAAL,CACZ,KAAK,UADO,EAEZ,KAAK,WAAL,GAAmB,KAAK,GAAL,CAAS,KAAK,QAAd,EAAwB,KAAxB,CAFP,CAAd;;;AAKA,kBAAU,WAAY,OAAO,QAAP,KAAoB,KAAK,IAA1B,IACC,IAAI,KAAK,IAAL,GAAU,CADf,CAAX,CAAV;AAEA,eAAO,OAAP;AACD,OA1BuB;;;AA6BxB,kBAAY,oBAAU,KAAV,EAAiB,EAAjB,EAAqB;AAC/B,YAAI,OAAO,IAAX;AACA,YAAI,UAAU,KAAK,QAAL,CAAc,KAAd,CAAd;AACA,YAAI,KAAK,UAAT,EACE,aAAa,KAAK,UAAlB;AACF,aAAK,UAAL,GAAkB,OAAO,UAAP,CAAkB,EAAlB,EAAsB,OAAtB,CAAlB;AACA,eAAO,OAAP;AACD;;AApCuB,KAA1B;;;AA0CC,GA3ED,EA2EG,IA3EH,CA2EQ,IA3ER;;;AA+EA,MAAI,OAAO,OAAP,KAAmB,WAAvB,EAAoC,UAAU,EAAV;AACpC,GAAC,UAAU,GAAV,EAAe,OAAf,EAAwB;AACvB,SAAK,IAAI,CAAT,IAAc,OAAd;AACG,WAAK,GAAN,KAAe,IAAI,CAAJ,IAAS,QAAQ,CAAR,CAAxB;AADF;AAED,GAHD,EAGG,QAAQ,KAAR,GAAgB,EAHnB,EAGuB;AACrB,WAAO;AADc,GAHvB;AAOC,CAnGD","file":"/bundle/programs/server/packages/retry.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar Random = Package.random.Random;\n\n/* Package-scope variables */\nvar Retry;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////\n//                                                                         //\n// packages/retry/retry.js                                                 //\n//                                                                         //\n/////////////////////////////////////////////////////////////////////////////\n                                                                           //\n// Retry logic with an exponential backoff.\n//\n// options:\n//  baseTimeout: time for initial reconnect attempt (ms).\n//  exponent: exponential factor to increase timeout each attempt.\n//  maxTimeout: maximum time between retries (ms).\n//  minCount: how many times to reconnect \"instantly\".\n//  minTimeout: time to wait for the first `minCount` retries (ms).\n//  fuzz: factor to randomize retry times by (to avoid retry storms).\n\nRetry = function (options) {\n  var self = this;\n  _.extend(self, _.defaults(_.clone(options || {}), {\n    baseTimeout: 1000, // 1 second\n    exponent: 2.2,\n    // The default is high-ish to ensure a server can recover from a\n    // failure caused by load.\n    maxTimeout: 5 * 60000, // 5 minutes\n    minTimeout: 10,\n    minCount: 2,\n    fuzz: 0.5 // +- 25%\n  }));\n  self.retryTimer = null;\n};\n\n_.extend(Retry.prototype, {\n\n  // Reset a pending retry, if any.\n  clear: function () {\n    var self = this;\n    if (self.retryTimer)\n      clearTimeout(self.retryTimer);\n    self.retryTimer = null;\n  },\n\n  // Calculate how long to wait in milliseconds to retry, based on the\n  // `count` of which retry this is.\n  _timeout: function (count) {\n    var self = this;\n\n    if (count < self.minCount)\n      return self.minTimeout;\n\n    var timeout = Math.min(\n      self.maxTimeout,\n      self.baseTimeout * Math.pow(self.exponent, count));\n    // fuzz the timeout randomly, to avoid reconnect storms when a\n    // server goes down.\n    timeout = timeout * ((Random.fraction() * self.fuzz) +\n                         (1 - self.fuzz/2));\n    return timeout;\n  },\n\n  // Call `fn` after a delay, based on the `count` of which retry this is.\n  retryLater: function (count, fn) {\n    var self = this;\n    var timeout = self._timeout(count);\n    if (self.retryTimer)\n      clearTimeout(self.retryTimer);\n    self.retryTimer = Meteor.setTimeout(fn, timeout);\n    return timeout;\n  }\n\n});\n\n/////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package.retry = {}, {\n  Retry: Retry\n});\n\n})();\n\n//# sourceMappingURL=retry.js.map\n"]},"hash":"a46606abcc9a339eb6793ec4bcbcafe5a9ab7bdf"}

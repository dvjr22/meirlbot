{"metadata":{"usedHelpers":["typeof"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/ddp-client.js","filenameRelative":"/bundle/programs/server/packages/ddp-client.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/ddp-client.js.map","sourceFileName":"/bundle/programs/server/packages/ddp-client.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"ddp-client"},"ignored":false,"code":"var _typeof;module.import('babel-runtime/helpers/typeof',{\"default\":function(v){_typeof=v}});\n(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var check = Package.check.check;\n  var Match = Package.check.Match;\n  var Random = Package.random.Random;\n  var EJSON = Package.ejson.EJSON;\n  var _ = Package.underscore._;\n  var Tracker = Package.tracker.Tracker;\n  var Deps = Package.tracker.Deps;\n  var Retry = Package.retry.Retry;\n  var IdMap = Package['id-map'].IdMap;\n  var DDPCommon = Package['ddp-common'].DDPCommon;\n  var DiffSequence = Package['diff-sequence'].DiffSequence;\n  var MongoID = Package['mongo-id'].MongoID;\n\n  /* Package-scope variables */\n  var DDP, LivedataTest, MongoIDMap, toSockjsUrl, toWebsocketUrl, allConnections;\n\n  (function () {\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                            //\n    // packages/ddp-client/namespace.js                                                                           //\n    //                                                                                                            //\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    /**\n     * @namespace DDP\n     * @summary Namespace for DDP-related methods/classes.\n     */\n    DDP = {};\n    LivedataTest = {};\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  (function () {\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                            //\n    // packages/ddp-client/id_map.js                                                                              //\n    //                                                                                                            //\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    MongoIDMap = function MongoIDMap() {\n      var self = this;\n      IdMap.call(self, MongoID.idStringify, MongoID.idParse);\n    };\n\n    Meteor._inherits(MongoIDMap, IdMap);\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  (function () {\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                            //\n    // packages/ddp-client/stream_client_nodejs.js                                                                //\n    //                                                                                                            //\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // @param endpoint {String} URL to Meteor app\n    //   \"http://subdomain.meteor.com/\" or \"/\" or\n    //   \"ddp+sockjs://foo-**.meteor.com/sockjs\"\n    //\n    // We do some rewriting of the URL to eventually make it \"ws://\" or \"wss://\",\n    // whatever was passed in.  At the very least, what Meteor.absoluteUrl() returns\n    // us should work.\n    //\n    // We don't do any heartbeating. (The logic that did this in sockjs was removed,\n    // because it used a built-in sockjs mechanism. We could do it with WebSocket\n    // ping frames or with DDP-level messages.)\n    LivedataTest.ClientStream = function (endpoint, options) {\n      var self = this;\n      options = options || {};\n\n      self.options = _.extend({\n        retry: true\n      }, options);\n\n      self.client = null; // created in _launchConnection\n      self.endpoint = endpoint;\n\n      self.headers = self.options.headers || {};\n      self.npmFayeOptions = self.options.npmFayeOptions || {};\n\n      self._initCommon(self.options);\n\n      //// Kickoff!\n      self._launchConnection();\n    };\n\n    _.extend(LivedataTest.ClientStream.prototype, {\n\n      // data is a utf8 string. Data sent while not connected is dropped on\n      // the floor, and it is up the user of this API to retransmit lost\n      // messages on 'reset'\n      send: function send(data) {\n        var self = this;\n        if (self.currentStatus.connected) {\n          self.client.send(data);\n        }\n      },\n\n      // Changes where this connection points\n      _changeUrl: function _changeUrl(url) {\n        var self = this;\n        self.endpoint = url;\n      },\n\n      _onConnect: function _onConnect(client) {\n        var self = this;\n\n        if (client !== self.client) {\n          // This connection is not from the last call to _launchConnection.\n          // But _launchConnection calls _cleanup which closes previous connections.\n          // It's our belief that this stifles future 'open' events, but maybe\n          // we are wrong?\n          throw new Error(\"Got open from inactive client \" + !!self.client);\n        }\n\n        if (self._forcedToDisconnect) {\n          // We were asked to disconnect between trying to open the connection and\n          // actually opening it. Let's just pretend this never happened.\n          self.client.close();\n          self.client = null;\n          return;\n        }\n\n        if (self.currentStatus.connected) {\n          // We already have a connection. It must have been the case that we\n          // started two parallel connection attempts (because we wanted to\n          // 'reconnect now' on a hanging connection and we had no way to cancel the\n          // connection attempt.) But this shouldn't happen (similarly to the client\n          // !== self.client check above).\n          throw new Error(\"Two parallel connections?\");\n        }\n\n        self._clearConnectionTimer();\n\n        // update status\n        self.currentStatus.status = \"connected\";\n        self.currentStatus.connected = true;\n        self.currentStatus.retryCount = 0;\n        self.statusChanged();\n\n        // fire resets. This must come after status change so that clients\n        // can call send from within a reset callback.\n        _.each(self.eventCallbacks.reset, function (callback) {\n          callback();\n        });\n      },\n\n      _cleanup: function _cleanup(maybeError) {\n        var self = this;\n\n        self._clearConnectionTimer();\n        if (self.client) {\n          var client = self.client;\n          self.client = null;\n          client.close();\n\n          _.each(self.eventCallbacks.disconnect, function (callback) {\n            callback(maybeError);\n          });\n        }\n      },\n\n      _clearConnectionTimer: function _clearConnectionTimer() {\n        var self = this;\n\n        if (self.connectionTimer) {\n          clearTimeout(self.connectionTimer);\n          self.connectionTimer = null;\n        }\n      },\n\n      _getProxyUrl: function _getProxyUrl(targetUrl) {\n        var self = this;\n        // Similar to code in tools/http-helpers.js.\n        var proxy = process.env.HTTP_PROXY || process.env.http_proxy || null;\n        // if we're going to a secure url, try the https_proxy env variable first.\n        if (targetUrl.match(/^wss:/)) {\n          proxy = process.env.HTTPS_PROXY || process.env.https_proxy || proxy;\n        }\n        return proxy;\n      },\n\n      _launchConnection: function _launchConnection() {\n        var self = this;\n        self._cleanup(); // cleanup the old socket, if there was one.\n\n        // Since server-to-server DDP is still an experimental feature, we only\n        // require the module if we actually create a server-to-server\n        // connection.\n        var FayeWebSocket = Npm.require('faye-websocket');\n        var deflate = Npm.require('permessage-deflate');\n\n        var targetUrl = toWebsocketUrl(self.endpoint);\n        var fayeOptions = {\n          headers: self.headers,\n          extensions: [deflate]\n        };\n        fayeOptions = _.extend(fayeOptions, self.npmFayeOptions);\n        var proxyUrl = self._getProxyUrl(targetUrl);\n        if (proxyUrl) {\n          fayeOptions.proxy = { origin: proxyUrl };\n        };\n\n        // We would like to specify 'ddp' as the subprotocol here. The npm module we\n        // used to use as a client would fail the handshake if we ask for a\n        // subprotocol and the server doesn't send one back (and sockjs doesn't).\n        // Faye doesn't have that behavior; it's unclear from reading RFC 6455 if\n        // Faye is erroneous or not.  So for now, we don't specify protocols.\n        var subprotocols = [];\n\n        var client = self.client = new FayeWebSocket.Client(targetUrl, subprotocols, fayeOptions);\n\n        self._clearConnectionTimer();\n        self.connectionTimer = Meteor.setTimeout(function () {\n          self._lostConnection(new DDP.ConnectionError(\"DDP connection timed out\"));\n        }, self.CONNECT_TIMEOUT);\n\n        self.client.on('open', Meteor.bindEnvironment(function () {\n          return self._onConnect(client);\n        }, \"stream connect callback\"));\n\n        var clientOnIfCurrent = function clientOnIfCurrent(event, description, f) {\n          self.client.on(event, Meteor.bindEnvironment(function () {\n            // Ignore events from any connection we've already cleaned up.\n            if (client !== self.client) return;\n            f.apply(this, arguments);\n          }, description));\n        };\n\n        clientOnIfCurrent('error', 'stream error callback', function (error) {\n          if (!self.options._dontPrintErrors) Meteor._debug(\"stream error\", error.message);\n\n          // Faye's 'error' object is not a JS error (and among other things,\n          // doesn't stringify well). Convert it to one.\n          self._lostConnection(new DDP.ConnectionError(error.message));\n        });\n\n        clientOnIfCurrent('close', 'stream close callback', function () {\n          self._lostConnection();\n        });\n\n        clientOnIfCurrent('message', 'stream message callback', function (message) {\n          // Ignore binary frames, where message.data is a Buffer\n          if (typeof message.data !== \"string\") return;\n\n          _.each(self.eventCallbacks.message, function (callback) {\n            callback(message.data);\n          });\n        });\n      }\n    });\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  (function () {\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                            //\n    // packages/ddp-client/stream_client_common.js                                                                //\n    //                                                                                                            //\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // XXX from Underscore.String (http://epeli.github.com/underscore.string/)\n    var startsWith = function startsWith(str, starts) {\n      return str.length >= starts.length && str.substring(0, starts.length) === starts;\n    };\n    var endsWith = function endsWith(str, ends) {\n      return str.length >= ends.length && str.substring(str.length - ends.length) === ends;\n    };\n\n    // @param url {String} URL to Meteor app, eg:\n    //   \"/\" or \"madewith.meteor.com\" or \"https://foo.meteor.com\"\n    //   or \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"\n    // @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.\n    // for scheme \"http\" and subPath \"sockjs\"\n    //   \"http://subdomain.meteor.com/sockjs\" or \"/sockjs\"\n    //   or \"https://ddp--1234-foo.meteor.com/sockjs\"\n    var translateUrl = function translateUrl(url, newSchemeBase, subPath) {\n      if (!newSchemeBase) {\n        newSchemeBase = \"http\";\n      }\n\n      var ddpUrlMatch = url.match(/^ddp(i?)\\+sockjs:\\/\\//);\n      var httpUrlMatch = url.match(/^http(s?):\\/\\//);\n      var newScheme;\n      if (ddpUrlMatch) {\n        // Remove scheme and split off the host.\n        var urlAfterDDP = url.substr(ddpUrlMatch[0].length);\n        newScheme = ddpUrlMatch[1] === \"i\" ? newSchemeBase : newSchemeBase + \"s\";\n        var slashPos = urlAfterDDP.indexOf('/');\n        var host = slashPos === -1 ? urlAfterDDP : urlAfterDDP.substr(0, slashPos);\n        var rest = slashPos === -1 ? '' : urlAfterDDP.substr(slashPos);\n\n        // In the host (ONLY!), change '*' characters into random digits. This\n        // allows different stream connections to connect to different hostnames\n        // and avoid browser per-hostname connection limits.\n        host = host.replace(/\\*/g, function () {\n          return Math.floor(Random.fraction() * 10);\n        });\n\n        return newScheme + '://' + host + rest;\n      } else if (httpUrlMatch) {\n        newScheme = !httpUrlMatch[1] ? newSchemeBase : newSchemeBase + \"s\";\n        var urlAfterHttp = url.substr(httpUrlMatch[0].length);\n        url = newScheme + \"://\" + urlAfterHttp;\n      }\n\n      // Prefix FQDNs but not relative URLs\n      if (url.indexOf(\"://\") === -1 && !startsWith(url, \"/\")) {\n        url = newSchemeBase + \"://\" + url;\n      }\n\n      // XXX This is not what we should be doing: if I have a site\n      // deployed at \"/foo\", then DDP.connect(\"/\") should actually connect\n      // to \"/\", not to \"/foo\". \"/\" is an absolute path. (Contrast: if\n      // deployed at \"/foo\", it would be reasonable for DDP.connect(\"bar\")\n      // to connect to \"/foo/bar\").\n      //\n      // We should make this properly honor absolute paths rather than\n      // forcing the path to be relative to the site root. Simultaneously,\n      // we should set DDP_DEFAULT_CONNECTION_URL to include the site\n      // root. See also client_convenience.js #RationalizingRelativeDDPURLs\n      url = Meteor._relativeToSiteRootUrl(url);\n\n      if (endsWith(url, \"/\")) return url + subPath;else return url + \"/\" + subPath;\n    };\n\n    toSockjsUrl = function toSockjsUrl(url) {\n      return translateUrl(url, \"http\", \"sockjs\");\n    };\n\n    toWebsocketUrl = function toWebsocketUrl(url) {\n      var ret = translateUrl(url, \"ws\", \"websocket\");\n      return ret;\n    };\n\n    LivedataTest.toSockjsUrl = toSockjsUrl;\n\n    _.extend(LivedataTest.ClientStream.prototype, {\n\n      // Register for callbacks.\n      on: function on(name, callback) {\n        var self = this;\n\n        if (name !== 'message' && name !== 'reset' && name !== 'disconnect') throw new Error(\"unknown event type: \" + name);\n\n        if (!self.eventCallbacks[name]) self.eventCallbacks[name] = [];\n        self.eventCallbacks[name].push(callback);\n      },\n\n      _initCommon: function _initCommon(options) {\n        var self = this;\n        options = options || {};\n\n        //// Constants\n\n        // how long to wait until we declare the connection attempt\n        // failed.\n        self.CONNECT_TIMEOUT = options.connectTimeoutMs || 10000;\n\n        self.eventCallbacks = {}; // name -> [callback]\n\n        self._forcedToDisconnect = false;\n\n        //// Reactive status\n        self.currentStatus = {\n          status: \"connecting\",\n          connected: false,\n          retryCount: 0\n        };\n\n        self.statusListeners = typeof Tracker !== 'undefined' && new Tracker.Dependency();\n        self.statusChanged = function () {\n          if (self.statusListeners) self.statusListeners.changed();\n        };\n\n        //// Retry logic\n        self._retry = new Retry();\n        self.connectionTimer = null;\n      },\n\n      // Trigger a reconnect.\n      reconnect: function reconnect(options) {\n        var self = this;\n        options = options || {};\n\n        if (options.url) {\n          self._changeUrl(options.url);\n        }\n\n        if (options._sockjsOptions) {\n          self.options._sockjsOptions = options._sockjsOptions;\n        }\n\n        if (self.currentStatus.connected) {\n          if (options._force || options.url) {\n            // force reconnect.\n            self._lostConnection(new DDP.ForcedReconnectError());\n          } // else, noop.\n          return;\n        }\n\n        // if we're mid-connection, stop it.\n        if (self.currentStatus.status === \"connecting\") {\n          // Pretend it's a clean close.\n          self._lostConnection();\n        }\n\n        self._retry.clear();\n        self.currentStatus.retryCount -= 1; // don't count manual retries\n        self._retryNow();\n      },\n\n      disconnect: function disconnect(options) {\n        var self = this;\n        options = options || {};\n\n        // Failed is permanent. If we're failed, don't let people go back\n        // online by calling 'disconnect' then 'reconnect'.\n        if (self._forcedToDisconnect) return;\n\n        // If _permanent is set, permanently disconnect a stream. Once a stream\n        // is forced to disconnect, it can never reconnect. This is for\n        // error cases such as ddp version mismatch, where trying again\n        // won't fix the problem.\n        if (options._permanent) {\n          self._forcedToDisconnect = true;\n        }\n\n        self._cleanup();\n        self._retry.clear();\n\n        self.currentStatus = {\n          status: options._permanent ? \"failed\" : \"offline\",\n          connected: false,\n          retryCount: 0\n        };\n\n        if (options._permanent && options._error) self.currentStatus.reason = options._error;\n\n        self.statusChanged();\n      },\n\n      // maybeError is set unless it's a clean protocol-level close.\n      _lostConnection: function _lostConnection(maybeError) {\n        var self = this;\n\n        self._cleanup(maybeError);\n        self._retryLater(maybeError); // sets status. no need to do it here.\n      },\n\n      // fired when we detect that we've gone online. try to reconnect\n      // immediately.\n      _online: function _online() {\n        // if we've requested to be offline by disconnecting, don't reconnect.\n        if (this.currentStatus.status != \"offline\") this.reconnect();\n      },\n\n      _retryLater: function _retryLater(maybeError) {\n        var self = this;\n\n        var timeout = 0;\n        if (self.options.retry || maybeError && maybeError.errorType === \"DDP.ForcedReconnectError\") {\n          timeout = self._retry.retryLater(self.currentStatus.retryCount, _.bind(self._retryNow, self));\n          self.currentStatus.status = \"waiting\";\n          self.currentStatus.retryTime = new Date().getTime() + timeout;\n        } else {\n          self.currentStatus.status = \"failed\";\n          delete self.currentStatus.retryTime;\n        }\n\n        self.currentStatus.connected = false;\n        self.statusChanged();\n      },\n\n      _retryNow: function _retryNow() {\n        var self = this;\n\n        if (self._forcedToDisconnect) return;\n\n        self.currentStatus.retryCount += 1;\n        self.currentStatus.status = \"connecting\";\n        self.currentStatus.connected = false;\n        delete self.currentStatus.retryTime;\n        self.statusChanged();\n\n        self._launchConnection();\n      },\n\n      // Get current status. Reactive.\n      status: function status() {\n        var self = this;\n        if (self.statusListeners) self.statusListeners.depend();\n        return self.currentStatus;\n      }\n    });\n\n    DDP.ConnectionError = Meteor.makeErrorType(\"DDP.ConnectionError\", function (message) {\n      var self = this;\n      self.message = message;\n    });\n\n    DDP.ForcedReconnectError = Meteor.makeErrorType(\"DDP.ForcedReconnectError\", function () {});\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  (function () {\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                            //\n    // packages/ddp-client/livedata_common.js                                                                     //\n    //                                                                                                            //\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    LivedataTest.SUPPORTED_DDP_VERSIONS = DDPCommon.SUPPORTED_DDP_VERSIONS;\n\n    // This is private but it's used in a few places. accounts-base uses\n    // it to get the current user. Meteor.setTimeout and friends clear\n    // it. We can probably find a better way to factor this.\n    DDP._CurrentInvocation = new Meteor.EnvironmentVariable();\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  (function () {\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                            //\n    // packages/ddp-client/random_stream.js                                                                       //\n    //                                                                                                            //\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // Returns the named sequence of pseudo-random values.\n    // The scope will be DDP._CurrentInvocation.get(), so the stream will produce\n    // consistent values for method calls on the client and server.\n    DDP.randomStream = function (name) {\n      var scope = DDP._CurrentInvocation.get();\n      return DDPCommon.RandomStream.get(scope, name);\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  (function () {\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                            //\n    // packages/ddp-client/livedata_connection.js                                                                 //\n    //                                                                                                            //\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    if (Meteor.isServer) {\n      var path = Npm.require('path');\n      var Fiber = Npm.require('fibers');\n      var Future = Npm.require(path.join('fibers', 'future'));\n    }\n\n    // @param url {String|Object} URL to Meteor app,\n    //   or an object as a test hook (see code)\n    // Options:\n    //   reloadWithOutstanding: is it OK to reload if there are outstanding methods?\n    //   headers: extra headers to send on the websockets connection, for\n    //     server-to-server DDP only\n    //   _sockjsOptions: Specifies options to pass through to the sockjs client\n    //   onDDPNegotiationVersionFailure: callback when version negotiation fails.\n    //\n    // XXX There should be a way to destroy a DDP connection, causing all\n    // outstanding method calls to fail.\n    //\n    // XXX Our current way of handling failure and reconnection is great\n    // for an app (where we want to tolerate being disconnected as an\n    // expect state, and keep trying forever to reconnect) but cumbersome\n    // for something like a command line tool that wants to make a\n    // connection, call a method, and print an error if connection\n    // fails. We should have better usability in the latter case (while\n    // still transparently reconnecting if it's just a transient failure\n    // or the server migrating us).\n    var Connection = function Connection(url, options) {\n      var self = this;\n      options = _.extend({\n        onConnected: function onConnected() {},\n        onDDPVersionNegotiationFailure: function onDDPVersionNegotiationFailure(description) {\n          Meteor._debug(description);\n        },\n        heartbeatInterval: 17500,\n        heartbeatTimeout: 15000,\n        npmFayeOptions: {},\n        // These options are only for testing.\n        reloadWithOutstanding: false,\n        supportedDDPVersions: DDPCommon.SUPPORTED_DDP_VERSIONS,\n        retry: true,\n        respondToPings: true,\n        // When updates are coming within this ms interval, batch them together.\n        bufferedWritesInterval: 5,\n        // Flush buffers immediately if writes are happening continuously for more than this many ms.\n        bufferedWritesMaxAge: 500\n      }, options);\n\n      // If set, called when we reconnect, queuing method calls _before_ the\n      // existing outstanding ones. This is the only data member that is part of the\n      // public API!\n      self.onReconnect = null;\n\n      // as a test hook, allow passing a stream instead of a url.\n      if ((typeof url === 'undefined' ? 'undefined' : _typeof(url)) === \"object\") {\n        self._stream = url;\n      } else {\n        self._stream = new LivedataTest.ClientStream(url, {\n          retry: options.retry,\n          headers: options.headers,\n          _sockjsOptions: options._sockjsOptions,\n          // Used to keep some tests quiet, or for other cases in which\n          // the right thing to do with connection errors is to silently\n          // fail (e.g. sending package usage stats). At some point we\n          // should have a real API for handling client-stream-level\n          // errors.\n          _dontPrintErrors: options._dontPrintErrors,\n          connectTimeoutMs: options.connectTimeoutMs,\n          npmFayeOptions: options.npmFayeOptions\n        });\n      }\n\n      self._lastSessionId = null;\n      self._versionSuggestion = null; // The last proposed DDP version.\n      self._version = null; // The DDP version agreed on by client and server.\n      self._stores = {}; // name -> object with methods\n      self._methodHandlers = {}; // name -> func\n      self._nextMethodId = 1;\n      self._supportedDDPVersions = options.supportedDDPVersions;\n\n      self._heartbeatInterval = options.heartbeatInterval;\n      self._heartbeatTimeout = options.heartbeatTimeout;\n\n      // Tracks methods which the user has tried to call but which have not yet\n      // called their user callback (ie, they are waiting on their result or for all\n      // of their writes to be written to the local cache). Map from method ID to\n      // MethodInvoker object.\n      self._methodInvokers = {};\n\n      // Tracks methods which the user has called but whose result messages have not\n      // arrived yet.\n      //\n      // _outstandingMethodBlocks is an array of blocks of methods. Each block\n      // represents a set of methods that can run at the same time. The first block\n      // represents the methods which are currently in flight; subsequent blocks\n      // must wait for previous blocks to be fully finished before they can be sent\n      // to the server.\n      //\n      // Each block is an object with the following fields:\n      // - methods: a list of MethodInvoker objects\n      // - wait: a boolean; if true, this block had a single method invoked with\n      //         the \"wait\" option\n      //\n      // There will never be adjacent blocks with wait=false, because the only thing\n      // that makes methods need to be serialized is a wait method.\n      //\n      // Methods are removed from the first block when their \"result\" is\n      // received. The entire first block is only removed when all of the in-flight\n      // methods have received their results (so the \"methods\" list is empty) *AND*\n      // all of the data written by those methods are visible in the local cache. So\n      // it is possible for the first block's methods list to be empty, if we are\n      // still waiting for some objects to quiesce.\n      //\n      // Example:\n      //  _outstandingMethodBlocks = [\n      //    {wait: false, methods: []},\n      //    {wait: true, methods: [<MethodInvoker for 'login'>]},\n      //    {wait: false, methods: [<MethodInvoker for 'foo'>,\n      //                            <MethodInvoker for 'bar'>]}]\n      // This means that there were some methods which were sent to the server and\n      // which have returned their results, but some of the data written by\n      // the methods may not be visible in the local cache. Once all that data is\n      // visible, we will send a 'login' method. Once the login method has returned\n      // and all the data is visible (including re-running subs if userId changes),\n      // we will send the 'foo' and 'bar' methods in parallel.\n      self._outstandingMethodBlocks = [];\n\n      // method ID -> array of objects with keys 'collection' and 'id', listing\n      // documents written by a given method's stub. keys are associated with\n      // methods whose stub wrote at least one document, and whose data-done message\n      // has not yet been received.\n      self._documentsWrittenByStub = {};\n      // collection -> IdMap of \"server document\" object. A \"server document\" has:\n      // - \"document\": the version of the document according the\n      //   server (ie, the snapshot before a stub wrote it, amended by any changes\n      //   received from the server)\n      //   It is undefined if we think the document does not exist\n      // - \"writtenByStubs\": a set of method IDs whose stubs wrote to the document\n      //   whose \"data done\" messages have not yet been processed\n      self._serverDocuments = {};\n\n      // Array of callbacks to be called after the next update of the local\n      // cache. Used for:\n      //  - Calling methodInvoker.dataVisible and sub ready callbacks after\n      //    the relevant data is flushed.\n      //  - Invoking the callbacks of \"half-finished\" methods after reconnect\n      //    quiescence. Specifically, methods whose result was received over the old\n      //    connection (so we don't re-send it) but whose data had not been made\n      //    visible.\n      self._afterUpdateCallbacks = [];\n\n      // In two contexts, we buffer all incoming data messages and then process them\n      // all at once in a single update:\n      //   - During reconnect, we buffer all data messages until all subs that had\n      //     been ready before reconnect are ready again, and all methods that are\n      //     active have returned their \"data done message\"; then\n      //   - During the execution of a \"wait\" method, we buffer all data messages\n      //     until the wait method gets its \"data done\" message. (If the wait method\n      //     occurs during reconnect, it doesn't get any special handling.)\n      // all data messages are processed in one update.\n      //\n      // The following fields are used for this \"quiescence\" process.\n\n      // This buffers the messages that aren't being processed yet.\n      self._messagesBufferedUntilQuiescence = [];\n      // Map from method ID -> true. Methods are removed from this when their\n      // \"data done\" message is received, and we will not quiesce until it is\n      // empty.\n      self._methodsBlockingQuiescence = {};\n      // map from sub ID -> true for subs that were ready (ie, called the sub\n      // ready callback) before reconnect but haven't become ready again yet\n      self._subsBeingRevived = {}; // map from sub._id -> true\n      // if true, the next data update should reset all stores. (set during\n      // reconnect.)\n      self._resetStores = false;\n\n      // name -> array of updates for (yet to be created) collections\n      self._updatesForUnknownStores = {};\n      // if we're blocking a migration, the retry func\n      self._retryMigrate = null;\n\n      self.__flushBufferedWrites = Meteor.bindEnvironment(self._flushBufferedWrites, \"flushing DDP buffered writes\", self);\n      // Collection name -> array of messages.\n      self._bufferedWrites = {};\n      // When current buffer of updates must be flushed at, in ms timestamp.\n      self._bufferedWritesFlushAt = null;\n      // Timeout handle for the next processing of all pending writes\n      self._bufferedWritesFlushHandle = null;\n\n      self._bufferedWritesInterval = options.bufferedWritesInterval;\n      self._bufferedWritesMaxAge = options.bufferedWritesMaxAge;\n\n      // metadata for subscriptions.  Map from sub ID to object with keys:\n      //   - id\n      //   - name\n      //   - params\n      //   - inactive (if true, will be cleaned up if not reused in re-run)\n      //   - ready (has the 'ready' message been received?)\n      //   - readyCallback (an optional callback to call when ready)\n      //   - errorCallback (an optional callback to call if the sub terminates with\n      //                    an error, XXX COMPAT WITH 1.0.3.1)\n      //   - stopCallback (an optional callback to call when the sub terminates\n      //     for any reason, with an error argument if an error triggered the stop)\n      self._subscriptions = {};\n\n      // Reactive userId.\n      self._userId = null;\n      self._userIdDeps = new Tracker.Dependency();\n\n      // Block auto-reload while we're waiting for method responses.\n      if (Meteor.isClient && Package.reload && !options.reloadWithOutstanding) {\n        Package.reload.Reload._onMigrate(function (retry) {\n          if (!self._readyToMigrate()) {\n            if (self._retryMigrate) throw new Error(\"Two migrations in progress?\");\n            self._retryMigrate = retry;\n            return false;\n          } else {\n            return [true];\n          }\n        });\n      }\n\n      var onMessage = function onMessage(raw_msg) {\n        try {\n          var msg = DDPCommon.parseDDP(raw_msg);\n        } catch (e) {\n          Meteor._debug(\"Exception while parsing DDP\", e);\n          return;\n        }\n\n        // Any message counts as receiving a pong, as it demonstrates that\n        // the server is still alive.\n        if (self._heartbeat) {\n          self._heartbeat.messageReceived();\n        }\n\n        if (msg === null || !msg.msg) {\n          // XXX COMPAT WITH 0.6.6. ignore the old welcome message for back\n          // compat.  Remove this 'if' once the server stops sending welcome\n          // messages (stream_server.js).\n          if (!(msg && msg.server_id)) Meteor._debug(\"discarding invalid livedata message\", msg);\n          return;\n        }\n\n        if (msg.msg === 'connected') {\n          self._version = self._versionSuggestion;\n          self._livedata_connected(msg);\n          options.onConnected();\n        } else if (msg.msg === 'failed') {\n          if (_.contains(self._supportedDDPVersions, msg.version)) {\n            self._versionSuggestion = msg.version;\n            self._stream.reconnect({ _force: true });\n          } else {\n            var description = \"DDP version negotiation failed; server requested version \" + msg.version;\n            self._stream.disconnect({ _permanent: true, _error: description });\n            options.onDDPVersionNegotiationFailure(description);\n          }\n        } else if (msg.msg === 'ping' && options.respondToPings) {\n          self._send({ msg: \"pong\", id: msg.id });\n        } else if (msg.msg === 'pong') {\n          // noop, as we assume everything's a pong\n        } else if (_.include(['added', 'changed', 'removed', 'ready', 'updated'], msg.msg)) self._livedata_data(msg);else if (msg.msg === 'nosub') self._livedata_nosub(msg);else if (msg.msg === 'result') self._livedata_result(msg);else if (msg.msg === 'error') self._livedata_error(msg);else Meteor._debug(\"discarding unknown livedata message type\", msg);\n      };\n\n      var onReset = function onReset() {\n        // Send a connect message at the beginning of the stream.\n        // NOTE: reset is called even on the first connection, so this is\n        // the only place we send this message.\n        var msg = { msg: 'connect' };\n        if (self._lastSessionId) msg.session = self._lastSessionId;\n        msg.version = self._versionSuggestion || self._supportedDDPVersions[0];\n        self._versionSuggestion = msg.version;\n        msg.support = self._supportedDDPVersions;\n        self._send(msg);\n\n        // Mark non-retry calls as failed. This has to be done early as getting these methods out of the\n        // current block is pretty important to making sure that quiescence is properly calculated, as\n        // well as possibly moving on to another useful block.\n\n        // Only bother testing if there is an outstandingMethodBlock (there might not be, especially if\n        // we are connecting for the first time.\n        if (self._outstandingMethodBlocks.length > 0) {\n          // If there is an outstanding method block, we only care about the first one as that is the\n          // one that could have already sent messages with no response, that are not allowed to retry.\n          _.each(self._outstandingMethodBlocks[0].methods, function (methodInvoker) {\n            // If the message wasn't sent or it's allowed to retry, do nothing.\n            if (methodInvoker.sentMessage && methodInvoker.noRetry) {\n              // The next loop serves to get the index in the current method block of this method.\n              var currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n              var loopMethod;\n              for (var i = 0; i < currentMethodBlock.length; i++) {\n                loopMethod = currentMethodBlock[i];\n                if (loopMethod.methodId === methodInvoker.methodId) {\n                  break;\n                }\n              }\n\n              // Remove from current method block. This may leave the block empty, but we\n              // don't move on to the next block until the callback has been delivered, in\n              // _outstandingMethodFinished.\n              currentMethodBlock.splice(i, 1);\n\n              // Make sure that the method is told that it failed.\n              methodInvoker.receiveResult(new Meteor.Error('invocation-failed', 'Method invocation might have failed due to dropped connection. ' + 'Failing because `noRetry` option was passed to Meteor.apply.'));\n            }\n          });\n        }\n\n        // Now, to minimize setup latency, go ahead and blast out all of\n        // our pending methods ands subscriptions before we've even taken\n        // the necessary RTT to know if we successfully reconnected. (1)\n        // They're supposed to be idempotent, and where they are not,\n        // they can block retry in apply; (2) even if we did reconnect,\n        // we're not sure what messages might have gotten lost\n        // (in either direction) since we were disconnected (TCP being\n        // sloppy about that.)\n\n        // If the current block of methods all got their results (but didn't all get\n        // their data visible), discard the empty block now.\n        if (!_.isEmpty(self._outstandingMethodBlocks) && _.isEmpty(self._outstandingMethodBlocks[0].methods)) {\n          self._outstandingMethodBlocks.shift();\n        }\n\n        // Mark all messages as unsent, they have not yet been sent on this\n        // connection.\n        _.each(self._methodInvokers, function (m) {\n          m.sentMessage = false;\n        });\n\n        // If an `onReconnect` handler is set, call it first. Go through\n        // some hoops to ensure that methods that are called from within\n        // `onReconnect` get executed _before_ ones that were originally\n        // outstanding (since `onReconnect` is used to re-establish auth\n        // certificates)\n        if (self.onReconnect) self._callOnReconnectAndSendAppropriateOutstandingMethods();else self._sendOutstandingMethods();\n\n        // add new subscriptions at the end. this way they take effect after\n        // the handlers and we don't see flicker.\n        _.each(self._subscriptions, function (sub, id) {\n          self._send({\n            msg: 'sub',\n            id: id,\n            name: sub.name,\n            params: sub.params\n          });\n        });\n      };\n\n      var onDisconnect = function onDisconnect() {\n        if (self._heartbeat) {\n          self._heartbeat.stop();\n          self._heartbeat = null;\n        }\n      };\n\n      if (Meteor.isServer) {\n        self._stream.on('message', Meteor.bindEnvironment(onMessage, \"handling DDP message\"));\n        self._stream.on('reset', Meteor.bindEnvironment(onReset, \"handling DDP reset\"));\n        self._stream.on('disconnect', Meteor.bindEnvironment(onDisconnect, \"handling DDP disconnect\"));\n      } else {\n        self._stream.on('message', onMessage);\n        self._stream.on('reset', onReset);\n        self._stream.on('disconnect', onDisconnect);\n      }\n    };\n\n    // A MethodInvoker manages sending a method to the server and calling the user's\n    // callbacks. On construction, it registers itself in the connection's\n    // _methodInvokers map; it removes itself once the method is fully finished and\n    // the callback is invoked. This occurs when it has both received a result,\n    // and the data written by it is fully visible.\n    var MethodInvoker = function MethodInvoker(options) {\n      var self = this;\n\n      // Public (within this file) fields.\n      self.methodId = options.methodId;\n      self.sentMessage = false;\n\n      self._callback = options.callback;\n      self._connection = options.connection;\n      self._message = options.message;\n      self._onResultReceived = options.onResultReceived || function () {};\n      self._wait = options.wait;\n      self.noRetry = options.noRetry;\n      self._methodResult = null;\n      self._dataVisible = false;\n\n      // Register with the connection.\n      self._connection._methodInvokers[self.methodId] = self;\n    };\n    _.extend(MethodInvoker.prototype, {\n      // Sends the method message to the server. May be called additional times if\n      // we lose the connection and reconnect before receiving a result.\n      sendMessage: function sendMessage() {\n        var self = this;\n        // This function is called before sending a method (including resending on\n        // reconnect). We should only (re)send methods where we don't already have a\n        // result!\n        if (self.gotResult()) throw new Error(\"sendingMethod is called on method with result\");\n\n        // If we're re-sending it, it doesn't matter if data was written the first\n        // time.\n        self._dataVisible = false;\n        self.sentMessage = true;\n\n        // If this is a wait method, make all data messages be buffered until it is\n        // done.\n        if (self._wait) self._connection._methodsBlockingQuiescence[self.methodId] = true;\n\n        // Actually send the message.\n        self._connection._send(self._message);\n      },\n      // Invoke the callback, if we have both a result and know that all data has\n      // been written to the local cache.\n      _maybeInvokeCallback: function _maybeInvokeCallback() {\n        var self = this;\n        if (self._methodResult && self._dataVisible) {\n          // Call the callback. (This won't throw: the callback was wrapped with\n          // bindEnvironment.)\n          self._callback(self._methodResult[0], self._methodResult[1]);\n\n          // Forget about this method.\n          delete self._connection._methodInvokers[self.methodId];\n\n          // Let the connection know that this method is finished, so it can try to\n          // move on to the next block of methods.\n          self._connection._outstandingMethodFinished();\n        }\n      },\n      // Call with the result of the method from the server. Only may be called\n      // once; once it is called, you should not call sendMessage again.\n      // If the user provided an onResultReceived callback, call it immediately.\n      // Then invoke the main callback if data is also visible.\n      receiveResult: function receiveResult(err, result) {\n        var self = this;\n        if (self.gotResult()) throw new Error(\"Methods should only receive results once\");\n        self._methodResult = [err, result];\n        self._onResultReceived(err, result);\n        self._maybeInvokeCallback();\n      },\n      // Call this when all data written by the method is visible. This means that\n      // the method has returns its \"data is done\" message *AND* all server\n      // documents that are buffered at that time have been written to the local\n      // cache. Invokes the main callback if the result has been received.\n      dataVisible: function dataVisible() {\n        var self = this;\n        self._dataVisible = true;\n        self._maybeInvokeCallback();\n      },\n      // True if receiveResult has been called.\n      gotResult: function gotResult() {\n        var self = this;\n        return !!self._methodResult;\n      }\n    });\n\n    _.extend(Connection.prototype, {\n      // 'name' is the name of the data on the wire that should go in the\n      // store. 'wrappedStore' should be an object with methods beginUpdate, update,\n      // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.\n      registerStore: function registerStore(name, wrappedStore) {\n        var self = this;\n\n        if (name in self._stores) return false;\n\n        // Wrap the input object in an object which makes any store method not\n        // implemented by 'store' into a no-op.\n        var store = {};\n        _.each(['update', 'beginUpdate', 'endUpdate', 'saveOriginals', 'retrieveOriginals', 'getDoc', '_getCollection'], function (method) {\n          store[method] = function () {\n            return wrappedStore[method] ? wrappedStore[method].apply(wrappedStore, arguments) : undefined;\n          };\n        });\n\n        self._stores[name] = store;\n\n        var queued = self._updatesForUnknownStores[name];\n        if (queued) {\n          store.beginUpdate(queued.length, false);\n          _.each(queued, function (msg) {\n            store.update(msg);\n          });\n          store.endUpdate();\n          delete self._updatesForUnknownStores[name];\n        }\n\n        return true;\n      },\n\n      /**\n       * @memberOf Meteor\n       * @importFromPackage meteor\n       * @summary Subscribe to a record set.  Returns a handle that provides\n       * `stop()` and `ready()` methods.\n       * @locus Client\n       * @param {String} name Name of the subscription.  Matches the name of the\n       * server's `publish()` call.\n       * @param {EJSONable} [arg1,arg2...] Optional arguments passed to publisher\n       * function on server.\n       * @param {Function|Object} [callbacks] Optional. May include `onStop`\n       * and `onReady` callbacks. If there is an error, it is passed as an\n       * argument to `onStop`. If a function is passed instead of an object, it\n       * is interpreted as an `onReady` callback.\n       */\n      subscribe: function subscribe(name /* .. [arguments] .. (callback|callbacks) */) {\n        var self = this;\n\n        var params = Array.prototype.slice.call(arguments, 1);\n        var callbacks = {};\n        if (params.length) {\n          var lastParam = params[params.length - 1];\n          if (_.isFunction(lastParam)) {\n            callbacks.onReady = params.pop();\n          } else if (lastParam &&\n          // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use\n          // onStop with an error callback instead.\n          _.any([lastParam.onReady, lastParam.onError, lastParam.onStop], _.isFunction)) {\n            callbacks = params.pop();\n          }\n        }\n\n        // Is there an existing sub with the same name and param, run in an\n        // invalidated Computation? This will happen if we are rerunning an\n        // existing computation.\n        //\n        // For example, consider a rerun of:\n        //\n        //     Tracker.autorun(function () {\n        //       Meteor.subscribe(\"foo\", Session.get(\"foo\"));\n        //       Meteor.subscribe(\"bar\", Session.get(\"bar\"));\n        //     });\n        //\n        // If \"foo\" has changed but \"bar\" has not, we will match the \"bar\"\n        // subcribe to an existing inactive subscription in order to not\n        // unsub and resub the subscription unnecessarily.\n        //\n        // We only look for one such sub; if there are N apparently-identical subs\n        // being invalidated, we will require N matching subscribe calls to keep\n        // them all active.\n        var existing = _.find(self._subscriptions, function (sub) {\n          return sub.inactive && sub.name === name && EJSON.equals(sub.params, params);\n        });\n\n        var id;\n        if (existing) {\n          id = existing.id;\n          existing.inactive = false; // reactivate\n\n          if (callbacks.onReady) {\n            // If the sub is not already ready, replace any ready callback with the\n            // one provided now. (It's not really clear what users would expect for\n            // an onReady callback inside an autorun; the semantics we provide is\n            // that at the time the sub first becomes ready, we call the last\n            // onReady callback provided, if any.)\n            if (!existing.ready) existing.readyCallback = callbacks.onReady;\n          }\n\n          // XXX COMPAT WITH 1.0.3.1 we used to have onError but now we call\n          // onStop with an optional error argument\n          if (callbacks.onError) {\n            // Replace existing callback if any, so that errors aren't\n            // double-reported.\n            existing.errorCallback = callbacks.onError;\n          }\n\n          if (callbacks.onStop) {\n            existing.stopCallback = callbacks.onStop;\n          }\n        } else {\n          // New sub! Generate an id, save it locally, and send message.\n          id = Random.id();\n          self._subscriptions[id] = {\n            id: id,\n            name: name,\n            params: EJSON.clone(params),\n            inactive: false,\n            ready: false,\n            readyDeps: new Tracker.Dependency(),\n            readyCallback: callbacks.onReady,\n            // XXX COMPAT WITH 1.0.3.1 #errorCallback\n            errorCallback: callbacks.onError,\n            stopCallback: callbacks.onStop,\n            connection: self,\n            remove: function remove() {\n              delete this.connection._subscriptions[this.id];\n              this.ready && this.readyDeps.changed();\n            },\n            stop: function stop() {\n              this.connection._send({ msg: 'unsub', id: id });\n              this.remove();\n\n              if (callbacks.onStop) {\n                callbacks.onStop();\n              }\n            }\n          };\n          self._send({ msg: 'sub', id: id, name: name, params: params });\n        }\n\n        // return a handle to the application.\n        var handle = {\n          stop: function stop() {\n            if (!_.has(self._subscriptions, id)) return;\n\n            self._subscriptions[id].stop();\n          },\n          ready: function ready() {\n            // return false if we've unsubscribed.\n            if (!_.has(self._subscriptions, id)) return false;\n            var record = self._subscriptions[id];\n            record.readyDeps.depend();\n            return record.ready;\n          },\n          subscriptionId: id\n        };\n\n        if (Tracker.active) {\n          // We're in a reactive computation, so we'd like to unsubscribe when the\n          // computation is invalidated... but not if the rerun just re-subscribes\n          // to the same subscription!  When a rerun happens, we use onInvalidate\n          // as a change to mark the subscription \"inactive\" so that it can\n          // be reused from the rerun.  If it isn't reused, it's killed from\n          // an afterFlush.\n          Tracker.onInvalidate(function (c) {\n            if (_.has(self._subscriptions, id)) self._subscriptions[id].inactive = true;\n\n            Tracker.afterFlush(function () {\n              if (_.has(self._subscriptions, id) && self._subscriptions[id].inactive) handle.stop();\n            });\n          });\n        }\n\n        return handle;\n      },\n\n      // options:\n      // - onLateError {Function(error)} called if an error was received after the ready event.\n      //     (errors received before ready cause an error to be thrown)\n      _subscribeAndWait: function _subscribeAndWait(name, args, options) {\n        var self = this;\n        var f = new Future();\n        var ready = false;\n        var handle;\n        args = args || [];\n        args.push({\n          onReady: function onReady() {\n            ready = true;\n            f['return']();\n          },\n          onError: function onError(e) {\n            if (!ready) f['throw'](e);else options && options.onLateError && options.onLateError(e);\n          }\n        });\n\n        handle = self.subscribe.apply(self, [name].concat(args));\n        f.wait();\n        return handle;\n      },\n\n      methods: function methods(_methods) {\n        var self = this;\n        _.each(_methods, function (func, name) {\n          if (typeof func !== 'function') throw new Error(\"Method '\" + name + \"' must be a function\");\n          if (self._methodHandlers[name]) throw new Error(\"A method named '\" + name + \"' is already defined\");\n          self._methodHandlers[name] = func;\n        });\n      },\n\n      /**\n       * @memberOf Meteor\n       * @importFromPackage meteor\n       * @summary Invokes a method passing any number of arguments.\n       * @locus Anywhere\n       * @param {String} name Name of method to invoke\n       * @param {EJSONable} [arg1,arg2...] Optional method arguments\n       * @param {Function} [asyncCallback] Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).\n       */\n      call: function call(name /* .. [arguments] .. callback */) {\n        // if it's a function, the last argument is the result callback,\n        // not a parameter to the remote method.\n        var args = Array.prototype.slice.call(arguments, 1);\n        if (args.length && typeof args[args.length - 1] === \"function\") var callback = args.pop();\n        return this.apply(name, args, callback);\n      },\n\n      // @param options {Optional Object}\n      //   wait: Boolean - Should we wait to call this until all current methods\n      //                   are fully finished, and block subsequent method calls\n      //                   until this method is fully finished?\n      //                   (does not affect methods called from within this method)\n      //   onResultReceived: Function - a callback to call as soon as the method\n      //                                result is received. the data written by\n      //                                the method may not yet be in the cache!\n      //   returnStubValue: Boolean - If true then in cases where we would have\n      //                              otherwise discarded the stub's return value\n      //                              and returned undefined, instead we go ahead\n      //                              and return it.  Specifically, this is any\n      //                              time other than when (a) we are already\n      //                              inside a stub or (b) we are in Node and no\n      //                              callback was provided.  Currently we require\n      //                              this flag to be explicitly passed to reduce\n      //                              the likelihood that stub return values will\n      //                              be confused with server return values; we\n      //                              may improve this in future.\n      // @param callback {Optional Function}\n\n      /**\n       * @memberOf Meteor\n       * @importFromPackage meteor\n       * @summary Invoke a method passing an array of arguments.\n       * @locus Anywhere\n       * @param {String} name Name of method to invoke\n       * @param {EJSONable[]} args Method arguments\n       * @param {Object} [options]\n       * @param {Boolean} options.wait (Client only) If true, don't send this method until all previous method calls have completed, and don't send any subsequent method calls until this one is completed.\n       * @param {Function} options.onResultReceived (Client only) This callback is invoked with the error or result of the method (just like `asyncCallback`) as soon as the error or result is available. The local cache may not yet reflect the writes performed by the method.\n       * @param {Boolean} options.noRetry (Client only) if true, don't send this method again on reload, simply call the callback an error with the error code 'invocation-failed'.\n       * @param {Function} [asyncCallback] Optional callback; same semantics as in [`Meteor.call`](#meteor_call).\n       */\n      apply: function apply(name, args, options, callback) {\n        var self = this;\n\n        // We were passed 3 arguments. They may be either (name, args, options)\n        // or (name, args, callback)\n        if (!callback && typeof options === 'function') {\n          callback = options;\n          options = {};\n        }\n        options = options || {};\n\n        if (callback) {\n          // XXX would it be better form to do the binding in stream.on,\n          // or caller, instead of here?\n          // XXX improve error message (and how we report it)\n          callback = Meteor.bindEnvironment(callback, \"delivering result of invoking '\" + name + \"'\");\n        }\n\n        // Keep our args safe from mutation (eg if we don't send the message for a\n        // while because of a wait method).\n        args = EJSON.clone(args);\n\n        // Lazily allocate method ID once we know that it'll be needed.\n        var methodId = function () {\n          var id;\n          return function () {\n            if (id === undefined) id = '' + self._nextMethodId++;\n            return id;\n          };\n        }();\n\n        var enclosing = DDP._CurrentInvocation.get();\n        var alreadyInSimulation = enclosing && enclosing.isSimulation;\n\n        // Lazily generate a randomSeed, only if it is requested by the stub.\n        // The random streams only have utility if they're used on both the client\n        // and the server; if the client doesn't generate any 'random' values\n        // then we don't expect the server to generate any either.\n        // Less commonly, the server may perform different actions from the client,\n        // and may in fact generate values where the client did not, but we don't\n        // have any client-side values to match, so even here we may as well just\n        // use a random seed on the server.  In that case, we don't pass the\n        // randomSeed to save bandwidth, and we don't even generate it to save a\n        // bit of CPU and to avoid consuming entropy.\n        var randomSeed = null;\n        var randomSeedGenerator = function randomSeedGenerator() {\n          if (randomSeed === null) {\n            randomSeed = DDPCommon.makeRpcSeed(enclosing, name);\n          }\n          return randomSeed;\n        };\n\n        // Run the stub, if we have one. The stub is supposed to make some\n        // temporary writes to the database to give the user a smooth experience\n        // until the actual result of executing the method comes back from the\n        // server (whereupon the temporary writes to the database will be reversed\n        // during the beginUpdate/endUpdate process.)\n        //\n        // Normally, we ignore the return value of the stub (even if it is an\n        // exception), in favor of the real return value from the server. The\n        // exception is if the *caller* is a stub. In that case, we're not going\n        // to do a RPC, so we use the return value of the stub as our return\n        // value.\n\n        var stub = self._methodHandlers[name];\n        if (stub) {\n          var setUserId = function setUserId(userId) {\n            self.setUserId(userId);\n          };\n\n          var invocation = new DDPCommon.MethodInvocation({\n            isSimulation: true,\n            userId: self.userId(),\n            setUserId: setUserId,\n            randomSeed: function randomSeed() {\n              return randomSeedGenerator();\n            }\n          });\n\n          if (!alreadyInSimulation) self._saveOriginals();\n\n          try {\n            // Note that unlike in the corresponding server code, we never audit\n            // that stubs check() their arguments.\n            var stubReturnValue = DDP._CurrentInvocation.withValue(invocation, function () {\n              if (Meteor.isServer) {\n                // Because saveOriginals and retrieveOriginals aren't reentrant,\n                // don't allow stubs to yield.\n                return Meteor._noYieldsAllowed(function () {\n                  // re-clone, so that the stub can't affect our caller's values\n                  return stub.apply(invocation, EJSON.clone(args));\n                });\n              } else {\n                return stub.apply(invocation, EJSON.clone(args));\n              }\n            });\n          } catch (e) {\n            var exception = e;\n          }\n\n          if (!alreadyInSimulation) self._retrieveAndStoreOriginals(methodId());\n        }\n\n        // If we're in a simulation, stop and return the result we have,\n        // rather than going on to do an RPC. If there was no stub,\n        // we'll end up returning undefined.\n        if (alreadyInSimulation) {\n          if (callback) {\n            callback(exception, stubReturnValue);\n            return undefined;\n          }\n          if (exception) throw exception;\n          return stubReturnValue;\n        }\n\n        // If an exception occurred in a stub, and we're ignoring it\n        // because we're doing an RPC and want to use what the server\n        // returns instead, log it so the developer knows\n        // (unless they explicitly ask to see the error).\n        //\n        // Tests can set the 'expected' flag on an exception so it won't\n        // go to log.\n        if (exception) {\n          if (options.throwStubExceptions) {\n            throw exception;\n          } else if (!exception.expected) {\n            Meteor._debug(\"Exception while simulating the effect of invoking '\" + name + \"'\", exception, exception.stack);\n          }\n        }\n\n        // At this point we're definitely doing an RPC, and we're going to\n        // return the value of the RPC to the caller.\n\n        // If the caller didn't give a callback, decide what to do.\n        if (!callback) {\n          if (Meteor.isClient) {\n            // On the client, we don't have fibers, so we can't block. The\n            // only thing we can do is to return undefined and discard the\n            // result of the RPC. If an error occurred then print the error\n            // to the console.\n            callback = function callback(err) {\n              err && Meteor._debug(\"Error invoking Method '\" + name + \"':\", err.message);\n            };\n          } else {\n            // On the server, make the function synchronous. Throw on\n            // errors, return on success.\n            var future = new Future();\n            callback = future.resolver();\n          }\n        }\n        // Send the RPC. Note that on the client, it is important that the\n        // stub have finished before we send the RPC, so that we know we have\n        // a complete list of which local documents the stub wrote.\n        var message = {\n          msg: 'method',\n          method: name,\n          params: args,\n          id: methodId()\n        };\n\n        // Send the randomSeed only if we used it\n        if (randomSeed !== null) {\n          message.randomSeed = randomSeed;\n        }\n\n        var methodInvoker = new MethodInvoker({\n          methodId: methodId(),\n          callback: callback,\n          connection: self,\n          onResultReceived: options.onResultReceived,\n          wait: !!options.wait,\n          message: message,\n          noRetry: !!options.noRetry\n        });\n\n        if (options.wait) {\n          // It's a wait method! Wait methods go in their own block.\n          self._outstandingMethodBlocks.push({ wait: true, methods: [methodInvoker] });\n        } else {\n          // Not a wait method. Start a new block if the previous block was a wait\n          // block, and add it to the last block of methods.\n          if (_.isEmpty(self._outstandingMethodBlocks) || _.last(self._outstandingMethodBlocks).wait) self._outstandingMethodBlocks.push({ wait: false, methods: [] });\n          _.last(self._outstandingMethodBlocks).methods.push(methodInvoker);\n        }\n\n        // If we added it to the first block, send it out now.\n        if (self._outstandingMethodBlocks.length === 1) methodInvoker.sendMessage();\n\n        // If we're using the default callback on the server,\n        // block waiting for the result.\n        if (future) {\n          return future.wait();\n        }\n        return options.returnStubValue ? stubReturnValue : undefined;\n      },\n\n      // Before calling a method stub, prepare all stores to track changes and allow\n      // _retrieveAndStoreOriginals to get the original versions of changed\n      // documents.\n      _saveOriginals: function _saveOriginals() {\n        var self = this;\n        _.each(self._stores, function (s) {\n          s.saveOriginals();\n        });\n      },\n      // Retrieves the original versions of all documents modified by the stub for\n      // method 'methodId' from all stores and saves them to _serverDocuments (keyed\n      // by document) and _documentsWrittenByStub (keyed by method ID).\n      _retrieveAndStoreOriginals: function _retrieveAndStoreOriginals(methodId) {\n        var self = this;\n        if (self._documentsWrittenByStub[methodId]) throw new Error(\"Duplicate methodId in _retrieveAndStoreOriginals\");\n\n        var docsWritten = [];\n        _.each(self._stores, function (s, collection) {\n          var originals = s.retrieveOriginals();\n          // not all stores define retrieveOriginals\n          if (!originals) return;\n          originals.forEach(function (doc, id) {\n            docsWritten.push({ collection: collection, id: id });\n            if (!_.has(self._serverDocuments, collection)) self._serverDocuments[collection] = new MongoIDMap();\n            var serverDoc = self._serverDocuments[collection].setDefault(id, {});\n            if (serverDoc.writtenByStubs) {\n              // We're not the first stub to write this doc. Just add our method ID\n              // to the record.\n              serverDoc.writtenByStubs[methodId] = true;\n            } else {\n              // First stub! Save the original value and our method ID.\n              serverDoc.document = doc;\n              serverDoc.flushCallbacks = [];\n              serverDoc.writtenByStubs = {};\n              serverDoc.writtenByStubs[methodId] = true;\n            }\n          });\n        });\n        if (!_.isEmpty(docsWritten)) {\n          self._documentsWrittenByStub[methodId] = docsWritten;\n        }\n      },\n\n      // This is very much a private function we use to make the tests\n      // take up fewer server resources after they complete.\n      _unsubscribeAll: function _unsubscribeAll() {\n        var self = this;\n        _.each(_.clone(self._subscriptions), function (sub, id) {\n          // Avoid killing the autoupdate subscription so that developers\n          // still get hot code pushes when writing tests.\n          //\n          // XXX it's a hack to encode knowledge about autoupdate here,\n          // but it doesn't seem worth it yet to have a special API for\n          // subscriptions to preserve after unit tests.\n          if (sub.name !== 'meteor_autoupdate_clientVersions') {\n            self._subscriptions[id].stop();\n          }\n        });\n      },\n\n      // Sends the DDP stringification of the given message object\n      _send: function _send(obj) {\n        var self = this;\n        self._stream.send(DDPCommon.stringifyDDP(obj));\n      },\n\n      // We detected via DDP-level heartbeats that we've lost the\n      // connection.  Unlike `disconnect` or `close`, a lost connection\n      // will be automatically retried.\n      _lostConnection: function _lostConnection(error) {\n        var self = this;\n        self._stream._lostConnection(error);\n      },\n\n      /**\n       * @summary Get the current connection status. A reactive data source.\n       * @locus Client\n       * @memberOf Meteor\n       * @importFromPackage meteor\n       */\n      status: function status() /*passthrough args*/{\n        var self = this;\n        return self._stream.status.apply(self._stream, arguments);\n      },\n\n      /**\n       * @summary Force an immediate reconnection attempt if the client is not connected to the server.\n       This method does nothing if the client is already connected.\n       * @locus Client\n       * @memberOf Meteor\n       * @importFromPackage meteor\n       */\n      reconnect: function reconnect() /*passthrough args*/{\n        var self = this;\n        return self._stream.reconnect.apply(self._stream, arguments);\n      },\n\n      /**\n       * @summary Disconnect the client from the server.\n       * @locus Client\n       * @memberOf Meteor\n       * @importFromPackage meteor\n       */\n      disconnect: function disconnect() /*passthrough args*/{\n        var self = this;\n        return self._stream.disconnect.apply(self._stream, arguments);\n      },\n\n      close: function close() {\n        var self = this;\n        return self._stream.disconnect({ _permanent: true });\n      },\n\n      ///\n      /// Reactive user system\n      ///\n      userId: function userId() {\n        var self = this;\n        if (self._userIdDeps) self._userIdDeps.depend();\n        return self._userId;\n      },\n\n      setUserId: function setUserId(userId) {\n        var self = this;\n        // Avoid invalidating dependents if setUserId is called with current value.\n        if (self._userId === userId) return;\n        self._userId = userId;\n        if (self._userIdDeps) self._userIdDeps.changed();\n      },\n\n      // Returns true if we are in a state after reconnect of waiting for subs to be\n      // revived or early methods to finish their data, or we are waiting for a\n      // \"wait\" method to finish.\n      _waitingForQuiescence: function _waitingForQuiescence() {\n        var self = this;\n        return !_.isEmpty(self._subsBeingRevived) || !_.isEmpty(self._methodsBlockingQuiescence);\n      },\n\n      // Returns true if any method whose message has been sent to the server has\n      // not yet invoked its user callback.\n      _anyMethodsAreOutstanding: function _anyMethodsAreOutstanding() {\n        var self = this;\n        return _.any(_.pluck(self._methodInvokers, 'sentMessage'));\n      },\n\n      _livedata_connected: function _livedata_connected(msg) {\n        var self = this;\n\n        if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {\n          self._heartbeat = new DDPCommon.Heartbeat({\n            heartbeatInterval: self._heartbeatInterval,\n            heartbeatTimeout: self._heartbeatTimeout,\n            onTimeout: function onTimeout() {\n              self._lostConnection(new DDP.ConnectionError(\"DDP heartbeat timed out\"));\n            },\n            sendPing: function sendPing() {\n              self._send({ msg: 'ping' });\n            }\n          });\n          self._heartbeat.start();\n        }\n\n        // If this is a reconnect, we'll have to reset all stores.\n        if (self._lastSessionId) self._resetStores = true;\n\n        if (typeof msg.session === \"string\") {\n          var reconnectedToPreviousSession = self._lastSessionId === msg.session;\n          self._lastSessionId = msg.session;\n        }\n\n        if (reconnectedToPreviousSession) {\n          // Successful reconnection -- pick up where we left off.  Note that right\n          // now, this never happens: the server never connects us to a previous\n          // session, because DDP doesn't provide enough data for the server to know\n          // what messages the client has processed. We need to improve DDP to make\n          // this possible, at which point we'll probably need more code here.\n          return;\n        }\n\n        // Server doesn't have our data any more. Re-sync a new session.\n\n        // Forget about messages we were buffering for unknown collections. They'll\n        // be resent if still relevant.\n        self._updatesForUnknownStores = {};\n\n        if (self._resetStores) {\n          // Forget about the effects of stubs. We'll be resetting all collections\n          // anyway.\n          self._documentsWrittenByStub = {};\n          self._serverDocuments = {};\n        }\n\n        // Clear _afterUpdateCallbacks.\n        self._afterUpdateCallbacks = [];\n\n        // Mark all named subscriptions which are ready (ie, we already called the\n        // ready callback) as needing to be revived.\n        // XXX We should also block reconnect quiescence until unnamed subscriptions\n        //     (eg, autopublish) are done re-publishing to avoid flicker!\n        self._subsBeingRevived = {};\n        _.each(self._subscriptions, function (sub, id) {\n          if (sub.ready) self._subsBeingRevived[id] = true;\n        });\n\n        // Arrange for \"half-finished\" methods to have their callbacks run, and\n        // track methods that were sent on this connection so that we don't\n        // quiesce until they are all done.\n        //\n        // Start by clearing _methodsBlockingQuiescence: methods sent before\n        // reconnect don't matter, and any \"wait\" methods sent on the new connection\n        // that we drop here will be restored by the loop below.\n        self._methodsBlockingQuiescence = {};\n        if (self._resetStores) {\n          _.each(self._methodInvokers, function (invoker) {\n            if (invoker.gotResult()) {\n              // This method already got its result, but it didn't call its callback\n              // because its data didn't become visible. We did not resend the\n              // method RPC. We'll call its callback when we get a full quiesce,\n              // since that's as close as we'll get to \"data must be visible\".\n              self._afterUpdateCallbacks.push(_.bind(invoker.dataVisible, invoker));\n            } else if (invoker.sentMessage) {\n              // This method has been sent on this connection (maybe as a resend\n              // from the last connection, maybe from onReconnect, maybe just very\n              // quickly before processing the connected message).\n              //\n              // We don't need to do anything special to ensure its callbacks get\n              // called, but we'll count it as a method which is preventing\n              // reconnect quiescence. (eg, it might be a login method that was run\n              // from onReconnect, and we don't want to see flicker by seeing a\n              // logged-out state.)\n              self._methodsBlockingQuiescence[invoker.methodId] = true;\n            }\n          });\n        }\n\n        self._messagesBufferedUntilQuiescence = [];\n\n        // If we're not waiting on any methods or subs, we can reset the stores and\n        // call the callbacks immediately.\n        if (!self._waitingForQuiescence()) {\n          if (self._resetStores) {\n            _.each(self._stores, function (s) {\n              s.beginUpdate(0, true);\n              s.endUpdate();\n            });\n            self._resetStores = false;\n          }\n          self._runAfterUpdateCallbacks();\n        }\n      },\n\n      _processOneDataMessage: function _processOneDataMessage(msg, updates) {\n        var self = this;\n        // Using underscore here so as not to need to capitalize.\n        self['_process_' + msg.msg](msg, updates);\n      },\n\n      _livedata_data: function _livedata_data(msg) {\n        var self = this;\n\n        if (self._waitingForQuiescence()) {\n          self._messagesBufferedUntilQuiescence.push(msg);\n\n          if (msg.msg === \"nosub\") delete self._subsBeingRevived[msg.id];\n\n          _.each(msg.subs || [], function (subId) {\n            delete self._subsBeingRevived[subId];\n          });\n          _.each(msg.methods || [], function (methodId) {\n            delete self._methodsBlockingQuiescence[methodId];\n          });\n\n          if (self._waitingForQuiescence()) return;\n\n          // No methods or subs are blocking quiescence!\n          // We'll now process and all of our buffered messages, reset all stores,\n          // and apply them all at once.\n          _.each(self._messagesBufferedUntilQuiescence, function (bufferedMsg) {\n            self._processOneDataMessage(bufferedMsg, self._bufferedWrites);\n          });\n          self._messagesBufferedUntilQuiescence = [];\n        } else {\n          self._processOneDataMessage(msg, self._bufferedWrites);\n        }\n\n        // Immediately flush writes when:\n        //  1. Buffering is disabled. Or;\n        //  2. any non-(added/changed/removed) message arrives.\n        var standardWrite = _.include(['added', 'changed', 'removed'], msg.msg);\n        if (self._bufferedWritesInterval === 0 || !standardWrite) {\n          self._flushBufferedWrites();\n          return;\n        }\n\n        if (self._bufferedWritesFlushAt === null) {\n          self._bufferedWritesFlushAt = new Date().valueOf() + self._bufferedWritesMaxAge;\n        } else if (self._bufferedWritesFlushAt < new Date().valueOf()) {\n          self._flushBufferedWrites();\n          return;\n        }\n\n        if (self._bufferedWritesFlushHandle) {\n          clearTimeout(self._bufferedWritesFlushHandle);\n        }\n        self._bufferedWritesFlushHandle = setTimeout(self.__flushBufferedWrites, self._bufferedWritesInterval);\n      },\n\n      _flushBufferedWrites: function _flushBufferedWrites() {\n        var self = this;\n        if (self._bufferedWritesFlushHandle) {\n          clearTimeout(self._bufferedWritesFlushHandle);\n          self._bufferedWritesFlushHandle = null;\n        }\n\n        self._bufferedWritesFlushAt = null;\n        // We need to clear the buffer before passing it to\n        //  performWrites. As there's no guarantee that it\n        //  will exit cleanly.\n        var writes = self._bufferedWrites;\n        self._bufferedWrites = {};\n        self._performWrites(writes);\n      },\n\n      _performWrites: function _performWrites(updates) {\n        var self = this;\n\n        if (self._resetStores || !_.isEmpty(updates)) {\n          // Begin a transactional update of each store.\n          _.each(self._stores, function (s, storeName) {\n            s.beginUpdate(_.has(updates, storeName) ? updates[storeName].length : 0, self._resetStores);\n          });\n          self._resetStores = false;\n\n          _.each(updates, function (updateMessages, storeName) {\n            var store = self._stores[storeName];\n            if (store) {\n              _.each(updateMessages, function (updateMessage) {\n                store.update(updateMessage);\n              });\n            } else {\n              // Nobody's listening for this data. Queue it up until\n              // someone wants it.\n              // XXX memory use will grow without bound if you forget to\n              // create a collection or just don't care about it... going\n              // to have to do something about that.\n              if (!_.has(self._updatesForUnknownStores, storeName)) self._updatesForUnknownStores[storeName] = [];\n              Array.prototype.push.apply(self._updatesForUnknownStores[storeName], updateMessages);\n            }\n          });\n\n          // End update transaction.\n          _.each(self._stores, function (s) {\n            s.endUpdate();\n          });\n        }\n\n        self._runAfterUpdateCallbacks();\n      },\n\n      // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose\n      // relevant docs have been flushed, as well as dataVisible callbacks at\n      // reconnect-quiescence time.\n      _runAfterUpdateCallbacks: function _runAfterUpdateCallbacks() {\n        var self = this;\n        var callbacks = self._afterUpdateCallbacks;\n        self._afterUpdateCallbacks = [];\n        _.each(callbacks, function (c) {\n          c();\n        });\n      },\n\n      _pushUpdate: function _pushUpdate(updates, collection, msg) {\n        var self = this;\n        if (!_.has(updates, collection)) {\n          updates[collection] = [];\n        }\n        updates[collection].push(msg);\n      },\n\n      _getServerDoc: function _getServerDoc(collection, id) {\n        var self = this;\n        if (!_.has(self._serverDocuments, collection)) return null;\n        var serverDocsForCollection = self._serverDocuments[collection];\n        return serverDocsForCollection.get(id) || null;\n      },\n\n      _process_added: function _process_added(msg, updates) {\n        var self = this;\n        var id = MongoID.idParse(msg.id);\n        var serverDoc = self._getServerDoc(msg.collection, id);\n        if (serverDoc) {\n          // Some outstanding stub wrote here.\n          var isExisting = serverDoc.document !== undefined;\n\n          serverDoc.document = msg.fields || {};\n          serverDoc.document._id = id;\n\n          if (self._resetStores) {\n            // During reconnect the server is sending adds for existing ids.\n            // Always push an update so that document stays in the store after\n            // reset. Use current version of the document for this update, so\n            // that stub-written values are preserved.\n            var currentDoc = self._stores[msg.collection].getDoc(msg.id);\n            if (currentDoc !== undefined) msg.fields = currentDoc;\n\n            self._pushUpdate(updates, msg.collection, msg);\n          } else if (isExisting) {\n            throw new Error(\"Server sent add for existing id: \" + msg.id);\n          }\n        } else {\n          self._pushUpdate(updates, msg.collection, msg);\n        }\n      },\n\n      _process_changed: function _process_changed(msg, updates) {\n        var self = this;\n        var serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));\n        if (serverDoc) {\n          if (serverDoc.document === undefined) throw new Error(\"Server sent changed for nonexisting id: \" + msg.id);\n          DiffSequence.applyChanges(serverDoc.document, msg.fields);\n        } else {\n          self._pushUpdate(updates, msg.collection, msg);\n        }\n      },\n\n      _process_removed: function _process_removed(msg, updates) {\n        var self = this;\n        var serverDoc = self._getServerDoc(msg.collection, MongoID.idParse(msg.id));\n        if (serverDoc) {\n          // Some outstanding stub wrote here.\n          if (serverDoc.document === undefined) throw new Error(\"Server sent removed for nonexisting id:\" + msg.id);\n          serverDoc.document = undefined;\n        } else {\n          self._pushUpdate(updates, msg.collection, {\n            msg: 'removed',\n            collection: msg.collection,\n            id: msg.id\n          });\n        }\n      },\n\n      _process_updated: function _process_updated(msg, updates) {\n        var self = this;\n        // Process \"method done\" messages.\n        _.each(msg.methods, function (methodId) {\n          _.each(self._documentsWrittenByStub[methodId], function (written) {\n            var serverDoc = self._getServerDoc(written.collection, written.id);\n            if (!serverDoc) throw new Error(\"Lost serverDoc for \" + JSON.stringify(written));\n            if (!serverDoc.writtenByStubs[methodId]) throw new Error(\"Doc \" + JSON.stringify(written) + \" not written by  method \" + methodId);\n            delete serverDoc.writtenByStubs[methodId];\n            if (_.isEmpty(serverDoc.writtenByStubs)) {\n              // All methods whose stubs wrote this method have completed! We can\n              // now copy the saved document to the database (reverting the stub's\n              // change if the server did not write to this object, or applying the\n              // server's writes if it did).\n\n              // This is a fake ddp 'replace' message.  It's just for talking\n              // between livedata connections and minimongo.  (We have to stringify\n              // the ID because it's supposed to look like a wire message.)\n              self._pushUpdate(updates, written.collection, {\n                msg: 'replace',\n                id: MongoID.idStringify(written.id),\n                replace: serverDoc.document\n              });\n              // Call all flush callbacks.\n              _.each(serverDoc.flushCallbacks, function (c) {\n                c();\n              });\n\n              // Delete this completed serverDocument. Don't bother to GC empty\n              // IdMaps inside self._serverDocuments, since there probably aren't\n              // many collections and they'll be written repeatedly.\n              self._serverDocuments[written.collection].remove(written.id);\n            }\n          });\n          delete self._documentsWrittenByStub[methodId];\n\n          // We want to call the data-written callback, but we can't do so until all\n          // currently buffered messages are flushed.\n          var callbackInvoker = self._methodInvokers[methodId];\n          if (!callbackInvoker) throw new Error(\"No callback invoker for method \" + methodId);\n          self._runWhenAllServerDocsAreFlushed(_.bind(callbackInvoker.dataVisible, callbackInvoker));\n        });\n      },\n\n      _process_ready: function _process_ready(msg, updates) {\n        var self = this;\n        // Process \"sub ready\" messages. \"sub ready\" messages don't take effect\n        // until all current server documents have been flushed to the local\n        // database. We can use a write fence to implement this.\n        _.each(msg.subs, function (subId) {\n          self._runWhenAllServerDocsAreFlushed(function () {\n            var subRecord = self._subscriptions[subId];\n            // Did we already unsubscribe?\n            if (!subRecord) return;\n            // Did we already receive a ready message? (Oops!)\n            if (subRecord.ready) return;\n            subRecord.ready = true;\n            subRecord.readyCallback && subRecord.readyCallback();\n            subRecord.readyDeps.changed();\n          });\n        });\n      },\n\n      // Ensures that \"f\" will be called after all documents currently in\n      // _serverDocuments have been written to the local cache. f will not be called\n      // if the connection is lost before then!\n      _runWhenAllServerDocsAreFlushed: function _runWhenAllServerDocsAreFlushed(f) {\n        var self = this;\n        var runFAfterUpdates = function runFAfterUpdates() {\n          self._afterUpdateCallbacks.push(f);\n        };\n        var unflushedServerDocCount = 0;\n        var onServerDocFlush = function onServerDocFlush() {\n          --unflushedServerDocCount;\n          if (unflushedServerDocCount === 0) {\n            // This was the last doc to flush! Arrange to run f after the updates\n            // have been applied.\n            runFAfterUpdates();\n          }\n        };\n        _.each(self._serverDocuments, function (collectionDocs) {\n          collectionDocs.forEach(function (serverDoc) {\n            var writtenByStubForAMethodWithSentMessage = _.any(serverDoc.writtenByStubs, function (dummy, methodId) {\n              var invoker = self._methodInvokers[methodId];\n              return invoker && invoker.sentMessage;\n            });\n            if (writtenByStubForAMethodWithSentMessage) {\n              ++unflushedServerDocCount;\n              serverDoc.flushCallbacks.push(onServerDocFlush);\n            }\n          });\n        });\n        if (unflushedServerDocCount === 0) {\n          // There aren't any buffered docs --- we can call f as soon as the current\n          // round of updates is applied!\n          runFAfterUpdates();\n        }\n      },\n\n      _livedata_nosub: function _livedata_nosub(msg) {\n        var self = this;\n\n        // First pass it through _livedata_data, which only uses it to help get\n        // towards quiescence.\n        self._livedata_data(msg);\n\n        // Do the rest of our processing immediately, with no\n        // buffering-until-quiescence.\n\n        // we weren't subbed anyway, or we initiated the unsub.\n        if (!_.has(self._subscriptions, msg.id)) return;\n\n        // XXX COMPAT WITH 1.0.3.1 #errorCallback\n        var errorCallback = self._subscriptions[msg.id].errorCallback;\n        var stopCallback = self._subscriptions[msg.id].stopCallback;\n\n        self._subscriptions[msg.id].remove();\n\n        var meteorErrorFromMsg = function meteorErrorFromMsg(msgArg) {\n          return msgArg && msgArg.error && new Meteor.Error(msgArg.error.error, msgArg.error.reason, msgArg.error.details);\n        };\n\n        // XXX COMPAT WITH 1.0.3.1 #errorCallback\n        if (errorCallback && msg.error) {\n          errorCallback(meteorErrorFromMsg(msg));\n        }\n\n        if (stopCallback) {\n          stopCallback(meteorErrorFromMsg(msg));\n        }\n      },\n\n      _process_nosub: function _process_nosub() {\n        // This is called as part of the \"buffer until quiescence\" process, but\n        // nosub's effect is always immediate. It only goes in the buffer at all\n        // because it's possible for a nosub to be the thing that triggers\n        // quiescence, if we were waiting for a sub to be revived and it dies\n        // instead.\n      },\n\n      _livedata_result: function _livedata_result(msg) {\n        // id, result or error. error has error (code), reason, details\n\n        var self = this;\n\n        // Lets make sure there are no buffered writes before returning result.\n        if (!_.isEmpty(self._bufferedWrites)) {\n          self._flushBufferedWrites();\n        }\n\n        // find the outstanding request\n        // should be O(1) in nearly all realistic use cases\n        if (_.isEmpty(self._outstandingMethodBlocks)) {\n          Meteor._debug(\"Received method result but no methods outstanding\");\n          return;\n        }\n        var currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n        var m;\n        for (var i = 0; i < currentMethodBlock.length; i++) {\n          m = currentMethodBlock[i];\n          if (m.methodId === msg.id) break;\n        }\n\n        if (!m) {\n          Meteor._debug(\"Can't match method response to original method call\", msg);\n          return;\n        }\n\n        // Remove from current method block. This may leave the block empty, but we\n        // don't move on to the next block until the callback has been delivered, in\n        // _outstandingMethodFinished.\n        currentMethodBlock.splice(i, 1);\n\n        if (_.has(msg, 'error')) {\n          m.receiveResult(new Meteor.Error(msg.error.error, msg.error.reason, msg.error.details));\n        } else {\n          // msg.result may be undefined if the method didn't return a\n          // value\n          m.receiveResult(undefined, msg.result);\n        }\n      },\n\n      // Called by MethodInvoker after a method's callback is invoked.  If this was\n      // the last outstanding method in the current block, runs the next block. If\n      // there are no more methods, consider accepting a hot code push.\n      _outstandingMethodFinished: function _outstandingMethodFinished() {\n        var self = this;\n        if (self._anyMethodsAreOutstanding()) return;\n\n        // No methods are outstanding. This should mean that the first block of\n        // methods is empty. (Or it might not exist, if this was a method that\n        // half-finished before disconnect/reconnect.)\n        if (!_.isEmpty(self._outstandingMethodBlocks)) {\n          var firstBlock = self._outstandingMethodBlocks.shift();\n          if (!_.isEmpty(firstBlock.methods)) throw new Error(\"No methods outstanding but nonempty block: \" + JSON.stringify(firstBlock));\n\n          // Send the outstanding methods now in the first block.\n          if (!_.isEmpty(self._outstandingMethodBlocks)) self._sendOutstandingMethods();\n        }\n\n        // Maybe accept a hot code push.\n        self._maybeMigrate();\n      },\n\n      // Sends messages for all the methods in the first block in\n      // _outstandingMethodBlocks.\n      _sendOutstandingMethods: function _sendOutstandingMethods() {\n        var self = this;\n        if (_.isEmpty(self._outstandingMethodBlocks)) return;\n        _.each(self._outstandingMethodBlocks[0].methods, function (m) {\n          m.sendMessage();\n        });\n      },\n\n      _livedata_error: function _livedata_error(msg) {\n        Meteor._debug(\"Received error from server: \", msg.reason);\n        if (msg.offendingMessage) Meteor._debug(\"For: \", msg.offendingMessage);\n      },\n\n      _callOnReconnectAndSendAppropriateOutstandingMethods: function _callOnReconnectAndSendAppropriateOutstandingMethods() {\n        var self = this;\n        var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;\n        self._outstandingMethodBlocks = [];\n\n        self.onReconnect();\n\n        if (_.isEmpty(oldOutstandingMethodBlocks)) return;\n\n        // We have at least one block worth of old outstanding methods to try\n        // again. First: did onReconnect actually send anything? If not, we just\n        // restore all outstanding methods and run the first block.\n        if (_.isEmpty(self._outstandingMethodBlocks)) {\n          self._outstandingMethodBlocks = oldOutstandingMethodBlocks;\n          self._sendOutstandingMethods();\n          return;\n        }\n\n        // OK, there are blocks on both sides. Special case: merge the last block of\n        // the reconnect methods with the first block of the original methods, if\n        // neither of them are \"wait\" blocks.\n        if (!_.last(self._outstandingMethodBlocks).wait && !oldOutstandingMethodBlocks[0].wait) {\n          _.each(oldOutstandingMethodBlocks[0].methods, function (m) {\n            _.last(self._outstandingMethodBlocks).methods.push(m);\n\n            // If this \"last block\" is also the first block, send the message.\n            if (self._outstandingMethodBlocks.length === 1) m.sendMessage();\n          });\n\n          oldOutstandingMethodBlocks.shift();\n        }\n\n        // Now add the rest of the original blocks on.\n        _.each(oldOutstandingMethodBlocks, function (block) {\n          self._outstandingMethodBlocks.push(block);\n        });\n      },\n\n      // We can accept a hot code push if there are no methods in flight.\n      _readyToMigrate: function _readyToMigrate() {\n        var self = this;\n        return _.isEmpty(self._methodInvokers);\n      },\n\n      // If we were blocking a migration, see if it's now possible to continue.\n      // Call whenever the set of outstanding/blocked methods shrinks.\n      _maybeMigrate: function _maybeMigrate() {\n        var self = this;\n        if (self._retryMigrate && self._readyToMigrate()) {\n          self._retryMigrate();\n          self._retryMigrate = null;\n        }\n      }\n    });\n\n    LivedataTest.Connection = Connection;\n\n    // @param url {String} URL to Meteor app,\n    //     e.g.:\n    //     \"subdomain.meteor.com\",\n    //     \"http://subdomain.meteor.com\",\n    //     \"/\",\n    //     \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"\n\n    /**\n     * @summary Connect to the server of a different Meteor application to subscribe to its document sets and invoke its remote methods.\n     * @locus Anywhere\n     * @param {String} url The URL of another Meteor application.\n     */\n    DDP.connect = function (url, options) {\n      var ret = new Connection(url, options);\n      allConnections.push(ret); // hack. see below.\n      return ret;\n    };\n\n    // Hack for `spiderable` package: a way to see if the page is done\n    // loading all the data it needs.\n    //\n    allConnections = [];\n    DDP._allSubscriptionsReady = function () {\n      return _.all(allConnections, function (conn) {\n        return _.all(conn._subscriptions, function (sub) {\n          return sub.ready;\n        });\n      });\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package['ddp-client'] = {}, {\n    DDP: DDP,\n    LivedataTest: LivedataTest\n  });\n})();\n\n//# sourceMappingURL=ddp-client.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/ddp-client.js"],"names":[],"mappings":"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","file":"/bundle/programs/server/packages/ddp-client.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar Random = Package.random.Random;\nvar EJSON = Package.ejson.EJSON;\nvar _ = Package.underscore._;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar Retry = Package.retry.Retry;\nvar IdMap = Package['id-map'].IdMap;\nvar DDPCommon = Package['ddp-common'].DDPCommon;\nvar DiffSequence = Package['diff-sequence'].DiffSequence;\nvar MongoID = Package['mongo-id'].MongoID;\n\n/* Package-scope variables */\nvar DDP, LivedataTest, MongoIDMap, toSockjsUrl, toWebsocketUrl, allConnections;\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/ddp-client/namespace.js                                                                           //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\n/**\n * @namespace DDP\n * @summary Namespace for DDP-related methods/classes.\n */\nDDP          = {};\nLivedataTest = {};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/ddp-client/id_map.js                                                                              //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\nMongoIDMap = function () {\n  var self = this;\n  IdMap.call(self, MongoID.idStringify, MongoID.idParse);\n};\n\nMeteor._inherits(MongoIDMap, IdMap);\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/ddp-client/stream_client_nodejs.js                                                                //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\n// @param endpoint {String} URL to Meteor app\n//   \"http://subdomain.meteor.com/\" or \"/\" or\n//   \"ddp+sockjs://foo-**.meteor.com/sockjs\"\n//\n// We do some rewriting of the URL to eventually make it \"ws://\" or \"wss://\",\n// whatever was passed in.  At the very least, what Meteor.absoluteUrl() returns\n// us should work.\n//\n// We don't do any heartbeating. (The logic that did this in sockjs was removed,\n// because it used a built-in sockjs mechanism. We could do it with WebSocket\n// ping frames or with DDP-level messages.)\nLivedataTest.ClientStream = function (endpoint, options) {\n  var self = this;\n  options = options || {};\n\n  self.options = _.extend({\n    retry: true\n  }, options);\n\n  self.client = null;  // created in _launchConnection\n  self.endpoint = endpoint;\n\n  self.headers = self.options.headers || {};\n  self.npmFayeOptions = self.options.npmFayeOptions || {};\n\n  self._initCommon(self.options);\n\n  //// Kickoff!\n  self._launchConnection();\n};\n\n_.extend(LivedataTest.ClientStream.prototype, {\n\n  // data is a utf8 string. Data sent while not connected is dropped on\n  // the floor, and it is up the user of this API to retransmit lost\n  // messages on 'reset'\n  send: function (data) {\n    var self = this;\n    if (self.currentStatus.connected) {\n      self.client.send(data);\n    }\n  },\n\n  // Changes where this connection points\n  _changeUrl: function (url) {\n    var self = this;\n    self.endpoint = url;\n  },\n\n  _onConnect: function (client) {\n    var self = this;\n\n    if (client !== self.client) {\n      // This connection is not from the last call to _launchConnection.\n      // But _launchConnection calls _cleanup which closes previous connections.\n      // It's our belief that this stifles future 'open' events, but maybe\n      // we are wrong?\n      throw new Error(\"Got open from inactive client \" + !!self.client);\n    }\n\n    if (self._forcedToDisconnect) {\n      // We were asked to disconnect between trying to open the connection and\n      // actually opening it. Let's just pretend this never happened.\n      self.client.close();\n      self.client = null;\n      return;\n    }\n\n    if (self.currentStatus.connected) {\n      // We already have a connection. It must have been the case that we\n      // started two parallel connection attempts (because we wanted to\n      // 'reconnect now' on a hanging connection and we had no way to cancel the\n      // connection attempt.) But this shouldn't happen (similarly to the client\n      // !== self.client check above).\n      throw new Error(\"Two parallel connections?\");\n    }\n\n    self._clearConnectionTimer();\n\n    // update status\n    self.currentStatus.status = \"connected\";\n    self.currentStatus.connected = true;\n    self.currentStatus.retryCount = 0;\n    self.statusChanged();\n\n    // fire resets. This must come after status change so that clients\n    // can call send from within a reset callback.\n    _.each(self.eventCallbacks.reset, function (callback) { callback(); });\n  },\n\n  _cleanup: function (maybeError) {\n    var self = this;\n\n    self._clearConnectionTimer();\n    if (self.client) {\n      var client = self.client;\n      self.client = null;\n      client.close();\n\n      _.each(self.eventCallbacks.disconnect, function (callback) {\n        callback(maybeError);\n      });\n    }\n  },\n\n  _clearConnectionTimer: function () {\n    var self = this;\n\n    if (self.connectionTimer) {\n      clearTimeout(self.connectionTimer);\n      self.connectionTimer = null;\n    }\n  },\n\n  _getProxyUrl: function (targetUrl) {\n    var self = this;\n    // Similar to code in tools/http-helpers.js.\n    var proxy = process.env.HTTP_PROXY || process.env.http_proxy || null;\n    // if we're going to a secure url, try the https_proxy env variable first.\n    if (targetUrl.match(/^wss:/)) {\n      proxy = process.env.HTTPS_PROXY || process.env.https_proxy || proxy;\n    }\n    return proxy;\n  },\n\n  _launchConnection: function () {\n    var self = this;\n    self._cleanup(); // cleanup the old socket, if there was one.\n\n    // Since server-to-server DDP is still an experimental feature, we only\n    // require the module if we actually create a server-to-server\n    // connection.\n    var FayeWebSocket = Npm.require('faye-websocket');\n    var deflate = Npm.require('permessage-deflate');\n\n    var targetUrl = toWebsocketUrl(self.endpoint);\n    var fayeOptions = {\n      headers: self.headers,\n      extensions: [deflate]\n    };\n    fayeOptions = _.extend(fayeOptions, self.npmFayeOptions);\n    var proxyUrl = self._getProxyUrl(targetUrl);\n    if (proxyUrl) {\n      fayeOptions.proxy = { origin: proxyUrl };\n    };\n\n    // We would like to specify 'ddp' as the subprotocol here. The npm module we\n    // used to use as a client would fail the handshake if we ask for a\n    // subprotocol and the server doesn't send one back (and sockjs doesn't).\n    // Faye doesn't have that behavior; it's unclear from reading RFC 6455 if\n    // Faye is erroneous or not.  So for now, we don't specify protocols.\n    var subprotocols = [];\n\n    var client = self.client = new FayeWebSocket.Client(\n      targetUrl, subprotocols, fayeOptions);\n\n    self._clearConnectionTimer();\n    self.connectionTimer = Meteor.setTimeout(\n      function () {\n        self._lostConnection(\n          new DDP.ConnectionError(\"DDP connection timed out\"));\n      },\n      self.CONNECT_TIMEOUT);\n\n    self.client.on('open', Meteor.bindEnvironment(function () {\n      return self._onConnect(client);\n    }, \"stream connect callback\"));\n\n    var clientOnIfCurrent = function (event, description, f) {\n      self.client.on(event, Meteor.bindEnvironment(function () {\n        // Ignore events from any connection we've already cleaned up.\n        if (client !== self.client)\n          return;\n        f.apply(this, arguments);\n      }, description));\n    };\n\n    clientOnIfCurrent('error', 'stream error callback', function (error) {\n      if (!self.options._dontPrintErrors)\n        Meteor._debug(\"stream error\", error.message);\n\n      // Faye's 'error' object is not a JS error (and among other things,\n      // doesn't stringify well). Convert it to one.\n      self._lostConnection(new DDP.ConnectionError(error.message));\n    });\n\n\n    clientOnIfCurrent('close', 'stream close callback', function () {\n      self._lostConnection();\n    });\n\n\n    clientOnIfCurrent('message', 'stream message callback', function (message) {\n      // Ignore binary frames, where message.data is a Buffer\n      if (typeof message.data !== \"string\")\n        return;\n\n      _.each(self.eventCallbacks.message, function (callback) {\n        callback(message.data);\n      });\n    });\n  }\n});\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/ddp-client/stream_client_common.js                                                                //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\n// XXX from Underscore.String (http://epeli.github.com/underscore.string/)\nvar startsWith = function(str, starts) {\n  return str.length >= starts.length &&\n    str.substring(0, starts.length) === starts;\n};\nvar endsWith = function(str, ends) {\n  return str.length >= ends.length &&\n    str.substring(str.length - ends.length) === ends;\n};\n\n// @param url {String} URL to Meteor app, eg:\n//   \"/\" or \"madewith.meteor.com\" or \"https://foo.meteor.com\"\n//   or \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"\n// @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.\n// for scheme \"http\" and subPath \"sockjs\"\n//   \"http://subdomain.meteor.com/sockjs\" or \"/sockjs\"\n//   or \"https://ddp--1234-foo.meteor.com/sockjs\"\nvar translateUrl =  function(url, newSchemeBase, subPath) {\n  if (! newSchemeBase) {\n    newSchemeBase = \"http\";\n  }\n\n  var ddpUrlMatch = url.match(/^ddp(i?)\\+sockjs:\\/\\//);\n  var httpUrlMatch = url.match(/^http(s?):\\/\\//);\n  var newScheme;\n  if (ddpUrlMatch) {\n    // Remove scheme and split off the host.\n    var urlAfterDDP = url.substr(ddpUrlMatch[0].length);\n    newScheme = ddpUrlMatch[1] === \"i\" ? newSchemeBase : newSchemeBase + \"s\";\n    var slashPos = urlAfterDDP.indexOf('/');\n    var host =\n          slashPos === -1 ? urlAfterDDP : urlAfterDDP.substr(0, slashPos);\n    var rest = slashPos === -1 ? '' : urlAfterDDP.substr(slashPos);\n\n    // In the host (ONLY!), change '*' characters into random digits. This\n    // allows different stream connections to connect to different hostnames\n    // and avoid browser per-hostname connection limits.\n    host = host.replace(/\\*/g, function () {\n      return Math.floor(Random.fraction()*10);\n    });\n\n    return newScheme + '://' + host + rest;\n  } else if (httpUrlMatch) {\n    newScheme = !httpUrlMatch[1] ? newSchemeBase : newSchemeBase + \"s\";\n    var urlAfterHttp = url.substr(httpUrlMatch[0].length);\n    url = newScheme + \"://\" + urlAfterHttp;\n  }\n\n  // Prefix FQDNs but not relative URLs\n  if (url.indexOf(\"://\") === -1 && !startsWith(url, \"/\")) {\n    url = newSchemeBase + \"://\" + url;\n  }\n\n  // XXX This is not what we should be doing: if I have a site\n  // deployed at \"/foo\", then DDP.connect(\"/\") should actually connect\n  // to \"/\", not to \"/foo\". \"/\" is an absolute path. (Contrast: if\n  // deployed at \"/foo\", it would be reasonable for DDP.connect(\"bar\")\n  // to connect to \"/foo/bar\").\n  //\n  // We should make this properly honor absolute paths rather than\n  // forcing the path to be relative to the site root. Simultaneously,\n  // we should set DDP_DEFAULT_CONNECTION_URL to include the site\n  // root. See also client_convenience.js #RationalizingRelativeDDPURLs\n  url = Meteor._relativeToSiteRootUrl(url);\n\n  if (endsWith(url, \"/\"))\n    return url + subPath;\n  else\n    return url + \"/\" + subPath;\n};\n\ntoSockjsUrl = function (url) {\n  return translateUrl(url, \"http\", \"sockjs\");\n};\n\ntoWebsocketUrl = function (url) {\n  var ret = translateUrl(url, \"ws\", \"websocket\");\n  return ret;\n};\n\nLivedataTest.toSockjsUrl = toSockjsUrl;\n\n \n_.extend(LivedataTest.ClientStream.prototype, {\n\n  // Register for callbacks.\n  on: function (name, callback) {\n    var self = this;\n\n    if (name !== 'message' && name !== 'reset' && name !== 'disconnect')\n      throw new Error(\"unknown event type: \" + name);\n\n    if (!self.eventCallbacks[name])\n      self.eventCallbacks[name] = [];\n    self.eventCallbacks[name].push(callback);\n  },\n\n\n  _initCommon: function (options) {\n    var self = this;\n    options = options || {};\n\n    //// Constants\n\n    // how long to wait until we declare the connection attempt\n    // failed.\n    self.CONNECT_TIMEOUT = options.connectTimeoutMs || 10000;\n\n    self.eventCallbacks = {}; // name -> [callback]\n\n    self._forcedToDisconnect = false;\n\n    //// Reactive status\n    self.currentStatus = {\n      status: \"connecting\",\n      connected: false,\n      retryCount: 0\n    };\n\n\n    self.statusListeners = typeof Tracker !== 'undefined' && new Tracker.Dependency;\n    self.statusChanged = function () {\n      if (self.statusListeners)\n        self.statusListeners.changed();\n    };\n\n    //// Retry logic\n    self._retry = new Retry;\n    self.connectionTimer = null;\n\n  },\n\n  // Trigger a reconnect.\n  reconnect: function (options) {\n    var self = this;\n    options = options || {};\n\n    if (options.url) {\n      self._changeUrl(options.url);\n    }\n\n    if (options._sockjsOptions) {\n      self.options._sockjsOptions = options._sockjsOptions;\n    }\n\n    if (self.currentStatus.connected) {\n      if (options._force || options.url) {\n        // force reconnect.\n        self._lostConnection(new DDP.ForcedReconnectError);\n      } // else, noop.\n      return;\n    }\n\n    // if we're mid-connection, stop it.\n    if (self.currentStatus.status === \"connecting\") {\n      // Pretend it's a clean close.\n      self._lostConnection();\n    }\n\n    self._retry.clear();\n    self.currentStatus.retryCount -= 1; // don't count manual retries\n    self._retryNow();\n  },\n\n  disconnect: function (options) {\n    var self = this;\n    options = options || {};\n\n    // Failed is permanent. If we're failed, don't let people go back\n    // online by calling 'disconnect' then 'reconnect'.\n    if (self._forcedToDisconnect)\n      return;\n\n    // If _permanent is set, permanently disconnect a stream. Once a stream\n    // is forced to disconnect, it can never reconnect. This is for\n    // error cases such as ddp version mismatch, where trying again\n    // won't fix the problem.\n    if (options._permanent) {\n      self._forcedToDisconnect = true;\n    }\n\n    self._cleanup();\n    self._retry.clear();\n\n    self.currentStatus = {\n      status: (options._permanent ? \"failed\" : \"offline\"),\n      connected: false,\n      retryCount: 0\n    };\n\n    if (options._permanent && options._error)\n      self.currentStatus.reason = options._error;\n\n    self.statusChanged();\n  },\n\n  // maybeError is set unless it's a clean protocol-level close.\n  _lostConnection: function (maybeError) {\n    var self = this;\n\n    self._cleanup(maybeError);\n    self._retryLater(maybeError); // sets status. no need to do it here.\n  },\n\n  // fired when we detect that we've gone online. try to reconnect\n  // immediately.\n  _online: function () {\n    // if we've requested to be offline by disconnecting, don't reconnect.\n    if (this.currentStatus.status != \"offline\")\n      this.reconnect();\n  },\n\n  _retryLater: function (maybeError) {\n    var self = this;\n\n    var timeout = 0;\n    if (self.options.retry ||\n        (maybeError && maybeError.errorType === \"DDP.ForcedReconnectError\")) {\n      timeout = self._retry.retryLater(\n        self.currentStatus.retryCount,\n        _.bind(self._retryNow, self)\n      );\n      self.currentStatus.status = \"waiting\";\n      self.currentStatus.retryTime = (new Date()).getTime() + timeout;\n    } else {\n      self.currentStatus.status = \"failed\";\n      delete self.currentStatus.retryTime;\n    }\n\n    self.currentStatus.connected = false;\n    self.statusChanged();\n  },\n\n  _retryNow: function () {\n    var self = this;\n\n    if (self._forcedToDisconnect)\n      return;\n\n    self.currentStatus.retryCount += 1;\n    self.currentStatus.status = \"connecting\";\n    self.currentStatus.connected = false;\n    delete self.currentStatus.retryTime;\n    self.statusChanged();\n\n    self._launchConnection();\n  },\n\n\n  // Get current status. Reactive.\n  status: function () {\n    var self = this;\n    if (self.statusListeners)\n      self.statusListeners.depend();\n    return self.currentStatus;\n  }\n});\n\nDDP.ConnectionError = Meteor.makeErrorType(\n  \"DDP.ConnectionError\", function (message) {\n    var self = this;\n    self.message = message;\n});\n\nDDP.ForcedReconnectError = Meteor.makeErrorType(\n  \"DDP.ForcedReconnectError\", function () {});\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/ddp-client/livedata_common.js                                                                     //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\nLivedataTest.SUPPORTED_DDP_VERSIONS = DDPCommon.SUPPORTED_DDP_VERSIONS;\n\n// This is private but it's used in a few places. accounts-base uses\n// it to get the current user. Meteor.setTimeout and friends clear\n// it. We can probably find a better way to factor this.\nDDP._CurrentInvocation = new Meteor.EnvironmentVariable;\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/ddp-client/random_stream.js                                                                       //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\n// Returns the named sequence of pseudo-random values.\n// The scope will be DDP._CurrentInvocation.get(), so the stream will produce\n// consistent values for method calls on the client and server.\nDDP.randomStream = function (name) {\n  var scope = DDP._CurrentInvocation.get();\n  return DDPCommon.RandomStream.get(scope, name);\n};\n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/ddp-client/livedata_connection.js                                                                 //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\nif (Meteor.isServer) {\n  var path = Npm.require('path');\n  var Fiber = Npm.require('fibers');\n  var Future = Npm.require(path.join('fibers', 'future'));\n}\n\n// @param url {String|Object} URL to Meteor app,\n//   or an object as a test hook (see code)\n// Options:\n//   reloadWithOutstanding: is it OK to reload if there are outstanding methods?\n//   headers: extra headers to send on the websockets connection, for\n//     server-to-server DDP only\n//   _sockjsOptions: Specifies options to pass through to the sockjs client\n//   onDDPNegotiationVersionFailure: callback when version negotiation fails.\n//\n// XXX There should be a way to destroy a DDP connection, causing all\n// outstanding method calls to fail.\n//\n// XXX Our current way of handling failure and reconnection is great\n// for an app (where we want to tolerate being disconnected as an\n// expect state, and keep trying forever to reconnect) but cumbersome\n// for something like a command line tool that wants to make a\n// connection, call a method, and print an error if connection\n// fails. We should have better usability in the latter case (while\n// still transparently reconnecting if it's just a transient failure\n// or the server migrating us).\nvar Connection = function (url, options) {\n  var self = this;\n  options = _.extend({\n    onConnected: function () {},\n    onDDPVersionNegotiationFailure: function (description) {\n      Meteor._debug(description);\n    },\n    heartbeatInterval: 17500,\n    heartbeatTimeout: 15000,\n    npmFayeOptions: {},\n    // These options are only for testing.\n    reloadWithOutstanding: false,\n    supportedDDPVersions: DDPCommon.SUPPORTED_DDP_VERSIONS,\n    retry: true,\n    respondToPings: true,\n    // When updates are coming within this ms interval, batch them together.\n    bufferedWritesInterval: 5,\n    // Flush buffers immediately if writes are happening continuously for more than this many ms.\n    bufferedWritesMaxAge: 500\n  }, options);\n\n  // If set, called when we reconnect, queuing method calls _before_ the\n  // existing outstanding ones. This is the only data member that is part of the\n  // public API!\n  self.onReconnect = null;\n\n  // as a test hook, allow passing a stream instead of a url.\n  if (typeof url === \"object\") {\n    self._stream = url;\n  } else {\n    self._stream = new LivedataTest.ClientStream(url, {\n      retry: options.retry,\n      headers: options.headers,\n      _sockjsOptions: options._sockjsOptions,\n      // Used to keep some tests quiet, or for other cases in which\n      // the right thing to do with connection errors is to silently\n      // fail (e.g. sending package usage stats). At some point we\n      // should have a real API for handling client-stream-level\n      // errors.\n      _dontPrintErrors: options._dontPrintErrors,\n      connectTimeoutMs: options.connectTimeoutMs,\n      npmFayeOptions: options.npmFayeOptions\n    });\n  }\n\n  self._lastSessionId = null;\n  self._versionSuggestion = null;  // The last proposed DDP version.\n  self._version = null;   // The DDP version agreed on by client and server.\n  self._stores = {}; // name -> object with methods\n  self._methodHandlers = {}; // name -> func\n  self._nextMethodId = 1;\n  self._supportedDDPVersions = options.supportedDDPVersions;\n\n  self._heartbeatInterval = options.heartbeatInterval;\n  self._heartbeatTimeout = options.heartbeatTimeout;\n\n  // Tracks methods which the user has tried to call but which have not yet\n  // called their user callback (ie, they are waiting on their result or for all\n  // of their writes to be written to the local cache). Map from method ID to\n  // MethodInvoker object.\n  self._methodInvokers = {};\n\n  // Tracks methods which the user has called but whose result messages have not\n  // arrived yet.\n  //\n  // _outstandingMethodBlocks is an array of blocks of methods. Each block\n  // represents a set of methods that can run at the same time. The first block\n  // represents the methods which are currently in flight; subsequent blocks\n  // must wait for previous blocks to be fully finished before they can be sent\n  // to the server.\n  //\n  // Each block is an object with the following fields:\n  // - methods: a list of MethodInvoker objects\n  // - wait: a boolean; if true, this block had a single method invoked with\n  //         the \"wait\" option\n  //\n  // There will never be adjacent blocks with wait=false, because the only thing\n  // that makes methods need to be serialized is a wait method.\n  //\n  // Methods are removed from the first block when their \"result\" is\n  // received. The entire first block is only removed when all of the in-flight\n  // methods have received their results (so the \"methods\" list is empty) *AND*\n  // all of the data written by those methods are visible in the local cache. So\n  // it is possible for the first block's methods list to be empty, if we are\n  // still waiting for some objects to quiesce.\n  //\n  // Example:\n  //  _outstandingMethodBlocks = [\n  //    {wait: false, methods: []},\n  //    {wait: true, methods: [<MethodInvoker for 'login'>]},\n  //    {wait: false, methods: [<MethodInvoker for 'foo'>,\n  //                            <MethodInvoker for 'bar'>]}]\n  // This means that there were some methods which were sent to the server and\n  // which have returned their results, but some of the data written by\n  // the methods may not be visible in the local cache. Once all that data is\n  // visible, we will send a 'login' method. Once the login method has returned\n  // and all the data is visible (including re-running subs if userId changes),\n  // we will send the 'foo' and 'bar' methods in parallel.\n  self._outstandingMethodBlocks = [];\n\n  // method ID -> array of objects with keys 'collection' and 'id', listing\n  // documents written by a given method's stub. keys are associated with\n  // methods whose stub wrote at least one document, and whose data-done message\n  // has not yet been received.\n  self._documentsWrittenByStub = {};\n  // collection -> IdMap of \"server document\" object. A \"server document\" has:\n  // - \"document\": the version of the document according the\n  //   server (ie, the snapshot before a stub wrote it, amended by any changes\n  //   received from the server)\n  //   It is undefined if we think the document does not exist\n  // - \"writtenByStubs\": a set of method IDs whose stubs wrote to the document\n  //   whose \"data done\" messages have not yet been processed\n  self._serverDocuments = {};\n\n  // Array of callbacks to be called after the next update of the local\n  // cache. Used for:\n  //  - Calling methodInvoker.dataVisible and sub ready callbacks after\n  //    the relevant data is flushed.\n  //  - Invoking the callbacks of \"half-finished\" methods after reconnect\n  //    quiescence. Specifically, methods whose result was received over the old\n  //    connection (so we don't re-send it) but whose data had not been made\n  //    visible.\n  self._afterUpdateCallbacks = [];\n\n  // In two contexts, we buffer all incoming data messages and then process them\n  // all at once in a single update:\n  //   - During reconnect, we buffer all data messages until all subs that had\n  //     been ready before reconnect are ready again, and all methods that are\n  //     active have returned their \"data done message\"; then\n  //   - During the execution of a \"wait\" method, we buffer all data messages\n  //     until the wait method gets its \"data done\" message. (If the wait method\n  //     occurs during reconnect, it doesn't get any special handling.)\n  // all data messages are processed in one update.\n  //\n  // The following fields are used for this \"quiescence\" process.\n\n  // This buffers the messages that aren't being processed yet.\n  self._messagesBufferedUntilQuiescence = [];\n  // Map from method ID -> true. Methods are removed from this when their\n  // \"data done\" message is received, and we will not quiesce until it is\n  // empty.\n  self._methodsBlockingQuiescence = {};\n  // map from sub ID -> true for subs that were ready (ie, called the sub\n  // ready callback) before reconnect but haven't become ready again yet\n  self._subsBeingRevived = {}; // map from sub._id -> true\n  // if true, the next data update should reset all stores. (set during\n  // reconnect.)\n  self._resetStores = false;\n\n  // name -> array of updates for (yet to be created) collections\n  self._updatesForUnknownStores = {};\n  // if we're blocking a migration, the retry func\n  self._retryMigrate = null;\n\n  self.__flushBufferedWrites = Meteor.bindEnvironment(\n    self._flushBufferedWrites, \"flushing DDP buffered writes\", self);\n  // Collection name -> array of messages.\n  self._bufferedWrites = {};\n  // When current buffer of updates must be flushed at, in ms timestamp.\n  self._bufferedWritesFlushAt = null;\n  // Timeout handle for the next processing of all pending writes\n  self._bufferedWritesFlushHandle = null;\n\n  self._bufferedWritesInterval = options.bufferedWritesInterval;\n  self._bufferedWritesMaxAge = options.bufferedWritesMaxAge;\n\n  // metadata for subscriptions.  Map from sub ID to object with keys:\n  //   - id\n  //   - name\n  //   - params\n  //   - inactive (if true, will be cleaned up if not reused in re-run)\n  //   - ready (has the 'ready' message been received?)\n  //   - readyCallback (an optional callback to call when ready)\n  //   - errorCallback (an optional callback to call if the sub terminates with\n  //                    an error, XXX COMPAT WITH 1.0.3.1)\n  //   - stopCallback (an optional callback to call when the sub terminates\n  //     for any reason, with an error argument if an error triggered the stop)\n  self._subscriptions = {};\n\n  // Reactive userId.\n  self._userId = null;\n  self._userIdDeps = new Tracker.Dependency;\n\n  // Block auto-reload while we're waiting for method responses.\n  if (Meteor.isClient && Package.reload && !options.reloadWithOutstanding) {\n    Package.reload.Reload._onMigrate(function (retry) {\n      if (!self._readyToMigrate()) {\n        if (self._retryMigrate)\n          throw new Error(\"Two migrations in progress?\");\n        self._retryMigrate = retry;\n        return false;\n      } else {\n        return [true];\n      }\n    });\n  }\n\n  var onMessage = function (raw_msg) {\n    try {\n      var msg = DDPCommon.parseDDP(raw_msg);\n    } catch (e) {\n      Meteor._debug(\"Exception while parsing DDP\", e);\n      return;\n    }\n\n    // Any message counts as receiving a pong, as it demonstrates that\n    // the server is still alive.\n    if (self._heartbeat) {\n      self._heartbeat.messageReceived();\n    }\n\n    if (msg === null || !msg.msg) {\n      // XXX COMPAT WITH 0.6.6. ignore the old welcome message for back\n      // compat.  Remove this 'if' once the server stops sending welcome\n      // messages (stream_server.js).\n      if (! (msg && msg.server_id))\n        Meteor._debug(\"discarding invalid livedata message\", msg);\n      return;\n    }\n\n    if (msg.msg === 'connected') {\n      self._version = self._versionSuggestion;\n      self._livedata_connected(msg);\n      options.onConnected();\n    }\n    else if (msg.msg === 'failed') {\n      if (_.contains(self._supportedDDPVersions, msg.version)) {\n        self._versionSuggestion = msg.version;\n        self._stream.reconnect({_force: true});\n      } else {\n        var description =\n              \"DDP version negotiation failed; server requested version \" + msg.version;\n        self._stream.disconnect({_permanent: true, _error: description});\n        options.onDDPVersionNegotiationFailure(description);\n      }\n    }\n    else if (msg.msg === 'ping' && options.respondToPings) {\n      self._send({msg: \"pong\", id: msg.id});\n    }\n    else if (msg.msg === 'pong') {\n      // noop, as we assume everything's a pong\n    }\n    else if (_.include(['added', 'changed', 'removed', 'ready', 'updated'], msg.msg))\n      self._livedata_data(msg);\n    else if (msg.msg === 'nosub')\n      self._livedata_nosub(msg);\n    else if (msg.msg === 'result')\n      self._livedata_result(msg);\n    else if (msg.msg === 'error')\n      self._livedata_error(msg);\n    else\n      Meteor._debug(\"discarding unknown livedata message type\", msg);\n  };\n\n  var onReset = function () {\n    // Send a connect message at the beginning of the stream.\n    // NOTE: reset is called even on the first connection, so this is\n    // the only place we send this message.\n    var msg = {msg: 'connect'};\n    if (self._lastSessionId)\n      msg.session = self._lastSessionId;\n    msg.version = self._versionSuggestion || self._supportedDDPVersions[0];\n    self._versionSuggestion = msg.version;\n    msg.support = self._supportedDDPVersions;\n    self._send(msg);\n\n    // Mark non-retry calls as failed. This has to be done early as getting these methods out of the\n    // current block is pretty important to making sure that quiescence is properly calculated, as\n    // well as possibly moving on to another useful block.\n\n    // Only bother testing if there is an outstandingMethodBlock (there might not be, especially if\n    // we are connecting for the first time.\n    if (self._outstandingMethodBlocks.length > 0) {\n      // If there is an outstanding method block, we only care about the first one as that is the\n      // one that could have already sent messages with no response, that are not allowed to retry.\n      _.each(self._outstandingMethodBlocks[0].methods, function(methodInvoker) {\n        // If the message wasn't sent or it's allowed to retry, do nothing.\n        if (methodInvoker.sentMessage && methodInvoker.noRetry) {\n          // The next loop serves to get the index in the current method block of this method.\n          var currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n          var loopMethod;\n          for (var i = 0; i < currentMethodBlock.length; i++) {\n            loopMethod = currentMethodBlock[i];\n            if (loopMethod.methodId === methodInvoker.methodId) {\n              break;\n            }\n          }\n\n          // Remove from current method block. This may leave the block empty, but we\n          // don't move on to the next block until the callback has been delivered, in\n          // _outstandingMethodFinished.\n          currentMethodBlock.splice(i, 1);\n\n          // Make sure that the method is told that it failed.\n          methodInvoker.receiveResult(new Meteor.Error('invocation-failed',\n            'Method invocation might have failed due to dropped connection. ' +\n            'Failing because `noRetry` option was passed to Meteor.apply.'));\n        }\n      });\n    }\n\n    // Now, to minimize setup latency, go ahead and blast out all of\n    // our pending methods ands subscriptions before we've even taken\n    // the necessary RTT to know if we successfully reconnected. (1)\n    // They're supposed to be idempotent, and where they are not,\n    // they can block retry in apply; (2) even if we did reconnect,\n    // we're not sure what messages might have gotten lost\n    // (in either direction) since we were disconnected (TCP being\n    // sloppy about that.)\n\n    // If the current block of methods all got their results (but didn't all get\n    // their data visible), discard the empty block now.\n    if (! _.isEmpty(self._outstandingMethodBlocks) &&\n        _.isEmpty(self._outstandingMethodBlocks[0].methods)) {\n      self._outstandingMethodBlocks.shift();\n    }\n\n    // Mark all messages as unsent, they have not yet been sent on this\n    // connection.\n    _.each(self._methodInvokers, function (m) {\n      m.sentMessage = false;\n    });\n\n    // If an `onReconnect` handler is set, call it first. Go through\n    // some hoops to ensure that methods that are called from within\n    // `onReconnect` get executed _before_ ones that were originally\n    // outstanding (since `onReconnect` is used to re-establish auth\n    // certificates)\n    if (self.onReconnect)\n      self._callOnReconnectAndSendAppropriateOutstandingMethods();\n    else\n      self._sendOutstandingMethods();\n\n    // add new subscriptions at the end. this way they take effect after\n    // the handlers and we don't see flicker.\n    _.each(self._subscriptions, function (sub, id) {\n      self._send({\n        msg: 'sub',\n        id: id,\n        name: sub.name,\n        params: sub.params\n      });\n    });\n  };\n\n  var onDisconnect = function () {\n    if (self._heartbeat) {\n      self._heartbeat.stop();\n      self._heartbeat = null;\n    }\n  };\n\n  if (Meteor.isServer) {\n    self._stream.on('message', Meteor.bindEnvironment(onMessage, \"handling DDP message\"));\n    self._stream.on('reset', Meteor.bindEnvironment(onReset, \"handling DDP reset\"));\n    self._stream.on('disconnect', Meteor.bindEnvironment(onDisconnect, \"handling DDP disconnect\"));\n  } else {\n    self._stream.on('message', onMessage);\n    self._stream.on('reset', onReset);\n    self._stream.on('disconnect', onDisconnect);\n  }\n};\n\n// A MethodInvoker manages sending a method to the server and calling the user's\n// callbacks. On construction, it registers itself in the connection's\n// _methodInvokers map; it removes itself once the method is fully finished and\n// the callback is invoked. This occurs when it has both received a result,\n// and the data written by it is fully visible.\nvar MethodInvoker = function (options) {\n  var self = this;\n\n  // Public (within this file) fields.\n  self.methodId = options.methodId;\n  self.sentMessage = false;\n\n  self._callback = options.callback;\n  self._connection = options.connection;\n  self._message = options.message;\n  self._onResultReceived = options.onResultReceived || function () {};\n  self._wait = options.wait;\n  self.noRetry = options.noRetry;\n  self._methodResult = null;\n  self._dataVisible = false;\n\n  // Register with the connection.\n  self._connection._methodInvokers[self.methodId] = self;\n};\n_.extend(MethodInvoker.prototype, {\n  // Sends the method message to the server. May be called additional times if\n  // we lose the connection and reconnect before receiving a result.\n  sendMessage: function () {\n    var self = this;\n    // This function is called before sending a method (including resending on\n    // reconnect). We should only (re)send methods where we don't already have a\n    // result!\n    if (self.gotResult())\n      throw new Error(\"sendingMethod is called on method with result\");\n\n\n    // If we're re-sending it, it doesn't matter if data was written the first\n    // time.\n    self._dataVisible = false;\n    self.sentMessage = true;\n\n    // If this is a wait method, make all data messages be buffered until it is\n    // done.\n    if (self._wait)\n      self._connection._methodsBlockingQuiescence[self.methodId] = true;\n\n    // Actually send the message.\n    self._connection._send(self._message);\n  },\n  // Invoke the callback, if we have both a result and know that all data has\n  // been written to the local cache.\n  _maybeInvokeCallback: function () {\n    var self = this;\n    if (self._methodResult && self._dataVisible) {\n      // Call the callback. (This won't throw: the callback was wrapped with\n      // bindEnvironment.)\n      self._callback(self._methodResult[0], self._methodResult[1]);\n\n      // Forget about this method.\n      delete self._connection._methodInvokers[self.methodId];\n\n      // Let the connection know that this method is finished, so it can try to\n      // move on to the next block of methods.\n      self._connection._outstandingMethodFinished();\n    }\n  },\n  // Call with the result of the method from the server. Only may be called\n  // once; once it is called, you should not call sendMessage again.\n  // If the user provided an onResultReceived callback, call it immediately.\n  // Then invoke the main callback if data is also visible.\n  receiveResult: function (err, result) {\n    var self = this;\n    if (self.gotResult())\n      throw new Error(\"Methods should only receive results once\");\n    self._methodResult = [err, result];\n    self._onResultReceived(err, result);\n    self._maybeInvokeCallback();\n  },\n  // Call this when all data written by the method is visible. This means that\n  // the method has returns its \"data is done\" message *AND* all server\n  // documents that are buffered at that time have been written to the local\n  // cache. Invokes the main callback if the result has been received.\n  dataVisible: function () {\n    var self = this;\n    self._dataVisible = true;\n    self._maybeInvokeCallback();\n  },\n  // True if receiveResult has been called.\n  gotResult: function () {\n    var self = this;\n    return !!self._methodResult;\n  }\n});\n\n_.extend(Connection.prototype, {\n  // 'name' is the name of the data on the wire that should go in the\n  // store. 'wrappedStore' should be an object with methods beginUpdate, update,\n  // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.\n  registerStore: function (name, wrappedStore) {\n    var self = this;\n\n    if (name in self._stores)\n      return false;\n\n    // Wrap the input object in an object which makes any store method not\n    // implemented by 'store' into a no-op.\n    var store = {};\n    _.each(['update', 'beginUpdate', 'endUpdate', 'saveOriginals',\n            'retrieveOriginals', 'getDoc',\n\t\t\t'_getCollection'], function (method) {\n              store[method] = function () {\n                return (wrappedStore[method]\n                        ? wrappedStore[method].apply(wrappedStore, arguments)\n                        : undefined);\n              };\n            });\n\n    self._stores[name] = store;\n\n    var queued = self._updatesForUnknownStores[name];\n    if (queued) {\n      store.beginUpdate(queued.length, false);\n      _.each(queued, function (msg) {\n        store.update(msg);\n      });\n      store.endUpdate();\n      delete self._updatesForUnknownStores[name];\n    }\n\n    return true;\n  },\n\n  /**\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @summary Subscribe to a record set.  Returns a handle that provides\n   * `stop()` and `ready()` methods.\n   * @locus Client\n   * @param {String} name Name of the subscription.  Matches the name of the\n   * server's `publish()` call.\n   * @param {EJSONable} [arg1,arg2...] Optional arguments passed to publisher\n   * function on server.\n   * @param {Function|Object} [callbacks] Optional. May include `onStop`\n   * and `onReady` callbacks. If there is an error, it is passed as an\n   * argument to `onStop`. If a function is passed instead of an object, it\n   * is interpreted as an `onReady` callback.\n   */\n  subscribe: function (name /* .. [arguments] .. (callback|callbacks) */) {\n    var self = this;\n\n    var params = Array.prototype.slice.call(arguments, 1);\n    var callbacks = {};\n    if (params.length) {\n      var lastParam = params[params.length - 1];\n      if (_.isFunction(lastParam)) {\n        callbacks.onReady = params.pop();\n      } else if (lastParam &&\n        // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use\n        // onStop with an error callback instead.\n        _.any([lastParam.onReady, lastParam.onError, lastParam.onStop],\n          _.isFunction)) {\n        callbacks = params.pop();\n      }\n    }\n\n    // Is there an existing sub with the same name and param, run in an\n    // invalidated Computation? This will happen if we are rerunning an\n    // existing computation.\n    //\n    // For example, consider a rerun of:\n    //\n    //     Tracker.autorun(function () {\n    //       Meteor.subscribe(\"foo\", Session.get(\"foo\"));\n    //       Meteor.subscribe(\"bar\", Session.get(\"bar\"));\n    //     });\n    //\n    // If \"foo\" has changed but \"bar\" has not, we will match the \"bar\"\n    // subcribe to an existing inactive subscription in order to not\n    // unsub and resub the subscription unnecessarily.\n    //\n    // We only look for one such sub; if there are N apparently-identical subs\n    // being invalidated, we will require N matching subscribe calls to keep\n    // them all active.\n    var existing = _.find(self._subscriptions, function (sub) {\n      return sub.inactive && sub.name === name &&\n        EJSON.equals(sub.params, params);\n    });\n\n    var id;\n    if (existing) {\n      id = existing.id;\n      existing.inactive = false; // reactivate\n\n      if (callbacks.onReady) {\n        // If the sub is not already ready, replace any ready callback with the\n        // one provided now. (It's not really clear what users would expect for\n        // an onReady callback inside an autorun; the semantics we provide is\n        // that at the time the sub first becomes ready, we call the last\n        // onReady callback provided, if any.)\n        if (!existing.ready)\n          existing.readyCallback = callbacks.onReady;\n      }\n\n      // XXX COMPAT WITH 1.0.3.1 we used to have onError but now we call\n      // onStop with an optional error argument\n      if (callbacks.onError) {\n        // Replace existing callback if any, so that errors aren't\n        // double-reported.\n        existing.errorCallback = callbacks.onError;\n      }\n\n      if (callbacks.onStop) {\n        existing.stopCallback = callbacks.onStop;\n      }\n    } else {\n      // New sub! Generate an id, save it locally, and send message.\n      id = Random.id();\n      self._subscriptions[id] = {\n        id: id,\n        name: name,\n        params: EJSON.clone(params),\n        inactive: false,\n        ready: false,\n        readyDeps: new Tracker.Dependency,\n        readyCallback: callbacks.onReady,\n        // XXX COMPAT WITH 1.0.3.1 #errorCallback\n        errorCallback: callbacks.onError,\n        stopCallback: callbacks.onStop,\n        connection: self,\n        remove: function() {\n          delete this.connection._subscriptions[this.id];\n          this.ready && this.readyDeps.changed();\n        },\n        stop: function() {\n          this.connection._send({msg: 'unsub', id: id});\n          this.remove();\n\n          if (callbacks.onStop) {\n            callbacks.onStop();\n          }\n        }\n      };\n      self._send({msg: 'sub', id: id, name: name, params: params});\n    }\n\n    // return a handle to the application.\n    var handle = {\n      stop: function () {\n        if (!_.has(self._subscriptions, id))\n          return;\n\n        self._subscriptions[id].stop();\n      },\n      ready: function () {\n        // return false if we've unsubscribed.\n        if (!_.has(self._subscriptions, id))\n          return false;\n        var record = self._subscriptions[id];\n        record.readyDeps.depend();\n        return record.ready;\n      },\n      subscriptionId: id\n    };\n\n    if (Tracker.active) {\n      // We're in a reactive computation, so we'd like to unsubscribe when the\n      // computation is invalidated... but not if the rerun just re-subscribes\n      // to the same subscription!  When a rerun happens, we use onInvalidate\n      // as a change to mark the subscription \"inactive\" so that it can\n      // be reused from the rerun.  If it isn't reused, it's killed from\n      // an afterFlush.\n      Tracker.onInvalidate(function (c) {\n        if (_.has(self._subscriptions, id))\n          self._subscriptions[id].inactive = true;\n\n        Tracker.afterFlush(function () {\n          if (_.has(self._subscriptions, id) &&\n              self._subscriptions[id].inactive)\n            handle.stop();\n        });\n      });\n    }\n\n    return handle;\n  },\n\n  // options:\n  // - onLateError {Function(error)} called if an error was received after the ready event.\n  //     (errors received before ready cause an error to be thrown)\n  _subscribeAndWait: function (name, args, options) {\n    var self = this;\n    var f = new Future();\n    var ready = false;\n    var handle;\n    args = args || [];\n    args.push({\n      onReady: function () {\n        ready = true;\n        f['return']();\n      },\n      onError: function (e) {\n        if (!ready)\n          f['throw'](e);\n        else\n          options && options.onLateError && options.onLateError(e);\n      }\n    });\n\n    handle = self.subscribe.apply(self, [name].concat(args));\n    f.wait();\n    return handle;\n  },\n\n  methods: function (methods) {\n    var self = this;\n    _.each(methods, function (func, name) {\n      if (typeof func !== 'function')\n        throw new Error(\"Method '\" + name + \"' must be a function\");\n      if (self._methodHandlers[name])\n        throw new Error(\"A method named '\" + name + \"' is already defined\");\n      self._methodHandlers[name] = func;\n    });\n  },\n\n  /**\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @summary Invokes a method passing any number of arguments.\n   * @locus Anywhere\n   * @param {String} name Name of method to invoke\n   * @param {EJSONable} [arg1,arg2...] Optional method arguments\n   * @param {Function} [asyncCallback] Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).\n   */\n  call: function (name /* .. [arguments] .. callback */) {\n    // if it's a function, the last argument is the result callback,\n    // not a parameter to the remote method.\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (args.length && typeof args[args.length - 1] === \"function\")\n      var callback = args.pop();\n    return this.apply(name, args, callback);\n  },\n\n  // @param options {Optional Object}\n  //   wait: Boolean - Should we wait to call this until all current methods\n  //                   are fully finished, and block subsequent method calls\n  //                   until this method is fully finished?\n  //                   (does not affect methods called from within this method)\n  //   onResultReceived: Function - a callback to call as soon as the method\n  //                                result is received. the data written by\n  //                                the method may not yet be in the cache!\n  //   returnStubValue: Boolean - If true then in cases where we would have\n  //                              otherwise discarded the stub's return value\n  //                              and returned undefined, instead we go ahead\n  //                              and return it.  Specifically, this is any\n  //                              time other than when (a) we are already\n  //                              inside a stub or (b) we are in Node and no\n  //                              callback was provided.  Currently we require\n  //                              this flag to be explicitly passed to reduce\n  //                              the likelihood that stub return values will\n  //                              be confused with server return values; we\n  //                              may improve this in future.\n  // @param callback {Optional Function}\n\n  /**\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @summary Invoke a method passing an array of arguments.\n   * @locus Anywhere\n   * @param {String} name Name of method to invoke\n   * @param {EJSONable[]} args Method arguments\n   * @param {Object} [options]\n   * @param {Boolean} options.wait (Client only) If true, don't send this method until all previous method calls have completed, and don't send any subsequent method calls until this one is completed.\n   * @param {Function} options.onResultReceived (Client only) This callback is invoked with the error or result of the method (just like `asyncCallback`) as soon as the error or result is available. The local cache may not yet reflect the writes performed by the method.\n   * @param {Boolean} options.noRetry (Client only) if true, don't send this method again on reload, simply call the callback an error with the error code 'invocation-failed'.\n   * @param {Function} [asyncCallback] Optional callback; same semantics as in [`Meteor.call`](#meteor_call).\n   */\n  apply: function (name, args, options, callback) {\n    var self = this;\n\n    // We were passed 3 arguments. They may be either (name, args, options)\n    // or (name, args, callback)\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    options = options || {};\n\n    if (callback) {\n      // XXX would it be better form to do the binding in stream.on,\n      // or caller, instead of here?\n      // XXX improve error message (and how we report it)\n      callback = Meteor.bindEnvironment(\n        callback,\n        \"delivering result of invoking '\" + name + \"'\"\n      );\n    }\n\n    // Keep our args safe from mutation (eg if we don't send the message for a\n    // while because of a wait method).\n    args = EJSON.clone(args);\n\n    // Lazily allocate method ID once we know that it'll be needed.\n    var methodId = (function () {\n      var id;\n      return function () {\n        if (id === undefined)\n          id = '' + (self._nextMethodId++);\n        return id;\n      };\n    })();\n\n    var enclosing = DDP._CurrentInvocation.get();\n    var alreadyInSimulation = enclosing && enclosing.isSimulation;\n\n    // Lazily generate a randomSeed, only if it is requested by the stub.\n    // The random streams only have utility if they're used on both the client\n    // and the server; if the client doesn't generate any 'random' values\n    // then we don't expect the server to generate any either.\n    // Less commonly, the server may perform different actions from the client,\n    // and may in fact generate values where the client did not, but we don't\n    // have any client-side values to match, so even here we may as well just\n    // use a random seed on the server.  In that case, we don't pass the\n    // randomSeed to save bandwidth, and we don't even generate it to save a\n    // bit of CPU and to avoid consuming entropy.\n    var randomSeed = null;\n    var randomSeedGenerator = function () {\n      if (randomSeed === null) {\n        randomSeed = DDPCommon.makeRpcSeed(enclosing, name);\n      }\n      return randomSeed;\n    };\n\n    // Run the stub, if we have one. The stub is supposed to make some\n    // temporary writes to the database to give the user a smooth experience\n    // until the actual result of executing the method comes back from the\n    // server (whereupon the temporary writes to the database will be reversed\n    // during the beginUpdate/endUpdate process.)\n    //\n    // Normally, we ignore the return value of the stub (even if it is an\n    // exception), in favor of the real return value from the server. The\n    // exception is if the *caller* is a stub. In that case, we're not going\n    // to do a RPC, so we use the return value of the stub as our return\n    // value.\n\n    var stub = self._methodHandlers[name];\n    if (stub) {\n      var setUserId = function(userId) {\n        self.setUserId(userId);\n      };\n\n      var invocation = new DDPCommon.MethodInvocation({\n        isSimulation: true,\n        userId: self.userId(),\n        setUserId: setUserId,\n        randomSeed: function () { return randomSeedGenerator(); }\n      });\n\n      if (!alreadyInSimulation)\n        self._saveOriginals();\n\n      try {\n        // Note that unlike in the corresponding server code, we never audit\n        // that stubs check() their arguments.\n        var stubReturnValue = DDP._CurrentInvocation.withValue(invocation, function () {\n          if (Meteor.isServer) {\n            // Because saveOriginals and retrieveOriginals aren't reentrant,\n            // don't allow stubs to yield.\n            return Meteor._noYieldsAllowed(function () {\n              // re-clone, so that the stub can't affect our caller's values\n              return stub.apply(invocation, EJSON.clone(args));\n            });\n          } else {\n            return stub.apply(invocation, EJSON.clone(args));\n          }\n        });\n      }\n      catch (e) {\n        var exception = e;\n      }\n\n      if (!alreadyInSimulation)\n        self._retrieveAndStoreOriginals(methodId());\n    }\n\n    // If we're in a simulation, stop and return the result we have,\n    // rather than going on to do an RPC. If there was no stub,\n    // we'll end up returning undefined.\n    if (alreadyInSimulation) {\n      if (callback) {\n        callback(exception, stubReturnValue);\n        return undefined;\n      }\n      if (exception)\n        throw exception;\n      return stubReturnValue;\n    }\n\n    // If an exception occurred in a stub, and we're ignoring it\n    // because we're doing an RPC and want to use what the server\n    // returns instead, log it so the developer knows\n    // (unless they explicitly ask to see the error).\n    //\n    // Tests can set the 'expected' flag on an exception so it won't\n    // go to log.\n    if (exception) {\n      if (options.throwStubExceptions) {\n        throw exception;\n      } else if (!exception.expected) {\n        Meteor._debug(\"Exception while simulating the effect of invoking '\" +\n          name + \"'\", exception, exception.stack);\n      }\n    }\n\n\n    // At this point we're definitely doing an RPC, and we're going to\n    // return the value of the RPC to the caller.\n\n    // If the caller didn't give a callback, decide what to do.\n    if (!callback) {\n      if (Meteor.isClient) {\n        // On the client, we don't have fibers, so we can't block. The\n        // only thing we can do is to return undefined and discard the\n        // result of the RPC. If an error occurred then print the error\n        // to the console.\n        callback = function (err) {\n          err && Meteor._debug(\"Error invoking Method '\" + name + \"':\",\n                               err.message);\n        };\n      } else {\n        // On the server, make the function synchronous. Throw on\n        // errors, return on success.\n        var future = new Future;\n        callback = future.resolver();\n      }\n    }\n    // Send the RPC. Note that on the client, it is important that the\n    // stub have finished before we send the RPC, so that we know we have\n    // a complete list of which local documents the stub wrote.\n    var message = {\n      msg: 'method',\n      method: name,\n      params: args,\n      id: methodId()\n    };\n\n    // Send the randomSeed only if we used it\n    if (randomSeed !== null) {\n      message.randomSeed = randomSeed;\n    }\n\n    var methodInvoker = new MethodInvoker({\n      methodId: methodId(),\n      callback: callback,\n      connection: self,\n      onResultReceived: options.onResultReceived,\n      wait: !!options.wait,\n      message: message,\n      noRetry: !!options.noRetry\n    });\n\n    if (options.wait) {\n      // It's a wait method! Wait methods go in their own block.\n      self._outstandingMethodBlocks.push(\n        {wait: true, methods: [methodInvoker]});\n    } else {\n      // Not a wait method. Start a new block if the previous block was a wait\n      // block, and add it to the last block of methods.\n      if (_.isEmpty(self._outstandingMethodBlocks) ||\n          _.last(self._outstandingMethodBlocks).wait)\n        self._outstandingMethodBlocks.push({wait: false, methods: []});\n      _.last(self._outstandingMethodBlocks).methods.push(methodInvoker);\n    }\n\n    // If we added it to the first block, send it out now.\n    if (self._outstandingMethodBlocks.length === 1)\n      methodInvoker.sendMessage();\n\n    // If we're using the default callback on the server,\n    // block waiting for the result.\n    if (future) {\n      return future.wait();\n    }\n    return options.returnStubValue ? stubReturnValue : undefined;\n  },\n\n  // Before calling a method stub, prepare all stores to track changes and allow\n  // _retrieveAndStoreOriginals to get the original versions of changed\n  // documents.\n  _saveOriginals: function () {\n    var self = this;\n    _.each(self._stores, function (s) {\n      s.saveOriginals();\n    });\n  },\n  // Retrieves the original versions of all documents modified by the stub for\n  // method 'methodId' from all stores and saves them to _serverDocuments (keyed\n  // by document) and _documentsWrittenByStub (keyed by method ID).\n  _retrieveAndStoreOriginals: function (methodId) {\n    var self = this;\n    if (self._documentsWrittenByStub[methodId])\n      throw new Error(\"Duplicate methodId in _retrieveAndStoreOriginals\");\n\n    var docsWritten = [];\n    _.each(self._stores, function (s, collection) {\n      var originals = s.retrieveOriginals();\n      // not all stores define retrieveOriginals\n      if (!originals)\n        return;\n      originals.forEach(function (doc, id) {\n        docsWritten.push({collection: collection, id: id});\n        if (!_.has(self._serverDocuments, collection))\n          self._serverDocuments[collection] = new MongoIDMap;\n        var serverDoc = self._serverDocuments[collection].setDefault(id, {});\n        if (serverDoc.writtenByStubs) {\n          // We're not the first stub to write this doc. Just add our method ID\n          // to the record.\n          serverDoc.writtenByStubs[methodId] = true;\n        } else {\n          // First stub! Save the original value and our method ID.\n          serverDoc.document = doc;\n          serverDoc.flushCallbacks = [];\n          serverDoc.writtenByStubs = {};\n          serverDoc.writtenByStubs[methodId] = true;\n        }\n      });\n    });\n    if (!_.isEmpty(docsWritten)) {\n      self._documentsWrittenByStub[methodId] = docsWritten;\n    }\n  },\n\n  // This is very much a private function we use to make the tests\n  // take up fewer server resources after they complete.\n  _unsubscribeAll: function () {\n    var self = this;\n    _.each(_.clone(self._subscriptions), function (sub, id) {\n      // Avoid killing the autoupdate subscription so that developers\n      // still get hot code pushes when writing tests.\n      //\n      // XXX it's a hack to encode knowledge about autoupdate here,\n      // but it doesn't seem worth it yet to have a special API for\n      // subscriptions to preserve after unit tests.\n      if (sub.name !== 'meteor_autoupdate_clientVersions') {\n        self._subscriptions[id].stop();\n      }\n    });\n  },\n\n  // Sends the DDP stringification of the given message object\n  _send: function (obj) {\n    var self = this;\n    self._stream.send(DDPCommon.stringifyDDP(obj));\n  },\n\n  // We detected via DDP-level heartbeats that we've lost the\n  // connection.  Unlike `disconnect` or `close`, a lost connection\n  // will be automatically retried.\n  _lostConnection: function (error) {\n    var self = this;\n    self._stream._lostConnection(error);\n  },\n\n  /**\n   * @summary Get the current connection status. A reactive data source.\n   * @locus Client\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  status: function (/*passthrough args*/) {\n    var self = this;\n    return self._stream.status.apply(self._stream, arguments);\n  },\n\n  /**\n   * @summary Force an immediate reconnection attempt if the client is not connected to the server.\n\n  This method does nothing if the client is already connected.\n   * @locus Client\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  reconnect: function (/*passthrough args*/) {\n    var self = this;\n    return self._stream.reconnect.apply(self._stream, arguments);\n  },\n\n  /**\n   * @summary Disconnect the client from the server.\n   * @locus Client\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  disconnect: function (/*passthrough args*/) {\n    var self = this;\n    return self._stream.disconnect.apply(self._stream, arguments);\n  },\n\n  close: function () {\n    var self = this;\n    return self._stream.disconnect({_permanent: true});\n  },\n\n  ///\n  /// Reactive user system\n  ///\n  userId: function () {\n    var self = this;\n    if (self._userIdDeps)\n      self._userIdDeps.depend();\n    return self._userId;\n  },\n\n  setUserId: function (userId) {\n    var self = this;\n    // Avoid invalidating dependents if setUserId is called with current value.\n    if (self._userId === userId)\n      return;\n    self._userId = userId;\n    if (self._userIdDeps)\n      self._userIdDeps.changed();\n  },\n\n  // Returns true if we are in a state after reconnect of waiting for subs to be\n  // revived or early methods to finish their data, or we are waiting for a\n  // \"wait\" method to finish.\n  _waitingForQuiescence: function () {\n    var self = this;\n    return (! _.isEmpty(self._subsBeingRevived) ||\n            ! _.isEmpty(self._methodsBlockingQuiescence));\n  },\n\n  // Returns true if any method whose message has been sent to the server has\n  // not yet invoked its user callback.\n  _anyMethodsAreOutstanding: function () {\n    var self = this;\n    return _.any(_.pluck(self._methodInvokers, 'sentMessage'));\n  },\n\n  _livedata_connected: function (msg) {\n    var self = this;\n\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {\n      self._heartbeat = new DDPCommon.Heartbeat({\n        heartbeatInterval: self._heartbeatInterval,\n        heartbeatTimeout: self._heartbeatTimeout,\n        onTimeout: function () {\n          self._lostConnection(\n            new DDP.ConnectionError(\"DDP heartbeat timed out\"));\n        },\n        sendPing: function () {\n          self._send({msg: 'ping'});\n        }\n      });\n      self._heartbeat.start();\n    }\n\n    // If this is a reconnect, we'll have to reset all stores.\n    if (self._lastSessionId)\n      self._resetStores = true;\n\n    if (typeof (msg.session) === \"string\") {\n      var reconnectedToPreviousSession = (self._lastSessionId === msg.session);\n      self._lastSessionId = msg.session;\n    }\n\n    if (reconnectedToPreviousSession) {\n      // Successful reconnection -- pick up where we left off.  Note that right\n      // now, this never happens: the server never connects us to a previous\n      // session, because DDP doesn't provide enough data for the server to know\n      // what messages the client has processed. We need to improve DDP to make\n      // this possible, at which point we'll probably need more code here.\n      return;\n    }\n\n    // Server doesn't have our data any more. Re-sync a new session.\n\n    // Forget about messages we were buffering for unknown collections. They'll\n    // be resent if still relevant.\n    self._updatesForUnknownStores = {};\n\n    if (self._resetStores) {\n      // Forget about the effects of stubs. We'll be resetting all collections\n      // anyway.\n      self._documentsWrittenByStub = {};\n      self._serverDocuments = {};\n    }\n\n    // Clear _afterUpdateCallbacks.\n    self._afterUpdateCallbacks = [];\n\n    // Mark all named subscriptions which are ready (ie, we already called the\n    // ready callback) as needing to be revived.\n    // XXX We should also block reconnect quiescence until unnamed subscriptions\n    //     (eg, autopublish) are done re-publishing to avoid flicker!\n    self._subsBeingRevived = {};\n    _.each(self._subscriptions, function (sub, id) {\n      if (sub.ready)\n        self._subsBeingRevived[id] = true;\n    });\n\n    // Arrange for \"half-finished\" methods to have their callbacks run, and\n    // track methods that were sent on this connection so that we don't\n    // quiesce until they are all done.\n    //\n    // Start by clearing _methodsBlockingQuiescence: methods sent before\n    // reconnect don't matter, and any \"wait\" methods sent on the new connection\n    // that we drop here will be restored by the loop below.\n    self._methodsBlockingQuiescence = {};\n    if (self._resetStores) {\n      _.each(self._methodInvokers, function (invoker) {\n        if (invoker.gotResult()) {\n          // This method already got its result, but it didn't call its callback\n          // because its data didn't become visible. We did not resend the\n          // method RPC. We'll call its callback when we get a full quiesce,\n          // since that's as close as we'll get to \"data must be visible\".\n          self._afterUpdateCallbacks.push(_.bind(invoker.dataVisible, invoker));\n        } else if (invoker.sentMessage) {\n          // This method has been sent on this connection (maybe as a resend\n          // from the last connection, maybe from onReconnect, maybe just very\n          // quickly before processing the connected message).\n          //\n          // We don't need to do anything special to ensure its callbacks get\n          // called, but we'll count it as a method which is preventing\n          // reconnect quiescence. (eg, it might be a login method that was run\n          // from onReconnect, and we don't want to see flicker by seeing a\n          // logged-out state.)\n          self._methodsBlockingQuiescence[invoker.methodId] = true;\n        }\n      });\n    }\n\n    self._messagesBufferedUntilQuiescence = [];\n\n    // If we're not waiting on any methods or subs, we can reset the stores and\n    // call the callbacks immediately.\n    if (!self._waitingForQuiescence()) {\n      if (self._resetStores) {\n        _.each(self._stores, function (s) {\n          s.beginUpdate(0, true);\n          s.endUpdate();\n        });\n        self._resetStores = false;\n      }\n      self._runAfterUpdateCallbacks();\n    }\n  },\n\n\n  _processOneDataMessage: function (msg, updates) {\n    var self = this;\n    // Using underscore here so as not to need to capitalize.\n    self['_process_' + msg.msg](msg, updates);\n  },\n\n\n  _livedata_data: function (msg) {\n    var self = this;\n\n    if (self._waitingForQuiescence()) {\n      self._messagesBufferedUntilQuiescence.push(msg);\n\n      if (msg.msg === \"nosub\")\n        delete self._subsBeingRevived[msg.id];\n\n      _.each(msg.subs || [], function (subId) {\n        delete self._subsBeingRevived[subId];\n      });\n      _.each(msg.methods || [], function (methodId) {\n        delete self._methodsBlockingQuiescence[methodId];\n      });\n\n      if (self._waitingForQuiescence())\n        return;\n\n      // No methods or subs are blocking quiescence!\n      // We'll now process and all of our buffered messages, reset all stores,\n      // and apply them all at once.\n      _.each(self._messagesBufferedUntilQuiescence, function (bufferedMsg) {\n        self._processOneDataMessage(bufferedMsg, self._bufferedWrites);\n      });\n      self._messagesBufferedUntilQuiescence = [];\n    } else {\n      self._processOneDataMessage(msg, self._bufferedWrites);\n    }\n\n    // Immediately flush writes when:\n    //  1. Buffering is disabled. Or;\n    //  2. any non-(added/changed/removed) message arrives.\n    var standardWrite = _.include(['added', 'changed', 'removed'], msg.msg);\n    if (self._bufferedWritesInterval === 0 || !standardWrite) {\n      self._flushBufferedWrites();\n      return;\n    }\n\n    if (self._bufferedWritesFlushAt === null) {\n      self._bufferedWritesFlushAt = new Date().valueOf() + self._bufferedWritesMaxAge;\n    }\n    else if (self._bufferedWritesFlushAt < new Date().valueOf()) {\n      self._flushBufferedWrites();\n      return;\n    }\n\n    if (self._bufferedWritesFlushHandle) {\n      clearTimeout(self._bufferedWritesFlushHandle);\n    }\n    self._bufferedWritesFlushHandle = setTimeout(self.__flushBufferedWrites,\n                                                      self._bufferedWritesInterval);\n  },\n\n  _flushBufferedWrites: function () {\n    var self = this;\n    if (self._bufferedWritesFlushHandle) {\n      clearTimeout(self._bufferedWritesFlushHandle);\n      self._bufferedWritesFlushHandle = null;\n    }\n\n    self._bufferedWritesFlushAt = null;\n    // We need to clear the buffer before passing it to\n    //  performWrites. As there's no guarantee that it\n    //  will exit cleanly.\n    var writes = self._bufferedWrites;\n    self._bufferedWrites = {};\n    self._performWrites(writes);\n  },\n\n  _performWrites: function(updates){\n    var self = this;\n\n    if (self._resetStores || !_.isEmpty(updates)) {\n      // Begin a transactional update of each store.\n      _.each(self._stores, function (s, storeName) {\n        s.beginUpdate(_.has(updates, storeName) ? updates[storeName].length : 0,\n                      self._resetStores);\n      });\n      self._resetStores = false;\n\n      _.each(updates, function (updateMessages, storeName) {\n        var store = self._stores[storeName];\n        if (store) {\n          _.each(updateMessages, function (updateMessage) {\n            store.update(updateMessage);\n          });\n        } else {\n          // Nobody's listening for this data. Queue it up until\n          // someone wants it.\n          // XXX memory use will grow without bound if you forget to\n          // create a collection or just don't care about it... going\n          // to have to do something about that.\n          if (!_.has(self._updatesForUnknownStores, storeName))\n            self._updatesForUnknownStores[storeName] = [];\n          Array.prototype.push.apply(self._updatesForUnknownStores[storeName],\n                                     updateMessages);\n        }\n      });\n\n      // End update transaction.\n      _.each(self._stores, function (s) { s.endUpdate(); });\n    }\n\n    self._runAfterUpdateCallbacks();\n  },\n\n  // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose\n  // relevant docs have been flushed, as well as dataVisible callbacks at\n  // reconnect-quiescence time.\n  _runAfterUpdateCallbacks: function () {\n    var self = this;\n    var callbacks = self._afterUpdateCallbacks;\n    self._afterUpdateCallbacks = [];\n    _.each(callbacks, function (c) {\n      c();\n    });\n  },\n\n  _pushUpdate: function (updates, collection, msg) {\n    var self = this;\n    if (!_.has(updates, collection)) {\n      updates[collection] = [];\n    }\n    updates[collection].push(msg);\n  },\n\n  _getServerDoc: function (collection, id) {\n    var self = this;\n    if (!_.has(self._serverDocuments, collection))\n      return null;\n    var serverDocsForCollection = self._serverDocuments[collection];\n    return serverDocsForCollection.get(id) || null;\n  },\n\n  _process_added: function (msg, updates) {\n    var self = this;\n    var id = MongoID.idParse(msg.id);\n    var serverDoc = self._getServerDoc(msg.collection, id);\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      var isExisting = (serverDoc.document !== undefined);\n\n      serverDoc.document = msg.fields || {};\n      serverDoc.document._id = id;\n\n      if (self._resetStores) {\n        // During reconnect the server is sending adds for existing ids.\n        // Always push an update so that document stays in the store after\n        // reset. Use current version of the document for this update, so\n        // that stub-written values are preserved.\n        var currentDoc = self._stores[msg.collection].getDoc(msg.id);\n        if (currentDoc !== undefined)\n          msg.fields = currentDoc;\n\n        self._pushUpdate(updates, msg.collection, msg);\n      } else if (isExisting) {\n        throw new Error(\"Server sent add for existing id: \" + msg.id);\n      }\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  },\n\n  _process_changed: function (msg, updates) {\n    var self = this;\n    var serverDoc = self._getServerDoc(\n      msg.collection, MongoID.idParse(msg.id));\n    if (serverDoc) {\n      if (serverDoc.document === undefined)\n        throw new Error(\"Server sent changed for nonexisting id: \" + msg.id);\n      DiffSequence.applyChanges(serverDoc.document, msg.fields);\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  },\n\n  _process_removed: function (msg, updates) {\n    var self = this;\n    var serverDoc = self._getServerDoc(\n      msg.collection, MongoID.idParse(msg.id));\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      if (serverDoc.document === undefined)\n        throw new Error(\"Server sent removed for nonexisting id:\" + msg.id);\n      serverDoc.document = undefined;\n    } else {\n      self._pushUpdate(updates, msg.collection, {\n        msg: 'removed',\n        collection: msg.collection,\n        id: msg.id\n      });\n    }\n  },\n\n  _process_updated: function (msg, updates) {\n    var self = this;\n    // Process \"method done\" messages.\n    _.each(msg.methods, function (methodId) {\n      _.each(self._documentsWrittenByStub[methodId], function (written) {\n        var serverDoc = self._getServerDoc(written.collection, written.id);\n        if (!serverDoc)\n          throw new Error(\"Lost serverDoc for \" + JSON.stringify(written));\n        if (!serverDoc.writtenByStubs[methodId])\n          throw new Error(\"Doc \" + JSON.stringify(written) +\n                          \" not written by  method \" + methodId);\n        delete serverDoc.writtenByStubs[methodId];\n        if (_.isEmpty(serverDoc.writtenByStubs)) {\n          // All methods whose stubs wrote this method have completed! We can\n          // now copy the saved document to the database (reverting the stub's\n          // change if the server did not write to this object, or applying the\n          // server's writes if it did).\n\n          // This is a fake ddp 'replace' message.  It's just for talking\n          // between livedata connections and minimongo.  (We have to stringify\n          // the ID because it's supposed to look like a wire message.)\n          self._pushUpdate(updates, written.collection, {\n            msg: 'replace',\n            id: MongoID.idStringify(written.id),\n            replace: serverDoc.document\n          });\n          // Call all flush callbacks.\n          _.each(serverDoc.flushCallbacks, function (c) {\n            c();\n          });\n\n          // Delete this completed serverDocument. Don't bother to GC empty\n          // IdMaps inside self._serverDocuments, since there probably aren't\n          // many collections and they'll be written repeatedly.\n          self._serverDocuments[written.collection].remove(written.id);\n        }\n      });\n      delete self._documentsWrittenByStub[methodId];\n\n      // We want to call the data-written callback, but we can't do so until all\n      // currently buffered messages are flushed.\n      var callbackInvoker = self._methodInvokers[methodId];\n      if (!callbackInvoker)\n        throw new Error(\"No callback invoker for method \" + methodId);\n      self._runWhenAllServerDocsAreFlushed(\n        _.bind(callbackInvoker.dataVisible, callbackInvoker));\n    });\n  },\n\n  _process_ready: function (msg, updates) {\n    var self = this;\n    // Process \"sub ready\" messages. \"sub ready\" messages don't take effect\n    // until all current server documents have been flushed to the local\n    // database. We can use a write fence to implement this.\n    _.each(msg.subs, function (subId) {\n      self._runWhenAllServerDocsAreFlushed(function () {\n        var subRecord = self._subscriptions[subId];\n        // Did we already unsubscribe?\n        if (!subRecord)\n          return;\n        // Did we already receive a ready message? (Oops!)\n        if (subRecord.ready)\n          return;\n        subRecord.ready = true;\n        subRecord.readyCallback && subRecord.readyCallback();\n        subRecord.readyDeps.changed();\n      });\n    });\n  },\n\n  // Ensures that \"f\" will be called after all documents currently in\n  // _serverDocuments have been written to the local cache. f will not be called\n  // if the connection is lost before then!\n  _runWhenAllServerDocsAreFlushed: function (f) {\n    var self = this;\n    var runFAfterUpdates = function () {\n      self._afterUpdateCallbacks.push(f);\n    };\n    var unflushedServerDocCount = 0;\n    var onServerDocFlush = function () {\n      --unflushedServerDocCount;\n      if (unflushedServerDocCount === 0) {\n        // This was the last doc to flush! Arrange to run f after the updates\n        // have been applied.\n        runFAfterUpdates();\n      }\n    };\n    _.each(self._serverDocuments, function (collectionDocs) {\n      collectionDocs.forEach(function (serverDoc) {\n        var writtenByStubForAMethodWithSentMessage = _.any(\n          serverDoc.writtenByStubs, function (dummy, methodId) {\n            var invoker = self._methodInvokers[methodId];\n            return invoker && invoker.sentMessage;\n          });\n        if (writtenByStubForAMethodWithSentMessage) {\n          ++unflushedServerDocCount;\n          serverDoc.flushCallbacks.push(onServerDocFlush);\n        }\n      });\n    });\n    if (unflushedServerDocCount === 0) {\n      // There aren't any buffered docs --- we can call f as soon as the current\n      // round of updates is applied!\n      runFAfterUpdates();\n    }\n  },\n\n  _livedata_nosub: function (msg) {\n    var self = this;\n\n    // First pass it through _livedata_data, which only uses it to help get\n    // towards quiescence.\n    self._livedata_data(msg);\n\n    // Do the rest of our processing immediately, with no\n    // buffering-until-quiescence.\n\n    // we weren't subbed anyway, or we initiated the unsub.\n    if (!_.has(self._subscriptions, msg.id))\n      return;\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    var errorCallback = self._subscriptions[msg.id].errorCallback;\n    var stopCallback = self._subscriptions[msg.id].stopCallback;\n\n    self._subscriptions[msg.id].remove();\n\n    var meteorErrorFromMsg = function (msgArg) {\n      return msgArg && msgArg.error && new Meteor.Error(\n        msgArg.error.error, msgArg.error.reason, msgArg.error.details);\n    }\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    if (errorCallback && msg.error) {\n      errorCallback(meteorErrorFromMsg(msg));\n    }\n\n    if (stopCallback) {\n      stopCallback(meteorErrorFromMsg(msg));\n    }\n  },\n\n  _process_nosub: function () {\n    // This is called as part of the \"buffer until quiescence\" process, but\n    // nosub's effect is always immediate. It only goes in the buffer at all\n    // because it's possible for a nosub to be the thing that triggers\n    // quiescence, if we were waiting for a sub to be revived and it dies\n    // instead.\n  },\n\n  _livedata_result: function (msg) {\n    // id, result or error. error has error (code), reason, details\n\n    var self = this;\n\n    // Lets make sure there are no buffered writes before returning result.\n    if (!_.isEmpty(self._bufferedWrites)) {\n      self._flushBufferedWrites();\n    }\n\n    // find the outstanding request\n    // should be O(1) in nearly all realistic use cases\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\n      Meteor._debug(\"Received method result but no methods outstanding\");\n      return;\n    }\n    var currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n    var m;\n    for (var i = 0; i < currentMethodBlock.length; i++) {\n      m = currentMethodBlock[i];\n      if (m.methodId === msg.id)\n        break;\n    }\n\n    if (!m) {\n      Meteor._debug(\"Can't match method response to original method call\", msg);\n      return;\n    }\n\n    // Remove from current method block. This may leave the block empty, but we\n    // don't move on to the next block until the callback has been delivered, in\n    // _outstandingMethodFinished.\n    currentMethodBlock.splice(i, 1);\n\n    if (_.has(msg, 'error')) {\n      m.receiveResult(new Meteor.Error(\n        msg.error.error, msg.error.reason,\n        msg.error.details));\n    } else {\n      // msg.result may be undefined if the method didn't return a\n      // value\n      m.receiveResult(undefined, msg.result);\n    }\n  },\n\n  // Called by MethodInvoker after a method's callback is invoked.  If this was\n  // the last outstanding method in the current block, runs the next block. If\n  // there are no more methods, consider accepting a hot code push.\n  _outstandingMethodFinished: function () {\n    var self = this;\n    if (self._anyMethodsAreOutstanding())\n      return;\n\n    // No methods are outstanding. This should mean that the first block of\n    // methods is empty. (Or it might not exist, if this was a method that\n    // half-finished before disconnect/reconnect.)\n    if (! _.isEmpty(self._outstandingMethodBlocks)) {\n      var firstBlock = self._outstandingMethodBlocks.shift();\n      if (! _.isEmpty(firstBlock.methods))\n        throw new Error(\"No methods outstanding but nonempty block: \" +\n                        JSON.stringify(firstBlock));\n\n      // Send the outstanding methods now in the first block.\n      if (!_.isEmpty(self._outstandingMethodBlocks))\n        self._sendOutstandingMethods();\n    }\n\n    // Maybe accept a hot code push.\n    self._maybeMigrate();\n  },\n\n  // Sends messages for all the methods in the first block in\n  // _outstandingMethodBlocks.\n  _sendOutstandingMethods: function() {\n    var self = this;\n    if (_.isEmpty(self._outstandingMethodBlocks))\n      return;\n    _.each(self._outstandingMethodBlocks[0].methods, function (m) {\n      m.sendMessage();\n    });\n  },\n\n  _livedata_error: function (msg) {\n    Meteor._debug(\"Received error from server: \", msg.reason);\n    if (msg.offendingMessage)\n      Meteor._debug(\"For: \", msg.offendingMessage);\n  },\n\n  _callOnReconnectAndSendAppropriateOutstandingMethods: function() {\n    var self = this;\n    var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;\n    self._outstandingMethodBlocks = [];\n\n    self.onReconnect();\n\n    if (_.isEmpty(oldOutstandingMethodBlocks))\n      return;\n\n    // We have at least one block worth of old outstanding methods to try\n    // again. First: did onReconnect actually send anything? If not, we just\n    // restore all outstanding methods and run the first block.\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\n      self._outstandingMethodBlocks = oldOutstandingMethodBlocks;\n      self._sendOutstandingMethods();\n      return;\n    }\n\n    // OK, there are blocks on both sides. Special case: merge the last block of\n    // the reconnect methods with the first block of the original methods, if\n    // neither of them are \"wait\" blocks.\n    if (!_.last(self._outstandingMethodBlocks).wait &&\n        !oldOutstandingMethodBlocks[0].wait) {\n      _.each(oldOutstandingMethodBlocks[0].methods, function (m) {\n        _.last(self._outstandingMethodBlocks).methods.push(m);\n\n        // If this \"last block\" is also the first block, send the message.\n        if (self._outstandingMethodBlocks.length === 1)\n          m.sendMessage();\n      });\n\n      oldOutstandingMethodBlocks.shift();\n    }\n\n    // Now add the rest of the original blocks on.\n    _.each(oldOutstandingMethodBlocks, function (block) {\n      self._outstandingMethodBlocks.push(block);\n    });\n  },\n\n  // We can accept a hot code push if there are no methods in flight.\n  _readyToMigrate: function() {\n    var self = this;\n    return _.isEmpty(self._methodInvokers);\n  },\n\n  // If we were blocking a migration, see if it's now possible to continue.\n  // Call whenever the set of outstanding/blocked methods shrinks.\n  _maybeMigrate: function () {\n    var self = this;\n    if (self._retryMigrate && self._readyToMigrate()) {\n      self._retryMigrate();\n      self._retryMigrate = null;\n    }\n  }\n});\n\nLivedataTest.Connection = Connection;\n\n// @param url {String} URL to Meteor app,\n//     e.g.:\n//     \"subdomain.meteor.com\",\n//     \"http://subdomain.meteor.com\",\n//     \"/\",\n//     \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"\n\n/**\n * @summary Connect to the server of a different Meteor application to subscribe to its document sets and invoke its remote methods.\n * @locus Anywhere\n * @param {String} url The URL of another Meteor application.\n */\nDDP.connect = function (url, options) {\n  var ret = new Connection(url, options);\n  allConnections.push(ret); // hack. see below.\n  return ret;\n};\n\n// Hack for `spiderable` package: a way to see if the page is done\n// loading all the data it needs.\n//\nallConnections = [];\nDDP._allSubscriptionsReady = function () {\n  return _.all(allConnections, function (conn) {\n    return _.all(conn._subscriptions, function (sub) {\n      return sub.ready;\n    });\n  });\n};\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['ddp-client'] = {}, {\n  DDP: DDP,\n  LivedataTest: LivedataTest\n});\n\n})();\n\n//# sourceMappingURL=ddp-client.js.map\n"]},"hash":"def58a10333ca81b671b8679206c7e6f3daab1b0"}

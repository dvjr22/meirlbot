{"metadata":{"usedHelpers":["typeof"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/startbootstrap-sb-admin-gh-pages/js/plugins/flot/jquery.flot.js","filenameRelative":"/startbootstrap-sb-admin-gh-pages/js/plugins/flot/jquery.flot.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/startbootstrap-sb-admin-gh-pages/js/plugins/flot/jquery.flot.js.map","sourceFileName":"/startbootstrap-sb-admin-gh-pages/js/plugins/flot/jquery.flot.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"jquery.flot"},"ignored":false,"code":"var _typeof;module.import(\"babel-runtime/helpers/typeof\",{\"default\":function(v){_typeof=v}});\n/* Javascript plotting library for jQuery, version 0.8.3.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\n*/\n\n// first an inline dependency, jquery.colorhelpers.js, we inline it here\n// for convenience\n\n/* Plugin for jQuery for working with colors.\n *\n * Version 1.1.\n *\n * Inspiration from jQuery color animation plugin by John Resig.\n *\n * Released under the MIT license by Ole Laursen, October 2009.\n *\n * Examples:\n *\n *   $.color.parse(\"#fff\").scale('rgb', 0.25).add('a', -0.5).toString()\n *   var c = $.color.extract($(\"#mydiv\"), 'background-color');\n *   console.log(c.r, c.g, c.b, c.a);\n *   $.color.make(100, 50, 25, 0.4).toString() // returns \"rgba(100,50,25,0.4)\"\n *\n * Note that .scale() and .add() return the same modified object\n * instead of making a new one.\n *\n * V. 1.1: Fix error handling so e.g. parsing an empty string does\n * produce a color rather than just crashing.\n */\n(function ($) {\n    $.color = {};$.color.make = function (r, g, b, a) {\n        var o = {};o.r = r || 0;o.g = g || 0;o.b = b || 0;o.a = a != null ? a : 1;o.add = function (c, d) {\n            for (var i = 0; i < c.length; ++i) {\n                o[c.charAt(i)] += d;\n            }return o.normalize();\n        };o.scale = function (c, f) {\n            for (var i = 0; i < c.length; ++i) {\n                o[c.charAt(i)] *= f;\n            }return o.normalize();\n        };o.toString = function () {\n            if (o.a >= 1) {\n                return \"rgb(\" + [o.r, o.g, o.b].join(\",\") + \")\";\n            } else {\n                return \"rgba(\" + [o.r, o.g, o.b, o.a].join(\",\") + \")\";\n            }\n        };o.normalize = function () {\n            function clamp(min, value, max) {\n                return value < min ? min : value > max ? max : value;\n            }o.r = clamp(0, parseInt(o.r), 255);o.g = clamp(0, parseInt(o.g), 255);o.b = clamp(0, parseInt(o.b), 255);o.a = clamp(0, o.a, 1);return o;\n        };o.clone = function () {\n            return $.color.make(o.r, o.b, o.g, o.a);\n        };return o.normalize();\n    };$.color.extract = function (elem, css) {\n        var c;do {\n            c = elem.css(css).toLowerCase();if (c != \"\" && c != \"transparent\") break;elem = elem.parent();\n        } while (elem.length && !$.nodeName(elem.get(0), \"body\"));if (c == \"rgba(0, 0, 0, 0)\") c = \"transparent\";return $.color.parse(c);\n    };$.color.parse = function (str) {\n        var res,\n            m = $.color.make;if (res = /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/.exec(str)) return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10));if (res = /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str)) return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10), parseFloat(res[4]));if (res = /rgb\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*\\)/.exec(str)) return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55);if (res = /rgba\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str)) return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55, parseFloat(res[4]));if (res = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str)) return m(parseInt(res[1], 16), parseInt(res[2], 16), parseInt(res[3], 16));if (res = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str)) return m(parseInt(res[1] + res[1], 16), parseInt(res[2] + res[2], 16), parseInt(res[3] + res[3], 16));var name = $.trim(str).toLowerCase();if (name == \"transparent\") return m(255, 255, 255, 0);else {\n            res = lookupColors[name] || [0, 0, 0];return m(res[0], res[1], res[2]);\n        }\n    };var lookupColors = { aqua: [0, 255, 255], azure: [240, 255, 255], beige: [245, 245, 220], black: [0, 0, 0], blue: [0, 0, 255], brown: [165, 42, 42], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgrey: [169, 169, 169], darkgreen: [0, 100, 0], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkviolet: [148, 0, 211], fuchsia: [255, 0, 255], gold: [255, 215, 0], green: [0, 128, 0], indigo: [75, 0, 130], khaki: [240, 230, 140], lightblue: [173, 216, 230], lightcyan: [224, 255, 255], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightyellow: [255, 255, 224], lime: [0, 255, 0], magenta: [255, 0, 255], maroon: [128, 0, 0], navy: [0, 0, 128], olive: [128, 128, 0], orange: [255, 165, 0], pink: [255, 192, 203], purple: [128, 0, 128], violet: [128, 0, 128], red: [255, 0, 0], silver: [192, 192, 192], white: [255, 255, 255], yellow: [255, 255, 0] };\n})(jQuery);\n\n// the actual Flot code\n(function ($) {\n\n    // Cache the prototype hasOwnProperty for faster access\n\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    // A shim to provide 'detach' to jQuery versions prior to 1.4.  Using a DOM\n    // operation produces the same effect as detach, i.e. removing the element\n    // without touching its jQuery data.\n\n    // Do not merge this into Flot 0.9, since it requires jQuery 1.4.4+.\n\n    if (!$.fn.detach) {\n        $.fn.detach = function () {\n            return this.each(function () {\n                if (this.parentNode) {\n                    this.parentNode.removeChild(this);\n                }\n            });\n        };\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // The Canvas object is a wrapper around an HTML5 <canvas> tag.\n    //\n    // @constructor\n    // @param {string} cls List of classes to apply to the canvas.\n    // @param {element} container Element onto which to append the canvas.\n    //\n    // Requiring a container is a little iffy, but unfortunately canvas\n    // operations don't work unless the canvas is attached to the DOM.\n\n    function Canvas(cls, container) {\n\n        var element = container.children(\".\" + cls)[0];\n\n        if (element == null) {\n\n            element = document.createElement(\"canvas\");\n            element.className = cls;\n\n            $(element).css({ direction: \"ltr\", position: \"absolute\", left: 0, top: 0 }).appendTo(container);\n\n            // If HTML5 Canvas isn't available, fall back to [Ex|Flash]canvas\n\n            if (!element.getContext) {\n                if (window.G_vmlCanvasManager) {\n                    element = window.G_vmlCanvasManager.initElement(element);\n                } else {\n                    throw new Error(\"Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.\");\n                }\n            }\n        }\n\n        this.element = element;\n\n        var context = this.context = element.getContext(\"2d\");\n\n        // Determine the screen's ratio of physical to device-independent\n        // pixels.  This is the ratio between the canvas width that the browser\n        // advertises and the number of pixels actually present in that space.\n\n        // The iPhone 4, for example, has a device-independent width of 320px,\n        // but its screen is actually 640px wide.  It therefore has a pixel\n        // ratio of 2, while most normal devices have a ratio of 1.\n\n        var devicePixelRatio = window.devicePixelRatio || 1,\n            backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n\n        this.pixelRatio = devicePixelRatio / backingStoreRatio;\n\n        // Size the canvas to match the internal dimensions of its container\n\n        this.resize(container.width(), container.height());\n\n        // Collection of HTML div layers for text overlaid onto the canvas\n\n        this.textContainer = null;\n        this.text = {};\n\n        // Cache of text fragments and metrics, so we can avoid expensively\n        // re-calculating them when the plot is re-rendered in a loop.\n\n        this._textCache = {};\n    }\n\n    // Resizes the canvas to the given dimensions.\n    //\n    // @param {number} width New width of the canvas, in pixels.\n    // @param {number} width New height of the canvas, in pixels.\n\n    Canvas.prototype.resize = function (width, height) {\n\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid dimensions for plot, width = \" + width + \", height = \" + height);\n        }\n\n        var element = this.element,\n            context = this.context,\n            pixelRatio = this.pixelRatio;\n\n        // Resize the canvas, increasing its density based on the display's\n        // pixel ratio; basically giving it more pixels without increasing the\n        // size of its element, to take advantage of the fact that retina\n        // displays have that many more pixels in the same advertised space.\n\n        // Resizing should reset the state (excanvas seems to be buggy though)\n\n        if (this.width != width) {\n            element.width = width * pixelRatio;\n            element.style.width = width + \"px\";\n            this.width = width;\n        }\n\n        if (this.height != height) {\n            element.height = height * pixelRatio;\n            element.style.height = height + \"px\";\n            this.height = height;\n        }\n\n        // Save the context, so we can reset in case we get replotted.  The\n        // restore ensure that we're really back at the initial state, and\n        // should be safe even if we haven't saved the initial state yet.\n\n        context.restore();\n        context.save();\n\n        // Scale the coordinate space to match the display density; so even though we\n        // may have twice as many pixels, we still want lines and other drawing to\n        // appear at the same size; the extra pixels will just make them crisper.\n\n        context.scale(pixelRatio, pixelRatio);\n    };\n\n    // Clears the entire canvas area, not including any overlaid HTML text\n\n    Canvas.prototype.clear = function () {\n        this.context.clearRect(0, 0, this.width, this.height);\n    };\n\n    // Finishes rendering the canvas, including managing the text overlay.\n\n    Canvas.prototype.render = function () {\n\n        var cache = this._textCache;\n\n        // For each text layer, add elements marked as active that haven't\n        // already been rendered, and remove those that are no longer active.\n\n        for (var layerKey in meteorBabelHelpers.sanitizeForInObject(cache)) {\n            if (hasOwnProperty.call(cache, layerKey)) {\n\n                var layer = this.getTextLayer(layerKey),\n                    layerCache = cache[layerKey];\n\n                layer.hide();\n\n                for (var styleKey in meteorBabelHelpers.sanitizeForInObject(layerCache)) {\n                    if (hasOwnProperty.call(layerCache, styleKey)) {\n                        var styleCache = layerCache[styleKey];\n                        for (var key in meteorBabelHelpers.sanitizeForInObject(styleCache)) {\n                            if (hasOwnProperty.call(styleCache, key)) {\n\n                                var positions = styleCache[key].positions;\n\n                                for (var i = 0, position; position = positions[i]; i++) {\n                                    if (position.active) {\n                                        if (!position.rendered) {\n                                            layer.append(position.element);\n                                            position.rendered = true;\n                                        }\n                                    } else {\n                                        positions.splice(i--, 1);\n                                        if (position.rendered) {\n                                            position.element.detach();\n                                        }\n                                    }\n                                }\n\n                                if (positions.length == 0) {\n                                    delete styleCache[key];\n                                }\n                            }\n                        }\n                    }\n                }\n\n                layer.show();\n            }\n        }\n    };\n\n    // Creates (if necessary) and returns the text overlay container.\n    //\n    // @param {string} classes String of space-separated CSS classes used to\n    //     uniquely identify the text layer.\n    // @return {object} The jQuery-wrapped text-layer div.\n\n    Canvas.prototype.getTextLayer = function (classes) {\n\n        var layer = this.text[classes];\n\n        // Create the text layer if it doesn't exist\n\n        if (layer == null) {\n\n            // Create the text layer container, if it doesn't exist\n\n            if (this.textContainer == null) {\n                this.textContainer = $(\"<div class='flot-text'></div>\").css({\n                    position: \"absolute\",\n                    top: 0,\n                    left: 0,\n                    bottom: 0,\n                    right: 0,\n                    'font-size': \"smaller\",\n                    color: \"#545454\"\n                }).insertAfter(this.element);\n            }\n\n            layer = this.text[classes] = $(\"<div></div>\").addClass(classes).css({\n                position: \"absolute\",\n                top: 0,\n                left: 0,\n                bottom: 0,\n                right: 0\n            }).appendTo(this.textContainer);\n        }\n\n        return layer;\n    };\n\n    // Creates (if necessary) and returns a text info object.\n    //\n    // The object looks like this:\n    //\n    // {\n    //     width: Width of the text's wrapper div.\n    //     height: Height of the text's wrapper div.\n    //     element: The jQuery-wrapped HTML div containing the text.\n    //     positions: Array of positions at which this text is drawn.\n    // }\n    //\n    // The positions array contains objects that look like this:\n    //\n    // {\n    //     active: Flag indicating whether the text should be visible.\n    //     rendered: Flag indicating whether the text is currently visible.\n    //     element: The jQuery-wrapped HTML div containing the text.\n    //     x: X coordinate at which to draw the text.\n    //     y: Y coordinate at which to draw the text.\n    // }\n    //\n    // Each position after the first receives a clone of the original element.\n    //\n    // The idea is that that the width, height, and general 'identity' of the\n    // text is constant no matter where it is placed; the placements are a\n    // secondary property.\n    //\n    // Canvas maintains a cache of recently-used text info objects; getTextInfo\n    // either returns the cached element or creates a new entry.\n    //\n    // @param {string} layer A string of space-separated CSS classes uniquely\n    //     identifying the layer containing this text.\n    // @param {string} text Text string to retrieve info for.\n    // @param {(string|object)=} font Either a string of space-separated CSS\n    //     classes or a font-spec object, defining the text's font and style.\n    // @param {number=} angle Angle at which to rotate the text, in degrees.\n    //     Angle is currently unused, it will be implemented in the future.\n    // @param {number=} width Maximum width of the text before it wraps.\n    // @return {object} a text info object.\n\n    Canvas.prototype.getTextInfo = function (layer, text, font, angle, width) {\n\n        var textStyle, layerCache, styleCache, info;\n\n        // Cast the value to a string, in case we were given a number or such\n\n        text = \"\" + text;\n\n        // If the font is a font-spec object, generate a CSS font definition\n\n        if ((typeof font === \"undefined\" ? \"undefined\" : _typeof(font)) === \"object\") {\n            textStyle = font.style + \" \" + font.variant + \" \" + font.weight + \" \" + font.size + \"px/\" + font.lineHeight + \"px \" + font.family;\n        } else {\n            textStyle = font;\n        }\n\n        // Retrieve (or create) the cache for the text's layer and styles\n\n        layerCache = this._textCache[layer];\n\n        if (layerCache == null) {\n            layerCache = this._textCache[layer] = {};\n        }\n\n        styleCache = layerCache[textStyle];\n\n        if (styleCache == null) {\n            styleCache = layerCache[textStyle] = {};\n        }\n\n        info = styleCache[text];\n\n        // If we can't find a matching element in our cache, create a new one\n\n        if (info == null) {\n\n            var element = $(\"<div></div>\").html(text).css({\n                position: \"absolute\",\n                'max-width': width,\n                top: -9999\n            }).appendTo(this.getTextLayer(layer));\n\n            if ((typeof font === \"undefined\" ? \"undefined\" : _typeof(font)) === \"object\") {\n                element.css({\n                    font: textStyle,\n                    color: font.color\n                });\n            } else if (typeof font === \"string\") {\n                element.addClass(font);\n            }\n\n            info = styleCache[text] = {\n                width: element.outerWidth(true),\n                height: element.outerHeight(true),\n                element: element,\n                positions: []\n            };\n\n            element.detach();\n        }\n\n        return info;\n    };\n\n    // Adds a text string to the canvas text overlay.\n    //\n    // The text isn't drawn immediately; it is marked as rendering, which will\n    // result in its addition to the canvas on the next render pass.\n    //\n    // @param {string} layer A string of space-separated CSS classes uniquely\n    //     identifying the layer containing this text.\n    // @param {number} x X coordinate at which to draw the text.\n    // @param {number} y Y coordinate at which to draw the text.\n    // @param {string} text Text string to draw.\n    // @param {(string|object)=} font Either a string of space-separated CSS\n    //     classes or a font-spec object, defining the text's font and style.\n    // @param {number=} angle Angle at which to rotate the text, in degrees.\n    //     Angle is currently unused, it will be implemented in the future.\n    // @param {number=} width Maximum width of the text before it wraps.\n    // @param {string=} halign Horizontal alignment of the text; either \"left\",\n    //     \"center\" or \"right\".\n    // @param {string=} valign Vertical alignment of the text; either \"top\",\n    //     \"middle\" or \"bottom\".\n\n    Canvas.prototype.addText = function (layer, x, y, text, font, angle, width, halign, valign) {\n\n        var info = this.getTextInfo(layer, text, font, angle, width),\n            positions = info.positions;\n\n        // Tweak the div's position to match the text's alignment\n\n        if (halign == \"center\") {\n            x -= info.width / 2;\n        } else if (halign == \"right\") {\n            x -= info.width;\n        }\n\n        if (valign == \"middle\") {\n            y -= info.height / 2;\n        } else if (valign == \"bottom\") {\n            y -= info.height;\n        }\n\n        // Determine whether this text already exists at this position.\n        // If so, mark it for inclusion in the next render pass.\n\n        for (var i = 0, position; position = positions[i]; i++) {\n            if (position.x == x && position.y == y) {\n                position.active = true;\n                return;\n            }\n        }\n\n        // If the text doesn't exist at this position, create a new entry\n\n        // For the very first position we'll re-use the original element,\n        // while for subsequent ones we'll clone it.\n\n        position = {\n            active: true,\n            rendered: false,\n            element: positions.length ? info.element.clone() : info.element,\n            x: x,\n            y: y\n        };\n\n        positions.push(position);\n\n        // Move the element to its final position within the container\n\n        position.element.css({\n            top: Math.round(y),\n            left: Math.round(x),\n            'text-align': halign // In case the text wraps\n        });\n    };\n\n    // Removes one or more text strings from the canvas text overlay.\n    //\n    // If no parameters are given, all text within the layer is removed.\n    //\n    // Note that the text is not immediately removed; it is simply marked as\n    // inactive, which will result in its removal on the next render pass.\n    // This avoids the performance penalty for 'clear and redraw' behavior,\n    // where we potentially get rid of all text on a layer, but will likely\n    // add back most or all of it later, as when redrawing axes, for example.\n    //\n    // @param {string} layer A string of space-separated CSS classes uniquely\n    //     identifying the layer containing this text.\n    // @param {number=} x X coordinate of the text.\n    // @param {number=} y Y coordinate of the text.\n    // @param {string=} text Text string to remove.\n    // @param {(string|object)=} font Either a string of space-separated CSS\n    //     classes or a font-spec object, defining the text's font and style.\n    // @param {number=} angle Angle at which the text is rotated, in degrees.\n    //     Angle is currently unused, it will be implemented in the future.\n\n    Canvas.prototype.removeText = function (layer, x, y, text, font, angle) {\n        if (text == null) {\n            var layerCache = this._textCache[layer];\n            if (layerCache != null) {\n                for (var styleKey in meteorBabelHelpers.sanitizeForInObject(layerCache)) {\n                    if (hasOwnProperty.call(layerCache, styleKey)) {\n                        var styleCache = layerCache[styleKey];\n                        for (var key in meteorBabelHelpers.sanitizeForInObject(styleCache)) {\n                            if (hasOwnProperty.call(styleCache, key)) {\n                                var positions = styleCache[key].positions;\n                                for (var i = 0, position; position = positions[i]; i++) {\n                                    position.active = false;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        } else {\n            var positions = this.getTextInfo(layer, text, font, angle).positions;\n            for (var i = 0, position; position = positions[i]; i++) {\n                if (position.x == x && position.y == y) {\n                    position.active = false;\n                }\n            }\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n    // The top-level container for the entire plot.\n\n    function Plot(placeholder, data_, options_, plugins) {\n        // data is on the form:\n        //   [ series1, series2 ... ]\n        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]\n        // or { data: [ [x1, y1], [x2, y2], ... ], label: \"some label\", ... }\n\n        var series = [],\n            options = {\n            // the color theme used for graphs\n            colors: [\"#edc240\", \"#afd8f8\", \"#cb4b4b\", \"#4da74d\", \"#9440ed\"],\n            legend: {\n                show: true,\n                noColumns: 1, // number of colums in legend table\n                labelFormatter: null, // fn: string -> string\n                labelBoxBorderColor: \"#ccc\", // border color for the little label boxes\n                container: null, // container (as jQuery object) to put legend in, null means default on top of graph\n                position: \"ne\", // position of default legend container within plot\n                margin: 5, // distance from grid edge to default legend container within plot\n                backgroundColor: null, // null means auto-detect\n                backgroundOpacity: 0.85, // set to 0 to avoid background\n                sorted: null // default to no legend sorting\n            },\n            xaxis: {\n                show: null, // null = auto-detect, true = always, false = never\n                position: \"bottom\", // or \"top\"\n                mode: null, // null or \"time\"\n                font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: \"italic\", weight: \"bold\", family: \"sans-serif\", variant: \"small-caps\" }\n                color: null, // base color, labels, ticks\n                tickColor: null, // possibly different color of ticks, e.g. \"rgba(0,0,0,0.15)\"\n                transform: null, // null or f: number -> number to transform axis\n                inverseTransform: null, // if transform is set, this should be the inverse function\n                min: null, // min. value to show, null means set automatically\n                max: null, // max. value to show, null means set automatically\n                autoscaleMargin: null, // margin in % to add if auto-setting min/max\n                ticks: null, // either [1, 3] or [[1, \"a\"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks\n                tickFormatter: null, // fn: number -> string\n                labelWidth: null, // size of tick labels in pixels\n                labelHeight: null,\n                reserveSpace: null, // whether to reserve space even if axis isn't shown\n                tickLength: null, // size in pixels of ticks, or \"full\" for whole line\n                alignTicksWithAxis: null, // axis number or null for no sync\n                tickDecimals: null, // no. of decimals, null means auto\n                tickSize: null, // number or [number, \"unit\"]\n                minTickSize: null // number or [number, \"unit\"]\n            },\n            yaxis: {\n                autoscaleMargin: 0.02,\n                position: \"left\" // or \"right\"\n            },\n            xaxes: [],\n            yaxes: [],\n            series: {\n                points: {\n                    show: false,\n                    radius: 3,\n                    lineWidth: 2, // in pixels\n                    fill: true,\n                    fillColor: \"#ffffff\",\n                    symbol: \"circle\" // or callback\n                },\n                lines: {\n                    // we don't put in show: false so we can see\n                    // whether lines were actively disabled\n                    lineWidth: 2, // in pixels\n                    fill: false,\n                    fillColor: null,\n                    steps: false\n                    // Omit 'zero', so we can later default its value to\n                    // match that of the 'fill' option.\n                },\n                bars: {\n                    show: false,\n                    lineWidth: 2, // in pixels\n                    barWidth: 1, // in units of the x axis\n                    fill: true,\n                    fillColor: null,\n                    align: \"left\", // \"left\", \"right\", or \"center\"\n                    horizontal: false,\n                    zero: true\n                },\n                shadowSize: 3,\n                highlightColor: null\n            },\n            grid: {\n                show: true,\n                aboveData: false,\n                color: \"#545454\", // primary color used for outline and labels\n                backgroundColor: null, // null for transparent, else color\n                borderColor: null, // set if different from the grid color\n                tickColor: null, // color for the ticks, e.g. \"rgba(0,0,0,0.15)\"\n                margin: 0, // distance from the canvas edge to the grid\n                labelMargin: 5, // in pixels\n                axisMargin: 8, // in pixels\n                borderWidth: 2, // in pixels\n                minBorderMargin: null, // in pixels, null means taken from points radius\n                markings: null, // array of ranges or fn: axes -> array of ranges\n                markingsColor: \"#f4f4f4\",\n                markingsLineWidth: 2,\n                // interactive stuff\n                clickable: false,\n                hoverable: false,\n                autoHighlight: true, // highlight in case mouse is near\n                mouseActiveRadius: 10 // how far the mouse can be away to activate an item\n            },\n            interaction: {\n                redrawOverlayInterval: 1000 / 60 // time between updates, -1 means in same flow\n            },\n            hooks: {}\n        },\n            surface = null,\n            // the canvas for the plot itself\n        overlay = null,\n            // canvas for interactive stuff on top of plot\n        eventHolder = null,\n            // jQuery object that events should be bound to\n        ctx = null,\n            octx = null,\n            xaxes = [],\n            yaxes = [],\n            plotOffset = { left: 0, right: 0, top: 0, bottom: 0 },\n            plotWidth = 0,\n            plotHeight = 0,\n            hooks = {\n            processOptions: [],\n            processRawData: [],\n            processDatapoints: [],\n            processOffset: [],\n            drawBackground: [],\n            drawSeries: [],\n            draw: [],\n            bindEvents: [],\n            drawOverlay: [],\n            shutdown: []\n        },\n            plot = this;\n\n        // public functions\n        plot.setData = setData;\n        plot.setupGrid = setupGrid;\n        plot.draw = draw;\n        plot.getPlaceholder = function () {\n            return placeholder;\n        };\n        plot.getCanvas = function () {\n            return surface.element;\n        };\n        plot.getPlotOffset = function () {\n            return plotOffset;\n        };\n        plot.width = function () {\n            return plotWidth;\n        };\n        plot.height = function () {\n            return plotHeight;\n        };\n        plot.offset = function () {\n            var o = eventHolder.offset();\n            o.left += plotOffset.left;\n            o.top += plotOffset.top;\n            return o;\n        };\n        plot.getData = function () {\n            return series;\n        };\n        plot.getAxes = function () {\n            var res = {},\n                i;\n            $.each(xaxes.concat(yaxes), function (_, axis) {\n                if (axis) res[axis.direction + (axis.n != 1 ? axis.n : \"\") + \"axis\"] = axis;\n            });\n            return res;\n        };\n        plot.getXAxes = function () {\n            return xaxes;\n        };\n        plot.getYAxes = function () {\n            return yaxes;\n        };\n        plot.c2p = canvasToAxisCoords;\n        plot.p2c = axisToCanvasCoords;\n        plot.getOptions = function () {\n            return options;\n        };\n        plot.highlight = highlight;\n        plot.unhighlight = unhighlight;\n        plot.triggerRedrawOverlay = triggerRedrawOverlay;\n        plot.pointOffset = function (point) {\n            return {\n                left: parseInt(xaxes[axisNumber(point, \"x\") - 1].p2c(+point.x) + plotOffset.left, 10),\n                top: parseInt(yaxes[axisNumber(point, \"y\") - 1].p2c(+point.y) + plotOffset.top, 10)\n            };\n        };\n        plot.shutdown = shutdown;\n        plot.destroy = function () {\n            shutdown();\n            placeholder.removeData(\"plot\").empty();\n\n            series = [];\n            options = null;\n            surface = null;\n            overlay = null;\n            eventHolder = null;\n            ctx = null;\n            octx = null;\n            xaxes = [];\n            yaxes = [];\n            hooks = null;\n            highlights = [];\n            plot = null;\n        };\n        plot.resize = function () {\n            var width = placeholder.width(),\n                height = placeholder.height();\n            surface.resize(width, height);\n            overlay.resize(width, height);\n        };\n\n        // public attributes\n        plot.hooks = hooks;\n\n        // initialize\n        initPlugins(plot);\n        parseOptions(options_);\n        setupCanvases();\n        setData(data_);\n        setupGrid();\n        draw();\n        bindEvents();\n\n        function executeHooks(hook, args) {\n            args = [plot].concat(args);\n            for (var i = 0; i < hook.length; ++i) {\n                hook[i].apply(this, args);\n            }\n        }\n\n        function initPlugins() {\n\n            // References to key classes, allowing plugins to modify them\n\n            var classes = {\n                Canvas: Canvas\n            };\n\n            for (var i = 0; i < plugins.length; ++i) {\n                var p = plugins[i];\n                p.init(plot, classes);\n                if (p.options) $.extend(true, options, p.options);\n            }\n        }\n\n        function parseOptions(opts) {\n\n            $.extend(true, options, opts);\n\n            // $.extend merges arrays, rather than replacing them.  When less\n            // colors are provided than the size of the default palette, we\n            // end up with those colors plus the remaining defaults, which is\n            // not expected behavior; avoid it by replacing them here.\n\n            if (opts && opts.colors) {\n                options.colors = opts.colors;\n            }\n\n            if (options.xaxis.color == null) options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n            if (options.yaxis.color == null) options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n\n            if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility\n                options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;\n            if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility\n                options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;\n\n            if (options.grid.borderColor == null) options.grid.borderColor = options.grid.color;\n            if (options.grid.tickColor == null) options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n\n            // Fill in defaults for axis options, including any unspecified\n            // font-spec fields, if a font-spec was provided.\n\n            // If no x/y axis options were provided, create one of each anyway,\n            // since the rest of the code assumes that they exist.\n\n            var i,\n                axisOptions,\n                axisCount,\n                fontSize = placeholder.css(\"font-size\"),\n                fontSizeDefault = fontSize ? +fontSize.replace(\"px\", \"\") : 13,\n                fontDefaults = {\n                style: placeholder.css(\"font-style\"),\n                size: Math.round(0.8 * fontSizeDefault),\n                variant: placeholder.css(\"font-variant\"),\n                weight: placeholder.css(\"font-weight\"),\n                family: placeholder.css(\"font-family\")\n            };\n\n            axisCount = options.xaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n\n                axisOptions = options.xaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);\n                options.xaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            axisCount = options.yaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n\n                axisOptions = options.yaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);\n                options.yaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            // backwards compatibility, to be removed in future\n            if (options.xaxis.noTicks && options.xaxis.ticks == null) options.xaxis.ticks = options.xaxis.noTicks;\n            if (options.yaxis.noTicks && options.yaxis.ticks == null) options.yaxis.ticks = options.yaxis.noTicks;\n            if (options.x2axis) {\n                options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);\n                options.xaxes[1].position = \"top\";\n                // Override the inherit to allow the axis to auto-scale\n                if (options.x2axis.min == null) {\n                    options.xaxes[1].min = null;\n                }\n                if (options.x2axis.max == null) {\n                    options.xaxes[1].max = null;\n                }\n            }\n            if (options.y2axis) {\n                options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);\n                options.yaxes[1].position = \"right\";\n                // Override the inherit to allow the axis to auto-scale\n                if (options.y2axis.min == null) {\n                    options.yaxes[1].min = null;\n                }\n                if (options.y2axis.max == null) {\n                    options.yaxes[1].max = null;\n                }\n            }\n            if (options.grid.coloredAreas) options.grid.markings = options.grid.coloredAreas;\n            if (options.grid.coloredAreasColor) options.grid.markingsColor = options.grid.coloredAreasColor;\n            if (options.lines) $.extend(true, options.series.lines, options.lines);\n            if (options.points) $.extend(true, options.series.points, options.points);\n            if (options.bars) $.extend(true, options.series.bars, options.bars);\n            if (options.shadowSize != null) options.series.shadowSize = options.shadowSize;\n            if (options.highlightColor != null) options.series.highlightColor = options.highlightColor;\n\n            // save options on axes for future reference\n            for (i = 0; i < options.xaxes.length; ++i) {\n                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];\n            }for (i = 0; i < options.yaxes.length; ++i) {\n                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];\n            } // add hooks from options\n            for (var n in meteorBabelHelpers.sanitizeForInObject(hooks)) {\n                if (options.hooks[n] && options.hooks[n].length) hooks[n] = hooks[n].concat(options.hooks[n]);\n            }executeHooks(hooks.processOptions, [options]);\n        }\n\n        function setData(d) {\n            series = parseData(d);\n            fillInSeriesOptions();\n            processData();\n        }\n\n        function parseData(d) {\n            var res = [];\n            for (var i = 0; i < d.length; ++i) {\n                var s = $.extend(true, {}, options.series);\n\n                if (d[i].data != null) {\n                    s.data = d[i].data; // move the data instead of deep-copy\n                    delete d[i].data;\n\n                    $.extend(true, s, d[i]);\n\n                    d[i].data = s.data;\n                } else s.data = d[i];\n                res.push(s);\n            }\n\n            return res;\n        }\n\n        function axisNumber(obj, coord) {\n            var a = obj[coord + \"axis\"];\n            if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) == \"object\") // if we got a real axis, extract number\n                a = a.n;\n            if (typeof a != \"number\") a = 1; // default to first axis\n            return a;\n        }\n\n        function allAxes() {\n            // return flat array without annoying null entries\n            return $.grep(xaxes.concat(yaxes), function (a) {\n                return a;\n            });\n        }\n\n        function canvasToAxisCoords(pos) {\n            // return an object with x/y corresponding to all used axes\n            var res = {},\n                i,\n                axis;\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used) res[\"x\" + axis.n] = axis.c2p(pos.left);\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used) res[\"y\" + axis.n] = axis.c2p(pos.top);\n            }\n\n            if (res.x1 !== undefined) res.x = res.x1;\n            if (res.y1 !== undefined) res.y = res.y1;\n\n            return res;\n        }\n\n        function axisToCanvasCoords(pos) {\n            // get canvas coords from the first pair of x/y found in pos\n            var res = {},\n                i,\n                axis,\n                key;\n\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used) {\n                    key = \"x\" + axis.n;\n                    if (pos[key] == null && axis.n == 1) key = \"x\";\n\n                    if (pos[key] != null) {\n                        res.left = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used) {\n                    key = \"y\" + axis.n;\n                    if (pos[key] == null && axis.n == 1) key = \"y\";\n\n                    if (pos[key] != null) {\n                        res.top = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        function getOrCreateAxis(axes, number) {\n            if (!axes[number - 1]) axes[number - 1] = {\n                n: number, // save the number for future reference\n                direction: axes == xaxes ? \"x\" : \"y\",\n                options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)\n            };\n\n            return axes[number - 1];\n        }\n\n        function fillInSeriesOptions() {\n\n            var neededColors = series.length,\n                maxIndex = -1,\n                i;\n\n            // Subtract the number of series that already have fixed colors or\n            // color indexes from the number that we still need to generate.\n\n            for (i = 0; i < series.length; ++i) {\n                var sc = series[i].color;\n                if (sc != null) {\n                    neededColors--;\n                    if (typeof sc == \"number\" && sc > maxIndex) {\n                        maxIndex = sc;\n                    }\n                }\n            }\n\n            // If any of the series have fixed color indexes, then we need to\n            // generate at least as many colors as the highest index.\n\n            if (neededColors <= maxIndex) {\n                neededColors = maxIndex + 1;\n            }\n\n            // Generate all the colors, using first the option colors and then\n            // variations on those colors once they're exhausted.\n\n            var c,\n                colors = [],\n                colorPool = options.colors,\n                colorPoolSize = colorPool.length,\n                variation = 0;\n\n            for (i = 0; i < neededColors; i++) {\n\n                c = $.color.parse(colorPool[i % colorPoolSize] || \"#666\");\n\n                // Each time we exhaust the colors in the pool we adjust\n                // a scaling factor used to produce more variations on\n                // those colors. The factor alternates negative/positive\n                // to produce lighter/darker colors.\n\n                // Reset the variation after every few cycles, or else\n                // it will end up producing only white or black colors.\n\n                if (i % colorPoolSize == 0 && i) {\n                    if (variation >= 0) {\n                        if (variation < 0.5) {\n                            variation = -variation - 0.2;\n                        } else variation = 0;\n                    } else variation = -variation;\n                }\n\n                colors[i] = c.scale('rgb', 1 + variation);\n            }\n\n            // Finalize the series options, filling in their colors\n\n            var colori = 0,\n                s;\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                // assign colors\n                if (s.color == null) {\n                    s.color = colors[colori].toString();\n                    ++colori;\n                } else if (typeof s.color == \"number\") s.color = colors[s.color].toString();\n\n                // turn on lines automatically in case nothing is set\n                if (s.lines.show == null) {\n                    var v,\n                        show = true;\n                    for (v in meteorBabelHelpers.sanitizeForInObject(s)) {\n                        if (s[v] && s[v].show) {\n                            show = false;\n                            break;\n                        }\n                    }if (show) s.lines.show = true;\n                }\n\n                // If nothing was provided for lines.zero, default it to match\n                // lines.fill, since areas by default should extend to zero.\n\n                if (s.lines.zero == null) {\n                    s.lines.zero = !!s.lines.fill;\n                }\n\n                // setup axes\n                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, \"x\"));\n                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, \"y\"));\n            }\n        }\n\n        function processData() {\n            var topSentry = Number.POSITIVE_INFINITY,\n                bottomSentry = Number.NEGATIVE_INFINITY,\n                fakeInfinity = Number.MAX_VALUE,\n                i,\n                j,\n                k,\n                m,\n                length,\n                s,\n                points,\n                ps,\n                x,\n                y,\n                axis,\n                val,\n                f,\n                p,\n                data,\n                format;\n\n            function updateAxis(axis, min, max) {\n                if (min < axis.datamin && min != -fakeInfinity) axis.datamin = min;\n                if (max > axis.datamax && max != fakeInfinity) axis.datamax = max;\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                // init axis\n                axis.datamin = topSentry;\n                axis.datamax = bottomSentry;\n                axis.used = false;\n            });\n\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                s.datapoints = { points: [] };\n\n                executeHooks(hooks.processRawData, [s, s.data, s.datapoints]);\n            }\n\n            // first pass: clean and copy data\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                data = s.data;\n                format = s.datapoints.format;\n\n                if (!format) {\n                    format = [];\n                    // find out how to copy\n                    format.push({ x: true, number: true, required: true });\n                    format.push({ y: true, number: true, required: true });\n\n                    if (s.bars.show || s.lines.show && s.lines.fill) {\n                        var autoscale = !!(s.bars.show && s.bars.zero || s.lines.show && s.lines.zero);\n                        format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });\n                        if (s.bars.horizontal) {\n                            delete format[format.length - 1].y;\n                            format[format.length - 1].x = true;\n                        }\n                    }\n\n                    s.datapoints.format = format;\n                }\n\n                if (s.datapoints.pointsize != null) continue; // already filled in\n\n                s.datapoints.pointsize = format.length;\n\n                ps = s.datapoints.pointsize;\n                points = s.datapoints.points;\n\n                var insertSteps = s.lines.show && s.lines.steps;\n                s.xaxis.used = s.yaxis.used = true;\n\n                for (j = k = 0; j < data.length; ++j, k += ps) {\n                    p = data[j];\n\n                    var nullify = p == null;\n                    if (!nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = p[m];\n                            f = format[m];\n\n                            if (f) {\n                                if (f.number && val != null) {\n                                    val = +val; // convert to number\n                                    if (isNaN(val)) val = null;else if (val == Infinity) val = fakeInfinity;else if (val == -Infinity) val = -fakeInfinity;\n                                }\n\n                                if (val == null) {\n                                    if (f.required) nullify = true;\n\n                                    if (f.defaultValue != null) val = f.defaultValue;\n                                }\n                            }\n\n                            points[k + m] = val;\n                        }\n                    }\n\n                    if (nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = points[k + m];\n                            if (val != null) {\n                                f = format[m];\n                                // extract min/max info\n                                if (f.autoscale !== false) {\n                                    if (f.x) {\n                                        updateAxis(s.xaxis, val, val);\n                                    }\n                                    if (f.y) {\n                                        updateAxis(s.yaxis, val, val);\n                                    }\n                                }\n                            }\n                            points[k + m] = null;\n                        }\n                    } else {\n                        // a little bit of line specific stuff that\n                        // perhaps shouldn't be here, but lacking\n                        // better means...\n                        if (insertSteps && k > 0 && points[k - ps] != null && points[k - ps] != points[k] && points[k - ps + 1] != points[k + 1]) {\n                            // copy the point to make room for a middle point\n                            for (m = 0; m < ps; ++m) {\n                                points[k + ps + m] = points[k + m];\n                            } // middle point has same y\n                            points[k + 1] = points[k - ps + 1];\n\n                            // we've added a point, better reflect that\n                            k += ps;\n                        }\n                    }\n                }\n            }\n\n            // give the hooks a chance to run\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                executeHooks(hooks.processDatapoints, [s, s.datapoints]);\n            }\n\n            // second pass: find datamax/datamin for auto-scaling\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                points = s.datapoints.points;\n                ps = s.datapoints.pointsize;\n                format = s.datapoints.format;\n\n                var xmin = topSentry,\n                    ymin = topSentry,\n                    xmax = bottomSentry,\n                    ymax = bottomSentry;\n\n                for (j = 0; j < points.length; j += ps) {\n                    if (points[j] == null) continue;\n\n                    for (m = 0; m < ps; ++m) {\n                        val = points[j + m];\n                        f = format[m];\n                        if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity) continue;\n\n                        if (f.x) {\n                            if (val < xmin) xmin = val;\n                            if (val > xmax) xmax = val;\n                        }\n                        if (f.y) {\n                            if (val < ymin) ymin = val;\n                            if (val > ymax) ymax = val;\n                        }\n                    }\n                }\n\n                if (s.bars.show) {\n                    // make sure we got room for the bar on the dancing floor\n                    var delta;\n\n                    switch (s.bars.align) {\n                        case \"left\":\n                            delta = 0;\n                            break;\n                        case \"right\":\n                            delta = -s.bars.barWidth;\n                            break;\n                        default:\n                            delta = -s.bars.barWidth / 2;\n                    }\n\n                    if (s.bars.horizontal) {\n                        ymin += delta;\n                        ymax += delta + s.bars.barWidth;\n                    } else {\n                        xmin += delta;\n                        xmax += delta + s.bars.barWidth;\n                    }\n                }\n\n                updateAxis(s.xaxis, xmin, xmax);\n                updateAxis(s.yaxis, ymin, ymax);\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                if (axis.datamin == topSentry) axis.datamin = null;\n                if (axis.datamax == bottomSentry) axis.datamax = null;\n            });\n        }\n\n        function setupCanvases() {\n\n            // Make sure the placeholder is clear of everything except canvases\n            // from a previous plot in this container that we'll try to re-use.\n\n            placeholder.css(\"padding\", 0) // padding messes up the positioning\n            .children().filter(function () {\n                return !$(this).hasClass(\"flot-overlay\") && !$(this).hasClass('flot-base');\n            }).remove();\n\n            if (placeholder.css(\"position\") == 'static') placeholder.css(\"position\", \"relative\"); // for positioning labels and overlay\n\n            surface = new Canvas(\"flot-base\", placeholder);\n            overlay = new Canvas(\"flot-overlay\", placeholder); // overlay canvas for interactive features\n\n            ctx = surface.context;\n            octx = overlay.context;\n\n            // define which element we're listening for events on\n            eventHolder = $(overlay.element).unbind();\n\n            // If we're re-using a plot object, shut down the old one\n\n            var existing = placeholder.data(\"plot\");\n\n            if (existing) {\n                existing.shutdown();\n                overlay.clear();\n            }\n\n            // save in case we get replotted\n            placeholder.data(\"plot\", plot);\n        }\n\n        function bindEvents() {\n            // bind events\n            if (options.grid.hoverable) {\n                eventHolder.mousemove(onMouseMove);\n\n                // Use bind, rather than .mouseleave, because we officially\n                // still support jQuery 1.2.6, which doesn't define a shortcut\n                // for mouseenter or mouseleave.  This was a bug/oversight that\n                // was fixed somewhere around 1.3.x.  We can return to using\n                // .mouseleave when we drop support for 1.2.6.\n\n                eventHolder.bind(\"mouseleave\", onMouseLeave);\n            }\n\n            if (options.grid.clickable) eventHolder.click(onClick);\n\n            executeHooks(hooks.bindEvents, [eventHolder]);\n        }\n\n        function shutdown() {\n            if (redrawTimeout) clearTimeout(redrawTimeout);\n\n            eventHolder.unbind(\"mousemove\", onMouseMove);\n            eventHolder.unbind(\"mouseleave\", onMouseLeave);\n            eventHolder.unbind(\"click\", onClick);\n\n            executeHooks(hooks.shutdown, [eventHolder]);\n        }\n\n        function setTransformationHelpers(axis) {\n            // set helper functions on the axis, assumes plot area\n            // has been computed already\n\n            function identity(x) {\n                return x;\n            }\n\n            var s,\n                m,\n                t = axis.options.transform || identity,\n                it = axis.options.inverseTransform;\n\n            // precompute how much the axis is scaling a point\n            // in canvas space\n            if (axis.direction == \"x\") {\n                s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));\n                m = Math.min(t(axis.max), t(axis.min));\n            } else {\n                s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));\n                s = -s;\n                m = Math.max(t(axis.max), t(axis.min));\n            }\n\n            // data point to canvas coordinate\n            if (t == identity) // slight optimization\n                axis.p2c = function (p) {\n                    return (p - m) * s;\n                };else axis.p2c = function (p) {\n                return (t(p) - m) * s;\n            };\n            // canvas coordinate to data point\n            if (!it) axis.c2p = function (c) {\n                return m + c / s;\n            };else axis.c2p = function (c) {\n                return it(m + c / s);\n            };\n        }\n\n        function measureTickLabels(axis) {\n\n            var opts = axis.options,\n                ticks = axis.ticks || [],\n                labelWidth = opts.labelWidth || 0,\n                labelHeight = opts.labelHeight || 0,\n                maxWidth = labelWidth || (axis.direction == \"x\" ? Math.floor(surface.width / (ticks.length || 1)) : null),\n                legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                font = opts.font || \"flot-tick-label tickLabel\";\n\n            for (var i = 0; i < ticks.length; ++i) {\n\n                var t = ticks[i];\n\n                if (!t.label) continue;\n\n                var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);\n\n                labelWidth = Math.max(labelWidth, info.width);\n                labelHeight = Math.max(labelHeight, info.height);\n            }\n\n            axis.labelWidth = opts.labelWidth || labelWidth;\n            axis.labelHeight = opts.labelHeight || labelHeight;\n        }\n\n        function allocateAxisBoxFirstPhase(axis) {\n            // find the bounding box of the axis by looking at label\n            // widths/heights and ticks, make room by diminishing the\n            // plotOffset; this first phase only looks at one\n            // dimension per axis, the other dimension depends on the\n            // other axes so will have to wait\n\n            var lw = axis.labelWidth,\n                lh = axis.labelHeight,\n                pos = axis.options.position,\n                isXAxis = axis.direction === \"x\",\n                tickLength = axis.options.tickLength,\n                axisMargin = options.grid.axisMargin,\n                padding = options.grid.labelMargin,\n                innermost = true,\n                outermost = true,\n                first = true,\n                found = false;\n\n            // Determine the axis's position in its direction and on its side\n\n            $.each(isXAxis ? xaxes : yaxes, function (i, a) {\n                if (a && (a.show || a.reserveSpace)) {\n                    if (a === axis) {\n                        found = true;\n                    } else if (a.options.position === pos) {\n                        if (found) {\n                            outermost = false;\n                        } else {\n                            innermost = false;\n                        }\n                    }\n                    if (!found) {\n                        first = false;\n                    }\n                }\n            });\n\n            // The outermost axis on each side has no margin\n\n            if (outermost) {\n                axisMargin = 0;\n            }\n\n            // The ticks for the first axis in each direction stretch across\n\n            if (tickLength == null) {\n                tickLength = first ? \"full\" : 5;\n            }\n\n            if (!isNaN(+tickLength)) padding += +tickLength;\n\n            if (isXAxis) {\n                lh += padding;\n\n                if (pos == \"bottom\") {\n                    plotOffset.bottom += lh + axisMargin;\n                    axis.box = { top: surface.height - plotOffset.bottom, height: lh };\n                } else {\n                    axis.box = { top: plotOffset.top + axisMargin, height: lh };\n                    plotOffset.top += lh + axisMargin;\n                }\n            } else {\n                lw += padding;\n\n                if (pos == \"left\") {\n                    axis.box = { left: plotOffset.left + axisMargin, width: lw };\n                    plotOffset.left += lw + axisMargin;\n                } else {\n                    plotOffset.right += lw + axisMargin;\n                    axis.box = { left: surface.width - plotOffset.right, width: lw };\n                }\n            }\n\n            // save for future reference\n            axis.position = pos;\n            axis.tickLength = tickLength;\n            axis.box.padding = padding;\n            axis.innermost = innermost;\n        }\n\n        function allocateAxisBoxSecondPhase(axis) {\n            // now that all axis boxes have been placed in one\n            // dimension, we can set the remaining dimension coordinates\n            if (axis.direction == \"x\") {\n                axis.box.left = plotOffset.left - axis.labelWidth / 2;\n                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;\n            } else {\n                axis.box.top = plotOffset.top - axis.labelHeight / 2;\n                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;\n            }\n        }\n\n        function adjustLayoutForThingsStickingOut() {\n            // possibly adjust plot offset to ensure everything stays\n            // inside the canvas and isn't clipped off\n\n            var minMargin = options.grid.minBorderMargin,\n                axis,\n                i;\n\n            // check stuff from the plot (FIXME: this should just read\n            // a value from the series, otherwise it's impossible to\n            // customize)\n            if (minMargin == null) {\n                minMargin = 0;\n                for (i = 0; i < series.length; ++i) {\n                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth / 2));\n                }\n            }\n\n            var margins = {\n                left: minMargin,\n                right: minMargin,\n                top: minMargin,\n                bottom: minMargin\n            };\n\n            // check axis labels, note we don't check the actual\n            // labels but instead use the overall width/height to not\n            // jump as much around with replots\n            $.each(allAxes(), function (_, axis) {\n                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {\n                    if (axis.direction === \"x\") {\n                        margins.left = Math.max(margins.left, axis.labelWidth / 2);\n                        margins.right = Math.max(margins.right, axis.labelWidth / 2);\n                    } else {\n                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);\n                        margins.top = Math.max(margins.top, axis.labelHeight / 2);\n                    }\n                }\n            });\n\n            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));\n            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));\n            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));\n            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));\n        }\n\n        function setupGrid() {\n            var i,\n                axes = allAxes(),\n                showGrid = options.grid.show;\n\n            // Initialize the plot's offset from the edge of the canvas\n\n            for (var a in meteorBabelHelpers.sanitizeForInObject(plotOffset)) {\n                var margin = options.grid.margin || 0;\n                plotOffset[a] = typeof margin == \"number\" ? margin : margin[a] || 0;\n            }\n\n            executeHooks(hooks.processOffset, [plotOffset]);\n\n            // If the grid is visible, add its border width to the offset\n\n            for (var a in meteorBabelHelpers.sanitizeForInObject(plotOffset)) {\n                if (_typeof(options.grid.borderWidth) == \"object\") {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;\n                } else {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;\n                }\n            }\n\n            $.each(axes, function (_, axis) {\n                var axisOpts = axis.options;\n                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;\n                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;\n                setRange(axis);\n            });\n\n            if (showGrid) {\n\n                var allocatedAxes = $.grep(axes, function (axis) {\n                    return axis.show || axis.reserveSpace;\n                });\n\n                $.each(allocatedAxes, function (_, axis) {\n                    // make the ticks\n                    setupTickGeneration(axis);\n                    setTicks(axis);\n                    snapRangeToTicks(axis, axis.ticks);\n                    // find labelWidth/Height for axis\n                    measureTickLabels(axis);\n                });\n\n                // with all dimensions calculated, we can compute the\n                // axis bounding boxes, start from the outside\n                // (reverse order)\n                for (i = allocatedAxes.length - 1; i >= 0; --i) {\n                    allocateAxisBoxFirstPhase(allocatedAxes[i]);\n                } // make sure we've got enough space for things that\n                // might stick out\n                adjustLayoutForThingsStickingOut();\n\n                $.each(allocatedAxes, function (_, axis) {\n                    allocateAxisBoxSecondPhase(axis);\n                });\n            }\n\n            plotWidth = surface.width - plotOffset.left - plotOffset.right;\n            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;\n\n            // now we got the proper plot dimensions, we can compute the scaling\n            $.each(axes, function (_, axis) {\n                setTransformationHelpers(axis);\n            });\n\n            if (showGrid) {\n                drawAxisLabels();\n            }\n\n            insertLegend();\n        }\n\n        function setRange(axis) {\n            var opts = axis.options,\n                min = +(opts.min != null ? opts.min : axis.datamin),\n                max = +(opts.max != null ? opts.max : axis.datamax),\n                delta = max - min;\n\n            if (delta == 0.0) {\n                // degenerate case\n                var widen = max == 0 ? 1 : 0.01;\n\n                if (opts.min == null) min -= widen;\n                // always widen max if we couldn't widen min to ensure we\n                // don't fall into min == max which doesn't work\n                if (opts.max == null || opts.min != null) max += widen;\n            } else {\n                // consider autoscaling\n                var margin = opts.autoscaleMargin;\n                if (margin != null) {\n                    if (opts.min == null) {\n                        min -= delta * margin;\n                        // make sure we don't go below zero if all values\n                        // are positive\n                        if (min < 0 && axis.datamin != null && axis.datamin >= 0) min = 0;\n                    }\n                    if (opts.max == null) {\n                        max += delta * margin;\n                        if (max > 0 && axis.datamax != null && axis.datamax <= 0) max = 0;\n                    }\n                }\n            }\n            axis.min = min;\n            axis.max = max;\n        }\n\n        function setupTickGeneration(axis) {\n            var opts = axis.options;\n\n            // estimate number of ticks\n            var noTicks;\n            if (typeof opts.ticks == \"number\" && opts.ticks > 0) noTicks = opts.ticks;else\n                // heuristic based on the model a*sqrt(x) fitted to\n                // some data points that seemed reasonable\n                noTicks = 0.3 * Math.sqrt(axis.direction == \"x\" ? surface.width : surface.height);\n\n            var delta = (axis.max - axis.min) / noTicks,\n                dec = -Math.floor(Math.log(delta) / Math.LN10),\n                maxDec = opts.tickDecimals;\n\n            if (maxDec != null && dec > maxDec) {\n                dec = maxDec;\n            }\n\n            var magn = Math.pow(10, -dec),\n                norm = delta / magn,\n                // norm is between 1.0 and 10.0\n            size;\n\n            if (norm < 1.5) {\n                size = 1;\n            } else if (norm < 3) {\n                size = 2;\n                // special case for 2.5, requires an extra decimal\n                if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {\n                    size = 2.5;\n                    ++dec;\n                }\n            } else if (norm < 7.5) {\n                size = 5;\n            } else {\n                size = 10;\n            }\n\n            size *= magn;\n\n            if (opts.minTickSize != null && size < opts.minTickSize) {\n                size = opts.minTickSize;\n            }\n\n            axis.delta = delta;\n            axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);\n            axis.tickSize = opts.tickSize || size;\n\n            // Time mode was moved to a plug-in in 0.8, and since so many people use it\n            // we'll add an especially friendly reminder to make sure they included it.\n\n            if (opts.mode == \"time\" && !axis.tickGenerator) {\n                throw new Error(\"Time mode requires the flot.time plugin.\");\n            }\n\n            // Flot supports base-10 axes; any other mode else is handled by a plug-in,\n            // like flot.time.js.\n\n            if (!axis.tickGenerator) {\n\n                axis.tickGenerator = function (axis) {\n\n                    var ticks = [],\n                        start = floorInBase(axis.min, axis.tickSize),\n                        i = 0,\n                        v = Number.NaN,\n                        prev;\n\n                    do {\n                        prev = v;\n                        v = start + i * axis.tickSize;\n                        ticks.push(v);\n                        ++i;\n                    } while (v < axis.max && v != prev);\n                    return ticks;\n                };\n\n                axis.tickFormatter = function (value, axis) {\n\n                    var factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;\n                    var formatted = \"\" + Math.round(value * factor) / factor;\n\n                    // If tickDecimals was specified, ensure that we have exactly that\n                    // much precision; otherwise default to the value's own precision.\n\n                    if (axis.tickDecimals != null) {\n                        var decimal = formatted.indexOf(\".\");\n                        var precision = decimal == -1 ? 0 : formatted.length - decimal - 1;\n                        if (precision < axis.tickDecimals) {\n                            return (precision ? formatted : formatted + \".\") + (\"\" + factor).substr(1, axis.tickDecimals - precision);\n                        }\n                    }\n\n                    return formatted;\n                };\n            }\n\n            if ($.isFunction(opts.tickFormatter)) axis.tickFormatter = function (v, axis) {\n                return \"\" + opts.tickFormatter(v, axis);\n            };\n\n            if (opts.alignTicksWithAxis != null) {\n                var otherAxis = (axis.direction == \"x\" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];\n                if (otherAxis && otherAxis.used && otherAxis != axis) {\n                    // consider snapping min/max to outermost nice ticks\n                    var niceTicks = axis.tickGenerator(axis);\n                    if (niceTicks.length > 0) {\n                        if (opts.min == null) axis.min = Math.min(axis.min, niceTicks[0]);\n                        if (opts.max == null && niceTicks.length > 1) axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);\n                    }\n\n                    axis.tickGenerator = function (axis) {\n                        // copy ticks, scaled to this axis\n                        var ticks = [],\n                            v,\n                            i;\n                        for (i = 0; i < otherAxis.ticks.length; ++i) {\n                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);\n                            v = axis.min + v * (axis.max - axis.min);\n                            ticks.push(v);\n                        }\n                        return ticks;\n                    };\n\n                    // we might need an extra decimal since forced\n                    // ticks don't necessarily fit naturally\n                    if (!axis.mode && opts.tickDecimals == null) {\n                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),\n                            ts = axis.tickGenerator(axis);\n\n                        // only proceed if the tick interval rounded\n                        // with an extra decimal doesn't give us a\n                        // zero at end\n                        if (!(ts.length > 1 && /\\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec)))) axis.tickDecimals = extraDec;\n                    }\n                }\n            }\n        }\n\n        function setTicks(axis) {\n            var oticks = axis.options.ticks,\n                ticks = [];\n            if (oticks == null || typeof oticks == \"number\" && oticks > 0) ticks = axis.tickGenerator(axis);else if (oticks) {\n                if ($.isFunction(oticks))\n                    // generate the ticks\n                    ticks = oticks(axis);else ticks = oticks;\n            }\n\n            // clean up/labelify the supplied ticks, copy them over\n            var i, v;\n            axis.ticks = [];\n            for (i = 0; i < ticks.length; ++i) {\n                var label = null;\n                var t = ticks[i];\n                if ((typeof t === \"undefined\" ? \"undefined\" : _typeof(t)) == \"object\") {\n                    v = +t[0];\n                    if (t.length > 1) label = t[1];\n                } else v = +t;\n                if (label == null) label = axis.tickFormatter(v, axis);\n                if (!isNaN(v)) axis.ticks.push({ v: v, label: label });\n            }\n        }\n\n        function snapRangeToTicks(axis, ticks) {\n            if (axis.options.autoscaleMargin && ticks.length > 0) {\n                // snap to ticks\n                if (axis.options.min == null) axis.min = Math.min(axis.min, ticks[0].v);\n                if (axis.options.max == null && ticks.length > 1) axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);\n            }\n        }\n\n        function draw() {\n\n            surface.clear();\n\n            executeHooks(hooks.drawBackground, [ctx]);\n\n            var grid = options.grid;\n\n            // draw background, if any\n            if (grid.show && grid.backgroundColor) drawBackground();\n\n            if (grid.show && !grid.aboveData) {\n                drawGrid();\n            }\n\n            for (var i = 0; i < series.length; ++i) {\n                executeHooks(hooks.drawSeries, [ctx, series[i]]);\n                drawSeries(series[i]);\n            }\n\n            executeHooks(hooks.draw, [ctx]);\n\n            if (grid.show && grid.aboveData) {\n                drawGrid();\n            }\n\n            surface.render();\n\n            // A draw implies that either the axes or data have changed, so we\n            // should probably update the overlay highlights as well.\n\n            triggerRedrawOverlay();\n        }\n\n        function extractRange(ranges, coord) {\n            var axis,\n                from,\n                to,\n                key,\n                axes = allAxes();\n\n            for (var i = 0; i < axes.length; ++i) {\n                axis = axes[i];\n                if (axis.direction == coord) {\n                    key = coord + axis.n + \"axis\";\n                    if (!ranges[key] && axis.n == 1) key = coord + \"axis\"; // support x1axis as xaxis\n                    if (ranges[key]) {\n                        from = ranges[key].from;\n                        to = ranges[key].to;\n                        break;\n                    }\n                }\n            }\n\n            // backwards-compat stuff - to be removed in future\n            if (!ranges[key]) {\n                axis = coord == \"x\" ? xaxes[0] : yaxes[0];\n                from = ranges[coord + \"1\"];\n                to = ranges[coord + \"2\"];\n            }\n\n            // auto-reverse as an added bonus\n            if (from != null && to != null && from > to) {\n                var tmp = from;\n                from = to;\n                to = tmp;\n            }\n\n            return { from: from, to: to, axis: axis };\n        }\n\n        function drawBackground() {\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, \"rgba(255, 255, 255, 0)\");\n            ctx.fillRect(0, 0, plotWidth, plotHeight);\n            ctx.restore();\n        }\n\n        function drawGrid() {\n            var i, axes, bw, bc;\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // draw markings\n            var markings = options.grid.markings;\n            if (markings) {\n                if ($.isFunction(markings)) {\n                    axes = plot.getAxes();\n                    // xmin etc. is backwards compatibility, to be\n                    // removed in the future\n                    axes.xmin = axes.xaxis.min;\n                    axes.xmax = axes.xaxis.max;\n                    axes.ymin = axes.yaxis.min;\n                    axes.ymax = axes.yaxis.max;\n\n                    markings = markings(axes);\n                }\n\n                for (i = 0; i < markings.length; ++i) {\n                    var m = markings[i],\n                        xrange = extractRange(m, \"x\"),\n                        yrange = extractRange(m, \"y\");\n\n                    // fill in missing\n                    if (xrange.from == null) xrange.from = xrange.axis.min;\n                    if (xrange.to == null) xrange.to = xrange.axis.max;\n                    if (yrange.from == null) yrange.from = yrange.axis.min;\n                    if (yrange.to == null) yrange.to = yrange.axis.max;\n\n                    // clip\n                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max || yrange.to < yrange.axis.min || yrange.from > yrange.axis.max) continue;\n\n                    xrange.from = Math.max(xrange.from, xrange.axis.min);\n                    xrange.to = Math.min(xrange.to, xrange.axis.max);\n                    yrange.from = Math.max(yrange.from, yrange.axis.min);\n                    yrange.to = Math.min(yrange.to, yrange.axis.max);\n\n                    var xequal = xrange.from === xrange.to,\n                        yequal = yrange.from === yrange.to;\n\n                    if (xequal && yequal) {\n                        continue;\n                    }\n\n                    // then draw\n                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));\n                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));\n                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));\n                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));\n\n                    if (xequal || yequal) {\n                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth,\n                            subPixel = lineWidth % 2 ? 0.5 : 0;\n                        ctx.beginPath();\n                        ctx.strokeStyle = m.color || options.grid.markingsColor;\n                        ctx.lineWidth = lineWidth;\n                        if (xequal) {\n                            ctx.moveTo(xrange.to + subPixel, yrange.from);\n                            ctx.lineTo(xrange.to + subPixel, yrange.to);\n                        } else {\n                            ctx.moveTo(xrange.from, yrange.to + subPixel);\n                            ctx.lineTo(xrange.to, yrange.to + subPixel);\n                        }\n                        ctx.stroke();\n                    } else {\n                        ctx.fillStyle = m.color || options.grid.markingsColor;\n                        ctx.fillRect(xrange.from, yrange.to, xrange.to - xrange.from, yrange.from - yrange.to);\n                    }\n                }\n            }\n\n            // draw the ticks\n            axes = allAxes();\n            bw = options.grid.borderWidth;\n\n            for (var j = 0; j < axes.length; ++j) {\n                var axis = axes[j],\n                    box = axis.box,\n                    t = axis.tickLength,\n                    x,\n                    y,\n                    xoff,\n                    yoff;\n                if (!axis.show || axis.ticks.length == 0) continue;\n\n                ctx.lineWidth = 1;\n\n                // find the edges\n                if (axis.direction == \"x\") {\n                    x = 0;\n                    if (t == \"full\") y = axis.position == \"top\" ? 0 : plotHeight;else y = box.top - plotOffset.top + (axis.position == \"top\" ? box.height : 0);\n                } else {\n                    y = 0;\n                    if (t == \"full\") x = axis.position == \"left\" ? 0 : plotWidth;else x = box.left - plotOffset.left + (axis.position == \"left\" ? box.width : 0);\n                }\n\n                // draw tick bar\n                if (!axis.innermost) {\n                    ctx.strokeStyle = axis.options.color;\n                    ctx.beginPath();\n                    xoff = yoff = 0;\n                    if (axis.direction == \"x\") xoff = plotWidth + 1;else yoff = plotHeight + 1;\n\n                    if (ctx.lineWidth == 1) {\n                        if (axis.direction == \"x\") {\n                            y = Math.floor(y) + 0.5;\n                        } else {\n                            x = Math.floor(x) + 0.5;\n                        }\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                    ctx.stroke();\n                }\n\n                // draw ticks\n\n                ctx.strokeStyle = axis.options.tickColor;\n\n                ctx.beginPath();\n                for (i = 0; i < axis.ticks.length; ++i) {\n                    var v = axis.ticks[i].v;\n\n                    xoff = yoff = 0;\n\n                    if (isNaN(v) || v < axis.min || v > axis.max\n                    // skip those lying on the axes if we got a border\n                    || t == \"full\" && ((typeof bw === \"undefined\" ? \"undefined\" : _typeof(bw)) == \"object\" && bw[axis.position] > 0 || bw > 0) && (v == axis.min || v == axis.max)) continue;\n\n                    if (axis.direction == \"x\") {\n                        x = axis.p2c(v);\n                        yoff = t == \"full\" ? -plotHeight : t;\n\n                        if (axis.position == \"top\") yoff = -yoff;\n                    } else {\n                        y = axis.p2c(v);\n                        xoff = t == \"full\" ? -plotWidth : t;\n\n                        if (axis.position == \"left\") xoff = -xoff;\n                    }\n\n                    if (ctx.lineWidth == 1) {\n                        if (axis.direction == \"x\") x = Math.floor(x) + 0.5;else y = Math.floor(y) + 0.5;\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                }\n\n                ctx.stroke();\n            }\n\n            // draw border\n            if (bw) {\n                // If either borderWidth or borderColor is an object, then draw the border\n                // line by line instead of as one rectangle\n                bc = options.grid.borderColor;\n                if ((typeof bw === \"undefined\" ? \"undefined\" : _typeof(bw)) == \"object\" || (typeof bc === \"undefined\" ? \"undefined\" : _typeof(bc)) == \"object\") {\n                    if ((typeof bw === \"undefined\" ? \"undefined\" : _typeof(bw)) !== \"object\") {\n                        bw = { top: bw, right: bw, bottom: bw, left: bw };\n                    }\n                    if ((typeof bc === \"undefined\" ? \"undefined\" : _typeof(bc)) !== \"object\") {\n                        bc = { top: bc, right: bc, bottom: bc, left: bc };\n                    }\n\n                    if (bw.top > 0) {\n                        ctx.strokeStyle = bc.top;\n                        ctx.lineWidth = bw.top;\n                        ctx.beginPath();\n                        ctx.moveTo(0 - bw.left, 0 - bw.top / 2);\n                        ctx.lineTo(plotWidth, 0 - bw.top / 2);\n                        ctx.stroke();\n                    }\n\n                    if (bw.right > 0) {\n                        ctx.strokeStyle = bc.right;\n                        ctx.lineWidth = bw.right;\n                        ctx.beginPath();\n                        ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);\n                        ctx.lineTo(plotWidth + bw.right / 2, plotHeight);\n                        ctx.stroke();\n                    }\n\n                    if (bw.bottom > 0) {\n                        ctx.strokeStyle = bc.bottom;\n                        ctx.lineWidth = bw.bottom;\n                        ctx.beginPath();\n                        ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);\n                        ctx.lineTo(0, plotHeight + bw.bottom / 2);\n                        ctx.stroke();\n                    }\n\n                    if (bw.left > 0) {\n                        ctx.strokeStyle = bc.left;\n                        ctx.lineWidth = bw.left;\n                        ctx.beginPath();\n                        ctx.moveTo(0 - bw.left / 2, plotHeight + bw.bottom);\n                        ctx.lineTo(0 - bw.left / 2, 0);\n                        ctx.stroke();\n                    }\n                } else {\n                    ctx.lineWidth = bw;\n                    ctx.strokeStyle = options.grid.borderColor;\n                    ctx.strokeRect(-bw / 2, -bw / 2, plotWidth + bw, plotHeight + bw);\n                }\n            }\n\n            ctx.restore();\n        }\n\n        function drawAxisLabels() {\n\n            $.each(allAxes(), function (_, axis) {\n                var box = axis.box,\n                    legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                    layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                    font = axis.options.font || \"flot-tick-label tickLabel\",\n                    tick,\n                    x,\n                    y,\n                    halign,\n                    valign;\n\n                // Remove text before checking for axis.show and ticks.length;\n                // otherwise plugins, like flot-tickrotor, that draw their own\n                // tick labels will end up with both theirs and the defaults.\n\n                surface.removeText(layer);\n\n                if (!axis.show || axis.ticks.length == 0) return;\n\n                for (var i = 0; i < axis.ticks.length; ++i) {\n\n                    tick = axis.ticks[i];\n                    if (!tick.label || tick.v < axis.min || tick.v > axis.max) continue;\n\n                    if (axis.direction == \"x\") {\n                        halign = \"center\";\n                        x = plotOffset.left + axis.p2c(tick.v);\n                        if (axis.position == \"bottom\") {\n                            y = box.top + box.padding;\n                        } else {\n                            y = box.top + box.height - box.padding;\n                            valign = \"bottom\";\n                        }\n                    } else {\n                        valign = \"middle\";\n                        y = plotOffset.top + axis.p2c(tick.v);\n                        if (axis.position == \"left\") {\n                            x = box.left + box.width - box.padding;\n                            halign = \"right\";\n                        } else {\n                            x = box.left + box.padding;\n                        }\n                    }\n\n                    surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);\n                }\n            });\n        }\n\n        function drawSeries(series) {\n            if (series.lines.show) drawSeriesLines(series);\n            if (series.bars.show) drawSeriesBars(series);\n            if (series.points.show) drawSeriesPoints(series);\n        }\n\n        function drawSeriesLines(series) {\n            function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    prevx = null,\n                    prevy = null;\n\n                ctx.beginPath();\n                for (var i = ps; i < points.length; i += ps) {\n                    var x1 = points[i - ps],\n                        y1 = points[i - ps + 1],\n                        x2 = points[i],\n                        y2 = points[i + 1];\n\n                    if (x1 == null || x2 == null) continue;\n\n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min) {\n                        if (y2 < axisy.min) continue; // line segment is outside\n                        // compute new intersection point\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    } else if (y2 <= y1 && y2 < axisy.min) {\n                        if (y1 < axisy.min) continue;\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max) {\n                        if (y2 > axisy.max) continue;\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    } else if (y2 >= y1 && y2 > axisy.max) {\n                        if (y1 > axisy.max) continue;\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min) continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    } else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min) continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max) continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    } else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max) continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (x1 != prevx || y1 != prevy) ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);\n\n                    prevx = x2;\n                    prevy = y2;\n                    ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);\n                }\n                ctx.stroke();\n            }\n\n            function plotLineArea(datapoints, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    bottom = Math.min(Math.max(0, axisy.min), axisy.max),\n                    i = 0,\n                    top,\n                    areaOpen = false,\n                    ypos = 1,\n                    segmentStart = 0,\n                    segmentEnd = 0;\n\n                // we process each segment in two turns, first forward\n                // direction to sketch out top, then once we hit the\n                // end we go backwards to sketch the bottom\n                while (true) {\n                    if (ps > 0 && i > points.length + ps) break;\n\n                    i += ps; // ps is negative if going backwards\n\n                    var x1 = points[i - ps],\n                        y1 = points[i - ps + ypos],\n                        x2 = points[i],\n                        y2 = points[i + ypos];\n\n                    if (areaOpen) {\n                        if (ps > 0 && x1 != null && x2 == null) {\n                            // at turning point\n                            segmentEnd = i;\n                            ps = -ps;\n                            ypos = 2;\n                            continue;\n                        }\n\n                        if (ps < 0 && i == segmentStart + ps) {\n                            // done with the reverse sweep\n                            ctx.fill();\n                            areaOpen = false;\n                            ps = -ps;\n                            ypos = 1;\n                            i = segmentStart = segmentEnd + ps;\n                            continue;\n                        }\n                    }\n\n                    if (x1 == null || x2 == null) continue;\n\n                    // clip x values\n\n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min) continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    } else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min) continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max) continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    } else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max) continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (!areaOpen) {\n                        // open area\n                        ctx.beginPath();\n                        ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));\n                        areaOpen = true;\n                    }\n\n                    // now first check the case where both is outside\n                    if (y1 >= axisy.max && y2 >= axisy.max) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));\n                        continue;\n                    } else if (y1 <= axisy.min && y2 <= axisy.min) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));\n                        continue;\n                    }\n\n                    // else it's a bit more complicated, there might\n                    // be a flat maxed out rectangle first, then a\n                    // triangular cutout or reverse; to find these\n                    // keep track of the current x values\n                    var x1old = x1,\n                        x2old = x2;\n\n                    // clip the y values, without shortcutting, we\n                    // go through all cases in turn\n\n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    } else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    } else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // if the x value was changed we got a rectangle\n                    // to fill\n                    if (x1 != x1old) {\n                        ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));\n                        // it goes to (x1, y1), but we fill that below\n                    }\n\n                    // fill triangular section, this sometimes result\n                    // in redundant points if (x1, y1) hasn't changed\n                    // from previous line to, but we just ignore that\n                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));\n                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n\n                    // fill the other rectangle if it's there\n                    if (x2 != x2old) {\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n                        ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));\n                    }\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n            ctx.lineJoin = \"round\";\n\n            var lw = series.lines.lineWidth,\n                sw = series.shadowSize;\n            // FIXME: consider another form of shadow when filling is turned on\n            if (lw > 0 && sw > 0) {\n                // draw shadow as a thick and thin line with transparency\n                ctx.lineWidth = sw;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                // position shadow at angle from the mid of line\n                var angle = Math.PI / 18;\n                plotLine(series.datapoints, Math.sin(angle) * (lw / 2 + sw / 2), Math.cos(angle) * (lw / 2 + sw / 2), series.xaxis, series.yaxis);\n                ctx.lineWidth = sw / 2;\n                plotLine(series.datapoints, Math.sin(angle) * (lw / 2 + sw / 4), Math.cos(angle) * (lw / 2 + sw / 4), series.xaxis, series.yaxis);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);\n            if (fillStyle) {\n                ctx.fillStyle = fillStyle;\n                plotLineArea(series.datapoints, series.xaxis, series.yaxis);\n            }\n\n            if (lw > 0) plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function drawSeriesPoints(series) {\n            function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    var x = points[i],\n                        y = points[i + 1];\n                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) continue;\n\n                    ctx.beginPath();\n                    x = axisx.p2c(x);\n                    y = axisy.p2c(y) + offset;\n                    if (symbol == \"circle\") ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);else symbol(ctx, x, y, radius, shadow);\n                    ctx.closePath();\n\n                    if (fillStyle) {\n                        ctx.fillStyle = fillStyle;\n                        ctx.fill();\n                    }\n                    ctx.stroke();\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            var lw = series.points.lineWidth,\n                sw = series.shadowSize,\n                radius = series.points.radius,\n                symbol = series.points.symbol;\n\n            // If the user sets the line width to 0, we change it to a very\n            // small value. A line width of 0 seems to force the default of 1.\n            // Doing the conditional here allows the shadow setting to still be\n            // optional even with a lineWidth of 0.\n\n            if (lw == 0) lw = 0.0001;\n\n            if (lw > 0 && sw > 0) {\n                // draw shadow in two steps\n                var w = sw / 2;\n                ctx.lineWidth = w;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                plotPoints(series.datapoints, radius, null, w + w / 2, true, series.xaxis, series.yaxis, symbol);\n\n                ctx.strokeStyle = \"rgba(0,0,0,0.2)\";\n                plotPoints(series.datapoints, radius, null, w / 2, true, series.xaxis, series.yaxis, symbol);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            plotPoints(series.datapoints, radius, getFillStyle(series.points, series.color), 0, false, series.xaxis, series.yaxis, symbol);\n            ctx.restore();\n        }\n\n        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {\n            var left, right, bottom, top, drawLeft, drawRight, drawTop, drawBottom, tmp;\n\n            // in horizontal mode, we start the bar from the left\n            // instead of from the bottom so it appears to be\n            // horizontal rather than vertical\n            if (horizontal) {\n                drawBottom = drawRight = drawTop = true;\n                drawLeft = false;\n                left = b;\n                right = x;\n                top = y + barLeft;\n                bottom = y + barRight;\n\n                // account for negative bars\n                if (right < left) {\n                    tmp = right;\n                    right = left;\n                    left = tmp;\n                    drawLeft = true;\n                    drawRight = false;\n                }\n            } else {\n                drawLeft = drawRight = drawTop = true;\n                drawBottom = false;\n                left = x + barLeft;\n                right = x + barRight;\n                bottom = b;\n                top = y;\n\n                // account for negative bars\n                if (top < bottom) {\n                    tmp = top;\n                    top = bottom;\n                    bottom = tmp;\n                    drawBottom = true;\n                    drawTop = false;\n                }\n            }\n\n            // clip\n            if (right < axisx.min || left > axisx.max || top < axisy.min || bottom > axisy.max) return;\n\n            if (left < axisx.min) {\n                left = axisx.min;\n                drawLeft = false;\n            }\n\n            if (right > axisx.max) {\n                right = axisx.max;\n                drawRight = false;\n            }\n\n            if (bottom < axisy.min) {\n                bottom = axisy.min;\n                drawBottom = false;\n            }\n\n            if (top > axisy.max) {\n                top = axisy.max;\n                drawTop = false;\n            }\n\n            left = axisx.p2c(left);\n            bottom = axisy.p2c(bottom);\n            right = axisx.p2c(right);\n            top = axisy.p2c(top);\n\n            // fill the bar\n            if (fillStyleCallback) {\n                c.fillStyle = fillStyleCallback(bottom, top);\n                c.fillRect(left, top, right - left, bottom - top);\n            }\n\n            // draw outline\n            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {\n                c.beginPath();\n\n                // FIXME: inline moveTo is buggy with excanvas\n                c.moveTo(left, bottom);\n                if (drawLeft) c.lineTo(left, top);else c.moveTo(left, top);\n                if (drawTop) c.lineTo(right, top);else c.moveTo(right, top);\n                if (drawRight) c.lineTo(right, bottom);else c.moveTo(right, bottom);\n                if (drawBottom) c.lineTo(left, bottom);else c.moveTo(left, bottom);\n                c.stroke();\n            }\n        }\n\n        function drawSeriesBars(series) {\n            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    if (points[i] == null) continue;\n                    drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // FIXME: figure out a way to add shadows (for instance along the right edge)\n            ctx.lineWidth = series.bars.lineWidth;\n            ctx.strokeStyle = series.color;\n\n            var barLeft;\n\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -series.bars.barWidth;\n                    break;\n                default:\n                    barLeft = -series.bars.barWidth / 2;\n            }\n\n            var fillStyleCallback = series.bars.fill ? function (bottom, top) {\n                return getFillStyle(series.bars, series.color, bottom, top);\n            } : null;\n            plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function getFillStyle(filloptions, seriesColor, bottom, top) {\n            var fill = filloptions.fill;\n            if (!fill) return null;\n\n            if (filloptions.fillColor) return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);\n\n            var c = $.color.parse(seriesColor);\n            c.a = typeof fill == \"number\" ? fill : 0.4;\n            c.normalize();\n            return c.toString();\n        }\n\n        function insertLegend() {\n\n            if (options.legend.container != null) {\n                $(options.legend.container).html(\"\");\n            } else {\n                placeholder.find(\".legend\").remove();\n            }\n\n            if (!options.legend.show) {\n                return;\n            }\n\n            var fragments = [],\n                entries = [],\n                rowStarted = false,\n                lf = options.legend.labelFormatter,\n                s,\n                label;\n\n            // Build a list of legend entries, with each having a label and a color\n\n            for (var i = 0; i < series.length; ++i) {\n                s = series[i];\n                if (s.label) {\n                    label = lf ? lf(s.label, s) : s.label;\n                    if (label) {\n                        entries.push({\n                            label: label,\n                            color: s.color\n                        });\n                    }\n                }\n            }\n\n            // Sort the legend using either the default or a custom comparator\n\n            if (options.legend.sorted) {\n                if ($.isFunction(options.legend.sorted)) {\n                    entries.sort(options.legend.sorted);\n                } else if (options.legend.sorted == \"reverse\") {\n                    entries.reverse();\n                } else {\n                    var ascending = options.legend.sorted != \"descending\";\n                    entries.sort(function (a, b) {\n                        return a.label == b.label ? 0 : a.label < b.label != ascending ? 1 : -1 // Logical XOR\n                        ;\n                    });\n                }\n            }\n\n            // Generate markup for the list of entries, in their final order\n\n            for (var i = 0; i < entries.length; ++i) {\n\n                var entry = entries[i];\n\n                if (i % options.legend.noColumns == 0) {\n                    if (rowStarted) fragments.push('</tr>');\n                    fragments.push('<tr>');\n                    rowStarted = true;\n                }\n\n                fragments.push('<td class=\"legendColorBox\"><div style=\"border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px\"><div style=\"width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden\"></div></div></td>' + '<td class=\"legendLabel\">' + entry.label + '</td>');\n            }\n\n            if (rowStarted) fragments.push('</tr>');\n\n            if (fragments.length == 0) return;\n\n            var table = '<table style=\"font-size:smaller;color:' + options.grid.color + '\">' + fragments.join(\"\") + '</table>';\n            if (options.legend.container != null) $(options.legend.container).html(table);else {\n                var pos = \"\",\n                    p = options.legend.position,\n                    m = options.legend.margin;\n                if (m[0] == null) m = [m, m];\n                if (p.charAt(0) == \"n\") pos += 'top:' + (m[1] + plotOffset.top) + 'px;';else if (p.charAt(0) == \"s\") pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';\n                if (p.charAt(1) == \"e\") pos += 'right:' + (m[0] + plotOffset.right) + 'px;';else if (p.charAt(1) == \"w\") pos += 'left:' + (m[0] + plotOffset.left) + 'px;';\n                var legend = $('<div class=\"legend\">' + table.replace('style=\"', 'style=\"position:absolute;' + pos + ';') + '</div>').appendTo(placeholder);\n                if (options.legend.backgroundOpacity != 0.0) {\n                    // put in the transparent background\n                    // separately to avoid blended labels and\n                    // label boxes\n                    var c = options.legend.backgroundColor;\n                    if (c == null) {\n                        c = options.grid.backgroundColor;\n                        if (c && typeof c == \"string\") c = $.color.parse(c);else c = $.color.extract(legend, 'background-color');\n                        c.a = 1;\n                        c = c.toString();\n                    }\n                    var div = legend.children();\n                    $('<div style=\"position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos + 'background-color:' + c + ';\"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);\n                }\n            }\n        }\n\n        // interactive features\n\n        var highlights = [],\n            redrawTimeout = null;\n\n        // returns the data item the mouse is over, or null if none is found\n        function findNearbyItem(mouseX, mouseY, seriesFilter) {\n            var maxDistance = options.grid.mouseActiveRadius,\n                smallestDistance = maxDistance * maxDistance + 1,\n                item = null,\n                foundPoint = false,\n                i,\n                j,\n                ps;\n\n            for (i = series.length - 1; i >= 0; --i) {\n                if (!seriesFilter(series[i])) continue;\n\n                var s = series[i],\n                    axisx = s.xaxis,\n                    axisy = s.yaxis,\n                    points = s.datapoints.points,\n                    mx = axisx.c2p(mouseX),\n                    // precompute some stuff to make the loop faster\n                my = axisy.c2p(mouseY),\n                    maxx = maxDistance / axisx.scale,\n                    maxy = maxDistance / axisy.scale;\n\n                ps = s.datapoints.pointsize;\n                // with inverse transforms, we can't use the maxx/maxy\n                // optimization, sadly\n                if (axisx.options.inverseTransform) maxx = Number.MAX_VALUE;\n                if (axisy.options.inverseTransform) maxy = Number.MAX_VALUE;\n\n                if (s.lines.show || s.points.show) {\n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j],\n                            y = points[j + 1];\n                        if (x == null) continue;\n\n                        // For points and lines, the cursor must be within a\n                        // certain distance to the data point\n                        if (x - mx > maxx || x - mx < -maxx || y - my > maxy || y - my < -maxy) continue;\n\n                        // We have to calculate distances in pixels, not in\n                        // data units, because the scales of the axes may be different\n                        var dx = Math.abs(axisx.p2c(x) - mouseX),\n                            dy = Math.abs(axisy.p2c(y) - mouseY),\n                            dist = dx * dx + dy * dy; // we save the sqrt\n\n                        // use <= to ensure last point takes precedence\n                        // (last generally means on top of)\n                        if (dist < smallestDistance) {\n                            smallestDistance = dist;\n                            item = [i, j / ps];\n                        }\n                    }\n                }\n\n                if (s.bars.show && !item) {\n                    // no other point can be nearby\n\n                    var barLeft, barRight;\n\n                    switch (s.bars.align) {\n                        case \"left\":\n                            barLeft = 0;\n                            break;\n                        case \"right\":\n                            barLeft = -s.bars.barWidth;\n                            break;\n                        default:\n                            barLeft = -s.bars.barWidth / 2;\n                    }\n\n                    barRight = barLeft + s.bars.barWidth;\n\n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j],\n                            y = points[j + 1],\n                            b = points[j + 2];\n                        if (x == null) continue;\n\n                        // for a bar graph, the cursor must be inside the bar\n                        if (series[i].bars.horizontal ? mx <= Math.max(b, x) && mx >= Math.min(b, x) && my >= y + barLeft && my <= y + barRight : mx >= x + barLeft && mx <= x + barRight && my >= Math.min(b, y) && my <= Math.max(b, y)) item = [i, j / ps];\n                    }\n                }\n            }\n\n            if (item) {\n                i = item[0];\n                j = item[1];\n                ps = series[i].datapoints.pointsize;\n\n                return { datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),\n                    dataIndex: j,\n                    series: series[i],\n                    seriesIndex: i };\n            }\n\n            return null;\n        }\n\n        function onMouseMove(e) {\n            if (options.grid.hoverable) triggerClickHoverEvent(\"plothover\", e, function (s) {\n                return s[\"hoverable\"] != false;\n            });\n        }\n\n        function onMouseLeave(e) {\n            if (options.grid.hoverable) triggerClickHoverEvent(\"plothover\", e, function (s) {\n                return false;\n            });\n        }\n\n        function onClick(e) {\n            triggerClickHoverEvent(\"plotclick\", e, function (s) {\n                return s[\"clickable\"] != false;\n            });\n        }\n\n        // trigger click or hover event (they send the same parameters\n        // so we share their code)\n        function triggerClickHoverEvent(eventname, event, seriesFilter) {\n            var offset = eventHolder.offset(),\n                canvasX = event.pageX - offset.left - plotOffset.left,\n                canvasY = event.pageY - offset.top - plotOffset.top,\n                pos = canvasToAxisCoords({ left: canvasX, top: canvasY });\n\n            pos.pageX = event.pageX;\n            pos.pageY = event.pageY;\n\n            var item = findNearbyItem(canvasX, canvasY, seriesFilter);\n\n            if (item) {\n                // fill in mouse pos for any listeners out there\n                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);\n                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);\n            }\n\n            if (options.grid.autoHighlight) {\n                // clear auto-highlights\n                for (var i = 0; i < highlights.length; ++i) {\n                    var h = highlights[i];\n                    if (h.auto == eventname && !(item && h.series == item.series && h.point[0] == item.datapoint[0] && h.point[1] == item.datapoint[1])) unhighlight(h.series, h.point);\n                }\n\n                if (item) highlight(item.series, item.datapoint, eventname);\n            }\n\n            placeholder.trigger(eventname, [pos, item]);\n        }\n\n        function triggerRedrawOverlay() {\n            var t = options.interaction.redrawOverlayInterval;\n            if (t == -1) {\n                // skip event queue\n                drawOverlay();\n                return;\n            }\n\n            if (!redrawTimeout) redrawTimeout = setTimeout(drawOverlay, t);\n        }\n\n        function drawOverlay() {\n            redrawTimeout = null;\n\n            // draw highlights\n            octx.save();\n            overlay.clear();\n            octx.translate(plotOffset.left, plotOffset.top);\n\n            var i, hi;\n            for (i = 0; i < highlights.length; ++i) {\n                hi = highlights[i];\n\n                if (hi.series.bars.show) drawBarHighlight(hi.series, hi.point);else drawPointHighlight(hi.series, hi.point);\n            }\n            octx.restore();\n\n            executeHooks(hooks.drawOverlay, [octx]);\n        }\n\n        function highlight(s, point, auto) {\n            if (typeof s == \"number\") s = series[s];\n\n            if (typeof point == \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i == -1) {\n                highlights.push({ series: s, point: point, auto: auto });\n\n                triggerRedrawOverlay();\n            } else if (!auto) highlights[i].auto = false;\n        }\n\n        function unhighlight(s, point) {\n            if (s == null && point == null) {\n                highlights = [];\n                triggerRedrawOverlay();\n                return;\n            }\n\n            if (typeof s == \"number\") s = series[s];\n\n            if (typeof point == \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i != -1) {\n                highlights.splice(i, 1);\n\n                triggerRedrawOverlay();\n            }\n        }\n\n        function indexOfHighlight(s, p) {\n            for (var i = 0; i < highlights.length; ++i) {\n                var h = highlights[i];\n                if (h.series == s && h.point[0] == p[0] && h.point[1] == p[1]) return i;\n            }\n            return -1;\n        }\n\n        function drawPointHighlight(series, point) {\n            var x = point[0],\n                y = point[1],\n                axisx = series.xaxis,\n                axisy = series.yaxis,\n                highlightColor = typeof series.highlightColor === \"string\" ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();\n\n            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) return;\n\n            var pointRadius = series.points.radius + series.points.lineWidth / 2;\n            octx.lineWidth = pointRadius;\n            octx.strokeStyle = highlightColor;\n            var radius = 1.5 * pointRadius;\n            x = axisx.p2c(x);\n            y = axisy.p2c(y);\n\n            octx.beginPath();\n            if (series.points.symbol == \"circle\") octx.arc(x, y, radius, 0, 2 * Math.PI, false);else series.points.symbol(octx, x, y, radius, false);\n            octx.closePath();\n            octx.stroke();\n        }\n\n        function drawBarHighlight(series, point) {\n            var highlightColor = typeof series.highlightColor === \"string\" ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),\n                fillStyle = highlightColor,\n                barLeft;\n\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -series.bars.barWidth;\n                    break;\n                default:\n                    barLeft = -series.bars.barWidth / 2;\n            }\n\n            octx.lineWidth = series.bars.lineWidth;\n            octx.strokeStyle = highlightColor;\n\n            drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth, function () {\n                return fillStyle;\n            }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);\n        }\n\n        function getColorOrGradient(spec, bottom, top, defaultColor) {\n            if (typeof spec == \"string\") return spec;else {\n                // assume this is a gradient spec; IE currently only\n                // supports a simple vertical gradient properly, so that's\n                // what we support too\n                var gradient = ctx.createLinearGradient(0, top, 0, bottom);\n\n                for (var i = 0, l = spec.colors.length; i < l; ++i) {\n                    var c = spec.colors[i];\n                    if (typeof c != \"string\") {\n                        var co = $.color.parse(defaultColor);\n                        if (c.brightness != null) co = co.scale('rgb', c.brightness);\n                        if (c.opacity != null) co.a *= c.opacity;\n                        c = co.toString();\n                    }\n                    gradient.addColorStop(i / (l - 1), c);\n                }\n\n                return gradient;\n            }\n        }\n    }\n\n    // Add the plot function to the top level of the jQuery object\n\n    $.plot = function (placeholder, data, options) {\n        //var t0 = new Date();\n        var plot = new Plot($(placeholder), data, options, $.plot.plugins);\n        //(window.console ? console.log : alert)(\"time used (msecs): \" + ((new Date()).getTime() - t0.getTime()));\n        return plot;\n    };\n\n    $.plot.version = \"0.8.3\";\n\n    $.plot.plugins = [];\n\n    // Also add the plot function as a chainable property\n\n    $.fn.plot = function (data, options) {\n        return this.each(function () {\n            $.plot(this, data, options);\n        });\n    };\n\n    // round to nearby lower multiple of base\n    function floorInBase(n, base) {\n        return base * Math.floor(n / base);\n    }\n})(jQuery);","ast":null,"map":{"version":3,"sources":["/startbootstrap-sb-admin-gh-pages/js/plugins/flot/jquery.flot.js"],"names":[],"mappings":"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","file":"/startbootstrap-sb-admin-gh-pages/js/plugins/flot/jquery.flot.js.map","sourcesContent":["/* Javascript plotting library for jQuery, version 0.8.3.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\n*/\n\n// first an inline dependency, jquery.colorhelpers.js, we inline it here\n// for convenience\n\n/* Plugin for jQuery for working with colors.\n *\n * Version 1.1.\n *\n * Inspiration from jQuery color animation plugin by John Resig.\n *\n * Released under the MIT license by Ole Laursen, October 2009.\n *\n * Examples:\n *\n *   $.color.parse(\"#fff\").scale('rgb', 0.25).add('a', -0.5).toString()\n *   var c = $.color.extract($(\"#mydiv\"), 'background-color');\n *   console.log(c.r, c.g, c.b, c.a);\n *   $.color.make(100, 50, 25, 0.4).toString() // returns \"rgba(100,50,25,0.4)\"\n *\n * Note that .scale() and .add() return the same modified object\n * instead of making a new one.\n *\n * V. 1.1: Fix error handling so e.g. parsing an empty string does\n * produce a color rather than just crashing.\n */\n(function($){$.color={};$.color.make=function(r,g,b,a){var o={};o.r=r||0;o.g=g||0;o.b=b||0;o.a=a!=null?a:1;o.add=function(c,d){for(var i=0;i<c.length;++i)o[c.charAt(i)]+=d;return o.normalize()};o.scale=function(c,f){for(var i=0;i<c.length;++i)o[c.charAt(i)]*=f;return o.normalize()};o.toString=function(){if(o.a>=1){return\"rgb(\"+[o.r,o.g,o.b].join(\",\")+\")\"}else{return\"rgba(\"+[o.r,o.g,o.b,o.a].join(\",\")+\")\"}};o.normalize=function(){function clamp(min,value,max){return value<min?min:value>max?max:value}o.r=clamp(0,parseInt(o.r),255);o.g=clamp(0,parseInt(o.g),255);o.b=clamp(0,parseInt(o.b),255);o.a=clamp(0,o.a,1);return o};o.clone=function(){return $.color.make(o.r,o.b,o.g,o.a)};return o.normalize()};$.color.extract=function(elem,css){var c;do{c=elem.css(css).toLowerCase();if(c!=\"\"&&c!=\"transparent\")break;elem=elem.parent()}while(elem.length&&!$.nodeName(elem.get(0),\"body\"));if(c==\"rgba(0, 0, 0, 0)\")c=\"transparent\";return $.color.parse(c)};$.color.parse=function(str){var res,m=$.color.make;if(res=/rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10));if(res=/rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10),parseFloat(res[4]));if(res=/rgb\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*\\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55);if(res=/rgba\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55,parseFloat(res[4]));if(res=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))return m(parseInt(res[1],16),parseInt(res[2],16),parseInt(res[3],16));if(res=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))return m(parseInt(res[1]+res[1],16),parseInt(res[2]+res[2],16),parseInt(res[3]+res[3],16));var name=$.trim(str).toLowerCase();if(name==\"transparent\")return m(255,255,255,0);else{res=lookupColors[name]||[0,0,0];return m(res[0],res[1],res[2])}};var lookupColors={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);\n\n// the actual Flot code\n(function($) {\n\n\t// Cache the prototype hasOwnProperty for faster access\n\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    // A shim to provide 'detach' to jQuery versions prior to 1.4.  Using a DOM\n    // operation produces the same effect as detach, i.e. removing the element\n    // without touching its jQuery data.\n\n    // Do not merge this into Flot 0.9, since it requires jQuery 1.4.4+.\n\n    if (!$.fn.detach) {\n        $.fn.detach = function() {\n            return this.each(function() {\n                if (this.parentNode) {\n                    this.parentNode.removeChild( this );\n                }\n            });\n        };\n    }\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// The Canvas object is a wrapper around an HTML5 <canvas> tag.\n\t//\n\t// @constructor\n\t// @param {string} cls List of classes to apply to the canvas.\n\t// @param {element} container Element onto which to append the canvas.\n\t//\n\t// Requiring a container is a little iffy, but unfortunately canvas\n\t// operations don't work unless the canvas is attached to the DOM.\n\n\tfunction Canvas(cls, container) {\n\n\t\tvar element = container.children(\".\" + cls)[0];\n\n\t\tif (element == null) {\n\n\t\t\telement = document.createElement(\"canvas\");\n\t\t\telement.className = cls;\n\n\t\t\t$(element).css({ direction: \"ltr\", position: \"absolute\", left: 0, top: 0 })\n\t\t\t\t.appendTo(container);\n\n\t\t\t// If HTML5 Canvas isn't available, fall back to [Ex|Flash]canvas\n\n\t\t\tif (!element.getContext) {\n\t\t\t\tif (window.G_vmlCanvasManager) {\n\t\t\t\t\telement = window.G_vmlCanvasManager.initElement(element);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.element = element;\n\n\t\tvar context = this.context = element.getContext(\"2d\");\n\n\t\t// Determine the screen's ratio of physical to device-independent\n\t\t// pixels.  This is the ratio between the canvas width that the browser\n\t\t// advertises and the number of pixels actually present in that space.\n\n\t\t// The iPhone 4, for example, has a device-independent width of 320px,\n\t\t// but its screen is actually 640px wide.  It therefore has a pixel\n\t\t// ratio of 2, while most normal devices have a ratio of 1.\n\n\t\tvar devicePixelRatio = window.devicePixelRatio || 1,\n\t\t\tbackingStoreRatio =\n\t\t\t\tcontext.webkitBackingStorePixelRatio ||\n\t\t\t\tcontext.mozBackingStorePixelRatio ||\n\t\t\t\tcontext.msBackingStorePixelRatio ||\n\t\t\t\tcontext.oBackingStorePixelRatio ||\n\t\t\t\tcontext.backingStorePixelRatio || 1;\n\n\t\tthis.pixelRatio = devicePixelRatio / backingStoreRatio;\n\n\t\t// Size the canvas to match the internal dimensions of its container\n\n\t\tthis.resize(container.width(), container.height());\n\n\t\t// Collection of HTML div layers for text overlaid onto the canvas\n\n\t\tthis.textContainer = null;\n\t\tthis.text = {};\n\n\t\t// Cache of text fragments and metrics, so we can avoid expensively\n\t\t// re-calculating them when the plot is re-rendered in a loop.\n\n\t\tthis._textCache = {};\n\t}\n\n\t// Resizes the canvas to the given dimensions.\n\t//\n\t// @param {number} width New width of the canvas, in pixels.\n\t// @param {number} width New height of the canvas, in pixels.\n\n\tCanvas.prototype.resize = function(width, height) {\n\n\t\tif (width <= 0 || height <= 0) {\n\t\t\tthrow new Error(\"Invalid dimensions for plot, width = \" + width + \", height = \" + height);\n\t\t}\n\n\t\tvar element = this.element,\n\t\t\tcontext = this.context,\n\t\t\tpixelRatio = this.pixelRatio;\n\n\t\t// Resize the canvas, increasing its density based on the display's\n\t\t// pixel ratio; basically giving it more pixels without increasing the\n\t\t// size of its element, to take advantage of the fact that retina\n\t\t// displays have that many more pixels in the same advertised space.\n\n\t\t// Resizing should reset the state (excanvas seems to be buggy though)\n\n\t\tif (this.width != width) {\n\t\t\telement.width = width * pixelRatio;\n\t\t\telement.style.width = width + \"px\";\n\t\t\tthis.width = width;\n\t\t}\n\n\t\tif (this.height != height) {\n\t\t\telement.height = height * pixelRatio;\n\t\t\telement.style.height = height + \"px\";\n\t\t\tthis.height = height;\n\t\t}\n\n\t\t// Save the context, so we can reset in case we get replotted.  The\n\t\t// restore ensure that we're really back at the initial state, and\n\t\t// should be safe even if we haven't saved the initial state yet.\n\n\t\tcontext.restore();\n\t\tcontext.save();\n\n\t\t// Scale the coordinate space to match the display density; so even though we\n\t\t// may have twice as many pixels, we still want lines and other drawing to\n\t\t// appear at the same size; the extra pixels will just make them crisper.\n\n\t\tcontext.scale(pixelRatio, pixelRatio);\n\t};\n\n\t// Clears the entire canvas area, not including any overlaid HTML text\n\n\tCanvas.prototype.clear = function() {\n\t\tthis.context.clearRect(0, 0, this.width, this.height);\n\t};\n\n\t// Finishes rendering the canvas, including managing the text overlay.\n\n\tCanvas.prototype.render = function() {\n\n\t\tvar cache = this._textCache;\n\n\t\t// For each text layer, add elements marked as active that haven't\n\t\t// already been rendered, and remove those that are no longer active.\n\n\t\tfor (var layerKey in cache) {\n\t\t\tif (hasOwnProperty.call(cache, layerKey)) {\n\n\t\t\t\tvar layer = this.getTextLayer(layerKey),\n\t\t\t\t\tlayerCache = cache[layerKey];\n\n\t\t\t\tlayer.hide();\n\n\t\t\t\tfor (var styleKey in layerCache) {\n\t\t\t\t\tif (hasOwnProperty.call(layerCache, styleKey)) {\n\t\t\t\t\t\tvar styleCache = layerCache[styleKey];\n\t\t\t\t\t\tfor (var key in styleCache) {\n\t\t\t\t\t\t\tif (hasOwnProperty.call(styleCache, key)) {\n\n\t\t\t\t\t\t\t\tvar positions = styleCache[key].positions;\n\n\t\t\t\t\t\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\t\t\t\t\t\tif (position.active) {\n\t\t\t\t\t\t\t\t\t\tif (!position.rendered) {\n\t\t\t\t\t\t\t\t\t\t\tlayer.append(position.element);\n\t\t\t\t\t\t\t\t\t\t\tposition.rendered = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpositions.splice(i--, 1);\n\t\t\t\t\t\t\t\t\t\tif (position.rendered) {\n\t\t\t\t\t\t\t\t\t\t\tposition.element.detach();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (positions.length == 0) {\n\t\t\t\t\t\t\t\t\tdelete styleCache[key];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlayer.show();\n\t\t\t}\n\t\t}\n\t};\n\n\t// Creates (if necessary) and returns the text overlay container.\n\t//\n\t// @param {string} classes String of space-separated CSS classes used to\n\t//     uniquely identify the text layer.\n\t// @return {object} The jQuery-wrapped text-layer div.\n\n\tCanvas.prototype.getTextLayer = function(classes) {\n\n\t\tvar layer = this.text[classes];\n\n\t\t// Create the text layer if it doesn't exist\n\n\t\tif (layer == null) {\n\n\t\t\t// Create the text layer container, if it doesn't exist\n\n\t\t\tif (this.textContainer == null) {\n\t\t\t\tthis.textContainer = $(\"<div class='flot-text'></div>\")\n\t\t\t\t\t.css({\n\t\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\tbottom: 0,\n\t\t\t\t\t\tright: 0,\n\t\t\t\t\t\t'font-size': \"smaller\",\n\t\t\t\t\t\tcolor: \"#545454\"\n\t\t\t\t\t})\n\t\t\t\t\t.insertAfter(this.element);\n\t\t\t}\n\n\t\t\tlayer = this.text[classes] = $(\"<div></div>\")\n\t\t\t\t.addClass(classes)\n\t\t\t\t.css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tbottom: 0,\n\t\t\t\t\tright: 0\n\t\t\t\t})\n\t\t\t\t.appendTo(this.textContainer);\n\t\t}\n\n\t\treturn layer;\n\t};\n\n\t// Creates (if necessary) and returns a text info object.\n\t//\n\t// The object looks like this:\n\t//\n\t// {\n\t//     width: Width of the text's wrapper div.\n\t//     height: Height of the text's wrapper div.\n\t//     element: The jQuery-wrapped HTML div containing the text.\n\t//     positions: Array of positions at which this text is drawn.\n\t// }\n\t//\n\t// The positions array contains objects that look like this:\n\t//\n\t// {\n\t//     active: Flag indicating whether the text should be visible.\n\t//     rendered: Flag indicating whether the text is currently visible.\n\t//     element: The jQuery-wrapped HTML div containing the text.\n\t//     x: X coordinate at which to draw the text.\n\t//     y: Y coordinate at which to draw the text.\n\t// }\n\t//\n\t// Each position after the first receives a clone of the original element.\n\t//\n\t// The idea is that that the width, height, and general 'identity' of the\n\t// text is constant no matter where it is placed; the placements are a\n\t// secondary property.\n\t//\n\t// Canvas maintains a cache of recently-used text info objects; getTextInfo\n\t// either returns the cached element or creates a new entry.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {string} text Text string to retrieve info for.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which to rotate the text, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\t// @param {number=} width Maximum width of the text before it wraps.\n\t// @return {object} a text info object.\n\n\tCanvas.prototype.getTextInfo = function(layer, text, font, angle, width) {\n\n\t\tvar textStyle, layerCache, styleCache, info;\n\n\t\t// Cast the value to a string, in case we were given a number or such\n\n\t\ttext = \"\" + text;\n\n\t\t// If the font is a font-spec object, generate a CSS font definition\n\n\t\tif (typeof font === \"object\") {\n\t\t\ttextStyle = font.style + \" \" + font.variant + \" \" + font.weight + \" \" + font.size + \"px/\" + font.lineHeight + \"px \" + font.family;\n\t\t} else {\n\t\t\ttextStyle = font;\n\t\t}\n\n\t\t// Retrieve (or create) the cache for the text's layer and styles\n\n\t\tlayerCache = this._textCache[layer];\n\n\t\tif (layerCache == null) {\n\t\t\tlayerCache = this._textCache[layer] = {};\n\t\t}\n\n\t\tstyleCache = layerCache[textStyle];\n\n\t\tif (styleCache == null) {\n\t\t\tstyleCache = layerCache[textStyle] = {};\n\t\t}\n\n\t\tinfo = styleCache[text];\n\n\t\t// If we can't find a matching element in our cache, create a new one\n\n\t\tif (info == null) {\n\n\t\t\tvar element = $(\"<div></div>\").html(text)\n\t\t\t\t.css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t'max-width': width,\n\t\t\t\t\ttop: -9999\n\t\t\t\t})\n\t\t\t\t.appendTo(this.getTextLayer(layer));\n\n\t\t\tif (typeof font === \"object\") {\n\t\t\t\telement.css({\n\t\t\t\t\tfont: textStyle,\n\t\t\t\t\tcolor: font.color\n\t\t\t\t});\n\t\t\t} else if (typeof font === \"string\") {\n\t\t\t\telement.addClass(font);\n\t\t\t}\n\n\t\t\tinfo = styleCache[text] = {\n\t\t\t\twidth: element.outerWidth(true),\n\t\t\t\theight: element.outerHeight(true),\n\t\t\t\telement: element,\n\t\t\t\tpositions: []\n\t\t\t};\n\n\t\t\telement.detach();\n\t\t}\n\n\t\treturn info;\n\t};\n\n\t// Adds a text string to the canvas text overlay.\n\t//\n\t// The text isn't drawn immediately; it is marked as rendering, which will\n\t// result in its addition to the canvas on the next render pass.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {number} x X coordinate at which to draw the text.\n\t// @param {number} y Y coordinate at which to draw the text.\n\t// @param {string} text Text string to draw.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which to rotate the text, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\t// @param {number=} width Maximum width of the text before it wraps.\n\t// @param {string=} halign Horizontal alignment of the text; either \"left\",\n\t//     \"center\" or \"right\".\n\t// @param {string=} valign Vertical alignment of the text; either \"top\",\n\t//     \"middle\" or \"bottom\".\n\n\tCanvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {\n\n\t\tvar info = this.getTextInfo(layer, text, font, angle, width),\n\t\t\tpositions = info.positions;\n\n\t\t// Tweak the div's position to match the text's alignment\n\n\t\tif (halign == \"center\") {\n\t\t\tx -= info.width / 2;\n\t\t} else if (halign == \"right\") {\n\t\t\tx -= info.width;\n\t\t}\n\n\t\tif (valign == \"middle\") {\n\t\t\ty -= info.height / 2;\n\t\t} else if (valign == \"bottom\") {\n\t\t\ty -= info.height;\n\t\t}\n\n\t\t// Determine whether this text already exists at this position.\n\t\t// If so, mark it for inclusion in the next render pass.\n\n\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\tif (position.x == x && position.y == y) {\n\t\t\t\tposition.active = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If the text doesn't exist at this position, create a new entry\n\n\t\t// For the very first position we'll re-use the original element,\n\t\t// while for subsequent ones we'll clone it.\n\n\t\tposition = {\n\t\t\tactive: true,\n\t\t\trendered: false,\n\t\t\telement: positions.length ? info.element.clone() : info.element,\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\n\t\tpositions.push(position);\n\n\t\t// Move the element to its final position within the container\n\n\t\tposition.element.css({\n\t\t\ttop: Math.round(y),\n\t\t\tleft: Math.round(x),\n\t\t\t'text-align': halign\t// In case the text wraps\n\t\t});\n\t};\n\n\t// Removes one or more text strings from the canvas text overlay.\n\t//\n\t// If no parameters are given, all text within the layer is removed.\n\t//\n\t// Note that the text is not immediately removed; it is simply marked as\n\t// inactive, which will result in its removal on the next render pass.\n\t// This avoids the performance penalty for 'clear and redraw' behavior,\n\t// where we potentially get rid of all text on a layer, but will likely\n\t// add back most or all of it later, as when redrawing axes, for example.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {number=} x X coordinate of the text.\n\t// @param {number=} y Y coordinate of the text.\n\t// @param {string=} text Text string to remove.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which the text is rotated, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\n\tCanvas.prototype.removeText = function(layer, x, y, text, font, angle) {\n\t\tif (text == null) {\n\t\t\tvar layerCache = this._textCache[layer];\n\t\t\tif (layerCache != null) {\n\t\t\t\tfor (var styleKey in layerCache) {\n\t\t\t\t\tif (hasOwnProperty.call(layerCache, styleKey)) {\n\t\t\t\t\t\tvar styleCache = layerCache[styleKey];\n\t\t\t\t\t\tfor (var key in styleCache) {\n\t\t\t\t\t\t\tif (hasOwnProperty.call(styleCache, key)) {\n\t\t\t\t\t\t\t\tvar positions = styleCache[key].positions;\n\t\t\t\t\t\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\t\t\t\t\t\tposition.active = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar positions = this.getTextInfo(layer, text, font, angle).positions;\n\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\tif (position.x == x && position.y == y) {\n\t\t\t\t\tposition.active = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// The top-level container for the entire plot.\n\n    function Plot(placeholder, data_, options_, plugins) {\n        // data is on the form:\n        //   [ series1, series2 ... ]\n        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]\n        // or { data: [ [x1, y1], [x2, y2], ... ], label: \"some label\", ... }\n\n        var series = [],\n            options = {\n                // the color theme used for graphs\n                colors: [\"#edc240\", \"#afd8f8\", \"#cb4b4b\", \"#4da74d\", \"#9440ed\"],\n                legend: {\n                    show: true,\n                    noColumns: 1, // number of colums in legend table\n                    labelFormatter: null, // fn: string -> string\n                    labelBoxBorderColor: \"#ccc\", // border color for the little label boxes\n                    container: null, // container (as jQuery object) to put legend in, null means default on top of graph\n                    position: \"ne\", // position of default legend container within plot\n                    margin: 5, // distance from grid edge to default legend container within plot\n                    backgroundColor: null, // null means auto-detect\n                    backgroundOpacity: 0.85, // set to 0 to avoid background\n                    sorted: null    // default to no legend sorting\n                },\n                xaxis: {\n                    show: null, // null = auto-detect, true = always, false = never\n                    position: \"bottom\", // or \"top\"\n                    mode: null, // null or \"time\"\n                    font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: \"italic\", weight: \"bold\", family: \"sans-serif\", variant: \"small-caps\" }\n                    color: null, // base color, labels, ticks\n                    tickColor: null, // possibly different color of ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    transform: null, // null or f: number -> number to transform axis\n                    inverseTransform: null, // if transform is set, this should be the inverse function\n                    min: null, // min. value to show, null means set automatically\n                    max: null, // max. value to show, null means set automatically\n                    autoscaleMargin: null, // margin in % to add if auto-setting min/max\n                    ticks: null, // either [1, 3] or [[1, \"a\"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks\n                    tickFormatter: null, // fn: number -> string\n                    labelWidth: null, // size of tick labels in pixels\n                    labelHeight: null,\n                    reserveSpace: null, // whether to reserve space even if axis isn't shown\n                    tickLength: null, // size in pixels of ticks, or \"full\" for whole line\n                    alignTicksWithAxis: null, // axis number or null for no sync\n                    tickDecimals: null, // no. of decimals, null means auto\n                    tickSize: null, // number or [number, \"unit\"]\n                    minTickSize: null // number or [number, \"unit\"]\n                },\n                yaxis: {\n                    autoscaleMargin: 0.02,\n                    position: \"left\" // or \"right\"\n                },\n                xaxes: [],\n                yaxes: [],\n                series: {\n                    points: {\n                        show: false,\n                        radius: 3,\n                        lineWidth: 2, // in pixels\n                        fill: true,\n                        fillColor: \"#ffffff\",\n                        symbol: \"circle\" // or callback\n                    },\n                    lines: {\n                        // we don't put in show: false so we can see\n                        // whether lines were actively disabled\n                        lineWidth: 2, // in pixels\n                        fill: false,\n                        fillColor: null,\n                        steps: false\n                        // Omit 'zero', so we can later default its value to\n                        // match that of the 'fill' option.\n                    },\n                    bars: {\n                        show: false,\n                        lineWidth: 2, // in pixels\n                        barWidth: 1, // in units of the x axis\n                        fill: true,\n                        fillColor: null,\n                        align: \"left\", // \"left\", \"right\", or \"center\"\n                        horizontal: false,\n                        zero: true\n                    },\n                    shadowSize: 3,\n                    highlightColor: null\n                },\n                grid: {\n                    show: true,\n                    aboveData: false,\n                    color: \"#545454\", // primary color used for outline and labels\n                    backgroundColor: null, // null for transparent, else color\n                    borderColor: null, // set if different from the grid color\n                    tickColor: null, // color for the ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    margin: 0, // distance from the canvas edge to the grid\n                    labelMargin: 5, // in pixels\n                    axisMargin: 8, // in pixels\n                    borderWidth: 2, // in pixels\n                    minBorderMargin: null, // in pixels, null means taken from points radius\n                    markings: null, // array of ranges or fn: axes -> array of ranges\n                    markingsColor: \"#f4f4f4\",\n                    markingsLineWidth: 2,\n                    // interactive stuff\n                    clickable: false,\n                    hoverable: false,\n                    autoHighlight: true, // highlight in case mouse is near\n                    mouseActiveRadius: 10 // how far the mouse can be away to activate an item\n                },\n                interaction: {\n                    redrawOverlayInterval: 1000/60 // time between updates, -1 means in same flow\n                },\n                hooks: {}\n            },\n        surface = null,     // the canvas for the plot itself\n        overlay = null,     // canvas for interactive stuff on top of plot\n        eventHolder = null, // jQuery object that events should be bound to\n        ctx = null, octx = null,\n        xaxes = [], yaxes = [],\n        plotOffset = { left: 0, right: 0, top: 0, bottom: 0},\n        plotWidth = 0, plotHeight = 0,\n        hooks = {\n            processOptions: [],\n            processRawData: [],\n            processDatapoints: [],\n            processOffset: [],\n            drawBackground: [],\n            drawSeries: [],\n            draw: [],\n            bindEvents: [],\n            drawOverlay: [],\n            shutdown: []\n        },\n        plot = this;\n\n        // public functions\n        plot.setData = setData;\n        plot.setupGrid = setupGrid;\n        plot.draw = draw;\n        plot.getPlaceholder = function() { return placeholder; };\n        plot.getCanvas = function() { return surface.element; };\n        plot.getPlotOffset = function() { return plotOffset; };\n        plot.width = function () { return plotWidth; };\n        plot.height = function () { return plotHeight; };\n        plot.offset = function () {\n            var o = eventHolder.offset();\n            o.left += plotOffset.left;\n            o.top += plotOffset.top;\n            return o;\n        };\n        plot.getData = function () { return series; };\n        plot.getAxes = function () {\n            var res = {}, i;\n            $.each(xaxes.concat(yaxes), function (_, axis) {\n                if (axis)\n                    res[axis.direction + (axis.n != 1 ? axis.n : \"\") + \"axis\"] = axis;\n            });\n            return res;\n        };\n        plot.getXAxes = function () { return xaxes; };\n        plot.getYAxes = function () { return yaxes; };\n        plot.c2p = canvasToAxisCoords;\n        plot.p2c = axisToCanvasCoords;\n        plot.getOptions = function () { return options; };\n        plot.highlight = highlight;\n        plot.unhighlight = unhighlight;\n        plot.triggerRedrawOverlay = triggerRedrawOverlay;\n        plot.pointOffset = function(point) {\n            return {\n                left: parseInt(xaxes[axisNumber(point, \"x\") - 1].p2c(+point.x) + plotOffset.left, 10),\n                top: parseInt(yaxes[axisNumber(point, \"y\") - 1].p2c(+point.y) + plotOffset.top, 10)\n            };\n        };\n        plot.shutdown = shutdown;\n        plot.destroy = function () {\n            shutdown();\n            placeholder.removeData(\"plot\").empty();\n\n            series = [];\n            options = null;\n            surface = null;\n            overlay = null;\n            eventHolder = null;\n            ctx = null;\n            octx = null;\n            xaxes = [];\n            yaxes = [];\n            hooks = null;\n            highlights = [];\n            plot = null;\n        };\n        plot.resize = function () {\n        \tvar width = placeholder.width(),\n        \t\theight = placeholder.height();\n            surface.resize(width, height);\n            overlay.resize(width, height);\n        };\n\n        // public attributes\n        plot.hooks = hooks;\n\n        // initialize\n        initPlugins(plot);\n        parseOptions(options_);\n        setupCanvases();\n        setData(data_);\n        setupGrid();\n        draw();\n        bindEvents();\n\n\n        function executeHooks(hook, args) {\n            args = [plot].concat(args);\n            for (var i = 0; i < hook.length; ++i)\n                hook[i].apply(this, args);\n        }\n\n        function initPlugins() {\n\n            // References to key classes, allowing plugins to modify them\n\n            var classes = {\n                Canvas: Canvas\n            };\n\n            for (var i = 0; i < plugins.length; ++i) {\n                var p = plugins[i];\n                p.init(plot, classes);\n                if (p.options)\n                    $.extend(true, options, p.options);\n            }\n        }\n\n        function parseOptions(opts) {\n\n            $.extend(true, options, opts);\n\n            // $.extend merges arrays, rather than replacing them.  When less\n            // colors are provided than the size of the default palette, we\n            // end up with those colors plus the remaining defaults, which is\n            // not expected behavior; avoid it by replacing them here.\n\n            if (opts && opts.colors) {\n            \toptions.colors = opts.colors;\n            }\n\n            if (options.xaxis.color == null)\n                options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n            if (options.yaxis.color == null)\n                options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n\n            if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility\n                options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;\n            if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility\n                options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;\n\n            if (options.grid.borderColor == null)\n                options.grid.borderColor = options.grid.color;\n            if (options.grid.tickColor == null)\n                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n\n            // Fill in defaults for axis options, including any unspecified\n            // font-spec fields, if a font-spec was provided.\n\n            // If no x/y axis options were provided, create one of each anyway,\n            // since the rest of the code assumes that they exist.\n\n            var i, axisOptions, axisCount,\n                fontSize = placeholder.css(\"font-size\"),\n                fontSizeDefault = fontSize ? +fontSize.replace(\"px\", \"\") : 13,\n                fontDefaults = {\n                    style: placeholder.css(\"font-style\"),\n                    size: Math.round(0.8 * fontSizeDefault),\n                    variant: placeholder.css(\"font-variant\"),\n                    weight: placeholder.css(\"font-weight\"),\n                    family: placeholder.css(\"font-family\")\n                };\n\n            axisCount = options.xaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n\n                axisOptions = options.xaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);\n                options.xaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            axisCount = options.yaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n\n                axisOptions = options.yaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);\n                options.yaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            // backwards compatibility, to be removed in future\n            if (options.xaxis.noTicks && options.xaxis.ticks == null)\n                options.xaxis.ticks = options.xaxis.noTicks;\n            if (options.yaxis.noTicks && options.yaxis.ticks == null)\n                options.yaxis.ticks = options.yaxis.noTicks;\n            if (options.x2axis) {\n                options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);\n                options.xaxes[1].position = \"top\";\n                // Override the inherit to allow the axis to auto-scale\n                if (options.x2axis.min == null) {\n                    options.xaxes[1].min = null;\n                }\n                if (options.x2axis.max == null) {\n                    options.xaxes[1].max = null;\n                }\n            }\n            if (options.y2axis) {\n                options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);\n                options.yaxes[1].position = \"right\";\n                // Override the inherit to allow the axis to auto-scale\n                if (options.y2axis.min == null) {\n                    options.yaxes[1].min = null;\n                }\n                if (options.y2axis.max == null) {\n                    options.yaxes[1].max = null;\n                }\n            }\n            if (options.grid.coloredAreas)\n                options.grid.markings = options.grid.coloredAreas;\n            if (options.grid.coloredAreasColor)\n                options.grid.markingsColor = options.grid.coloredAreasColor;\n            if (options.lines)\n                $.extend(true, options.series.lines, options.lines);\n            if (options.points)\n                $.extend(true, options.series.points, options.points);\n            if (options.bars)\n                $.extend(true, options.series.bars, options.bars);\n            if (options.shadowSize != null)\n                options.series.shadowSize = options.shadowSize;\n            if (options.highlightColor != null)\n                options.series.highlightColor = options.highlightColor;\n\n            // save options on axes for future reference\n            for (i = 0; i < options.xaxes.length; ++i)\n                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];\n            for (i = 0; i < options.yaxes.length; ++i)\n                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];\n\n            // add hooks from options\n            for (var n in hooks)\n                if (options.hooks[n] && options.hooks[n].length)\n                    hooks[n] = hooks[n].concat(options.hooks[n]);\n\n            executeHooks(hooks.processOptions, [options]);\n        }\n\n        function setData(d) {\n            series = parseData(d);\n            fillInSeriesOptions();\n            processData();\n        }\n\n        function parseData(d) {\n            var res = [];\n            for (var i = 0; i < d.length; ++i) {\n                var s = $.extend(true, {}, options.series);\n\n                if (d[i].data != null) {\n                    s.data = d[i].data; // move the data instead of deep-copy\n                    delete d[i].data;\n\n                    $.extend(true, s, d[i]);\n\n                    d[i].data = s.data;\n                }\n                else\n                    s.data = d[i];\n                res.push(s);\n            }\n\n            return res;\n        }\n\n        function axisNumber(obj, coord) {\n            var a = obj[coord + \"axis\"];\n            if (typeof a == \"object\") // if we got a real axis, extract number\n                a = a.n;\n            if (typeof a != \"number\")\n                a = 1; // default to first axis\n            return a;\n        }\n\n        function allAxes() {\n            // return flat array without annoying null entries\n            return $.grep(xaxes.concat(yaxes), function (a) { return a; });\n        }\n\n        function canvasToAxisCoords(pos) {\n            // return an object with x/y corresponding to all used axes\n            var res = {}, i, axis;\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used)\n                    res[\"x\" + axis.n] = axis.c2p(pos.left);\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used)\n                    res[\"y\" + axis.n] = axis.c2p(pos.top);\n            }\n\n            if (res.x1 !== undefined)\n                res.x = res.x1;\n            if (res.y1 !== undefined)\n                res.y = res.y1;\n\n            return res;\n        }\n\n        function axisToCanvasCoords(pos) {\n            // get canvas coords from the first pair of x/y found in pos\n            var res = {}, i, axis, key;\n\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used) {\n                    key = \"x\" + axis.n;\n                    if (pos[key] == null && axis.n == 1)\n                        key = \"x\";\n\n                    if (pos[key] != null) {\n                        res.left = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used) {\n                    key = \"y\" + axis.n;\n                    if (pos[key] == null && axis.n == 1)\n                        key = \"y\";\n\n                    if (pos[key] != null) {\n                        res.top = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        function getOrCreateAxis(axes, number) {\n            if (!axes[number - 1])\n                axes[number - 1] = {\n                    n: number, // save the number for future reference\n                    direction: axes == xaxes ? \"x\" : \"y\",\n                    options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)\n                };\n\n            return axes[number - 1];\n        }\n\n        function fillInSeriesOptions() {\n\n            var neededColors = series.length, maxIndex = -1, i;\n\n            // Subtract the number of series that already have fixed colors or\n            // color indexes from the number that we still need to generate.\n\n            for (i = 0; i < series.length; ++i) {\n                var sc = series[i].color;\n                if (sc != null) {\n                    neededColors--;\n                    if (typeof sc == \"number\" && sc > maxIndex) {\n                        maxIndex = sc;\n                    }\n                }\n            }\n\n            // If any of the series have fixed color indexes, then we need to\n            // generate at least as many colors as the highest index.\n\n            if (neededColors <= maxIndex) {\n                neededColors = maxIndex + 1;\n            }\n\n            // Generate all the colors, using first the option colors and then\n            // variations on those colors once they're exhausted.\n\n            var c, colors = [], colorPool = options.colors,\n                colorPoolSize = colorPool.length, variation = 0;\n\n            for (i = 0; i < neededColors; i++) {\n\n                c = $.color.parse(colorPool[i % colorPoolSize] || \"#666\");\n\n                // Each time we exhaust the colors in the pool we adjust\n                // a scaling factor used to produce more variations on\n                // those colors. The factor alternates negative/positive\n                // to produce lighter/darker colors.\n\n                // Reset the variation after every few cycles, or else\n                // it will end up producing only white or black colors.\n\n                if (i % colorPoolSize == 0 && i) {\n                    if (variation >= 0) {\n                        if (variation < 0.5) {\n                            variation = -variation - 0.2;\n                        } else variation = 0;\n                    } else variation = -variation;\n                }\n\n                colors[i] = c.scale('rgb', 1 + variation);\n            }\n\n            // Finalize the series options, filling in their colors\n\n            var colori = 0, s;\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                // assign colors\n                if (s.color == null) {\n                    s.color = colors[colori].toString();\n                    ++colori;\n                }\n                else if (typeof s.color == \"number\")\n                    s.color = colors[s.color].toString();\n\n                // turn on lines automatically in case nothing is set\n                if (s.lines.show == null) {\n                    var v, show = true;\n                    for (v in s)\n                        if (s[v] && s[v].show) {\n                            show = false;\n                            break;\n                        }\n                    if (show)\n                        s.lines.show = true;\n                }\n\n                // If nothing was provided for lines.zero, default it to match\n                // lines.fill, since areas by default should extend to zero.\n\n                if (s.lines.zero == null) {\n                    s.lines.zero = !!s.lines.fill;\n                }\n\n                // setup axes\n                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, \"x\"));\n                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, \"y\"));\n            }\n        }\n\n        function processData() {\n            var topSentry = Number.POSITIVE_INFINITY,\n                bottomSentry = Number.NEGATIVE_INFINITY,\n                fakeInfinity = Number.MAX_VALUE,\n                i, j, k, m, length,\n                s, points, ps, x, y, axis, val, f, p,\n                data, format;\n\n            function updateAxis(axis, min, max) {\n                if (min < axis.datamin && min != -fakeInfinity)\n                    axis.datamin = min;\n                if (max > axis.datamax && max != fakeInfinity)\n                    axis.datamax = max;\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                // init axis\n                axis.datamin = topSentry;\n                axis.datamax = bottomSentry;\n                axis.used = false;\n            });\n\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                s.datapoints = { points: [] };\n\n                executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ]);\n            }\n\n            // first pass: clean and copy data\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                data = s.data;\n                format = s.datapoints.format;\n\n                if (!format) {\n                    format = [];\n                    // find out how to copy\n                    format.push({ x: true, number: true, required: true });\n                    format.push({ y: true, number: true, required: true });\n\n                    if (s.bars.show || (s.lines.show && s.lines.fill)) {\n                        var autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));\n                        format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });\n                        if (s.bars.horizontal) {\n                            delete format[format.length - 1].y;\n                            format[format.length - 1].x = true;\n                        }\n                    }\n\n                    s.datapoints.format = format;\n                }\n\n                if (s.datapoints.pointsize != null)\n                    continue; // already filled in\n\n                s.datapoints.pointsize = format.length;\n\n                ps = s.datapoints.pointsize;\n                points = s.datapoints.points;\n\n                var insertSteps = s.lines.show && s.lines.steps;\n                s.xaxis.used = s.yaxis.used = true;\n\n                for (j = k = 0; j < data.length; ++j, k += ps) {\n                    p = data[j];\n\n                    var nullify = p == null;\n                    if (!nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = p[m];\n                            f = format[m];\n\n                            if (f) {\n                                if (f.number && val != null) {\n                                    val = +val; // convert to number\n                                    if (isNaN(val))\n                                        val = null;\n                                    else if (val == Infinity)\n                                        val = fakeInfinity;\n                                    else if (val == -Infinity)\n                                        val = -fakeInfinity;\n                                }\n\n                                if (val == null) {\n                                    if (f.required)\n                                        nullify = true;\n\n                                    if (f.defaultValue != null)\n                                        val = f.defaultValue;\n                                }\n                            }\n\n                            points[k + m] = val;\n                        }\n                    }\n\n                    if (nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = points[k + m];\n                            if (val != null) {\n                                f = format[m];\n                                // extract min/max info\n                                if (f.autoscale !== false) {\n                                    if (f.x) {\n                                        updateAxis(s.xaxis, val, val);\n                                    }\n                                    if (f.y) {\n                                        updateAxis(s.yaxis, val, val);\n                                    }\n                                }\n                            }\n                            points[k + m] = null;\n                        }\n                    }\n                    else {\n                        // a little bit of line specific stuff that\n                        // perhaps shouldn't be here, but lacking\n                        // better means...\n                        if (insertSteps && k > 0\n                            && points[k - ps] != null\n                            && points[k - ps] != points[k]\n                            && points[k - ps + 1] != points[k + 1]) {\n                            // copy the point to make room for a middle point\n                            for (m = 0; m < ps; ++m)\n                                points[k + ps + m] = points[k + m];\n\n                            // middle point has same y\n                            points[k + 1] = points[k - ps + 1];\n\n                            // we've added a point, better reflect that\n                            k += ps;\n                        }\n                    }\n                }\n            }\n\n            // give the hooks a chance to run\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                executeHooks(hooks.processDatapoints, [ s, s.datapoints]);\n            }\n\n            // second pass: find datamax/datamin for auto-scaling\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                points = s.datapoints.points;\n                ps = s.datapoints.pointsize;\n                format = s.datapoints.format;\n\n                var xmin = topSentry, ymin = topSentry,\n                    xmax = bottomSentry, ymax = bottomSentry;\n\n                for (j = 0; j < points.length; j += ps) {\n                    if (points[j] == null)\n                        continue;\n\n                    for (m = 0; m < ps; ++m) {\n                        val = points[j + m];\n                        f = format[m];\n                        if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity)\n                            continue;\n\n                        if (f.x) {\n                            if (val < xmin)\n                                xmin = val;\n                            if (val > xmax)\n                                xmax = val;\n                        }\n                        if (f.y) {\n                            if (val < ymin)\n                                ymin = val;\n                            if (val > ymax)\n                                ymax = val;\n                        }\n                    }\n                }\n\n                if (s.bars.show) {\n                    // make sure we got room for the bar on the dancing floor\n                    var delta;\n\n                    switch (s.bars.align) {\n                        case \"left\":\n                            delta = 0;\n                            break;\n                        case \"right\":\n                            delta = -s.bars.barWidth;\n                            break;\n                        default:\n                            delta = -s.bars.barWidth / 2;\n                    }\n\n                    if (s.bars.horizontal) {\n                        ymin += delta;\n                        ymax += delta + s.bars.barWidth;\n                    }\n                    else {\n                        xmin += delta;\n                        xmax += delta + s.bars.barWidth;\n                    }\n                }\n\n                updateAxis(s.xaxis, xmin, xmax);\n                updateAxis(s.yaxis, ymin, ymax);\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                if (axis.datamin == topSentry)\n                    axis.datamin = null;\n                if (axis.datamax == bottomSentry)\n                    axis.datamax = null;\n            });\n        }\n\n        function setupCanvases() {\n\n            // Make sure the placeholder is clear of everything except canvases\n            // from a previous plot in this container that we'll try to re-use.\n\n            placeholder.css(\"padding\", 0) // padding messes up the positioning\n                .children().filter(function(){\n                    return !$(this).hasClass(\"flot-overlay\") && !$(this).hasClass('flot-base');\n                }).remove();\n\n            if (placeholder.css(\"position\") == 'static')\n                placeholder.css(\"position\", \"relative\"); // for positioning labels and overlay\n\n            surface = new Canvas(\"flot-base\", placeholder);\n            overlay = new Canvas(\"flot-overlay\", placeholder); // overlay canvas for interactive features\n\n            ctx = surface.context;\n            octx = overlay.context;\n\n            // define which element we're listening for events on\n            eventHolder = $(overlay.element).unbind();\n\n            // If we're re-using a plot object, shut down the old one\n\n            var existing = placeholder.data(\"plot\");\n\n            if (existing) {\n                existing.shutdown();\n                overlay.clear();\n            }\n\n            // save in case we get replotted\n            placeholder.data(\"plot\", plot);\n        }\n\n        function bindEvents() {\n            // bind events\n            if (options.grid.hoverable) {\n                eventHolder.mousemove(onMouseMove);\n\n                // Use bind, rather than .mouseleave, because we officially\n                // still support jQuery 1.2.6, which doesn't define a shortcut\n                // for mouseenter or mouseleave.  This was a bug/oversight that\n                // was fixed somewhere around 1.3.x.  We can return to using\n                // .mouseleave when we drop support for 1.2.6.\n\n                eventHolder.bind(\"mouseleave\", onMouseLeave);\n            }\n\n            if (options.grid.clickable)\n                eventHolder.click(onClick);\n\n            executeHooks(hooks.bindEvents, [eventHolder]);\n        }\n\n        function shutdown() {\n            if (redrawTimeout)\n                clearTimeout(redrawTimeout);\n\n            eventHolder.unbind(\"mousemove\", onMouseMove);\n            eventHolder.unbind(\"mouseleave\", onMouseLeave);\n            eventHolder.unbind(\"click\", onClick);\n\n            executeHooks(hooks.shutdown, [eventHolder]);\n        }\n\n        function setTransformationHelpers(axis) {\n            // set helper functions on the axis, assumes plot area\n            // has been computed already\n\n            function identity(x) { return x; }\n\n            var s, m, t = axis.options.transform || identity,\n                it = axis.options.inverseTransform;\n\n            // precompute how much the axis is scaling a point\n            // in canvas space\n            if (axis.direction == \"x\") {\n                s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));\n                m = Math.min(t(axis.max), t(axis.min));\n            }\n            else {\n                s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));\n                s = -s;\n                m = Math.max(t(axis.max), t(axis.min));\n            }\n\n            // data point to canvas coordinate\n            if (t == identity) // slight optimization\n                axis.p2c = function (p) { return (p - m) * s; };\n            else\n                axis.p2c = function (p) { return (t(p) - m) * s; };\n            // canvas coordinate to data point\n            if (!it)\n                axis.c2p = function (c) { return m + c / s; };\n            else\n                axis.c2p = function (c) { return it(m + c / s); };\n        }\n\n        function measureTickLabels(axis) {\n\n            var opts = axis.options,\n                ticks = axis.ticks || [],\n                labelWidth = opts.labelWidth || 0,\n                labelHeight = opts.labelHeight || 0,\n                maxWidth = labelWidth || (axis.direction == \"x\" ? Math.floor(surface.width / (ticks.length || 1)) : null),\n                legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                font = opts.font || \"flot-tick-label tickLabel\";\n\n            for (var i = 0; i < ticks.length; ++i) {\n\n                var t = ticks[i];\n\n                if (!t.label)\n                    continue;\n\n                var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);\n\n                labelWidth = Math.max(labelWidth, info.width);\n                labelHeight = Math.max(labelHeight, info.height);\n            }\n\n            axis.labelWidth = opts.labelWidth || labelWidth;\n            axis.labelHeight = opts.labelHeight || labelHeight;\n        }\n\n        function allocateAxisBoxFirstPhase(axis) {\n            // find the bounding box of the axis by looking at label\n            // widths/heights and ticks, make room by diminishing the\n            // plotOffset; this first phase only looks at one\n            // dimension per axis, the other dimension depends on the\n            // other axes so will have to wait\n\n            var lw = axis.labelWidth,\n                lh = axis.labelHeight,\n                pos = axis.options.position,\n                isXAxis = axis.direction === \"x\",\n                tickLength = axis.options.tickLength,\n                axisMargin = options.grid.axisMargin,\n                padding = options.grid.labelMargin,\n                innermost = true,\n                outermost = true,\n                first = true,\n                found = false;\n\n            // Determine the axis's position in its direction and on its side\n\n            $.each(isXAxis ? xaxes : yaxes, function(i, a) {\n                if (a && (a.show || a.reserveSpace)) {\n                    if (a === axis) {\n                        found = true;\n                    } else if (a.options.position === pos) {\n                        if (found) {\n                            outermost = false;\n                        } else {\n                            innermost = false;\n                        }\n                    }\n                    if (!found) {\n                        first = false;\n                    }\n                }\n            });\n\n            // The outermost axis on each side has no margin\n\n            if (outermost) {\n                axisMargin = 0;\n            }\n\n            // The ticks for the first axis in each direction stretch across\n\n            if (tickLength == null) {\n                tickLength = first ? \"full\" : 5;\n            }\n\n            if (!isNaN(+tickLength))\n                padding += +tickLength;\n\n            if (isXAxis) {\n                lh += padding;\n\n                if (pos == \"bottom\") {\n                    plotOffset.bottom += lh + axisMargin;\n                    axis.box = { top: surface.height - plotOffset.bottom, height: lh };\n                }\n                else {\n                    axis.box = { top: plotOffset.top + axisMargin, height: lh };\n                    plotOffset.top += lh + axisMargin;\n                }\n            }\n            else {\n                lw += padding;\n\n                if (pos == \"left\") {\n                    axis.box = { left: plotOffset.left + axisMargin, width: lw };\n                    plotOffset.left += lw + axisMargin;\n                }\n                else {\n                    plotOffset.right += lw + axisMargin;\n                    axis.box = { left: surface.width - plotOffset.right, width: lw };\n                }\n            }\n\n             // save for future reference\n            axis.position = pos;\n            axis.tickLength = tickLength;\n            axis.box.padding = padding;\n            axis.innermost = innermost;\n        }\n\n        function allocateAxisBoxSecondPhase(axis) {\n            // now that all axis boxes have been placed in one\n            // dimension, we can set the remaining dimension coordinates\n            if (axis.direction == \"x\") {\n                axis.box.left = plotOffset.left - axis.labelWidth / 2;\n                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;\n            }\n            else {\n                axis.box.top = plotOffset.top - axis.labelHeight / 2;\n                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;\n            }\n        }\n\n        function adjustLayoutForThingsStickingOut() {\n            // possibly adjust plot offset to ensure everything stays\n            // inside the canvas and isn't clipped off\n\n            var minMargin = options.grid.minBorderMargin,\n                axis, i;\n\n            // check stuff from the plot (FIXME: this should just read\n            // a value from the series, otherwise it's impossible to\n            // customize)\n            if (minMargin == null) {\n                minMargin = 0;\n                for (i = 0; i < series.length; ++i)\n                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth/2));\n            }\n\n            var margins = {\n                left: minMargin,\n                right: minMargin,\n                top: minMargin,\n                bottom: minMargin\n            };\n\n            // check axis labels, note we don't check the actual\n            // labels but instead use the overall width/height to not\n            // jump as much around with replots\n            $.each(allAxes(), function (_, axis) {\n                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {\n                    if (axis.direction === \"x\") {\n                        margins.left = Math.max(margins.left, axis.labelWidth / 2);\n                        margins.right = Math.max(margins.right, axis.labelWidth / 2);\n                    } else {\n                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);\n                        margins.top = Math.max(margins.top, axis.labelHeight / 2);\n                    }\n                }\n            });\n\n            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));\n            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));\n            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));\n            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));\n        }\n\n        function setupGrid() {\n            var i, axes = allAxes(), showGrid = options.grid.show;\n\n            // Initialize the plot's offset from the edge of the canvas\n\n            for (var a in plotOffset) {\n                var margin = options.grid.margin || 0;\n                plotOffset[a] = typeof margin == \"number\" ? margin : margin[a] || 0;\n            }\n\n            executeHooks(hooks.processOffset, [plotOffset]);\n\n            // If the grid is visible, add its border width to the offset\n\n            for (var a in plotOffset) {\n                if(typeof(options.grid.borderWidth) == \"object\") {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;\n                }\n                else {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;\n                }\n            }\n\n            $.each(axes, function (_, axis) {\n                var axisOpts = axis.options;\n                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;\n                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;\n                setRange(axis);\n            });\n\n            if (showGrid) {\n\n                var allocatedAxes = $.grep(axes, function (axis) {\n                    return axis.show || axis.reserveSpace;\n                });\n\n                $.each(allocatedAxes, function (_, axis) {\n                    // make the ticks\n                    setupTickGeneration(axis);\n                    setTicks(axis);\n                    snapRangeToTicks(axis, axis.ticks);\n                    // find labelWidth/Height for axis\n                    measureTickLabels(axis);\n                });\n\n                // with all dimensions calculated, we can compute the\n                // axis bounding boxes, start from the outside\n                // (reverse order)\n                for (i = allocatedAxes.length - 1; i >= 0; --i)\n                    allocateAxisBoxFirstPhase(allocatedAxes[i]);\n\n                // make sure we've got enough space for things that\n                // might stick out\n                adjustLayoutForThingsStickingOut();\n\n                $.each(allocatedAxes, function (_, axis) {\n                    allocateAxisBoxSecondPhase(axis);\n                });\n            }\n\n            plotWidth = surface.width - plotOffset.left - plotOffset.right;\n            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;\n\n            // now we got the proper plot dimensions, we can compute the scaling\n            $.each(axes, function (_, axis) {\n                setTransformationHelpers(axis);\n            });\n\n            if (showGrid) {\n                drawAxisLabels();\n            }\n\n            insertLegend();\n        }\n\n        function setRange(axis) {\n            var opts = axis.options,\n                min = +(opts.min != null ? opts.min : axis.datamin),\n                max = +(opts.max != null ? opts.max : axis.datamax),\n                delta = max - min;\n\n            if (delta == 0.0) {\n                // degenerate case\n                var widen = max == 0 ? 1 : 0.01;\n\n                if (opts.min == null)\n                    min -= widen;\n                // always widen max if we couldn't widen min to ensure we\n                // don't fall into min == max which doesn't work\n                if (opts.max == null || opts.min != null)\n                    max += widen;\n            }\n            else {\n                // consider autoscaling\n                var margin = opts.autoscaleMargin;\n                if (margin != null) {\n                    if (opts.min == null) {\n                        min -= delta * margin;\n                        // make sure we don't go below zero if all values\n                        // are positive\n                        if (min < 0 && axis.datamin != null && axis.datamin >= 0)\n                            min = 0;\n                    }\n                    if (opts.max == null) {\n                        max += delta * margin;\n                        if (max > 0 && axis.datamax != null && axis.datamax <= 0)\n                            max = 0;\n                    }\n                }\n            }\n            axis.min = min;\n            axis.max = max;\n        }\n\n        function setupTickGeneration(axis) {\n            var opts = axis.options;\n\n            // estimate number of ticks\n            var noTicks;\n            if (typeof opts.ticks == \"number\" && opts.ticks > 0)\n                noTicks = opts.ticks;\n            else\n                // heuristic based on the model a*sqrt(x) fitted to\n                // some data points that seemed reasonable\n                noTicks = 0.3 * Math.sqrt(axis.direction == \"x\" ? surface.width : surface.height);\n\n            var delta = (axis.max - axis.min) / noTicks,\n                dec = -Math.floor(Math.log(delta) / Math.LN10),\n                maxDec = opts.tickDecimals;\n\n            if (maxDec != null && dec > maxDec) {\n                dec = maxDec;\n            }\n\n            var magn = Math.pow(10, -dec),\n                norm = delta / magn, // norm is between 1.0 and 10.0\n                size;\n\n            if (norm < 1.5) {\n                size = 1;\n            } else if (norm < 3) {\n                size = 2;\n                // special case for 2.5, requires an extra decimal\n                if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {\n                    size = 2.5;\n                    ++dec;\n                }\n            } else if (norm < 7.5) {\n                size = 5;\n            } else {\n                size = 10;\n            }\n\n            size *= magn;\n\n            if (opts.minTickSize != null && size < opts.minTickSize) {\n                size = opts.minTickSize;\n            }\n\n            axis.delta = delta;\n            axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);\n            axis.tickSize = opts.tickSize || size;\n\n            // Time mode was moved to a plug-in in 0.8, and since so many people use it\n            // we'll add an especially friendly reminder to make sure they included it.\n\n            if (opts.mode == \"time\" && !axis.tickGenerator) {\n                throw new Error(\"Time mode requires the flot.time plugin.\");\n            }\n\n            // Flot supports base-10 axes; any other mode else is handled by a plug-in,\n            // like flot.time.js.\n\n            if (!axis.tickGenerator) {\n\n                axis.tickGenerator = function (axis) {\n\n                    var ticks = [],\n                        start = floorInBase(axis.min, axis.tickSize),\n                        i = 0,\n                        v = Number.NaN,\n                        prev;\n\n                    do {\n                        prev = v;\n                        v = start + i * axis.tickSize;\n                        ticks.push(v);\n                        ++i;\n                    } while (v < axis.max && v != prev);\n                    return ticks;\n                };\n\n\t\t\t\taxis.tickFormatter = function (value, axis) {\n\n\t\t\t\t\tvar factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;\n\t\t\t\t\tvar formatted = \"\" + Math.round(value * factor) / factor;\n\n\t\t\t\t\t// If tickDecimals was specified, ensure that we have exactly that\n\t\t\t\t\t// much precision; otherwise default to the value's own precision.\n\n\t\t\t\t\tif (axis.tickDecimals != null) {\n\t\t\t\t\t\tvar decimal = formatted.indexOf(\".\");\n\t\t\t\t\t\tvar precision = decimal == -1 ? 0 : formatted.length - decimal - 1;\n\t\t\t\t\t\tif (precision < axis.tickDecimals) {\n\t\t\t\t\t\t\treturn (precision ? formatted : formatted + \".\") + (\"\" + factor).substr(1, axis.tickDecimals - precision);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n                    return formatted;\n                };\n            }\n\n            if ($.isFunction(opts.tickFormatter))\n                axis.tickFormatter = function (v, axis) { return \"\" + opts.tickFormatter(v, axis); };\n\n            if (opts.alignTicksWithAxis != null) {\n                var otherAxis = (axis.direction == \"x\" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];\n                if (otherAxis && otherAxis.used && otherAxis != axis) {\n                    // consider snapping min/max to outermost nice ticks\n                    var niceTicks = axis.tickGenerator(axis);\n                    if (niceTicks.length > 0) {\n                        if (opts.min == null)\n                            axis.min = Math.min(axis.min, niceTicks[0]);\n                        if (opts.max == null && niceTicks.length > 1)\n                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);\n                    }\n\n                    axis.tickGenerator = function (axis) {\n                        // copy ticks, scaled to this axis\n                        var ticks = [], v, i;\n                        for (i = 0; i < otherAxis.ticks.length; ++i) {\n                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);\n                            v = axis.min + v * (axis.max - axis.min);\n                            ticks.push(v);\n                        }\n                        return ticks;\n                    };\n\n                    // we might need an extra decimal since forced\n                    // ticks don't necessarily fit naturally\n                    if (!axis.mode && opts.tickDecimals == null) {\n                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),\n                            ts = axis.tickGenerator(axis);\n\n                        // only proceed if the tick interval rounded\n                        // with an extra decimal doesn't give us a\n                        // zero at end\n                        if (!(ts.length > 1 && /\\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))\n                            axis.tickDecimals = extraDec;\n                    }\n                }\n            }\n        }\n\n        function setTicks(axis) {\n            var oticks = axis.options.ticks, ticks = [];\n            if (oticks == null || (typeof oticks == \"number\" && oticks > 0))\n                ticks = axis.tickGenerator(axis);\n            else if (oticks) {\n                if ($.isFunction(oticks))\n                    // generate the ticks\n                    ticks = oticks(axis);\n                else\n                    ticks = oticks;\n            }\n\n            // clean up/labelify the supplied ticks, copy them over\n            var i, v;\n            axis.ticks = [];\n            for (i = 0; i < ticks.length; ++i) {\n                var label = null;\n                var t = ticks[i];\n                if (typeof t == \"object\") {\n                    v = +t[0];\n                    if (t.length > 1)\n                        label = t[1];\n                }\n                else\n                    v = +t;\n                if (label == null)\n                    label = axis.tickFormatter(v, axis);\n                if (!isNaN(v))\n                    axis.ticks.push({ v: v, label: label });\n            }\n        }\n\n        function snapRangeToTicks(axis, ticks) {\n            if (axis.options.autoscaleMargin && ticks.length > 0) {\n                // snap to ticks\n                if (axis.options.min == null)\n                    axis.min = Math.min(axis.min, ticks[0].v);\n                if (axis.options.max == null && ticks.length > 1)\n                    axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);\n            }\n        }\n\n        function draw() {\n\n            surface.clear();\n\n            executeHooks(hooks.drawBackground, [ctx]);\n\n            var grid = options.grid;\n\n            // draw background, if any\n            if (grid.show && grid.backgroundColor)\n                drawBackground();\n\n            if (grid.show && !grid.aboveData) {\n                drawGrid();\n            }\n\n            for (var i = 0; i < series.length; ++i) {\n                executeHooks(hooks.drawSeries, [ctx, series[i]]);\n                drawSeries(series[i]);\n            }\n\n            executeHooks(hooks.draw, [ctx]);\n\n            if (grid.show && grid.aboveData) {\n                drawGrid();\n            }\n\n            surface.render();\n\n            // A draw implies that either the axes or data have changed, so we\n            // should probably update the overlay highlights as well.\n\n            triggerRedrawOverlay();\n        }\n\n        function extractRange(ranges, coord) {\n            var axis, from, to, key, axes = allAxes();\n\n            for (var i = 0; i < axes.length; ++i) {\n                axis = axes[i];\n                if (axis.direction == coord) {\n                    key = coord + axis.n + \"axis\";\n                    if (!ranges[key] && axis.n == 1)\n                        key = coord + \"axis\"; // support x1axis as xaxis\n                    if (ranges[key]) {\n                        from = ranges[key].from;\n                        to = ranges[key].to;\n                        break;\n                    }\n                }\n            }\n\n            // backwards-compat stuff - to be removed in future\n            if (!ranges[key]) {\n                axis = coord == \"x\" ? xaxes[0] : yaxes[0];\n                from = ranges[coord + \"1\"];\n                to = ranges[coord + \"2\"];\n            }\n\n            // auto-reverse as an added bonus\n            if (from != null && to != null && from > to) {\n                var tmp = from;\n                from = to;\n                to = tmp;\n            }\n\n            return { from: from, to: to, axis: axis };\n        }\n\n        function drawBackground() {\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, \"rgba(255, 255, 255, 0)\");\n            ctx.fillRect(0, 0, plotWidth, plotHeight);\n            ctx.restore();\n        }\n\n        function drawGrid() {\n            var i, axes, bw, bc;\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // draw markings\n            var markings = options.grid.markings;\n            if (markings) {\n                if ($.isFunction(markings)) {\n                    axes = plot.getAxes();\n                    // xmin etc. is backwards compatibility, to be\n                    // removed in the future\n                    axes.xmin = axes.xaxis.min;\n                    axes.xmax = axes.xaxis.max;\n                    axes.ymin = axes.yaxis.min;\n                    axes.ymax = axes.yaxis.max;\n\n                    markings = markings(axes);\n                }\n\n                for (i = 0; i < markings.length; ++i) {\n                    var m = markings[i],\n                        xrange = extractRange(m, \"x\"),\n                        yrange = extractRange(m, \"y\");\n\n                    // fill in missing\n                    if (xrange.from == null)\n                        xrange.from = xrange.axis.min;\n                    if (xrange.to == null)\n                        xrange.to = xrange.axis.max;\n                    if (yrange.from == null)\n                        yrange.from = yrange.axis.min;\n                    if (yrange.to == null)\n                        yrange.to = yrange.axis.max;\n\n                    // clip\n                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||\n                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max)\n                        continue;\n\n                    xrange.from = Math.max(xrange.from, xrange.axis.min);\n                    xrange.to = Math.min(xrange.to, xrange.axis.max);\n                    yrange.from = Math.max(yrange.from, yrange.axis.min);\n                    yrange.to = Math.min(yrange.to, yrange.axis.max);\n\n                    var xequal = xrange.from === xrange.to,\n                        yequal = yrange.from === yrange.to;\n\n                    if (xequal && yequal) {\n                        continue;\n                    }\n\n                    // then draw\n                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));\n                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));\n                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));\n                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));\n\n                    if (xequal || yequal) {\n                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth,\n                            subPixel = lineWidth % 2 ? 0.5 : 0;\n                        ctx.beginPath();\n                        ctx.strokeStyle = m.color || options.grid.markingsColor;\n                        ctx.lineWidth = lineWidth;\n                        if (xequal) {\n                            ctx.moveTo(xrange.to + subPixel, yrange.from);\n                            ctx.lineTo(xrange.to + subPixel, yrange.to);\n                        } else {\n                            ctx.moveTo(xrange.from, yrange.to + subPixel);\n                            ctx.lineTo(xrange.to, yrange.to + subPixel);                            \n                        }\n                        ctx.stroke();\n                    } else {\n                        ctx.fillStyle = m.color || options.grid.markingsColor;\n                        ctx.fillRect(xrange.from, yrange.to,\n                                     xrange.to - xrange.from,\n                                     yrange.from - yrange.to);\n                    }\n                }\n            }\n\n            // draw the ticks\n            axes = allAxes();\n            bw = options.grid.borderWidth;\n\n            for (var j = 0; j < axes.length; ++j) {\n                var axis = axes[j], box = axis.box,\n                    t = axis.tickLength, x, y, xoff, yoff;\n                if (!axis.show || axis.ticks.length == 0)\n                    continue;\n\n                ctx.lineWidth = 1;\n\n                // find the edges\n                if (axis.direction == \"x\") {\n                    x = 0;\n                    if (t == \"full\")\n                        y = (axis.position == \"top\" ? 0 : plotHeight);\n                    else\n                        y = box.top - plotOffset.top + (axis.position == \"top\" ? box.height : 0);\n                }\n                else {\n                    y = 0;\n                    if (t == \"full\")\n                        x = (axis.position == \"left\" ? 0 : plotWidth);\n                    else\n                        x = box.left - plotOffset.left + (axis.position == \"left\" ? box.width : 0);\n                }\n\n                // draw tick bar\n                if (!axis.innermost) {\n                    ctx.strokeStyle = axis.options.color;\n                    ctx.beginPath();\n                    xoff = yoff = 0;\n                    if (axis.direction == \"x\")\n                        xoff = plotWidth + 1;\n                    else\n                        yoff = plotHeight + 1;\n\n                    if (ctx.lineWidth == 1) {\n                        if (axis.direction == \"x\") {\n                            y = Math.floor(y) + 0.5;\n                        } else {\n                            x = Math.floor(x) + 0.5;\n                        }\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                    ctx.stroke();\n                }\n\n                // draw ticks\n\n                ctx.strokeStyle = axis.options.tickColor;\n\n                ctx.beginPath();\n                for (i = 0; i < axis.ticks.length; ++i) {\n                    var v = axis.ticks[i].v;\n\n                    xoff = yoff = 0;\n\n                    if (isNaN(v) || v < axis.min || v > axis.max\n                        // skip those lying on the axes if we got a border\n                        || (t == \"full\"\n                            && ((typeof bw == \"object\" && bw[axis.position] > 0) || bw > 0)\n                            && (v == axis.min || v == axis.max)))\n                        continue;\n\n                    if (axis.direction == \"x\") {\n                        x = axis.p2c(v);\n                        yoff = t == \"full\" ? -plotHeight : t;\n\n                        if (axis.position == \"top\")\n                            yoff = -yoff;\n                    }\n                    else {\n                        y = axis.p2c(v);\n                        xoff = t == \"full\" ? -plotWidth : t;\n\n                        if (axis.position == \"left\")\n                            xoff = -xoff;\n                    }\n\n                    if (ctx.lineWidth == 1) {\n                        if (axis.direction == \"x\")\n                            x = Math.floor(x) + 0.5;\n                        else\n                            y = Math.floor(y) + 0.5;\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                }\n\n                ctx.stroke();\n            }\n\n\n            // draw border\n            if (bw) {\n                // If either borderWidth or borderColor is an object, then draw the border\n                // line by line instead of as one rectangle\n                bc = options.grid.borderColor;\n                if(typeof bw == \"object\" || typeof bc == \"object\") {\n                    if (typeof bw !== \"object\") {\n                        bw = {top: bw, right: bw, bottom: bw, left: bw};\n                    }\n                    if (typeof bc !== \"object\") {\n                        bc = {top: bc, right: bc, bottom: bc, left: bc};\n                    }\n\n                    if (bw.top > 0) {\n                        ctx.strokeStyle = bc.top;\n                        ctx.lineWidth = bw.top;\n                        ctx.beginPath();\n                        ctx.moveTo(0 - bw.left, 0 - bw.top/2);\n                        ctx.lineTo(plotWidth, 0 - bw.top/2);\n                        ctx.stroke();\n                    }\n\n                    if (bw.right > 0) {\n                        ctx.strokeStyle = bc.right;\n                        ctx.lineWidth = bw.right;\n                        ctx.beginPath();\n                        ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);\n                        ctx.lineTo(plotWidth + bw.right / 2, plotHeight);\n                        ctx.stroke();\n                    }\n\n                    if (bw.bottom > 0) {\n                        ctx.strokeStyle = bc.bottom;\n                        ctx.lineWidth = bw.bottom;\n                        ctx.beginPath();\n                        ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);\n                        ctx.lineTo(0, plotHeight + bw.bottom / 2);\n                        ctx.stroke();\n                    }\n\n                    if (bw.left > 0) {\n                        ctx.strokeStyle = bc.left;\n                        ctx.lineWidth = bw.left;\n                        ctx.beginPath();\n                        ctx.moveTo(0 - bw.left/2, plotHeight + bw.bottom);\n                        ctx.lineTo(0- bw.left/2, 0);\n                        ctx.stroke();\n                    }\n                }\n                else {\n                    ctx.lineWidth = bw;\n                    ctx.strokeStyle = options.grid.borderColor;\n                    ctx.strokeRect(-bw/2, -bw/2, plotWidth + bw, plotHeight + bw);\n                }\n            }\n\n            ctx.restore();\n        }\n\n        function drawAxisLabels() {\n\n            $.each(allAxes(), function (_, axis) {\n                var box = axis.box,\n                    legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                    layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                    font = axis.options.font || \"flot-tick-label tickLabel\",\n                    tick, x, y, halign, valign;\n\n                // Remove text before checking for axis.show and ticks.length;\n                // otherwise plugins, like flot-tickrotor, that draw their own\n                // tick labels will end up with both theirs and the defaults.\n\n                surface.removeText(layer);\n\n                if (!axis.show || axis.ticks.length == 0)\n                    return;\n\n                for (var i = 0; i < axis.ticks.length; ++i) {\n\n                    tick = axis.ticks[i];\n                    if (!tick.label || tick.v < axis.min || tick.v > axis.max)\n                        continue;\n\n                    if (axis.direction == \"x\") {\n                        halign = \"center\";\n                        x = plotOffset.left + axis.p2c(tick.v);\n                        if (axis.position == \"bottom\") {\n                            y = box.top + box.padding;\n                        } else {\n                            y = box.top + box.height - box.padding;\n                            valign = \"bottom\";\n                        }\n                    } else {\n                        valign = \"middle\";\n                        y = plotOffset.top + axis.p2c(tick.v);\n                        if (axis.position == \"left\") {\n                            x = box.left + box.width - box.padding;\n                            halign = \"right\";\n                        } else {\n                            x = box.left + box.padding;\n                        }\n                    }\n\n                    surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);\n                }\n            });\n        }\n\n        function drawSeries(series) {\n            if (series.lines.show)\n                drawSeriesLines(series);\n            if (series.bars.show)\n                drawSeriesBars(series);\n            if (series.points.show)\n                drawSeriesPoints(series);\n        }\n\n        function drawSeriesLines(series) {\n            function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    prevx = null, prevy = null;\n\n                ctx.beginPath();\n                for (var i = ps; i < points.length; i += ps) {\n                    var x1 = points[i - ps], y1 = points[i - ps + 1],\n                        x2 = points[i], y2 = points[i + 1];\n\n                    if (x1 == null || x2 == null)\n                        continue;\n\n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min) {\n                        if (y2 < axisy.min)\n                            continue;   // line segment is outside\n                        // compute new intersection point\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    }\n                    else if (y2 <= y1 && y2 < axisy.min) {\n                        if (y1 < axisy.min)\n                            continue;\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max) {\n                        if (y2 > axisy.max)\n                            continue;\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    }\n                    else if (y2 >= y1 && y2 > axisy.max) {\n                        if (y1 > axisy.max)\n                            continue;\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min)\n                            continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    }\n                    else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min)\n                            continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max)\n                            continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    }\n                    else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max)\n                            continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (x1 != prevx || y1 != prevy)\n                        ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);\n\n                    prevx = x2;\n                    prevy = y2;\n                    ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);\n                }\n                ctx.stroke();\n            }\n\n            function plotLineArea(datapoints, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    bottom = Math.min(Math.max(0, axisy.min), axisy.max),\n                    i = 0, top, areaOpen = false,\n                    ypos = 1, segmentStart = 0, segmentEnd = 0;\n\n                // we process each segment in two turns, first forward\n                // direction to sketch out top, then once we hit the\n                // end we go backwards to sketch the bottom\n                while (true) {\n                    if (ps > 0 && i > points.length + ps)\n                        break;\n\n                    i += ps; // ps is negative if going backwards\n\n                    var x1 = points[i - ps],\n                        y1 = points[i - ps + ypos],\n                        x2 = points[i], y2 = points[i + ypos];\n\n                    if (areaOpen) {\n                        if (ps > 0 && x1 != null && x2 == null) {\n                            // at turning point\n                            segmentEnd = i;\n                            ps = -ps;\n                            ypos = 2;\n                            continue;\n                        }\n\n                        if (ps < 0 && i == segmentStart + ps) {\n                            // done with the reverse sweep\n                            ctx.fill();\n                            areaOpen = false;\n                            ps = -ps;\n                            ypos = 1;\n                            i = segmentStart = segmentEnd + ps;\n                            continue;\n                        }\n                    }\n\n                    if (x1 == null || x2 == null)\n                        continue;\n\n                    // clip x values\n\n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min)\n                            continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    }\n                    else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min)\n                            continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max)\n                            continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    }\n                    else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max)\n                            continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (!areaOpen) {\n                        // open area\n                        ctx.beginPath();\n                        ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));\n                        areaOpen = true;\n                    }\n\n                    // now first check the case where both is outside\n                    if (y1 >= axisy.max && y2 >= axisy.max) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));\n                        continue;\n                    }\n                    else if (y1 <= axisy.min && y2 <= axisy.min) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));\n                        continue;\n                    }\n\n                    // else it's a bit more complicated, there might\n                    // be a flat maxed out rectangle first, then a\n                    // triangular cutout or reverse; to find these\n                    // keep track of the current x values\n                    var x1old = x1, x2old = x2;\n\n                    // clip the y values, without shortcutting, we\n                    // go through all cases in turn\n\n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    }\n                    else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    }\n                    else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // if the x value was changed we got a rectangle\n                    // to fill\n                    if (x1 != x1old) {\n                        ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));\n                        // it goes to (x1, y1), but we fill that below\n                    }\n\n                    // fill triangular section, this sometimes result\n                    // in redundant points if (x1, y1) hasn't changed\n                    // from previous line to, but we just ignore that\n                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));\n                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n\n                    // fill the other rectangle if it's there\n                    if (x2 != x2old) {\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n                        ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));\n                    }\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n            ctx.lineJoin = \"round\";\n\n            var lw = series.lines.lineWidth,\n                sw = series.shadowSize;\n            // FIXME: consider another form of shadow when filling is turned on\n            if (lw > 0 && sw > 0) {\n                // draw shadow as a thick and thin line with transparency\n                ctx.lineWidth = sw;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                // position shadow at angle from the mid of line\n                var angle = Math.PI/18;\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/2), Math.cos(angle) * (lw/2 + sw/2), series.xaxis, series.yaxis);\n                ctx.lineWidth = sw/2;\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/4), Math.cos(angle) * (lw/2 + sw/4), series.xaxis, series.yaxis);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);\n            if (fillStyle) {\n                ctx.fillStyle = fillStyle;\n                plotLineArea(series.datapoints, series.xaxis, series.yaxis);\n            }\n\n            if (lw > 0)\n                plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function drawSeriesPoints(series) {\n            function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {\n                var points = datapoints.points, ps = datapoints.pointsize;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    var x = points[i], y = points[i + 1];\n                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\n                        continue;\n\n                    ctx.beginPath();\n                    x = axisx.p2c(x);\n                    y = axisy.p2c(y) + offset;\n                    if (symbol == \"circle\")\n                        ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);\n                    else\n                        symbol(ctx, x, y, radius, shadow);\n                    ctx.closePath();\n\n                    if (fillStyle) {\n                        ctx.fillStyle = fillStyle;\n                        ctx.fill();\n                    }\n                    ctx.stroke();\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            var lw = series.points.lineWidth,\n                sw = series.shadowSize,\n                radius = series.points.radius,\n                symbol = series.points.symbol;\n\n            // If the user sets the line width to 0, we change it to a very \n            // small value. A line width of 0 seems to force the default of 1.\n            // Doing the conditional here allows the shadow setting to still be \n            // optional even with a lineWidth of 0.\n\n            if( lw == 0 )\n                lw = 0.0001;\n\n            if (lw > 0 && sw > 0) {\n                // draw shadow in two steps\n                var w = sw / 2;\n                ctx.lineWidth = w;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                plotPoints(series.datapoints, radius, null, w + w/2, true,\n                           series.xaxis, series.yaxis, symbol);\n\n                ctx.strokeStyle = \"rgba(0,0,0,0.2)\";\n                plotPoints(series.datapoints, radius, null, w/2, true,\n                           series.xaxis, series.yaxis, symbol);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            plotPoints(series.datapoints, radius,\n                       getFillStyle(series.points, series.color), 0, false,\n                       series.xaxis, series.yaxis, symbol);\n            ctx.restore();\n        }\n\n        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {\n            var left, right, bottom, top,\n                drawLeft, drawRight, drawTop, drawBottom,\n                tmp;\n\n            // in horizontal mode, we start the bar from the left\n            // instead of from the bottom so it appears to be\n            // horizontal rather than vertical\n            if (horizontal) {\n                drawBottom = drawRight = drawTop = true;\n                drawLeft = false;\n                left = b;\n                right = x;\n                top = y + barLeft;\n                bottom = y + barRight;\n\n                // account for negative bars\n                if (right < left) {\n                    tmp = right;\n                    right = left;\n                    left = tmp;\n                    drawLeft = true;\n                    drawRight = false;\n                }\n            }\n            else {\n                drawLeft = drawRight = drawTop = true;\n                drawBottom = false;\n                left = x + barLeft;\n                right = x + barRight;\n                bottom = b;\n                top = y;\n\n                // account for negative bars\n                if (top < bottom) {\n                    tmp = top;\n                    top = bottom;\n                    bottom = tmp;\n                    drawBottom = true;\n                    drawTop = false;\n                }\n            }\n\n            // clip\n            if (right < axisx.min || left > axisx.max ||\n                top < axisy.min || bottom > axisy.max)\n                return;\n\n            if (left < axisx.min) {\n                left = axisx.min;\n                drawLeft = false;\n            }\n\n            if (right > axisx.max) {\n                right = axisx.max;\n                drawRight = false;\n            }\n\n            if (bottom < axisy.min) {\n                bottom = axisy.min;\n                drawBottom = false;\n            }\n\n            if (top > axisy.max) {\n                top = axisy.max;\n                drawTop = false;\n            }\n\n            left = axisx.p2c(left);\n            bottom = axisy.p2c(bottom);\n            right = axisx.p2c(right);\n            top = axisy.p2c(top);\n\n            // fill the bar\n            if (fillStyleCallback) {\n                c.fillStyle = fillStyleCallback(bottom, top);\n                c.fillRect(left, top, right - left, bottom - top)\n            }\n\n            // draw outline\n            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {\n                c.beginPath();\n\n                // FIXME: inline moveTo is buggy with excanvas\n                c.moveTo(left, bottom);\n                if (drawLeft)\n                    c.lineTo(left, top);\n                else\n                    c.moveTo(left, top);\n                if (drawTop)\n                    c.lineTo(right, top);\n                else\n                    c.moveTo(right, top);\n                if (drawRight)\n                    c.lineTo(right, bottom);\n                else\n                    c.moveTo(right, bottom);\n                if (drawBottom)\n                    c.lineTo(left, bottom);\n                else\n                    c.moveTo(left, bottom);\n                c.stroke();\n            }\n        }\n\n        function drawSeriesBars(series) {\n            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {\n                var points = datapoints.points, ps = datapoints.pointsize;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    if (points[i] == null)\n                        continue;\n                    drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // FIXME: figure out a way to add shadows (for instance along the right edge)\n            ctx.lineWidth = series.bars.lineWidth;\n            ctx.strokeStyle = series.color;\n\n            var barLeft;\n\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -series.bars.barWidth;\n                    break;\n                default:\n                    barLeft = -series.bars.barWidth / 2;\n            }\n\n            var fillStyleCallback = series.bars.fill ? function (bottom, top) { return getFillStyle(series.bars, series.color, bottom, top); } : null;\n            plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function getFillStyle(filloptions, seriesColor, bottom, top) {\n            var fill = filloptions.fill;\n            if (!fill)\n                return null;\n\n            if (filloptions.fillColor)\n                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);\n\n            var c = $.color.parse(seriesColor);\n            c.a = typeof fill == \"number\" ? fill : 0.4;\n            c.normalize();\n            return c.toString();\n        }\n\n        function insertLegend() {\n\n            if (options.legend.container != null) {\n                $(options.legend.container).html(\"\");\n            } else {\n                placeholder.find(\".legend\").remove();\n            }\n\n            if (!options.legend.show) {\n                return;\n            }\n\n            var fragments = [], entries = [], rowStarted = false,\n                lf = options.legend.labelFormatter, s, label;\n\n            // Build a list of legend entries, with each having a label and a color\n\n            for (var i = 0; i < series.length; ++i) {\n                s = series[i];\n                if (s.label) {\n                    label = lf ? lf(s.label, s) : s.label;\n                    if (label) {\n                        entries.push({\n                            label: label,\n                            color: s.color\n                        });\n                    }\n                }\n            }\n\n            // Sort the legend using either the default or a custom comparator\n\n            if (options.legend.sorted) {\n                if ($.isFunction(options.legend.sorted)) {\n                    entries.sort(options.legend.sorted);\n                } else if (options.legend.sorted == \"reverse\") {\n                \tentries.reverse();\n                } else {\n                    var ascending = options.legend.sorted != \"descending\";\n                    entries.sort(function(a, b) {\n                        return a.label == b.label ? 0 : (\n                            (a.label < b.label) != ascending ? 1 : -1   // Logical XOR\n                        );\n                    });\n                }\n            }\n\n            // Generate markup for the list of entries, in their final order\n\n            for (var i = 0; i < entries.length; ++i) {\n\n                var entry = entries[i];\n\n                if (i % options.legend.noColumns == 0) {\n                    if (rowStarted)\n                        fragments.push('</tr>');\n                    fragments.push('<tr>');\n                    rowStarted = true;\n                }\n\n                fragments.push(\n                    '<td class=\"legendColorBox\"><div style=\"border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px\"><div style=\"width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden\"></div></div></td>' +\n                    '<td class=\"legendLabel\">' + entry.label + '</td>'\n                );\n            }\n\n            if (rowStarted)\n                fragments.push('</tr>');\n\n            if (fragments.length == 0)\n                return;\n\n            var table = '<table style=\"font-size:smaller;color:' + options.grid.color + '\">' + fragments.join(\"\") + '</table>';\n            if (options.legend.container != null)\n                $(options.legend.container).html(table);\n            else {\n                var pos = \"\",\n                    p = options.legend.position,\n                    m = options.legend.margin;\n                if (m[0] == null)\n                    m = [m, m];\n                if (p.charAt(0) == \"n\")\n                    pos += 'top:' + (m[1] + plotOffset.top) + 'px;';\n                else if (p.charAt(0) == \"s\")\n                    pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';\n                if (p.charAt(1) == \"e\")\n                    pos += 'right:' + (m[0] + plotOffset.right) + 'px;';\n                else if (p.charAt(1) == \"w\")\n                    pos += 'left:' + (m[0] + plotOffset.left) + 'px;';\n                var legend = $('<div class=\"legend\">' + table.replace('style=\"', 'style=\"position:absolute;' + pos +';') + '</div>').appendTo(placeholder);\n                if (options.legend.backgroundOpacity != 0.0) {\n                    // put in the transparent background\n                    // separately to avoid blended labels and\n                    // label boxes\n                    var c = options.legend.backgroundColor;\n                    if (c == null) {\n                        c = options.grid.backgroundColor;\n                        if (c && typeof c == \"string\")\n                            c = $.color.parse(c);\n                        else\n                            c = $.color.extract(legend, 'background-color');\n                        c.a = 1;\n                        c = c.toString();\n                    }\n                    var div = legend.children();\n                    $('<div style=\"position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos +'background-color:' + c + ';\"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);\n                }\n            }\n        }\n\n\n        // interactive features\n\n        var highlights = [],\n            redrawTimeout = null;\n\n        // returns the data item the mouse is over, or null if none is found\n        function findNearbyItem(mouseX, mouseY, seriesFilter) {\n            var maxDistance = options.grid.mouseActiveRadius,\n                smallestDistance = maxDistance * maxDistance + 1,\n                item = null, foundPoint = false, i, j, ps;\n\n            for (i = series.length - 1; i >= 0; --i) {\n                if (!seriesFilter(series[i]))\n                    continue;\n\n                var s = series[i],\n                    axisx = s.xaxis,\n                    axisy = s.yaxis,\n                    points = s.datapoints.points,\n                    mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster\n                    my = axisy.c2p(mouseY),\n                    maxx = maxDistance / axisx.scale,\n                    maxy = maxDistance / axisy.scale;\n\n                ps = s.datapoints.pointsize;\n                // with inverse transforms, we can't use the maxx/maxy\n                // optimization, sadly\n                if (axisx.options.inverseTransform)\n                    maxx = Number.MAX_VALUE;\n                if (axisy.options.inverseTransform)\n                    maxy = Number.MAX_VALUE;\n\n                if (s.lines.show || s.points.show) {\n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j], y = points[j + 1];\n                        if (x == null)\n                            continue;\n\n                        // For points and lines, the cursor must be within a\n                        // certain distance to the data point\n                        if (x - mx > maxx || x - mx < -maxx ||\n                            y - my > maxy || y - my < -maxy)\n                            continue;\n\n                        // We have to calculate distances in pixels, not in\n                        // data units, because the scales of the axes may be different\n                        var dx = Math.abs(axisx.p2c(x) - mouseX),\n                            dy = Math.abs(axisy.p2c(y) - mouseY),\n                            dist = dx * dx + dy * dy; // we save the sqrt\n\n                        // use <= to ensure last point takes precedence\n                        // (last generally means on top of)\n                        if (dist < smallestDistance) {\n                            smallestDistance = dist;\n                            item = [i, j / ps];\n                        }\n                    }\n                }\n\n                if (s.bars.show && !item) { // no other point can be nearby\n\n                    var barLeft, barRight;\n\n                    switch (s.bars.align) {\n                        case \"left\":\n                            barLeft = 0;\n                            break;\n                        case \"right\":\n                            barLeft = -s.bars.barWidth;\n                            break;\n                        default:\n                            barLeft = -s.bars.barWidth / 2;\n                    }\n\n                    barRight = barLeft + s.bars.barWidth;\n\n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j], y = points[j + 1], b = points[j + 2];\n                        if (x == null)\n                            continue;\n\n                        // for a bar graph, the cursor must be inside the bar\n                        if (series[i].bars.horizontal ?\n                            (mx <= Math.max(b, x) && mx >= Math.min(b, x) &&\n                             my >= y + barLeft && my <= y + barRight) :\n                            (mx >= x + barLeft && mx <= x + barRight &&\n                             my >= Math.min(b, y) && my <= Math.max(b, y)))\n                                item = [i, j / ps];\n                    }\n                }\n            }\n\n            if (item) {\n                i = item[0];\n                j = item[1];\n                ps = series[i].datapoints.pointsize;\n\n                return { datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),\n                         dataIndex: j,\n                         series: series[i],\n                         seriesIndex: i };\n            }\n\n            return null;\n        }\n\n        function onMouseMove(e) {\n            if (options.grid.hoverable)\n                triggerClickHoverEvent(\"plothover\", e,\n                                       function (s) { return s[\"hoverable\"] != false; });\n        }\n\n        function onMouseLeave(e) {\n            if (options.grid.hoverable)\n                triggerClickHoverEvent(\"plothover\", e,\n                                       function (s) { return false; });\n        }\n\n        function onClick(e) {\n            triggerClickHoverEvent(\"plotclick\", e,\n                                   function (s) { return s[\"clickable\"] != false; });\n        }\n\n        // trigger click or hover event (they send the same parameters\n        // so we share their code)\n        function triggerClickHoverEvent(eventname, event, seriesFilter) {\n            var offset = eventHolder.offset(),\n                canvasX = event.pageX - offset.left - plotOffset.left,\n                canvasY = event.pageY - offset.top - plotOffset.top,\n            pos = canvasToAxisCoords({ left: canvasX, top: canvasY });\n\n            pos.pageX = event.pageX;\n            pos.pageY = event.pageY;\n\n            var item = findNearbyItem(canvasX, canvasY, seriesFilter);\n\n            if (item) {\n                // fill in mouse pos for any listeners out there\n                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);\n                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);\n            }\n\n            if (options.grid.autoHighlight) {\n                // clear auto-highlights\n                for (var i = 0; i < highlights.length; ++i) {\n                    var h = highlights[i];\n                    if (h.auto == eventname &&\n                        !(item && h.series == item.series &&\n                          h.point[0] == item.datapoint[0] &&\n                          h.point[1] == item.datapoint[1]))\n                        unhighlight(h.series, h.point);\n                }\n\n                if (item)\n                    highlight(item.series, item.datapoint, eventname);\n            }\n\n            placeholder.trigger(eventname, [ pos, item ]);\n        }\n\n        function triggerRedrawOverlay() {\n            var t = options.interaction.redrawOverlayInterval;\n            if (t == -1) {      // skip event queue\n                drawOverlay();\n                return;\n            }\n\n            if (!redrawTimeout)\n                redrawTimeout = setTimeout(drawOverlay, t);\n        }\n\n        function drawOverlay() {\n            redrawTimeout = null;\n\n            // draw highlights\n            octx.save();\n            overlay.clear();\n            octx.translate(plotOffset.left, plotOffset.top);\n\n            var i, hi;\n            for (i = 0; i < highlights.length; ++i) {\n                hi = highlights[i];\n\n                if (hi.series.bars.show)\n                    drawBarHighlight(hi.series, hi.point);\n                else\n                    drawPointHighlight(hi.series, hi.point);\n            }\n            octx.restore();\n\n            executeHooks(hooks.drawOverlay, [octx]);\n        }\n\n        function highlight(s, point, auto) {\n            if (typeof s == \"number\")\n                s = series[s];\n\n            if (typeof point == \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i == -1) {\n                highlights.push({ series: s, point: point, auto: auto });\n\n                triggerRedrawOverlay();\n            }\n            else if (!auto)\n                highlights[i].auto = false;\n        }\n\n        function unhighlight(s, point) {\n            if (s == null && point == null) {\n                highlights = [];\n                triggerRedrawOverlay();\n                return;\n            }\n\n            if (typeof s == \"number\")\n                s = series[s];\n\n            if (typeof point == \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i != -1) {\n                highlights.splice(i, 1);\n\n                triggerRedrawOverlay();\n            }\n        }\n\n        function indexOfHighlight(s, p) {\n            for (var i = 0; i < highlights.length; ++i) {\n                var h = highlights[i];\n                if (h.series == s && h.point[0] == p[0]\n                    && h.point[1] == p[1])\n                    return i;\n            }\n            return -1;\n        }\n\n        function drawPointHighlight(series, point) {\n            var x = point[0], y = point[1],\n                axisx = series.xaxis, axisy = series.yaxis,\n                highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();\n\n            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\n                return;\n\n            var pointRadius = series.points.radius + series.points.lineWidth / 2;\n            octx.lineWidth = pointRadius;\n            octx.strokeStyle = highlightColor;\n            var radius = 1.5 * pointRadius;\n            x = axisx.p2c(x);\n            y = axisy.p2c(y);\n\n            octx.beginPath();\n            if (series.points.symbol == \"circle\")\n                octx.arc(x, y, radius, 0, 2 * Math.PI, false);\n            else\n                series.points.symbol(octx, x, y, radius, false);\n            octx.closePath();\n            octx.stroke();\n        }\n\n        function drawBarHighlight(series, point) {\n            var highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),\n                fillStyle = highlightColor,\n                barLeft;\n\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -series.bars.barWidth;\n                    break;\n                default:\n                    barLeft = -series.bars.barWidth / 2;\n            }\n\n            octx.lineWidth = series.bars.lineWidth;\n            octx.strokeStyle = highlightColor;\n\n            drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,\n                    function () { return fillStyle; }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);\n        }\n\n        function getColorOrGradient(spec, bottom, top, defaultColor) {\n            if (typeof spec == \"string\")\n                return spec;\n            else {\n                // assume this is a gradient spec; IE currently only\n                // supports a simple vertical gradient properly, so that's\n                // what we support too\n                var gradient = ctx.createLinearGradient(0, top, 0, bottom);\n\n                for (var i = 0, l = spec.colors.length; i < l; ++i) {\n                    var c = spec.colors[i];\n                    if (typeof c != \"string\") {\n                        var co = $.color.parse(defaultColor);\n                        if (c.brightness != null)\n                            co = co.scale('rgb', c.brightness);\n                        if (c.opacity != null)\n                            co.a *= c.opacity;\n                        c = co.toString();\n                    }\n                    gradient.addColorStop(i / (l - 1), c);\n                }\n\n                return gradient;\n            }\n        }\n    }\n\n    // Add the plot function to the top level of the jQuery object\n\n    $.plot = function(placeholder, data, options) {\n        //var t0 = new Date();\n        var plot = new Plot($(placeholder), data, options, $.plot.plugins);\n        //(window.console ? console.log : alert)(\"time used (msecs): \" + ((new Date()).getTime() - t0.getTime()));\n        return plot;\n    };\n\n    $.plot.version = \"0.8.3\";\n\n    $.plot.plugins = [];\n\n    // Also add the plot function as a chainable property\n\n    $.fn.plot = function(data, options) {\n        return this.each(function() {\n            $.plot(this, data, options);\n        });\n    };\n\n    // round to nearby lower multiple of base\n    function floorInBase(n, base) {\n        return base * Math.floor(n / base);\n    }\n\n})(jQuery);\n"]},"hash":"2b0bbf449601e7e0fc8ee63a3a8435b8fb66e969"}

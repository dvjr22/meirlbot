{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/reactive-var.js","filenameRelative":"/bundle/programs/server/packages/reactive-var.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/reactive-var.js.map","sourceFileName":"/bundle/programs/server/packages/reactive-var.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"reactive-var"},"ignored":false,"code":"(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var Tracker = Package.tracker.Tracker;\n  var Deps = Package.tracker.Deps;\n\n  /* Package-scope variables */\n  var _ReactiveVar;\n\n  (function () {\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                              //\n    // packages/reactive-var/reactive-var.js                                                                        //\n    //                                                                                                              //\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    /*\n     * ## [new] ReactiveVar(initialValue, [equalsFunc])\n     *\n     * A ReactiveVar holds a single value that can be get and set,\n     * such that calling `set` will invalidate any Computations that\n     * called `get`, according to the usual contract for reactive\n     * data sources.\n     *\n     * A ReactiveVar is much like a Session variable -- compare `foo.get()`\n     * to `Session.get(\"foo\")` -- but it doesn't have a global name and isn't\n     * automatically migrated across hot code pushes.  Also, while Session\n     * variables can only hold JSON or EJSON, ReactiveVars can hold any value.\n     *\n     * An important property of ReactiveVars, which is sometimes the reason\n     * to use one, is that setting the value to the same value as before has\n     * no effect, meaning ReactiveVars can be used to absorb extra\n     * invalidations that wouldn't serve a purpose.  However, by default,\n     * ReactiveVars are extremely conservative about what changes they\n     * absorb.  Calling `set` with an object argument will *always* trigger\n     * invalidations, because even if the new value is `===` the old value,\n     * the object may have been mutated.  You can change the default behavior\n     * by passing a function of two arguments, `oldValue` and `newValue`,\n     * to the constructor as `equalsFunc`.\n     *\n     * This class is extremely basic right now, but the idea is to evolve\n     * it into the ReactiveVar of Geoff's Lickable Forms proposal.\n     */\n\n    /**\n     * @class \n     * @instanceName reactiveVar\n     * @summary Constructor for a ReactiveVar, which represents a single reactive variable.\n     * @locus Client\n     * @param {Any} initialValue The initial value to set.  `equalsFunc` is ignored when setting the initial value.\n     * @param {Function} [equalsFunc] Optional.  A function of two arguments, called on the old value and the new value whenever the ReactiveVar is set.  If it returns true, no set is performed.  If omitted, the default `equalsFunc` returns true if its arguments are `===` and are of type number, boolean, string, undefined, or null.\n     */\n    _ReactiveVar = function ReactiveVar(initialValue, equalsFunc) {\n      if (!(this instanceof _ReactiveVar))\n        // called without `new`\n        return new _ReactiveVar(initialValue, equalsFunc);\n\n      this.curValue = initialValue;\n      this.equalsFunc = equalsFunc;\n      this.dep = new Tracker.Dependency();\n    };\n\n    _ReactiveVar._isEqual = function (oldValue, newValue) {\n      var a = oldValue,\n          b = newValue;\n      // Two values are \"equal\" here if they are `===` and are\n      // number, boolean, string, undefined, or null.\n      if (a !== b) return false;else return !a || typeof a === 'number' || typeof a === 'boolean' || typeof a === 'string';\n    };\n\n    /**\n     * @summary Returns the current value of the ReactiveVar, establishing a reactive dependency.\n     * @locus Client\n     */\n    _ReactiveVar.prototype.get = function () {\n      if (Tracker.active) this.dep.depend();\n\n      return this.curValue;\n    };\n\n    /**\n     * @summary Sets the current value of the ReactiveVar, invalidating the Computations that called `get` if `newValue` is different from the old value.\n     * @locus Client\n     * @param {Any} newValue\n     */\n    _ReactiveVar.prototype.set = function (newValue) {\n      var oldValue = this.curValue;\n\n      if ((this.equalsFunc || _ReactiveVar._isEqual)(oldValue, newValue))\n        // value is same as last time\n        return;\n\n      this.curValue = newValue;\n      this.dep.changed();\n    };\n\n    _ReactiveVar.prototype.toString = function () {\n      return 'ReactiveVar{' + this.get() + '}';\n    };\n\n    _ReactiveVar.prototype._numListeners = function () {\n      // Tests want to know.\n      // Accesses a private field of Tracker.Dependency.\n      var count = 0;\n      for (var id in this.dep._dependentsById) {\n        count++;\n      }return count;\n    };\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package['reactive-var'] = {}, {\n    ReactiveVar: _ReactiveVar\n  });\n})();\n\n//# sourceMappingURL=reactive-var.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/reactive-var.js"],"names":[],"mappings":"AAAA,CAAC,YAAY;;;AAGb,MAAI,SAAS,QAAQ,MAAR,CAAe,MAA5B;AACA,MAAI,SAAS,QAAQ,MAAR,CAAe,MAA5B;AACA,MAAI,YAAY,QAAQ,MAAR,CAAe,SAA/B;AACA,MAAI,UAAU,QAAQ,OAAR,CAAgB,OAA9B;AACA,MAAI,OAAO,QAAQ,OAAR,CAAgB,IAA3B;;;AAGA,MAAI,YAAJ;;AAEA,GAAC,YAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CX,mBAAc,qBAAU,YAAV,EAAwB,UAAxB,EAAoC;AAChD,UAAI,EAAG,gBAAgB,YAAnB,CAAJ;;AAEE,eAAO,IAAI,YAAJ,CAAgB,YAAhB,EAA8B,UAA9B,CAAP;;AAEF,WAAK,QAAL,GAAgB,YAAhB;AACA,WAAK,UAAL,GAAkB,UAAlB;AACA,WAAK,GAAL,GAAW,IAAI,QAAQ,UAAZ,EAAX;AACD,KARD;;AAUA,iBAAY,QAAZ,GAAuB,UAAU,QAAV,EAAoB,QAApB,EAA8B;AACnD,UAAI,IAAI,QAAR;AAAA,UAAkB,IAAI,QAAtB;;;AAGA,UAAI,MAAM,CAAV,EACE,OAAO,KAAP,CADF,KAGE,OAAS,CAAC,CAAF,IAAS,OAAO,CAAP,KAAa,QAAtB,IAAoC,OAAO,CAAP,KAAa,SAAjD,IACC,OAAO,CAAP,KAAa,QADtB;AAEH,KATD;;;;;;AAeA,iBAAY,SAAZ,CAAsB,GAAtB,GAA4B,YAAY;AACtC,UAAI,QAAQ,MAAZ,EACE,KAAK,GAAL,CAAS,MAAT;;AAEF,aAAO,KAAK,QAAZ;AACD,KALD;;;;;;;AAYA,iBAAY,SAAZ,CAAsB,GAAtB,GAA4B,UAAU,QAAV,EAAoB;AAC9C,UAAI,WAAW,KAAK,QAApB;;AAEA,UAAI,CAAC,KAAK,UAAL,IAAmB,aAAY,QAAhC,EAA0C,QAA1C,EAAoD,QAApD,CAAJ;;AAEE;;AAEF,WAAK,QAAL,GAAgB,QAAhB;AACA,WAAK,GAAL,CAAS,OAAT;AACD,KATD;;AAWA,iBAAY,SAAZ,CAAsB,QAAtB,GAAiC,YAAY;AAC3C,aAAO,iBAAiB,KAAK,GAAL,EAAjB,GAA8B,GAArC;AACD,KAFD;;AAIA,iBAAY,SAAZ,CAAsB,aAAtB,GAAsC,YAAW;;;AAG/C,UAAI,QAAQ,CAAZ;AACA,WAAK,IAAI,EAAT,IAAe,KAAK,GAAL,CAAS,eAAxB;AACE;AADF,OAEA,OAAO,KAAP;AACD,KAPD;;;AAWC,GA3GD,EA2GG,IA3GH,CA2GQ,IA3GR;;;AA+GA,MAAI,OAAO,OAAP,KAAmB,WAAvB,EAAoC,UAAU,EAAV;AACpC,GAAC,UAAU,GAAV,EAAe,OAAf,EAAwB;AACvB,SAAK,IAAI,CAAT,IAAc,OAAd;AACG,WAAK,GAAN,KAAe,IAAI,CAAJ,IAAS,QAAQ,CAAR,CAAxB;AADF;AAED,GAHD,EAGG,QAAQ,cAAR,IAA0B,EAH7B,EAGiC;AAC/B,iBAAa;AADkB,GAHjC;AAOC,CAnID","file":"/bundle/programs/server/packages/reactive-var.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\n\n/* Package-scope variables */\nvar ReactiveVar;\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                              //\n// packages/reactive-var/reactive-var.js                                                                        //\n//                                                                                                              //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                //\n/*\n * ## [new] ReactiveVar(initialValue, [equalsFunc])\n *\n * A ReactiveVar holds a single value that can be get and set,\n * such that calling `set` will invalidate any Computations that\n * called `get`, according to the usual contract for reactive\n * data sources.\n *\n * A ReactiveVar is much like a Session variable -- compare `foo.get()`\n * to `Session.get(\"foo\")` -- but it doesn't have a global name and isn't\n * automatically migrated across hot code pushes.  Also, while Session\n * variables can only hold JSON or EJSON, ReactiveVars can hold any value.\n *\n * An important property of ReactiveVars, which is sometimes the reason\n * to use one, is that setting the value to the same value as before has\n * no effect, meaning ReactiveVars can be used to absorb extra\n * invalidations that wouldn't serve a purpose.  However, by default,\n * ReactiveVars are extremely conservative about what changes they\n * absorb.  Calling `set` with an object argument will *always* trigger\n * invalidations, because even if the new value is `===` the old value,\n * the object may have been mutated.  You can change the default behavior\n * by passing a function of two arguments, `oldValue` and `newValue`,\n * to the constructor as `equalsFunc`.\n *\n * This class is extremely basic right now, but the idea is to evolve\n * it into the ReactiveVar of Geoff's Lickable Forms proposal.\n */\n\n/**\n * @class \n * @instanceName reactiveVar\n * @summary Constructor for a ReactiveVar, which represents a single reactive variable.\n * @locus Client\n * @param {Any} initialValue The initial value to set.  `equalsFunc` is ignored when setting the initial value.\n * @param {Function} [equalsFunc] Optional.  A function of two arguments, called on the old value and the new value whenever the ReactiveVar is set.  If it returns true, no set is performed.  If omitted, the default `equalsFunc` returns true if its arguments are `===` and are of type number, boolean, string, undefined, or null.\n */\nReactiveVar = function (initialValue, equalsFunc) {\n  if (! (this instanceof ReactiveVar))\n    // called without `new`\n    return new ReactiveVar(initialValue, equalsFunc);\n\n  this.curValue = initialValue;\n  this.equalsFunc = equalsFunc;\n  this.dep = new Tracker.Dependency;\n};\n\nReactiveVar._isEqual = function (oldValue, newValue) {\n  var a = oldValue, b = newValue;\n  // Two values are \"equal\" here if they are `===` and are\n  // number, boolean, string, undefined, or null.\n  if (a !== b)\n    return false;\n  else\n    return ((!a) || (typeof a === 'number') || (typeof a === 'boolean') ||\n            (typeof a === 'string'));\n};\n\n/**\n * @summary Returns the current value of the ReactiveVar, establishing a reactive dependency.\n * @locus Client\n */\nReactiveVar.prototype.get = function () {\n  if (Tracker.active)\n    this.dep.depend();\n\n  return this.curValue;\n};\n\n/**\n * @summary Sets the current value of the ReactiveVar, invalidating the Computations that called `get` if `newValue` is different from the old value.\n * @locus Client\n * @param {Any} newValue\n */\nReactiveVar.prototype.set = function (newValue) {\n  var oldValue = this.curValue;\n\n  if ((this.equalsFunc || ReactiveVar._isEqual)(oldValue, newValue))\n    // value is same as last time\n    return;\n\n  this.curValue = newValue;\n  this.dep.changed();\n};\n\nReactiveVar.prototype.toString = function () {\n  return 'ReactiveVar{' + this.get() + '}';\n};\n\nReactiveVar.prototype._numListeners = function() {\n  // Tests want to know.\n  // Accesses a private field of Tracker.Dependency.\n  var count = 0;\n  for (var id in this.dep._dependentsById)\n    count++;\n  return count;\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['reactive-var'] = {}, {\n  ReactiveVar: ReactiveVar\n});\n\n})();\n\n//# sourceMappingURL=reactive-var.js.map\n"]},"hash":"1fd3560714eeb6162368a3a20dd4d9d2a0fa572b"}

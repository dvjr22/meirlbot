{"metadata":{"usedHelpers":["typeof"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/observe-sequence.js","filenameRelative":"/bundle/programs/server/packages/observe-sequence.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/observe-sequence.js.map","sourceFileName":"/bundle/programs/server/packages/observe-sequence.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"observe-sequence"},"ignored":false,"code":"var _typeof;module.import('babel-runtime/helpers/typeof',{\"default\":function(v){_typeof=v}});\n(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var Tracker = Package.tracker.Tracker;\n  var Deps = Package.tracker.Deps;\n  var MongoID = Package['mongo-id'].MongoID;\n  var DiffSequence = Package['diff-sequence'].DiffSequence;\n  var _ = Package.underscore._;\n  var Random = Package.random.Random;\n\n  /* Package-scope variables */\n  var ObserveSequence, seqChangedToEmpty, seqChangedToArray, seqChangedToCursor;\n\n  (function () {\n\n    ///////////////////////////////////////////////////////////////////////////////////\n    //                                                                               //\n    // packages/observe-sequence/observe_sequence.js                                 //\n    //                                                                               //\n    ///////////////////////////////////////////////////////////////////////////////////\n    //\n    var warn = function warn() {\n      if (ObserveSequence._suppressWarnings) {\n        ObserveSequence._suppressWarnings--;\n      } else {\n        if (typeof console !== 'undefined' && console.warn) console.warn.apply(console, arguments);\n\n        ObserveSequence._loggedWarnings++;\n      }\n    };\n\n    var idStringify = MongoID.idStringify;\n    var idParse = MongoID.idParse;\n\n    ObserveSequence = {\n      _suppressWarnings: 0,\n      _loggedWarnings: 0,\n\n      // A mechanism similar to cursor.observe which receives a reactive\n      // function returning a sequence type and firing appropriate callbacks\n      // when the value changes.\n      //\n      // @param sequenceFunc {Function} a reactive function returning a\n      //     sequence type. The currently supported sequence types are:\n      //     Array, Cursor, and null.\n      //\n      // @param callbacks {Object} similar to a specific subset of\n      //     callbacks passed to `cursor.observe`\n      //     (http://docs.meteor.com/#observe), with minor variations to\n      //     support the fact that not all sequences contain objects with\n      //     _id fields.  Specifically:\n      //\n      //     * addedAt(id, item, atIndex, beforeId)\n      //     * changedAt(id, newItem, oldItem, atIndex)\n      //     * removedAt(id, oldItem, atIndex)\n      //     * movedTo(id, item, fromIndex, toIndex, beforeId)\n      //\n      // @returns {Object(stop: Function)} call 'stop' on the return value\n      //     to stop observing this sequence function.\n      //\n      // We don't make any assumptions about our ability to compare sequence\n      // elements (ie, we don't assume EJSON.equals works; maybe there is extra\n      // state/random methods on the objects) so unlike cursor.observe, we may\n      // sometimes call changedAt() when nothing actually changed.\n      // XXX consider if we *can* make the stronger assumption and avoid\n      //     no-op changedAt calls (in some cases?)\n      //\n      // XXX currently only supports the callbacks used by our\n      // implementation of {{#each}}, but this can be expanded.\n      //\n      // XXX #each doesn't use the indices (though we'll eventually need\n      // a way to get them when we support `@index`), but calling\n      // `cursor.observe` causes the index to be calculated on every\n      // callback using a linear scan (unless you turn it off by passing\n      // `_no_indices`).  Any way to avoid calculating indices on a pure\n      // cursor observe like we used to?\n      observe: function observe(sequenceFunc, callbacks) {\n        var lastSeq = null;\n        var activeObserveHandle = null;\n\n        // 'lastSeqArray' contains the previous value of the sequence\n        // we're observing. It is an array of objects with '_id' and\n        // 'item' fields.  'item' is the element in the array, or the\n        // document in the cursor.\n        //\n        // '_id' is whichever of the following is relevant, unless it has\n        // already appeared -- in which case it's randomly generated.\n        //\n        // * if 'item' is an object:\n        //   * an '_id' field, if present\n        //   * otherwise, the index in the array\n        //\n        // * if 'item' is a number or string, use that value\n        //\n        // XXX this can be generalized by allowing {{#each}} to accept a\n        // general 'key' argument which could be a function, a dotted\n        // field name, or the special @index value.\n        var lastSeqArray = []; // elements are objects of form {_id, item}\n        var computation = Tracker.autorun(function () {\n          var seq = sequenceFunc();\n\n          Tracker.nonreactive(function () {\n            var seqArray; // same structure as `lastSeqArray` above.\n\n            if (activeObserveHandle) {\n              // If we were previously observing a cursor, replace lastSeqArray with\n              // more up-to-date information.  Then stop the old observe.\n              lastSeqArray = _.map(lastSeq.fetch(), function (doc) {\n                return { _id: doc._id, item: doc };\n              });\n              activeObserveHandle.stop();\n              activeObserveHandle = null;\n            }\n\n            if (!seq) {\n              seqArray = seqChangedToEmpty(lastSeqArray, callbacks);\n            } else if (seq instanceof Array) {\n              seqArray = seqChangedToArray(lastSeqArray, seq, callbacks);\n            } else if (isStoreCursor(seq)) {\n              var result /* [seqArray, activeObserveHandle] */ = seqChangedToCursor(lastSeqArray, seq, callbacks);\n              seqArray = result[0];\n              activeObserveHandle = result[1];\n            } else {\n              throw badSequenceError();\n            }\n\n            diffArray(lastSeqArray, seqArray, callbacks);\n            lastSeq = seq;\n            lastSeqArray = seqArray;\n          });\n        });\n\n        return {\n          stop: function stop() {\n            computation.stop();\n            if (activeObserveHandle) activeObserveHandle.stop();\n          }\n        };\n      },\n\n      // Fetch the items of `seq` into an array, where `seq` is of one of the\n      // sequence types accepted by `observe`.  If `seq` is a cursor, a\n      // dependency is established.\n      fetch: function fetch(seq) {\n        if (!seq) {\n          return [];\n        } else if (seq instanceof Array) {\n          return seq;\n        } else if (isStoreCursor(seq)) {\n          return seq.fetch();\n        } else {\n          throw badSequenceError();\n        }\n      }\n    };\n\n    var badSequenceError = function badSequenceError() {\n      return new Error(\"{{#each}} currently only accepts \" + \"arrays, cursors or falsey values.\");\n    };\n\n    var isStoreCursor = function isStoreCursor(cursor) {\n      return cursor && _.isObject(cursor) && _.isFunction(cursor.observe) && _.isFunction(cursor.fetch);\n    };\n\n    // Calculates the differences between `lastSeqArray` and\n    // `seqArray` and calls appropriate functions from `callbacks`.\n    // Reuses Minimongo's diff algorithm implementation.\n    var diffArray = function diffArray(lastSeqArray, seqArray, callbacks) {\n      var diffFn = Package['diff-sequence'].DiffSequence.diffQueryOrderedChanges;\n      var oldIdObjects = [];\n      var newIdObjects = [];\n      var posOld = {}; // maps from idStringify'd ids\n      var posNew = {}; // ditto\n      var posCur = {};\n      var lengthCur = lastSeqArray.length;\n\n      _.each(seqArray, function (doc, i) {\n        newIdObjects.push({ _id: doc._id });\n        posNew[idStringify(doc._id)] = i;\n      });\n      _.each(lastSeqArray, function (doc, i) {\n        oldIdObjects.push({ _id: doc._id });\n        posOld[idStringify(doc._id)] = i;\n        posCur[idStringify(doc._id)] = i;\n      });\n\n      // Arrays can contain arbitrary objects. We don't diff the\n      // objects. Instead we always fire 'changedAt' callback on every\n      // object. The consumer of `observe-sequence` should deal with\n      // it appropriately.\n      diffFn(oldIdObjects, newIdObjects, {\n        addedBefore: function addedBefore(id, doc, before) {\n          var position = before ? posCur[idStringify(before)] : lengthCur;\n\n          if (before) {\n            // If not adding at the end, we need to update indexes.\n            // XXX this can still be improved greatly!\n            _.each(posCur, function (pos, id) {\n              if (pos >= position) posCur[id]++;\n            });\n          }\n\n          lengthCur++;\n          posCur[idStringify(id)] = position;\n\n          callbacks.addedAt(id, seqArray[posNew[idStringify(id)]].item, position, before);\n        },\n        movedBefore: function movedBefore(id, before) {\n          if (id === before) return;\n\n          var oldPosition = posCur[idStringify(id)];\n          var newPosition = before ? posCur[idStringify(before)] : lengthCur;\n\n          // Moving the item forward. The new element is losing one position as it\n          // was removed from the old position before being inserted at the new\n          // position.\n          // Ex.:   0  *1*  2   3   4\n          //        0   2   3  *1*  4\n          // The original issued callback is \"1\" before \"4\".\n          // The position of \"1\" is 1, the position of \"4\" is 4.\n          // The generated move is (1) -> (3)\n          if (newPosition > oldPosition) {\n            newPosition--;\n          }\n\n          // Fix up the positions of elements between the old and the new positions\n          // of the moved element.\n          //\n          // There are two cases:\n          //   1. The element is moved forward. Then all the positions in between\n          //   are moved back.\n          //   2. The element is moved back. Then the positions in between *and* the\n          //   element that is currently standing on the moved element's future\n          //   position are moved forward.\n          _.each(posCur, function (elCurPosition, id) {\n            if (oldPosition < elCurPosition && elCurPosition < newPosition) posCur[id]--;else if (newPosition <= elCurPosition && elCurPosition < oldPosition) posCur[id]++;\n          });\n\n          // Finally, update the position of the moved element.\n          posCur[idStringify(id)] = newPosition;\n\n          callbacks.movedTo(id, seqArray[posNew[idStringify(id)]].item, oldPosition, newPosition, before);\n        },\n        removed: function removed(id) {\n          var prevPosition = posCur[idStringify(id)];\n\n          _.each(posCur, function (pos, id) {\n            if (pos >= prevPosition) posCur[id]--;\n          });\n\n          delete posCur[idStringify(id)];\n          lengthCur--;\n\n          callbacks.removedAt(id, lastSeqArray[posOld[idStringify(id)]].item, prevPosition);\n        }\n      });\n\n      _.each(posNew, function (pos, idString) {\n        var id = idParse(idString);\n        if (_.has(posOld, idString)) {\n          // specifically for primitive types, compare equality before\n          // firing the 'changedAt' callback. otherwise, always fire it\n          // because doing a deep EJSON comparison is not guaranteed to\n          // work (an array can contain arbitrary objects, and 'transform'\n          // can be used on cursors). also, deep diffing is not\n          // necessarily the most efficient (if only a specific subfield\n          // of the object is later accessed).\n          var newItem = seqArray[pos].item;\n          var oldItem = lastSeqArray[posOld[idString]].item;\n\n          if ((typeof newItem === 'undefined' ? 'undefined' : _typeof(newItem)) === 'object' || newItem !== oldItem) callbacks.changedAt(id, newItem, oldItem, pos);\n        }\n      });\n    };\n\n    seqChangedToEmpty = function seqChangedToEmpty(lastSeqArray, callbacks) {\n      return [];\n    };\n\n    seqChangedToArray = function seqChangedToArray(lastSeqArray, array, callbacks) {\n      var idsUsed = {};\n      var seqArray = _.map(array, function (item, index) {\n        var id;\n        if (typeof item === 'string') {\n          // ensure not empty, since other layers (eg DomRange) assume this as well\n          id = \"-\" + item;\n        } else if (typeof item === 'number' || typeof item === 'boolean' || item === undefined) {\n          id = item;\n        } else if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {\n          id = item && '_id' in item ? item._id : index;\n        } else {\n          throw new Error(\"{{#each}} doesn't support arrays with \" + \"elements of type \" + (typeof item === 'undefined' ? 'undefined' : _typeof(item)));\n        }\n\n        var idString = idStringify(id);\n        if (idsUsed[idString]) {\n          if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object' && '_id' in item) warn(\"duplicate id \" + id + \" in\", array);\n          id = Random.id();\n        } else {\n          idsUsed[idString] = true;\n        }\n\n        return { _id: id, item: item };\n      });\n\n      return seqArray;\n    };\n\n    seqChangedToCursor = function seqChangedToCursor(lastSeqArray, cursor, callbacks) {\n      var initial = true; // are we observing initial data from cursor?\n      var seqArray = [];\n\n      var observeHandle = cursor.observe({\n        addedAt: function addedAt(document, atIndex, before) {\n          if (initial) {\n            // keep track of initial data so that we can diff once\n            // we exit `observe`.\n            if (before !== null) throw new Error(\"Expected initial data from observe in order\");\n            seqArray.push({ _id: document._id, item: document });\n          } else {\n            callbacks.addedAt(document._id, document, atIndex, before);\n          }\n        },\n        changedAt: function changedAt(newDocument, oldDocument, atIndex) {\n          callbacks.changedAt(newDocument._id, newDocument, oldDocument, atIndex);\n        },\n        removedAt: function removedAt(oldDocument, atIndex) {\n          callbacks.removedAt(oldDocument._id, oldDocument, atIndex);\n        },\n        movedTo: function movedTo(document, fromIndex, toIndex, before) {\n          callbacks.movedTo(document._id, document, fromIndex, toIndex, before);\n        }\n      });\n      initial = false;\n\n      return [seqArray, observeHandle];\n    };\n\n    ///////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package['observe-sequence'] = {}, {\n    ObserveSequence: ObserveSequence\n  });\n})();\n\n//# sourceMappingURL=observe-sequence.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/observe-sequence.js"],"names":[],"mappings":"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","file":"/bundle/programs/server/packages/observe-sequence.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar MongoID = Package['mongo-id'].MongoID;\nvar DiffSequence = Package['diff-sequence'].DiffSequence;\nvar _ = Package.underscore._;\nvar Random = Package.random.Random;\n\n/* Package-scope variables */\nvar ObserveSequence, seqChangedToEmpty, seqChangedToArray, seqChangedToCursor;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////\n//                                                                               //\n// packages/observe-sequence/observe_sequence.js                                 //\n//                                                                               //\n///////////////////////////////////////////////////////////////////////////////////\n                                                                                 //\nvar warn = function () {\n  if (ObserveSequence._suppressWarnings) {\n    ObserveSequence._suppressWarnings--;\n  } else {\n    if (typeof console !== 'undefined' && console.warn)\n      console.warn.apply(console, arguments);\n\n    ObserveSequence._loggedWarnings++;\n  }\n};\n\nvar idStringify = MongoID.idStringify;\nvar idParse = MongoID.idParse;\n\nObserveSequence = {\n  _suppressWarnings: 0,\n  _loggedWarnings: 0,\n\n  // A mechanism similar to cursor.observe which receives a reactive\n  // function returning a sequence type and firing appropriate callbacks\n  // when the value changes.\n  //\n  // @param sequenceFunc {Function} a reactive function returning a\n  //     sequence type. The currently supported sequence types are:\n  //     Array, Cursor, and null.\n  //\n  // @param callbacks {Object} similar to a specific subset of\n  //     callbacks passed to `cursor.observe`\n  //     (http://docs.meteor.com/#observe), with minor variations to\n  //     support the fact that not all sequences contain objects with\n  //     _id fields.  Specifically:\n  //\n  //     * addedAt(id, item, atIndex, beforeId)\n  //     * changedAt(id, newItem, oldItem, atIndex)\n  //     * removedAt(id, oldItem, atIndex)\n  //     * movedTo(id, item, fromIndex, toIndex, beforeId)\n  //\n  // @returns {Object(stop: Function)} call 'stop' on the return value\n  //     to stop observing this sequence function.\n  //\n  // We don't make any assumptions about our ability to compare sequence\n  // elements (ie, we don't assume EJSON.equals works; maybe there is extra\n  // state/random methods on the objects) so unlike cursor.observe, we may\n  // sometimes call changedAt() when nothing actually changed.\n  // XXX consider if we *can* make the stronger assumption and avoid\n  //     no-op changedAt calls (in some cases?)\n  //\n  // XXX currently only supports the callbacks used by our\n  // implementation of {{#each}}, but this can be expanded.\n  //\n  // XXX #each doesn't use the indices (though we'll eventually need\n  // a way to get them when we support `@index`), but calling\n  // `cursor.observe` causes the index to be calculated on every\n  // callback using a linear scan (unless you turn it off by passing\n  // `_no_indices`).  Any way to avoid calculating indices on a pure\n  // cursor observe like we used to?\n  observe: function (sequenceFunc, callbacks) {\n    var lastSeq = null;\n    var activeObserveHandle = null;\n\n    // 'lastSeqArray' contains the previous value of the sequence\n    // we're observing. It is an array of objects with '_id' and\n    // 'item' fields.  'item' is the element in the array, or the\n    // document in the cursor.\n    //\n    // '_id' is whichever of the following is relevant, unless it has\n    // already appeared -- in which case it's randomly generated.\n    //\n    // * if 'item' is an object:\n    //   * an '_id' field, if present\n    //   * otherwise, the index in the array\n    //\n    // * if 'item' is a number or string, use that value\n    //\n    // XXX this can be generalized by allowing {{#each}} to accept a\n    // general 'key' argument which could be a function, a dotted\n    // field name, or the special @index value.\n    var lastSeqArray = []; // elements are objects of form {_id, item}\n    var computation = Tracker.autorun(function () {\n      var seq = sequenceFunc();\n\n      Tracker.nonreactive(function () {\n        var seqArray; // same structure as `lastSeqArray` above.\n\n        if (activeObserveHandle) {\n          // If we were previously observing a cursor, replace lastSeqArray with\n          // more up-to-date information.  Then stop the old observe.\n          lastSeqArray = _.map(lastSeq.fetch(), function (doc) {\n            return {_id: doc._id, item: doc};\n          });\n          activeObserveHandle.stop();\n          activeObserveHandle = null;\n        }\n\n        if (!seq) {\n          seqArray = seqChangedToEmpty(lastSeqArray, callbacks);\n        } else if (seq instanceof Array) {\n          seqArray = seqChangedToArray(lastSeqArray, seq, callbacks);\n        } else if (isStoreCursor(seq)) {\n          var result /* [seqArray, activeObserveHandle] */ =\n                seqChangedToCursor(lastSeqArray, seq, callbacks);\n          seqArray = result[0];\n          activeObserveHandle = result[1];\n        } else {\n          throw badSequenceError();\n        }\n\n        diffArray(lastSeqArray, seqArray, callbacks);\n        lastSeq = seq;\n        lastSeqArray = seqArray;\n      });\n    });\n\n    return {\n      stop: function () {\n        computation.stop();\n        if (activeObserveHandle)\n          activeObserveHandle.stop();\n      }\n    };\n  },\n\n  // Fetch the items of `seq` into an array, where `seq` is of one of the\n  // sequence types accepted by `observe`.  If `seq` is a cursor, a\n  // dependency is established.\n  fetch: function (seq) {\n    if (!seq) {\n      return [];\n    } else if (seq instanceof Array) {\n      return seq;\n    } else if (isStoreCursor(seq)) {\n      return seq.fetch();\n    } else {\n      throw badSequenceError();\n    }\n  }\n};\n\nvar badSequenceError = function () {\n  return new Error(\"{{#each}} currently only accepts \" +\n                   \"arrays, cursors or falsey values.\");\n};\n\nvar isStoreCursor = function (cursor) {\n  return cursor && _.isObject(cursor) &&\n    _.isFunction(cursor.observe) && _.isFunction(cursor.fetch);\n};\n\n// Calculates the differences between `lastSeqArray` and\n// `seqArray` and calls appropriate functions from `callbacks`.\n// Reuses Minimongo's diff algorithm implementation.\nvar diffArray = function (lastSeqArray, seqArray, callbacks) {\n  var diffFn = Package['diff-sequence'].DiffSequence.diffQueryOrderedChanges;\n  var oldIdObjects = [];\n  var newIdObjects = [];\n  var posOld = {}; // maps from idStringify'd ids\n  var posNew = {}; // ditto\n  var posCur = {};\n  var lengthCur = lastSeqArray.length;\n\n  _.each(seqArray, function (doc, i) {\n    newIdObjects.push({_id: doc._id});\n    posNew[idStringify(doc._id)] = i;\n  });\n  _.each(lastSeqArray, function (doc, i) {\n    oldIdObjects.push({_id: doc._id});\n    posOld[idStringify(doc._id)] = i;\n    posCur[idStringify(doc._id)] = i;\n  });\n\n  // Arrays can contain arbitrary objects. We don't diff the\n  // objects. Instead we always fire 'changedAt' callback on every\n  // object. The consumer of `observe-sequence` should deal with\n  // it appropriately.\n  diffFn(oldIdObjects, newIdObjects, {\n    addedBefore: function (id, doc, before) {\n      var position = before ? posCur[idStringify(before)] : lengthCur;\n\n      if (before) {\n        // If not adding at the end, we need to update indexes.\n        // XXX this can still be improved greatly!\n        _.each(posCur, function (pos, id) {\n          if (pos >= position)\n            posCur[id]++;\n        });\n      }\n\n      lengthCur++;\n      posCur[idStringify(id)] = position;\n\n      callbacks.addedAt(\n        id,\n        seqArray[posNew[idStringify(id)]].item,\n        position,\n        before);\n    },\n    movedBefore: function (id, before) {\n      if (id === before)\n        return;\n\n      var oldPosition = posCur[idStringify(id)];\n      var newPosition = before ? posCur[idStringify(before)] : lengthCur;\n\n      // Moving the item forward. The new element is losing one position as it\n      // was removed from the old position before being inserted at the new\n      // position.\n      // Ex.:   0  *1*  2   3   4\n      //        0   2   3  *1*  4\n      // The original issued callback is \"1\" before \"4\".\n      // The position of \"1\" is 1, the position of \"4\" is 4.\n      // The generated move is (1) -> (3)\n      if (newPosition > oldPosition) {\n        newPosition--;\n      }\n\n      // Fix up the positions of elements between the old and the new positions\n      // of the moved element.\n      //\n      // There are two cases:\n      //   1. The element is moved forward. Then all the positions in between\n      //   are moved back.\n      //   2. The element is moved back. Then the positions in between *and* the\n      //   element that is currently standing on the moved element's future\n      //   position are moved forward.\n      _.each(posCur, function (elCurPosition, id) {\n        if (oldPosition < elCurPosition && elCurPosition < newPosition)\n          posCur[id]--;\n        else if (newPosition <= elCurPosition && elCurPosition < oldPosition)\n          posCur[id]++;\n      });\n\n      // Finally, update the position of the moved element.\n      posCur[idStringify(id)] = newPosition;\n\n      callbacks.movedTo(\n        id,\n        seqArray[posNew[idStringify(id)]].item,\n        oldPosition,\n        newPosition,\n        before);\n    },\n    removed: function (id) {\n      var prevPosition = posCur[idStringify(id)];\n\n      _.each(posCur, function (pos, id) {\n        if (pos >= prevPosition)\n          posCur[id]--;\n      });\n\n      delete posCur[idStringify(id)];\n      lengthCur--;\n\n      callbacks.removedAt(\n        id,\n        lastSeqArray[posOld[idStringify(id)]].item,\n        prevPosition);\n    }\n  });\n\n  _.each(posNew, function (pos, idString) {\n    var id = idParse(idString);\n    if (_.has(posOld, idString)) {\n      // specifically for primitive types, compare equality before\n      // firing the 'changedAt' callback. otherwise, always fire it\n      // because doing a deep EJSON comparison is not guaranteed to\n      // work (an array can contain arbitrary objects, and 'transform'\n      // can be used on cursors). also, deep diffing is not\n      // necessarily the most efficient (if only a specific subfield\n      // of the object is later accessed).\n      var newItem = seqArray[pos].item;\n      var oldItem = lastSeqArray[posOld[idString]].item;\n\n      if (typeof newItem === 'object' || newItem !== oldItem)\n          callbacks.changedAt(id, newItem, oldItem, pos);\n      }\n  });\n};\n\nseqChangedToEmpty = function (lastSeqArray, callbacks) {\n  return [];\n};\n\nseqChangedToArray = function (lastSeqArray, array, callbacks) {\n  var idsUsed = {};\n  var seqArray = _.map(array, function (item, index) {\n    var id;\n    if (typeof item === 'string') {\n      // ensure not empty, since other layers (eg DomRange) assume this as well\n      id = \"-\" + item;\n    } else if (typeof item === 'number' ||\n               typeof item === 'boolean' ||\n               item === undefined) {\n      id = item;\n    } else if (typeof item === 'object') {\n      id = (item && ('_id' in item)) ? item._id : index;\n    } else {\n      throw new Error(\"{{#each}} doesn't support arrays with \" +\n                      \"elements of type \" + typeof item);\n    }\n\n    var idString = idStringify(id);\n    if (idsUsed[idString]) {\n      if (typeof item === 'object' && '_id' in item)\n        warn(\"duplicate id \" + id + \" in\", array);\n      id = Random.id();\n    } else {\n      idsUsed[idString] = true;\n    }\n\n    return { _id: id, item: item };\n  });\n\n  return seqArray;\n};\n\nseqChangedToCursor = function (lastSeqArray, cursor, callbacks) {\n  var initial = true; // are we observing initial data from cursor?\n  var seqArray = [];\n\n  var observeHandle = cursor.observe({\n    addedAt: function (document, atIndex, before) {\n      if (initial) {\n        // keep track of initial data so that we can diff once\n        // we exit `observe`.\n        if (before !== null)\n          throw new Error(\"Expected initial data from observe in order\");\n        seqArray.push({ _id: document._id, item: document });\n      } else {\n        callbacks.addedAt(document._id, document, atIndex, before);\n      }\n    },\n    changedAt: function (newDocument, oldDocument, atIndex) {\n      callbacks.changedAt(newDocument._id, newDocument, oldDocument,\n                          atIndex);\n    },\n    removedAt: function (oldDocument, atIndex) {\n      callbacks.removedAt(oldDocument._id, oldDocument, atIndex);\n    },\n    movedTo: function (document, fromIndex, toIndex, before) {\n      callbacks.movedTo(\n        document._id, document, fromIndex, toIndex, before);\n    }\n  });\n  initial = false;\n\n  return [seqArray, observeHandle];\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['observe-sequence'] = {}, {\n  ObserveSequence: ObserveSequence\n});\n\n})();\n\n//# sourceMappingURL=observe-sequence.js.map\n"]},"hash":"ff8d4a4c08b4cd7d6d9622585289391e0849cea8"}

{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/ddp-server.js","filenameRelative":"/bundle/programs/server/packages/ddp-server.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/ddp-server.js.map","sourceFileName":"/bundle/programs/server/packages/ddp-server.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"ddp-server"},"ignored":false,"code":"(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var check = Package.check.check;\n  var Match = Package.check.Match;\n  var Random = Package.random.Random;\n  var EJSON = Package.ejson.EJSON;\n  var _ = Package.underscore._;\n  var Retry = Package.retry.Retry;\n  var MongoID = Package['mongo-id'].MongoID;\n  var DiffSequence = Package['diff-sequence'].DiffSequence;\n  var ECMAScript = Package.ecmascript.ECMAScript;\n  var DDPCommon = Package['ddp-common'].DDPCommon;\n  var DDP = Package['ddp-client'].DDP;\n  var WebApp = Package.webapp.WebApp;\n  var main = Package.webapp.main;\n  var WebAppInternals = Package.webapp.WebAppInternals;\n  var RoutePolicy = Package.routepolicy.RoutePolicy;\n  var Hook = Package['callback-hook'].Hook;\n  var LocalCollection = Package.minimongo.LocalCollection;\n  var Minimongo = Package.minimongo.Minimongo;\n  var meteorInstall = Package.modules.meteorInstall;\n  var Buffer = Package.modules.Buffer;\n  var process = Package.modules.process;\n  var _Symbol = Package['ecmascript-runtime'].Symbol;\n  var Map = Package['ecmascript-runtime'].Map;\n  var Set = Package['ecmascript-runtime'].Set;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n\n  /* Package-scope variables */\n  var StreamServer, DDPServer, Server;\n\n  var require = meteorInstall({ \"node_modules\": { \"meteor\": { \"ddp-server\": { \"stream_server.js\": function stream_serverJs(require) {\n\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/ddp-server/stream_server.js                                                                               //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            var url = Npm.require('url'); // 1\n            //\n            // By default, we use the permessage-deflate extension with default                                                   //\n            // configuration. If $SERVER_WEBSOCKET_COMPRESSION is set, then it must be valid                                      //\n            // JSON. If it represents a falsey value, then we do not use permessage-deflate                                       //\n            // at all; otherwise, the JSON value is used as an argument to deflate's                                              //\n            // configure method; see                                                                                              //\n            // https://github.com/faye/permessage-deflate-node/blob/master/README.md                                              //\n            //                                                                                                                    //\n            // (We do this in an _.once instead of at startup, because we don't want to                                           //\n            // crash the tool during isopacket load if your JSON doesn't parse. This is only                                      //\n            // a problem because the tool has to load the DDP server code just in order to                                        //\n            // be a DDP client; see https://github.com/meteor/meteor/issues/3452 .)                                               //\n            var websocketExtensions = _.once(function () {\n              // 14\n              var extensions = []; // 15\n              //\n              var websocketCompressionConfig = process.env.SERVER_WEBSOCKET_COMPRESSION ? JSON.parse(process.env.SERVER_WEBSOCKET_COMPRESSION) : {};\n              if (websocketCompressionConfig) {\n                // 19\n                extensions.push(Npm.require('permessage-deflate').configure(websocketCompressionConfig)); // 20\n              } // 23\n              //\n              return extensions; // 25\n            }); // 26\n            //\n            var pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || \"\"; // 28\n            //\n            StreamServer = function StreamServer() {\n              // 30\n              var self = this; // 31\n              self.registration_callbacks = []; // 32\n              self.open_sockets = []; // 33\n              //\n              // Because we are installing directly onto WebApp.httpServer instead of using                                       //\n              // WebApp.app, we have to process the path prefix ourselves.                                                        //\n              self.prefix = pathPrefix + '/sockjs'; // 37\n              RoutePolicy.declare(self.prefix + '/', 'network'); // 38\n              //\n              // set up sockjs                                                                                                    //\n              var sockjs = Npm.require('sockjs'); // 41\n              var serverOptions = { // 42\n                prefix: self.prefix, // 43\n                log: function log() {}, // 44\n                // this is the default, but we code it explicitly because we depend                                               //\n                // on it in stream_client:HEARTBEAT_TIMEOUT                                                                       //\n                heartbeat_delay: 45000, // 47\n                // The default disconnect_delay is 5 seconds, but if the server ends up CPU                                       //\n                // bound for that much time, SockJS might not notice that the user has                                            //\n                // reconnected because the timer (of disconnect_delay ms) can fire before                                         //\n                // SockJS processes the new connection. Eventually we'll fix this by not                                          //\n                // combining CPU-heavy processing with SockJS termination (eg a proxy which                                       //\n                // converts to Unix sockets) but for now, raise the delay.                                                        //\n                disconnect_delay: 60 * 1000, // 54\n                // Set the USE_JSESSIONID environment variable to enable setting the                                              //\n                // JSESSIONID cookie. This is useful for setting up proxies with                                                  //\n                // session affinity.                                                                                              //\n                jsessionid: !!process.env.USE_JSESSIONID // 58\n              }; // 42\n              //\n              // If you know your server environment (eg, proxies) will prevent websockets                                        //\n              // from ever working, set $DISABLE_WEBSOCKETS and SockJS clients (ie,                                               //\n              // browsers) will not waste time attempting to use them.                                                            //\n              // (Your server will still have a /websocket endpoint.)                                                             //\n              if (process.env.DISABLE_WEBSOCKETS) {\n                // 65\n                serverOptions.websocket = false; // 66\n              } else {\n                  // 67\n                  serverOptions.faye_server_options = { // 68\n                    extensions: websocketExtensions() // 69\n                  }; // 68\n                } // 71\n              //\n              self.server = sockjs.createServer(serverOptions); // 73\n              //\n              // Install the sockjs handlers, but we want to keep around our own particular                                       //\n              // request handler that adjusts idle timeouts while we have an outstanding                                          //\n              // request.  This compensates for the fact that sockjs removes all listeners                                        //\n              // for \"request\" to add its own.                                                                                    //\n              WebApp.httpServer.removeListener('request', WebApp._timeoutAdjustmentRequestCallback); // 79\n              self.server.installHandlers(WebApp.httpServer); // 81\n              WebApp.httpServer.addListener('request', WebApp._timeoutAdjustmentRequestCallback); // 82\n              //\n              // Support the /websocket endpoint                                                                                  //\n              self._redirectWebsocketEndpoint(); // 86\n              //\n              self.server.on('connection', function (socket) {\n                // 88\n                socket.send = function (data) {\n                  // 89\n                  socket.write(data); // 90\n                }; // 91\n                socket.on('close', function () {\n                  // 92\n                  self.open_sockets = _.without(self.open_sockets, socket); // 93\n                }); // 94\n                self.open_sockets.push(socket); // 95\n                //\n                // XXX COMPAT WITH 0.6.6. Send the old style welcome message, which                                               //\n                // will force old clients to reload. Remove this once we're not                                                   //\n                // concerned about people upgrading from a pre-0.7.0 release. Also,                                               //\n                // remove the clause in the client that ignores the welcome message                                               //\n                // (livedata_connection.js)                                                                                       //\n                socket.send(JSON.stringify({ server_id: \"0\" })); // 102\n                //\n                // call all our callbacks when we get a new socket. they will do the                                              //\n                // work of setting up handlers and such for specific messages.                                                    //\n                _.each(self.registration_callbacks, function (callback) {\n                  // 106\n                  callback(socket); // 107\n                }); // 108\n              }); // 109\n            }; // 111\n            //\n            _.extend(StreamServer.prototype, { // 113\n              // call my callback when a new socket connects.                                                                     //\n              // also call it for all current connections.                                                                        //\n              register: function register(callback) {\n                // 116\n                var self = this; // 117\n                self.registration_callbacks.push(callback); // 118\n                _.each(self.all_sockets(), function (socket) {\n                  // 119\n                  callback(socket); // 120\n                }); // 121\n              }, // 122\n              //\n              // get a list of all sockets                                                                                        //\n              all_sockets: function all_sockets() {\n                // 125\n                var self = this; // 126\n                return _.values(self.open_sockets); // 127\n              }, // 128\n              //\n              // Redirect /websocket to /sockjs/websocket in order to not expose                                                  //\n              // sockjs to clients that want to use raw websockets                                                                //\n              _redirectWebsocketEndpoint: function _redirectWebsocketEndpoint() {\n                // 132\n                var self = this; // 133\n                // Unfortunately we can't use a connect middleware here since                                                     //\n                // sockjs installs itself prior to all existing listeners                                                         //\n                // (meaning prior to any connect middlewares) so we need to take                                                  //\n                // an approach similar to overshadowListeners in                                                                  //\n                // https://github.com/sockjs/sockjs-node/blob/cf820c55af6a9953e16558555a31decea554f70e/src/utils.coffee           //\n                _.each(['request', 'upgrade'], function (event) {\n                  // 139\n                  var httpServer = WebApp.httpServer; // 140\n                  var oldHttpServerListeners = httpServer.listeners(event).slice(0); // 141\n                  httpServer.removeAllListeners(event); // 142\n                  //\n                  // request and upgrade have different arguments passed but                                                      //\n                  // we only care about the first one which is always request                                                     //\n                  var newListener = function newListener(request /*, moreArguments */) {\n                    // 146\n                    // Store arguments for use within the closure below                                                           //\n                    var args = arguments; // 148\n                    //\n                    // Rewrite /websocket and /websocket/ urls to /sockjs/websocket while                                         //\n                    // preserving query string.                                                                                   //\n                    var parsedUrl = url.parse(request.url); // 152\n                    if (parsedUrl.pathname === pathPrefix + '/websocket' || parsedUrl.pathname === pathPrefix + '/websocket/') {\n                      // 153\n                      parsedUrl.pathname = self.prefix + '/websocket'; // 155\n                      request.url = url.format(parsedUrl); // 156\n                    } // 157\n                    _.each(oldHttpServerListeners, function (oldListener) {\n                      // 158\n                      oldListener.apply(httpServer, args); // 159\n                    }); // 160\n                  }; // 161\n                  httpServer.addListener(event, newListener); // 162\n                }); // 163\n              } // 164\n            }); // 113\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }, \"livedata_server.js\": [\"babel-runtime/helpers/typeof\", function (require, exports, module) {\n\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/ddp-server/livedata_server.js                                                                             //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            var _typeof;module['import'](\"babel-runtime/helpers/typeof\", { \"default\": function _default(v) {\n                _typeof = v;\n              } }); //\n            DDPServer = {}; // 1\n            //\n            var Fiber = Npm.require('fibers'); // 3\n            //\n            // This file contains classes:                                                                                        //\n            // * Session - The server's connection to a single DDP client                                                         //\n            // * Subscription - A single subscription for a single client                                                         //\n            // * Server - An entire server that may talk to > 1 client. A DDP endpoint.                                           //\n            //                                                                                                                    //\n            // Session and Subscription are file scope. For now, until we freeze                                                  //\n            // the interface, Server is package scope (in the future it should be                                                 //\n            // exported.)                                                                                                         //\n            //\n            // Represents a single document in a SessionCollectionView                                                            //\n            var SessionDocumentView = function SessionDocumentView() {\n              // 15\n              var self = this; // 16\n              self.existsIn = {}; // set of subscriptionHandle                                                                    // 17\n              self.dataByKey = {}; // key-> [ {subscriptionHandle, value} by precedence]                                          // 18\n            }; // 19\n            //\n            DDPServer._SessionDocumentView = SessionDocumentView; // 21\n            //\n            _.extend(SessionDocumentView.prototype, { // 24\n              //\n              getFields: function getFields() {\n                // 26\n                var self = this; // 27\n                var ret = {}; // 28\n                _.each(self.dataByKey, function (precedenceList, key) {\n                  // 29\n                  ret[key] = precedenceList[0].value; // 30\n                }); // 31\n                return ret; // 32\n              }, // 33\n              //\n              clearField: function clearField(subscriptionHandle, key, changeCollector) {\n                // 35\n                var self = this; // 36\n                // Publish API ignores _id if present in fields                                                                   //\n                if (key === \"_id\") return; // 38\n                var precedenceList = self.dataByKey[key]; // 40\n                //\n                // It's okay to clear fields that didn't exist. No need to throw                                                  //\n                // an error.                                                                                                      //\n                if (!precedenceList) return; // 44\n                //\n                var removedValue = undefined; // 47\n                for (var i = 0; i < precedenceList.length; i++) {\n                  // 48\n                  var precedence = precedenceList[i]; // 49\n                  if (precedence.subscriptionHandle === subscriptionHandle) {\n                    // 50\n                    // The view's value can only change if this subscription is the one that                                      //\n                    // used to have precedence.                                                                                   //\n                    if (i === 0) removedValue = precedence.value; // 53\n                    precedenceList.splice(i, 1); // 55\n                    break; // 56\n                  } // 57\n                } // 58\n                if (_.isEmpty(precedenceList)) {\n                  // 59\n                  delete self.dataByKey[key]; // 60\n                  changeCollector[key] = undefined; // 61\n                } else if (removedValue !== undefined && !EJSON.equals(removedValue, precedenceList[0].value)) {\n                    // 62\n                    changeCollector[key] = precedenceList[0].value; // 64\n                  } // 65\n              }, // 66\n              //\n              changeField: function changeField(subscriptionHandle, key, value, changeCollector, isAdd) {\n                // 68\n                var self = this; // 70\n                // Publish API ignores _id if present in fields                                                                   //\n                if (key === \"_id\") return; // 72\n                //\n                // Don't share state with the data passed in by the user.                                                         //\n                value = EJSON.clone(value); // 76\n                //\n                if (!_.has(self.dataByKey, key)) {\n                  // 78\n                  self.dataByKey[key] = [{ subscriptionHandle: subscriptionHandle, // 79\n                    value: value }]; // 80\n                  changeCollector[key] = value; // 81\n                  return; // 82\n                } // 83\n                var precedenceList = self.dataByKey[key]; // 84\n                var elt; // 85\n                if (!isAdd) {\n                  // 86\n                  elt = _.find(precedenceList, function (precedence) {\n                    // 87\n                    return precedence.subscriptionHandle === subscriptionHandle; // 88\n                  }); // 89\n                } // 90\n                //\n                if (elt) {\n                  // 92\n                  if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {\n                    // 93\n                    // this subscription is changing the value of this field.                                                     //\n                    changeCollector[key] = value; // 95\n                  } // 96\n                  elt.value = value; // 97\n                } else {\n                    // 98\n                    // this subscription is newly caring about this field                                                           //\n                    precedenceList.push({ subscriptionHandle: subscriptionHandle, value: value }); // 100\n                  } // 101\n              } // 103\n            }); // 24\n            //\n            /**                                                                                                                   //\n             * Represents a client's view of a single collection                                                                  //\n             * @param {String} collectionName Name of the collection it represents                                                //\n             * @param {Object.<String, Function>} sessionCallbacks The callbacks for added, changed, removed                      //\n             * @class SessionCollectionView                                                                                       //\n             */ //\n            var SessionCollectionView = function SessionCollectionView(collectionName, sessionCallbacks) {\n              // 112\n              var self = this; // 113\n              self.collectionName = collectionName; // 114\n              self.documents = {}; // 115\n              self.callbacks = sessionCallbacks; // 116\n            }; // 117\n            //\n            DDPServer._SessionCollectionView = SessionCollectionView; // 119\n            //\n            _.extend(SessionCollectionView.prototype, { // 122\n              //\n              isEmpty: function isEmpty() {\n                // 124\n                var self = this; // 125\n                return _.isEmpty(self.documents); // 126\n              }, // 127\n              //\n              diff: function diff(previous) {\n                // 129\n                var self = this; // 130\n                DiffSequence.diffObjects(previous.documents, self.documents, { // 131\n                  both: _.bind(self.diffDocument, self), // 132\n                  //\n                  rightOnly: function rightOnly(id, nowDV) {\n                    // 134\n                    self.callbacks.added(self.collectionName, id, nowDV.getFields()); // 135\n                  }, // 136\n                  //\n                  leftOnly: function leftOnly(id, prevDV) {\n                    // 138\n                    self.callbacks.removed(self.collectionName, id); // 139\n                  } // 140\n                }); // 131\n              }, // 142\n              //\n              diffDocument: function diffDocument(id, prevDV, nowDV) {\n                // 144\n                var self = this; // 145\n                var fields = {}; // 146\n                DiffSequence.diffObjects(prevDV.getFields(), nowDV.getFields(), { // 147\n                  both: function both(key, prev, now) {\n                    // 148\n                    if (!EJSON.equals(prev, now)) fields[key] = now; // 149\n                  }, // 151\n                  rightOnly: function rightOnly(key, now) {\n                    // 152\n                    fields[key] = now; // 153\n                  }, // 154\n                  leftOnly: function leftOnly(key, prev) {\n                    // 155\n                    fields[key] = undefined; // 156\n                  } // 157\n                }); // 147\n                self.callbacks.changed(self.collectionName, id, fields); // 159\n              }, // 160\n              //\n              added: function added(subscriptionHandle, id, fields) {\n                // 162\n                var self = this; // 163\n                var docView = self.documents[id]; // 164\n                var added = false; // 165\n                if (!docView) {\n                  // 166\n                  added = true; // 167\n                  docView = new SessionDocumentView(); // 168\n                  self.documents[id] = docView; // 169\n                } // 170\n                docView.existsIn[subscriptionHandle] = true; // 171\n                var changeCollector = {}; // 172\n                _.each(fields, function (value, key) {\n                  // 173\n                  docView.changeField(subscriptionHandle, key, value, changeCollector, true); // 174\n                }); // 176\n                if (added) self.callbacks.added(self.collectionName, id, changeCollector);else self.callbacks.changed(self.collectionName, id, changeCollector);\n              }, // 181\n              //\n              changed: function changed(subscriptionHandle, id, _changed) {\n                // 183\n                var self = this; // 184\n                var changedResult = {}; // 185\n                var docView = self.documents[id]; // 186\n                if (!docView) throw new Error(\"Could not find element with id \" + id + \" to change\"); // 187\n                _.each(_changed, function (value, key) {\n                  // 189\n                  if (value === undefined) docView.clearField(subscriptionHandle, key, changedResult);else docView.changeField(subscriptionHandle, key, value, changedResult);\n                }); // 194\n                self.callbacks.changed(self.collectionName, id, changedResult); // 195\n              }, // 196\n              //\n              removed: function removed(subscriptionHandle, id) {\n                // 198\n                var self = this; // 199\n                var docView = self.documents[id]; // 200\n                if (!docView) {\n                  // 201\n                  var err = new Error(\"Removed nonexistent document \" + id); // 202\n                  throw err; // 203\n                } // 204\n                delete docView.existsIn[subscriptionHandle]; // 205\n                if (_.isEmpty(docView.existsIn)) {\n                  // 206\n                  // it is gone from everyone                                                                                     //\n                  self.callbacks.removed(self.collectionName, id); // 208\n                  delete self.documents[id]; // 209\n                } else {\n                    // 210\n                    var changed = {}; // 211\n                    // remove this subscription from every precedence list                                                          //\n                    // and record the changes                                                                                       //\n                    _.each(docView.dataByKey, function (precedenceList, key) {\n                      // 214\n                      docView.clearField(subscriptionHandle, key, changed); // 215\n                    }); // 216\n                    //\n                    self.callbacks.changed(self.collectionName, id, changed); // 218\n                  } // 219\n              } // 220\n            }); // 122\n            //\n            /******************************************************************************/ //\n            /* Session                                                                    */ //\n            /******************************************************************************/ //\n            //\n            var Session = function Session(server, version, socket, options) {\n              // 227\n              var self = this; // 228\n              self.id = Random.id(); // 229\n              //\n              self.server = server; // 231\n              self.version = version; // 232\n              //\n              self.initialized = false; // 234\n              self.socket = socket; // 235\n              //\n              // set to null when the session is destroyed. multiple places below                                                 //\n              // use this to determine if the session is alive or not.                                                            //\n              self.inQueue = new Meteor._DoubleEndedQueue(); // 239\n              //\n              self.blocked = false; // 241\n              self.workerRunning = false; // 242\n              //\n              // Sub objects for active subscriptions                                                                             //\n              self._namedSubs = {}; // 245\n              self._universalSubs = []; // 246\n              //\n              self.userId = null; // 248\n              //\n              self.collectionViews = {}; // 250\n              //\n              // Set this to false to not send messages when collectionViews are                                                  //\n              // modified. This is done when rerunning subs in _setUserId and those messages                                      //\n              // are calculated via a diff instead.                                                                               //\n              self._isSending = true; // 255\n              //\n              // If this is true, don't start a newly-created universal publisher on this                                         //\n              // session. The session will take care of starting it when appropriate.                                             //\n              self._dontStartNewUniversalSubs = false; // 259\n              //\n              // when we are rerunning subscriptions, any ready messages                                                          //\n              // we want to buffer up for when we are done rerunning subscriptions                                                //\n              self._pendingReady = []; // 263\n              //\n              // List of callbacks to call when this connection is closed.                                                        //\n              self._closeCallbacks = []; // 266\n              //\n              // XXX HACK: If a sockjs connection, save off the URL. This is                                                      //\n              // temporary and will go away in the near future.                                                                   //\n              self._socketUrl = socket.url; // 271\n              //\n              // Allow tests to disable responding to pings.                                                                      //\n              self._respondToPings = options.respondToPings; // 274\n              //\n              // This object is the public interface to the session. In the public                                                //\n              // API, it is called the `connection` object.  Internally we call it                                                //\n              // a `connectionHandle` to avoid ambiguity.                                                                         //\n              self.connectionHandle = { // 279\n                id: self.id, // 280\n                close: function close() {\n                  // 281\n                  self.close(); // 282\n                }, // 283\n                onClose: function onClose(fn) {\n                  // 284\n                  var cb = Meteor.bindEnvironment(fn, \"connection onClose callback\"); // 285\n                  if (self.inQueue) {\n                    // 286\n                    self._closeCallbacks.push(cb); // 287\n                  } else {\n                      // 288\n                      // if we're already closed, call the callback.                                                                //\n                      Meteor.defer(cb); // 290\n                    } // 291\n                }, // 292\n                clientAddress: self._clientAddress(), // 293\n                httpHeaders: self.socket.headers // 294\n              }; // 279\n              //\n              self.send({ msg: 'connected', session: self.id }); // 297\n              //\n              // On initial connect, spin up all the universal publishers.                                                        //\n              Fiber(function () {\n                // 300\n                self.startUniversalSubs(); // 301\n              }).run(); // 302\n              //\n              if (version !== 'pre1' && options.heartbeatInterval !== 0) {\n                // 304\n                self.heartbeat = new DDPCommon.Heartbeat({ // 305\n                  heartbeatInterval: options.heartbeatInterval, // 306\n                  heartbeatTimeout: options.heartbeatTimeout, // 307\n                  onTimeout: function onTimeout() {\n                    // 308\n                    self.close(); // 309\n                  }, // 310\n                  sendPing: function sendPing() {\n                    // 311\n                    self.send({ msg: 'ping' }); // 312\n                  } // 313\n                }); // 305\n                self.heartbeat.start(); // 315\n              } // 316\n              //\n              Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"sessions\", 1); // 318\n            }; // 320\n            //\n            _.extend(Session.prototype, { // 322\n              //\n              sendReady: function sendReady(subscriptionIds) {\n                // 324\n                var self = this; // 325\n                if (self._isSending) self.send({ msg: \"ready\", subs: subscriptionIds });else {\n                  // 326\n                  _.each(subscriptionIds, function (subscriptionId) {\n                    // 329\n                    self._pendingReady.push(subscriptionId); // 330\n                  }); // 331\n                } // 332\n              }, // 333\n              //\n              sendAdded: function sendAdded(collectionName, id, fields) {\n                // 335\n                var self = this; // 336\n                if (self._isSending) self.send({ msg: \"added\", collection: collectionName, id: id, fields: fields }); // 337\n              }, // 339\n              //\n              sendChanged: function sendChanged(collectionName, id, fields) {\n                // 341\n                var self = this; // 342\n                if (_.isEmpty(fields)) return; // 343\n                //\n                if (self._isSending) {\n                  // 346\n                  self.send({ // 347\n                    msg: \"changed\", // 348\n                    collection: collectionName, // 349\n                    id: id, // 350\n                    fields: fields // 351\n                  }); // 347\n                } // 353\n              }, // 354\n              //\n              sendRemoved: function sendRemoved(collectionName, id) {\n                // 356\n                var self = this; // 357\n                if (self._isSending) self.send({ msg: \"removed\", collection: collectionName, id: id }); // 358\n              }, // 360\n              //\n              getSendCallbacks: function getSendCallbacks() {\n                // 362\n                var self = this; // 363\n                return { // 364\n                  added: _.bind(self.sendAdded, self), // 365\n                  changed: _.bind(self.sendChanged, self), // 366\n                  removed: _.bind(self.sendRemoved, self) // 367\n                }; // 364\n              }, // 369\n              //\n              getCollectionView: function getCollectionView(collectionName) {\n                // 371\n                var self = this; // 372\n                if (_.has(self.collectionViews, collectionName)) {\n                  // 373\n                  return self.collectionViews[collectionName]; // 374\n                } // 375\n                var ret = new SessionCollectionView(collectionName, self.getSendCallbacks()); // 376\n                self.collectionViews[collectionName] = ret; // 378\n                return ret; // 379\n              }, // 380\n              //\n              added: function added(subscriptionHandle, collectionName, id, fields) {\n                // 382\n                var self = this; // 383\n                var view = self.getCollectionView(collectionName); // 384\n                view.added(subscriptionHandle, id, fields); // 385\n              }, // 386\n              //\n              removed: function removed(subscriptionHandle, collectionName, id) {\n                // 388\n                var self = this; // 389\n                var view = self.getCollectionView(collectionName); // 390\n                view.removed(subscriptionHandle, id); // 391\n                if (view.isEmpty()) {\n                  // 392\n                  delete self.collectionViews[collectionName]; // 393\n                } // 394\n              }, // 395\n              //\n              changed: function changed(subscriptionHandle, collectionName, id, fields) {\n                // 397\n                var self = this; // 398\n                var view = self.getCollectionView(collectionName); // 399\n                view.changed(subscriptionHandle, id, fields); // 400\n              }, // 401\n              //\n              startUniversalSubs: function startUniversalSubs() {\n                // 403\n                var self = this; // 404\n                // Make a shallow copy of the set of universal handlers and start them. If                                        //\n                // additional universal publishers start while we're running them (due to                                         //\n                // yielding), they will run separately as part of Server.publish.                                                 //\n                var handlers = _.clone(self.server.universal_publish_handlers); // 408\n                _.each(handlers, function (handler) {\n                  // 409\n                  self._startSubscription(handler); // 410\n                }); // 411\n              }, // 412\n              //\n              // Destroy this session and unregister it at the server.                                                            //\n              close: function close() {\n                // 415\n                var self = this; // 416\n                //\n                // Destroy this session, even if it's not registered at the                                                       //\n                // server. Stop all processing and tear everything down. If a socket                                              //\n                // was attached, close it.                                                                                        //\n                //\n                // Already destroyed.                                                                                             //\n                if (!self.inQueue) return; // 423\n                //\n                // Drop the merge box data immediately.                                                                           //\n                self.inQueue = null; // 427\n                self.collectionViews = {}; // 428\n                //\n                if (self.heartbeat) {\n                  // 430\n                  self.heartbeat.stop(); // 431\n                  self.heartbeat = null; // 432\n                } // 433\n                //\n                if (self.socket) {\n                  // 435\n                  self.socket.close(); // 436\n                  self.socket._meteorSession = null; // 437\n                } // 438\n                //\n                Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"sessions\", -1); // 440\n                //\n                Meteor.defer(function () {\n                  // 443\n                  // stop callbacks can yield, so we defer this on close.                                                         //\n                  // sub._isDeactivated() detects that we set inQueue to null and                                                 //\n                  // treats it as semi-deactivated (it will ignore incoming callbacks, etc).                                      //\n                  self._deactivateAllSubscriptions(); // 447\n                  //\n                  // Defer calling the close callbacks, so that the caller closing                                                //\n                  // the session isn't waiting for all the callbacks to complete.                                                 //\n                  _.each(self._closeCallbacks, function (callback) {\n                    // 451\n                    callback(); // 452\n                  }); // 453\n                }); // 454\n                //\n                // Unregister the session.                                                                                        //\n                self.server._removeSession(self); // 457\n              }, // 458\n              //\n              // Send a message (doing nothing if no socket is connected right now.)                                              //\n              // It should be a JSON object (it will be stringified.)                                                             //\n              send: function send(msg) {\n                // 462\n                var self = this; // 463\n                if (self.socket) {\n                  // 464\n                  if (Meteor._printSentDDP) Meteor._debug(\"Sent DDP\", DDPCommon.stringifyDDP(msg)); // 465\n                  self.socket.send(DDPCommon.stringifyDDP(msg)); // 467\n                } // 468\n              }, // 469\n              //\n              // Send a connection error.                                                                                         //\n              sendError: function sendError(reason, offendingMessage) {\n                // 472\n                var self = this; // 473\n                var msg = { msg: 'error', reason: reason }; // 474\n                if (offendingMessage) msg.offendingMessage = offendingMessage; // 475\n                self.send(msg); // 477\n              }, // 478\n              //\n              // Process 'msg' as an incoming message. (But as a guard against                                                    //\n              // race conditions during reconnection, ignore the message if                                                       //\n              // 'socket' is not the currently connected socket.)                                                                 //\n              //                                                                                                                  //\n              // We run the messages from the client one at a time, in the order                                                  //\n              // given by the client. The message handler is passed an idempotent                                                 //\n              // function 'unblock' which it may call to allow other messages to                                                  //\n              // begin running in parallel in another fiber (for example, a method                                                //\n              // that wants to yield.) Otherwise, it is automatically unblocked                                                   //\n              // when it returns.                                                                                                 //\n              //                                                                                                                  //\n              // Actually, we don't have to 'totally order' the messages in this                                                  //\n              // way, but it's the easiest thing that's correct. (unsub needs to                                                  //\n              // be ordered against sub, methods need to be ordered against each                                                  //\n              // other.)                                                                                                          //\n              processMessage: function processMessage(msg_in) {\n                // 495\n                var self = this; // 496\n                if (!self.inQueue) // we have been destroyed.                                                                     // 497\n                  return; // 498\n                //\n                // Respond to ping and pong messages immediately without queuing.                                                 //\n                // If the negotiated DDP version is \"pre1\" which didn't support                                                   //\n                // pings, preserve the \"pre1\" behavior of responding with a \"bad                                                  //\n                // request\" for the unknown messages.                                                                             //\n                //                                                                                                                //\n                // Fibers are needed because heartbeat uses Meteor.setTimeout, which                                              //\n                // needs a Fiber. We could actually use regular setTimeout and avoid                                              //\n                // these new fibers, but it is easier to just make everything use                                                 //\n                // Meteor.setTimeout and not think too hard.                                                                      //\n                //                                                                                                                //\n                // Any message counts as receiving a pong, as it demonstrates that                                                //\n                // the client is still alive.                                                                                     //\n                if (self.heartbeat) {\n                  // 512\n                  Fiber(function () {\n                    // 513\n                    self.heartbeat.messageReceived(); // 514\n                  }).run(); // 515\n                } // 516\n                //\n                if (self.version !== 'pre1' && msg_in.msg === 'ping') {\n                  // 518\n                  if (self._respondToPings) self.send({ msg: \"pong\", id: msg_in.id }); // 519\n                  return; // 521\n                } // 522\n                if (self.version !== 'pre1' && msg_in.msg === 'pong') {\n                  // 523\n                  // Since everything is a pong, nothing to do                                                                    //\n                  return; // 525\n                } // 526\n                //\n                self.inQueue.push(msg_in); // 528\n                if (self.workerRunning) return; // 529\n                self.workerRunning = true; // 531\n                //\n                var processNext = function processNext() {\n                  // 533\n                  var msg = self.inQueue && self.inQueue.shift(); // 534\n                  if (!msg) {\n                    // 535\n                    self.workerRunning = false; // 536\n                    return; // 537\n                  } // 538\n                  //\n                  Fiber(function () {\n                    // 540\n                    var blocked = true; // 541\n                    //\n                    var unblock = function unblock() {\n                      // 543\n                      if (!blocked) return; // idempotent                                                                         // 544\n                      blocked = false; // 546\n                      processNext(); // 547\n                    }; // 548\n                    //\n                    if (_.has(self.protocol_handlers, msg.msg)) self.protocol_handlers[msg.msg].call(self, msg, unblock);else self.sendError('Bad request', msg);\n                    unblock(); // in case the handler didn't already do it                                                        // 554\n                  }).run(); // 555\n                }; // 556\n                //\n                processNext(); // 558\n              }, // 559\n              //\n              protocol_handlers: { // 561\n                sub: function sub(msg) {\n                  // 562\n                  var self = this; // 563\n                  //\n                  // reject malformed messages                                                                                    //\n                  if (typeof msg.id !== \"string\" || typeof msg.name !== \"string\" || 'params' in msg && !(msg.params instanceof Array)) {\n                    self.sendError(\"Malformed subscription\", msg); // 569\n                    return; // 570\n                  } // 571\n                  //\n                  if (!self.server.publish_handlers[msg.name]) {\n                    // 573\n                    self.send({ // 574\n                      msg: 'nosub', id: msg.id, // 575\n                      error: new Meteor.Error(404, \"Subscription '\" + msg.name + \"' not found\") }); // 576\n                    return; // 577\n                  } // 578\n                  //\n                  if (_.has(self._namedSubs, msg.id)) // 580\n                    // subs are idempotent, or rather, they are ignored if a sub                                                  //\n                    // with that id already exists. this is important during                                                      //\n                    // reconnect.                                                                                                 //\n                    return; // 584\n                  //\n                  // XXX It'd be much better if we had generic hooks where any package can                                        //\n                  // hook into subscription handling, but in the mean while we special case                                       //\n                  // ddp-rate-limiter package. This is also done for weak requirements to                                         //\n                  // add the ddp-rate-limiter package in case we don't have Accounts. A                                           //\n                  // user trying to use the ddp-rate-limiter must explicitly require it.                                          //\n                  if (Package['ddp-rate-limiter']) {\n                    // 591\n                    var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter; // 592\n                    var rateLimiterInput = { // 593\n                      userId: self.userId, // 594\n                      clientAddress: self.connectionHandle.clientAddress, // 595\n                      type: \"subscription\", // 596\n                      name: msg.name, // 597\n                      connectionId: self.id // 598\n                    }; // 593\n                    //\n                    DDPRateLimiter._increment(rateLimiterInput); // 601\n                    var rateLimitResult = DDPRateLimiter._check(rateLimiterInput); // 602\n                    if (!rateLimitResult.allowed) {\n                      // 603\n                      self.send({ // 604\n                        msg: 'nosub', id: msg.id, // 605\n                        error: new Meteor.Error('too-many-requests', DDPRateLimiter.getErrorMessage(rateLimitResult), { timeToReset: rateLimitResult.timeToReset })\n                      }); // 604\n                      return; // 611\n                    } // 612\n                  } // 613\n                  //\n                  var handler = self.server.publish_handlers[msg.name]; // 615\n                  //\n                  self._startSubscription(handler, msg.id, msg.params, msg.name); // 617\n                }, // 619\n                //\n                unsub: function unsub(msg) {\n                  // 621\n                  var self = this; // 622\n                  //\n                  self._stopSubscription(msg.id); // 624\n                }, // 625\n                //\n                method: function method(msg, unblock) {\n                  // 627\n                  var self = this; // 628\n                  //\n                  // reject malformed messages                                                                                    //\n                  // For now, we silently ignore unknown attributes,                                                              //\n                  // for forwards compatibility.                                                                                  //\n                  if (typeof msg.id !== \"string\" || typeof msg.method !== \"string\" || 'params' in msg && !(msg.params instanceof Array) || 'randomSeed' in msg && typeof msg.randomSeed !== \"string\") {\n                    self.sendError(\"Malformed method invocation\", msg); // 637\n                    return; // 638\n                  } // 639\n                  //\n                  var randomSeed = msg.randomSeed || null; // 641\n                  //\n                  // set up to mark the method as satisfied once all observers                                                    //\n                  // (and subscriptions) have reacted to any writes that were                                                     //\n                  // done.                                                                                                        //\n                  var fence = new DDPServer._WriteFence(); // 646\n                  fence.onAllCommitted(function () {\n                    // 647\n                    // Retire the fence so that future writes are allowed.                                                        //\n                    // This means that callbacks like timers are free to use                                                      //\n                    // the fence, and if they fire before it's armed (for                                                         //\n                    // example, because the method waits for them) their                                                          //\n                    // writes will be included in the fence.                                                                      //\n                    fence.retire(); // 653\n                    self.send({ // 654\n                      msg: 'updated', methods: [msg.id] }); // 655\n                  }); // 656\n                  //\n                  // find the handler                                                                                             //\n                  var handler = self.server.method_handlers[msg.method]; // 659\n                  if (!handler) {\n                    // 660\n                    self.send({ // 661\n                      msg: 'result', id: msg.id, // 662\n                      error: new Meteor.Error(404, \"Method '\" + msg.method + \"' not found\") }); // 663\n                    fence.arm(); // 664\n                    return; // 665\n                  } // 666\n                  //\n                  var setUserId = function setUserId(userId) {\n                    // 668\n                    self._setUserId(userId); // 669\n                  }; // 670\n                  //\n                  var invocation = new DDPCommon.MethodInvocation({ // 672\n                    isSimulation: false, // 673\n                    userId: self.userId, // 674\n                    setUserId: setUserId, // 675\n                    unblock: unblock, // 676\n                    connection: self.connectionHandle, // 677\n                    randomSeed: randomSeed // 678\n                  }); // 672\n                  //\n                  var promise = new Promise(function (resolve, reject) {\n                    // 681\n                    // XXX It'd be better if we could hook into method handlers better but                                        //\n                    // for now, we need to check if the ddp-rate-limiter exists since we                                          //\n                    // have a weak requirement for the ddp-rate-limiter package to be added                                       //\n                    // to our application.                                                                                        //\n                    if (Package['ddp-rate-limiter']) {\n                      // 686\n                      var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter; // 687\n                      var rateLimiterInput = { // 688\n                        userId: self.userId, // 689\n                        clientAddress: self.connectionHandle.clientAddress, // 690\n                        type: \"method\", // 691\n                        name: msg.method, // 692\n                        connectionId: self.id // 693\n                      }; // 688\n                      DDPRateLimiter._increment(rateLimiterInput); // 695\n                      var rateLimitResult = DDPRateLimiter._check(rateLimiterInput); // 696\n                      if (!rateLimitResult.allowed) {\n                        // 697\n                        reject(new Meteor.Error(\"too-many-requests\", DDPRateLimiter.getErrorMessage(rateLimitResult), { timeToReset: rateLimitResult.timeToReset }));\n                        return; // 703\n                      } // 704\n                    } // 705\n                    //\n                    resolve(DDPServer._CurrentWriteFence.withValue(fence, function () {\n                      // 707\n                      return DDP._CurrentInvocation.withValue(invocation, function () {\n                        // 709\n                        return maybeAuditArgumentChecks(handler, invocation, msg.params, \"call to '\" + msg.method + \"'\"); // 711\n                      }); // 711\n                    })); // 709\n                  }); // 717\n                  //\n                  function finish() {\n                    // 719\n                    fence.arm(); // 720\n                    unblock(); // 721\n                  } // 722\n                  //\n                  var payload = { // 724\n                    msg: \"result\", // 725\n                    id: msg.id // 726\n                  }; // 724\n                  //\n                  promise.then(function (result) {\n                    // 729\n                    finish(); // 730\n                    if (result !== undefined) {\n                      // 731\n                      payload.result = result; // 732\n                    } // 733\n                    self.send(payload); // 734\n                  }, function (exception) {\n                    // 735\n                    finish(); // 736\n                    payload.error = wrapInternalException(exception, \"while invoking method '\" + msg.method + \"'\"); // 737\n                    self.send(payload); // 741\n                  }); // 742\n                } // 743\n              }, // 561\n              //\n              _eachSub: function _eachSub(f) {\n                // 746\n                var self = this; // 747\n                _.each(self._namedSubs, f); // 748\n                _.each(self._universalSubs, f); // 749\n              }, // 750\n              //\n              _diffCollectionViews: function _diffCollectionViews(beforeCVs) {\n                // 752\n                var self = this; // 753\n                DiffSequence.diffObjects(beforeCVs, self.collectionViews, { // 754\n                  both: function both(collectionName, leftValue, rightValue) {\n                    // 755\n                    rightValue.diff(leftValue); // 756\n                  }, // 757\n                  rightOnly: function rightOnly(collectionName, rightValue) {\n                    // 758\n                    _.each(rightValue.documents, function (docView, id) {\n                      // 759\n                      self.sendAdded(collectionName, id, docView.getFields()); // 760\n                    }); // 761\n                  }, // 762\n                  leftOnly: function leftOnly(collectionName, leftValue) {\n                    // 763\n                    _.each(leftValue.documents, function (doc, id) {\n                      // 764\n                      self.sendRemoved(collectionName, id); // 765\n                    }); // 766\n                  } // 767\n                }); // 754\n              }, // 769\n              //\n              // Sets the current user id in all appropriate contexts and reruns                                                  //\n              // all subscriptions                                                                                                //\n              _setUserId: function _setUserId(userId) {\n                // 773\n                var self = this; // 774\n                //\n                if (userId !== null && typeof userId !== \"string\") throw new Error(\"setUserId must be called on string or null, not \" + (typeof userId === \"undefined\" ? \"undefined\" : _typeof(userId)));\n                //\n                // Prevent newly-created universal subscriptions from being added to our                                          //\n                // session; they will be found below when we call startUniversalSubs.                                             //\n                //                                                                                                                //\n                // (We don't have to worry about named subscriptions, because we only add                                         //\n                // them when we process a 'sub' message. We are currently processing a                                            //\n                // 'method' message, and the method did not unblock, because it is illegal                                        //\n                // to call setUserId after unblock. Thus we cannot be concurrently adding a                                       //\n                // new named subscription.)                                                                                       //\n                self._dontStartNewUniversalSubs = true; // 788\n                //\n                // Prevent current subs from updating our collectionViews and call their                                          //\n                // stop callbacks. This may yield.                                                                                //\n                self._eachSub(function (sub) {\n                  // 792\n                  sub._deactivate(); // 793\n                }); // 794\n                //\n                // All subs should now be deactivated. Stop sending messages to the client,                                       //\n                // save the state of the published collections, reset to an empty view, and                                       //\n                // update the userId.                                                                                             //\n                self._isSending = false; // 799\n                var beforeCVs = self.collectionViews; // 800\n                self.collectionViews = {}; // 801\n                self.userId = userId; // 802\n                //\n                // Save the old named subs, and reset to having no subscriptions.                                                 //\n                var oldNamedSubs = self._namedSubs; // 805\n                self._namedSubs = {}; // 806\n                self._universalSubs = []; // 807\n                //\n                _.each(oldNamedSubs, function (sub, subscriptionId) {\n                  // 809\n                  self._namedSubs[subscriptionId] = sub._recreate(); // 810\n                  // nb: if the handler throws or calls this.error(), it will in fact                                             //\n                  // immediately send its 'nosub'. This is OK, though.                                                            //\n                  self._namedSubs[subscriptionId]._runHandler(); // 813\n                }); // 814\n                //\n                // Allow newly-created universal subs to be started on our connection in                                          //\n                // parallel with the ones we're spinning up here, and spin up universal                                           //\n                // subs.                                                                                                          //\n                self._dontStartNewUniversalSubs = false; // 819\n                self.startUniversalSubs(); // 820\n                //\n                // Start sending messages again, beginning with the diff from the previous                                        //\n                // state of the world to the current state. No yields are allowed during                                          //\n                // this diff, so that other changes cannot interleave.                                                            //\n                Meteor._noYieldsAllowed(function () {\n                  // 825\n                  self._isSending = true; // 826\n                  self._diffCollectionViews(beforeCVs); // 827\n                  if (!_.isEmpty(self._pendingReady)) {\n                    // 828\n                    self.sendReady(self._pendingReady); // 829\n                    self._pendingReady = []; // 830\n                  } // 831\n                }); // 832\n              }, // 833\n              //\n              _startSubscription: function _startSubscription(handler, subId, params, name) {\n                // 835\n                var self = this; // 836\n                //\n                var sub = new Subscription(self, handler, subId, params, name); // 838\n                if (subId) self._namedSubs[subId] = sub;else self._universalSubs.push(sub); // 840\n                //\n                sub._runHandler(); // 845\n              }, // 846\n              //\n              // tear down specified subscription                                                                                 //\n              _stopSubscription: function _stopSubscription(subId, error) {\n                // 849\n                var self = this; // 850\n                //\n                var subName = null; // 852\n                //\n                if (subId && self._namedSubs[subId]) {\n                  // 854\n                  subName = self._namedSubs[subId]._name; // 855\n                  self._namedSubs[subId]._removeAllDocuments(); // 856\n                  self._namedSubs[subId]._deactivate(); // 857\n                  delete self._namedSubs[subId]; // 858\n                } // 859\n                //\n                var response = { msg: 'nosub', id: subId }; // 861\n                //\n                if (error) {\n                  // 863\n                  response.error = wrapInternalException(error, subName ? \"from sub \" + subName + \" id \" + subId : \"from sub id \" + subId);\n                } // 868\n                //\n                self.send(response); // 870\n              }, // 871\n              //\n              // tear down all subscriptions. Note that this does NOT send removed or nosub                                       //\n              // messages, since we assume the client is gone.                                                                    //\n              _deactivateAllSubscriptions: function _deactivateAllSubscriptions() {\n                // 875\n                var self = this; // 876\n                //\n                _.each(self._namedSubs, function (sub, id) {\n                  // 878\n                  sub._deactivate(); // 879\n                }); // 880\n                self._namedSubs = {}; // 881\n                //\n                _.each(self._universalSubs, function (sub) {\n                  // 883\n                  sub._deactivate(); // 884\n                }); // 885\n                self._universalSubs = []; // 886\n              }, // 887\n              //\n              // Determine the remote client's IP address, based on the                                                           //\n              // HTTP_FORWARDED_COUNT environment variable representing how many                                                  //\n              // proxies the server is behind.                                                                                    //\n              _clientAddress: function _clientAddress() {\n                // 892\n                var self = this; // 893\n                //\n                // For the reported client address for a connection to be correct,                                                //\n                // the developer must set the HTTP_FORWARDED_COUNT environment                                                    //\n                // variable to an integer representing the number of hops they                                                    //\n                // expect in the `x-forwarded-for` header. E.g., set to \"1\" if the                                                //\n                // server is behind one proxy.                                                                                    //\n                //                                                                                                                //\n                // This could be computed once at startup instead of every time.                                                  //\n                var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0; // 902\n                //\n                if (httpForwardedCount === 0) return self.socket.remoteAddress; // 904\n                //\n                var forwardedFor = self.socket.headers[\"x-forwarded-for\"]; // 907\n                if (!_.isString(forwardedFor)) return null; // 908\n                forwardedFor = forwardedFor.trim().split(/\\s*,\\s*/); // 910\n                //\n                // Typically the first value in the `x-forwarded-for` header is                                                   //\n                // the original IP address of the client connecting to the first                                                  //\n                // proxy.  However, the end user can easily spoof the header, in                                                  //\n                // which case the first value(s) will be the fake IP address from                                                 //\n                // the user pretending to be a proxy reporting the original IP                                                    //\n                // address value.  By counting HTTP_FORWARDED_COUNT back from the                                                 //\n                // end of the list, we ensure that we get the IP address being                                                    //\n                // reported by *our* first proxy.                                                                                 //\n                //\n                if (httpForwardedCount < 0 || httpForwardedCount > forwardedFor.length) return null; // 921\n                //\n                return forwardedFor[forwardedFor.length - httpForwardedCount]; // 924\n              } // 925\n            }); // 322\n            //\n            /******************************************************************************/ //\n            /* Subscription                                                               */ //\n            /******************************************************************************/ //\n            //\n            // ctor for a sub handle: the input to each publish function                                                          //\n            //\n            // Instance name is this because it's usually referred to as this inside a                                            //\n            // publish                                                                                                            //\n            /**                                                                                                                   //\n             * @summary The server's side of a subscription                                                                       //\n             * @class Subscription                                                                                                //\n             * @instanceName this                                                                                                 //\n             */ //\n            var Subscription = function Subscription(session, handler, subscriptionId, params, name) {\n              // 941\n              var self = this; // 943\n              self._session = session; // type is Session                                                                         // 944\n              //\n              /**                                                                                                                 //\n               * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.\n               * @locus Server                                                                                                    //\n               * @name  connection                                                                                                //\n               * @memberOf Subscription                                                                                           //\n               * @instance                                                                                                        //\n               */ //\n              self.connection = session.connectionHandle; // public API object                                                    // 953\n              //\n              self._handler = handler; // 955\n              //\n              // my subscription ID (generated by client, undefined for universal subs).                                          //\n              self._subscriptionId = subscriptionId; // 958\n              // undefined for universal subs                                                                                     //\n              self._name = name; // 960\n              //\n              self._params = params || []; // 962\n              //\n              // Only named subscriptions have IDs, but we need some sort of string                                               //\n              // internally to keep track of all subscriptions inside                                                             //\n              // SessionDocumentViews. We use this subscriptionHandle for that.                                                   //\n              if (self._subscriptionId) {\n                // 967\n                self._subscriptionHandle = 'N' + self._subscriptionId; // 968\n              } else {\n                  // 969\n                  self._subscriptionHandle = 'U' + Random.id(); // 970\n                } // 971\n              //\n              // has _deactivate been called?                                                                                     //\n              self._deactivated = false; // 974\n              //\n              // stop callbacks to g/c this sub.  called w/ zero arguments.                                                       //\n              self._stopCallbacks = []; // 977\n              //\n              // the set of (collection, documentid) that this subscription has                                                   //\n              // an opinion about                                                                                                 //\n              self._documents = {}; // 981\n              //\n              // remember if we are ready.                                                                                        //\n              self._ready = false; // 984\n              //\n              // Part of the public API: the user of this sub.                                                                    //\n              //\n              /**                                                                                                                 //\n               * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.    //\n               * @locus Server                                                                                                    //\n               * @memberOf Subscription                                                                                           //\n               * @name  userId                                                                                                    //\n               * @instance                                                                                                        //\n               */ //\n              self.userId = session.userId; // 995\n              //\n              // For now, the id filter is going to default to                                                                    //\n              // the to/from DDP methods on MongoID, to                                                                           //\n              // specifically deal with mongo/minimongo ObjectIds.                                                                //\n              //\n              // Later, you will be able to make this be \"raw\"                                                                    //\n              // if you want to publish a collection that you know                                                                //\n              // just has strings for keys and no funny business, to                                                              //\n              // a ddp consumer that isn't minimongo                                                                              //\n              //\n              self._idFilter = { // 1006\n                idStringify: MongoID.idStringify, // 1007\n                idParse: MongoID.idParse // 1008\n              }; // 1006\n              //\n              Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"subscriptions\", 1); // 1011\n            }; // 1013\n            //\n            _.extend(Subscription.prototype, { // 1015\n              _runHandler: function _runHandler() {\n                // 1016\n                // XXX should we unblock() here? Either before running the publish                                                //\n                // function, or before running _publishCursor.                                                                    //\n                //                                                                                                                //\n                // Right now, each publish function blocks all future publishes and                                               //\n                // methods waiting on data from Mongo (or whatever else the function                                              //\n                // blocks on). This probably slows page load in common cases.                                                     //\n                //\n                var self = this; // 1024\n                try {\n                  // 1025\n                  var res = maybeAuditArgumentChecks(self._handler, self, EJSON.clone(self._params), // 1026\n                  // It's OK that this would look weird for universal subscriptions,                                              //\n                  // because they have no arguments so there can never be an                                                      //\n                  // audit-argument-checks failure.                                                                               //\n                  \"publisher '\" + self._name + \"'\"); // 1031\n                } catch (e) {\n                  // 1032\n                  self.error(e); // 1033\n                  return; // 1034\n                } // 1035\n                //\n                // Did the handler call this.error or this.stop?                                                                  //\n                if (self._isDeactivated()) return; // 1038\n                //\n                self._publishHandlerResult(res); // 1041\n              }, // 1042\n              //\n              _publishHandlerResult: function _publishHandlerResult(res) {\n                // 1044\n                // SPECIAL CASE: Instead of writing their own callbacks that invoke                                               //\n                // this.added/changed/ready/etc, the user can just return a collection                                            //\n                // cursor or array of cursors from the publish function; we call their                                            //\n                // _publishCursor method which starts observing the cursor and publishes the                                      //\n                // results. Note that _publishCursor does NOT call ready().                                                       //\n                //                                                                                                                //\n                // XXX This uses an undocumented interface which only the Mongo cursor                                            //\n                // interface publishes. Should we make this interface public and encourage                                        //\n                // users to implement it themselves? Arguably, it's unnecessary; users can                                        //\n                // already write their own functions like                                                                         //\n                //   var publishMyReactiveThingy = function (name, handler) {                                                     //\n                //     Meteor.publish(name, function () {                                                                         //\n                //       var reactiveThingy = handler();                                                                          //\n                //       reactiveThingy.publishMe();                                                                              //\n                //     });                                                                                                        //\n                //   };                                                                                                           //\n                //\n                var self = this; // 1062\n                var isCursor = function isCursor(c) {\n                  // 1063\n                  return c && c._publishCursor; // 1064\n                }; // 1065\n                if (isCursor(res)) {\n                  // 1066\n                  try {\n                    // 1067\n                    res._publishCursor(self); // 1068\n                  } catch (e) {\n                    // 1069\n                    self.error(e); // 1070\n                    return; // 1071\n                  } // 1072\n                  // _publishCursor only returns after the initial added callbacks have run.                                      //\n                  // mark subscription as ready.                                                                                  //\n                  self.ready(); // 1075\n                } else if (_.isArray(res)) {\n                    // 1076\n                    // check all the elements are cursors                                                                           //\n                    if (!_.all(res, isCursor)) {\n                      // 1078\n                      self.error(new Error(\"Publish function returned an array of non-Cursors\")); // 1079\n                      return; // 1080\n                    } // 1081\n                    // find duplicate collection names                                                                              //\n                    // XXX we should support overlapping cursors, but that would require the                                        //\n                    // merge box to allow overlap within a subscription                                                             //\n                    var collectionNames = {}; // 1085\n                    for (var i = 0; i < res.length; ++i) {\n                      // 1086\n                      var collectionName = res[i]._getCollectionName(); // 1087\n                      if (_.has(collectionNames, collectionName)) {\n                        // 1088\n                        self.error(new Error(\"Publish function returned multiple cursors for collection \" + collectionName)); // 1089\n                        return; // 1092\n                      } // 1093\n                      collectionNames[collectionName] = true; // 1094\n                    }; // 1095\n                    //\n                    try {\n                      // 1097\n                      _.each(res, function (cur) {\n                        // 1098\n                        cur._publishCursor(self); // 1099\n                      }); // 1100\n                    } catch (e) {\n                      // 1101\n                      self.error(e); // 1102\n                      return; // 1103\n                    } // 1104\n                    self.ready(); // 1105\n                  } else if (res) {\n                      // 1106\n                      // truthy values other than cursors or arrays are probably a                                                    //\n                      // user mistake (possible returning a Mongo document via, say,                                                  //\n                      // `coll.findOne()`).                                                                                           //\n                      self.error(new Error(\"Publish function can only return a Cursor or \" + \"an array of Cursors\")); // 1110\n                    } // 1112\n              }, // 1113\n              //\n              // This calls all stop callbacks and prevents the handler from updating any                                         //\n              // SessionCollectionViews further. It's used when the user unsubscribes or                                          //\n              // disconnects, as well as during setUserId re-runs. It does *NOT* send                                             //\n              // removed messages for the published objects; if that is necessary, call                                           //\n              // _removeAllDocuments first.                                                                                       //\n              _deactivate: function _deactivate() {\n                // 1120\n                var self = this; // 1121\n                if (self._deactivated) return; // 1122\n                self._deactivated = true; // 1124\n                self._callStopCallbacks(); // 1125\n                Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"subscriptions\", -1); // 1126\n              }, // 1128\n              //\n              _callStopCallbacks: function _callStopCallbacks() {\n                // 1130\n                var self = this; // 1131\n                // tell listeners, so they can clean up                                                                           //\n                var callbacks = self._stopCallbacks; // 1133\n                self._stopCallbacks = []; // 1134\n                _.each(callbacks, function (callback) {\n                  // 1135\n                  callback(); // 1136\n                }); // 1137\n              }, // 1138\n              //\n              // Send remove messages for every document.                                                                         //\n              _removeAllDocuments: function _removeAllDocuments() {\n                // 1141\n                var self = this; // 1142\n                Meteor._noYieldsAllowed(function () {\n                  // 1143\n                  _.each(self._documents, function (collectionDocs, collectionName) {\n                    // 1144\n                    // Iterate over _.keys instead of the dictionary itself, since we'll be                                       //\n                    // mutating it.                                                                                               //\n                    _.each(_.keys(collectionDocs), function (strId) {\n                      // 1147\n                      self.removed(collectionName, self._idFilter.idParse(strId)); // 1148\n                    }); // 1149\n                  }); // 1150\n                }); // 1151\n              }, // 1152\n              //\n              // Returns a new Subscription for the same session with the same                                                    //\n              // initial creation parameters. This isn't a clone: it doesn't have                                                 //\n              // the same _documents cache, stopped state or callbacks; may have a                                                //\n              // different _subscriptionHandle, and gets its userId from the                                                      //\n              // session, not from this object.                                                                                   //\n              _recreate: function _recreate() {\n                // 1159\n                var self = this; // 1160\n                return new Subscription(self._session, self._handler, self._subscriptionId, self._params, self._name); // 1161\n              }, // 1164\n              //\n              /**                                                                                                                 //\n               * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).\n               * @locus Server                                                                                                    //\n               * @param {Error} error The error to pass to the client.                                                            //\n               * @instance                                                                                                        //\n               * @memberOf Subscription                                                                                           //\n               */ //\n              error: function error(_error) {\n                // 1173\n                var self = this; // 1174\n                if (self._isDeactivated()) return; // 1175\n                self._session._stopSubscription(self._subscriptionId, _error); // 1177\n              }, // 1178\n              //\n              // Note that while our DDP client will notice that you've called stop() on the                                      //\n              // server (and clean up its _subscriptions table) we don't actually provide a                                       //\n              // mechanism for an app to notice this (the subscribe onError callback only                                         //\n              // triggers if there is an error).                                                                                  //\n              //\n              /**                                                                                                                 //\n               * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.\n               * @locus Server                                                                                                    //\n               * @instance                                                                                                        //\n               * @memberOf Subscription                                                                                           //\n               */ //\n              stop: function stop() {\n                // 1191\n                var self = this; // 1192\n                if (self._isDeactivated()) return; // 1193\n                self._session._stopSubscription(self._subscriptionId); // 1195\n              }, // 1196\n              //\n              /**                                                                                                                 //\n               * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.\n               * @locus Server                                                                                                    //\n               * @memberOf Subscription                                                                                           //\n               * @instance                                                                                                        //\n               * @param {Function} func The callback function                                                                     //\n               */ //\n              onStop: function onStop(callback) {\n                // 1205\n                var self = this; // 1206\n                if (self._isDeactivated()) callback();else self._stopCallbacks.push(callback); // 1207\n              }, // 1211\n              //\n              // This returns true if the sub has been deactivated, *OR* if the session was                                       //\n              // destroyed but the deferred call to _deactivateAllSubscriptions hasn't                                            //\n              // happened yet.                                                                                                    //\n              _isDeactivated: function _isDeactivated() {\n                // 1216\n                var self = this; // 1217\n                return self._deactivated || self._session.inQueue === null; // 1218\n              }, // 1219\n              //\n              /**                                                                                                                 //\n               * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.\n               * @locus Server                                                                                                    //\n               * @memberOf Subscription                                                                                           //\n               * @instance                                                                                                        //\n               * @param {String} collection The name of the collection that contains the new document.                            //\n               * @param {String} id The new document's ID.                                                                        //\n               * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.                       //\n               */ //\n              added: function added(collectionName, id, fields) {\n                // 1230\n                var self = this; // 1231\n                if (self._isDeactivated()) return; // 1232\n                id = self._idFilter.idStringify(id); // 1234\n                Meteor._ensure(self._documents, collectionName)[id] = true; // 1235\n                self._session.added(self._subscriptionHandle, collectionName, id, fields); // 1236\n              }, // 1237\n              //\n              /**                                                                                                                 //\n               * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.\n               * @locus Server                                                                                                    //\n               * @memberOf Subscription                                                                                           //\n               * @instance                                                                                                        //\n               * @param {String} collection The name of the collection that contains the changed document.                        //\n               * @param {String} id The changed document's ID.                                                                    //\n               * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.\n               */ //\n              changed: function changed(collectionName, id, fields) {\n                // 1248\n                var self = this; // 1249\n                if (self._isDeactivated()) return; // 1250\n                id = self._idFilter.idStringify(id); // 1252\n                self._session.changed(self._subscriptionHandle, collectionName, id, fields); // 1253\n              }, // 1254\n              //\n              /**                                                                                                                 //\n               * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.\n               * @locus Server                                                                                                    //\n               * @memberOf Subscription                                                                                           //\n               * @instance                                                                                                        //\n               * @param {String} collection The name of the collection that the document has been removed from.                   //\n               * @param {String} id The ID of the document that has been removed.                                                 //\n               */ //\n              removed: function removed(collectionName, id) {\n                // 1264\n                var self = this; // 1265\n                if (self._isDeactivated()) return; // 1266\n                id = self._idFilter.idStringify(id); // 1268\n                // We don't bother to delete sets of things in a collection if the                                                //\n                // collection is empty.  It could break _removeAllDocuments.                                                      //\n                delete self._documents[collectionName][id]; // 1271\n                self._session.removed(self._subscriptionHandle, collectionName, id); // 1272\n              }, // 1273\n              //\n              /**                                                                                                                 //\n               * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.\n               * @locus Server                                                                                                    //\n               * @memberOf Subscription                                                                                           //\n               * @instance                                                                                                        //\n               */ //\n              ready: function ready() {\n                // 1281\n                var self = this; // 1282\n                if (self._isDeactivated()) return; // 1283\n                if (!self._subscriptionId) return; // unnecessary but ignored for universal sub                                   // 1285\n                if (!self._ready) {\n                  // 1287\n                  self._session.sendReady([self._subscriptionId]); // 1288\n                  self._ready = true; // 1289\n                } // 1290\n              } // 1291\n            }); // 1015\n            //\n            /******************************************************************************/ //\n            /* Server                                                                     */ //\n            /******************************************************************************/ //\n            //\n            Server = function Server(options) {\n              // 1298\n              var self = this; // 1299\n              //\n              // The default heartbeat interval is 30 seconds on the server and 35                                                //\n              // seconds on the client.  Since the client doesn't need to send a                                                  //\n              // ping as long as it is receiving pings, this means that pings                                                     //\n              // normally go from the server to the client.                                                                       //\n              //                                                                                                                  //\n              // Note: Troposphere depends on the ability to mutate                                                               //\n              // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.                                           //\n              self.options = _.defaults(options || {}, { // 1308\n                heartbeatInterval: 15000, // 1309\n                heartbeatTimeout: 15000, // 1310\n                // For testing, allow responding to pings to be disabled.                                                         //\n                respondToPings: true // 1312\n              }); // 1308\n              //\n              // Map of callbacks to call when a new connection comes in to the                                                   //\n              // server and completes DDP version negotiation. Use an object instead                                              //\n              // of an array so we can safely remove one from the list while                                                      //\n              // iterating over it.                                                                                               //\n              self.onConnectionHook = new Hook({ // 1319\n                debugPrintExceptions: \"onConnection callback\" // 1320\n              }); // 1319\n              //\n              self.publish_handlers = {}; // 1323\n              self.universal_publish_handlers = []; // 1324\n              //\n              self.method_handlers = {}; // 1326\n              //\n              self.sessions = {}; // map from id to session                                                                       // 1328\n              //\n              self.stream_server = new StreamServer(); // 1330\n              //\n              self.stream_server.register(function (socket) {\n                // 1332\n                // socket implements the SockJSConnection interface                                                               //\n                socket._meteorSession = null; // 1334\n                //\n                var sendError = function sendError(reason, offendingMessage) {\n                  // 1336\n                  var msg = { msg: 'error', reason: reason }; // 1337\n                  if (offendingMessage) msg.offendingMessage = offendingMessage; // 1338\n                  socket.send(DDPCommon.stringifyDDP(msg)); // 1340\n                }; // 1341\n                //\n                socket.on('data', function (raw_msg) {\n                  // 1343\n                  if (Meteor._printReceivedDDP) {\n                    // 1344\n                    Meteor._debug(\"Received DDP\", raw_msg); // 1345\n                  } // 1346\n                  try {\n                    // 1347\n                    try {\n                      // 1348\n                      var msg = DDPCommon.parseDDP(raw_msg); // 1349\n                    } catch (err) {\n                      // 1350\n                      sendError('Parse error'); // 1351\n                      return; // 1352\n                    } // 1353\n                    if (msg === null || !msg.msg) {\n                      // 1354\n                      sendError('Bad request', msg); // 1355\n                      return; // 1356\n                    } // 1357\n                    //\n                    if (msg.msg === 'connect') {\n                      // 1359\n                      if (socket._meteorSession) {\n                        // 1360\n                        sendError(\"Already connected\", msg); // 1361\n                        return; // 1362\n                      } // 1363\n                      Fiber(function () {\n                        // 1364\n                        self._handleConnect(socket, msg); // 1365\n                      }).run(); // 1366\n                      return; // 1367\n                    } // 1368\n                    //\n                    if (!socket._meteorSession) {\n                      // 1370\n                      sendError('Must connect first', msg); // 1371\n                      return; // 1372\n                    } // 1373\n                    socket._meteorSession.processMessage(msg); // 1374\n                  } catch (e) {\n                    // 1375\n                    // XXX print stack nicely                                                                                     //\n                    Meteor._debug(\"Internal exception while processing message\", msg, e.message, e.stack); // 1377\n                  } // 1379\n                }); // 1380\n                //\n                socket.on('close', function () {\n                  // 1382\n                  if (socket._meteorSession) {\n                    // 1383\n                    Fiber(function () {\n                      // 1384\n                      socket._meteorSession.close(); // 1385\n                    }).run(); // 1386\n                  } // 1387\n                }); // 1388\n              }); // 1389\n            }; // 1390\n            //\n            _.extend(Server.prototype, { // 1392\n              //\n              /**                                                                                                                 //\n               * @summary Register a callback to be called when a new DDP connection is made to the server.                       //\n               * @locus Server                                                                                                    //\n               * @param {function} callback The function to call when a new DDP connection is established.                        //\n               * @memberOf Meteor                                                                                                 //\n               * @importFromPackage meteor                                                                                        //\n               */ //\n              onConnection: function onConnection(fn) {\n                // 1401\n                var self = this; // 1402\n                return self.onConnectionHook.register(fn); // 1403\n              }, // 1404\n              //\n              _handleConnect: function _handleConnect(socket, msg) {\n                // 1406\n                var self = this; // 1407\n                //\n                // The connect message must specify a version and an array of supported                                           //\n                // versions, and it must claim to support what it is proposing.                                                   //\n                if (!(typeof msg.version === 'string' && _.isArray(msg.support) && _.all(msg.support, _.isString) && _.contains(msg.support, msg.version))) {\n                  socket.send(DDPCommon.stringifyDDP({ msg: 'failed', // 1415\n                    version: DDPCommon.SUPPORTED_DDP_VERSIONS[0] })); // 1416\n                  socket.close(); // 1417\n                  return; // 1418\n                } // 1419\n                //\n                // In the future, handle session resumption: something like:                                                      //\n                //  socket._meteorSession = self.sessions[msg.session]                                                            //\n                var version = calculateVersion(msg.support, DDPCommon.SUPPORTED_DDP_VERSIONS); // 1423\n                //\n                if (msg.version !== version) {\n                  // 1425\n                  // The best version to use (according to the client's stated preferences)                                       //\n                  // is not the one the client is trying to use. Inform them about the best                                       //\n                  // version to use.                                                                                              //\n                  socket.send(DDPCommon.stringifyDDP({ msg: 'failed', version: version })); // 1429\n                  socket.close(); // 1430\n                  return; // 1431\n                } // 1432\n                //\n                // Yay, version matches! Create a new session.                                                                    //\n                // Note: Troposphere depends on the ability to mutate                                                             //\n                // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.                                         //\n                socket._meteorSession = new Session(self, version, socket, self.options); // 1437\n                self.sessions[socket._meteorSession.id] = socket._meteorSession; // 1438\n                self.onConnectionHook.each(function (callback) {\n                  // 1439\n                  if (socket._meteorSession) callback(socket._meteorSession.connectionHandle); // 1440\n                  return true; // 1442\n                }); // 1443\n              }, // 1444\n              /**                                                                                                                 //\n               * Register a publish handler function.                                                                             //\n               *                                                                                                                  //\n               * @param name {String} identifier for query                                                                        //\n               * @param handler {Function} publish handler                                                                        //\n               * @param options {Object}                                                                                          //\n               *                                                                                                                  //\n               * Server will call handler function on each new subscription,                                                      //\n               * either when receiving DDP sub message for a named subscription, or on                                            //\n               * DDP connect for a universal subscription.                                                                        //\n               *                                                                                                                  //\n               * If name is null, this will be a subscription that is                                                             //\n               * automatically established and permanently on for all connected                                                   //\n               * client, instead of a subscription that can be turned on and off                                                  //\n               * with subscribe().                                                                                                //\n               *                                                                                                                  //\n               * options to contain:                                                                                              //\n               *  - (mostly internal) is_auto: true if generated automatically                                                    //\n               *    from an autopublish hook. this is for cosmetic purposes only                                                  //\n               *    (it lets us determine whether to print a warning suggesting                                                   //\n               *    that you turn off autopublish.)                                                                               //\n               */ //\n              //\n              /**                                                                                                                 //\n               * @summary Publish a record set.                                                                                   //\n               * @memberOf Meteor                                                                                                 //\n               * @importFromPackage meteor                                                                                        //\n               * @locus Server                                                                                                    //\n               * @param {String|Object} name If String, name of the record set.  If Object, publications Dictionary of publish functions by name.  If `null`, the set has no name, and the record set is automatically sent to all connected clients.\n               * @param {Function} func Function called on the server each time a client subscribes.  Inside the function, `this` is the publish handler object, described below.  If the client passed arguments to `subscribe`, the function is called with the same arguments.\n               */ //\n              publish: function publish(name, handler, options) {\n                // 1476\n                var self = this; // 1477\n                //\n                if (!_.isObject(name)) {\n                  // 1479\n                  options = options || {}; // 1480\n                  //\n                  if (name && name in self.publish_handlers) {\n                    // 1482\n                    Meteor._debug(\"Ignoring duplicate publish named '\" + name + \"'\"); // 1483\n                    return; // 1484\n                  } // 1485\n                  //\n                  if (Package.autopublish && !options.is_auto) {\n                    // 1487\n                    // They have autopublish on, yet they're trying to manually                                                   //\n                    // picking stuff to publish. They probably should turn off                                                    //\n                    // autopublish. (This check isn't perfect -- if you create a                                                  //\n                    // publish before you turn on autopublish, it won't catch                                                     //\n                    // it. But this will definitely handle the simple case where                                                  //\n                    // you've added the autopublish package to your app, and are                                                  //\n                    // calling publish from your app code.)                                                                       //\n                    if (!self.warned_about_autopublish) {\n                      // 1495\n                      self.warned_about_autopublish = true; // 1496\n                      Meteor._debug(\"** You've set up some data subscriptions with Meteor.publish(), but\\n\" + \"** you still have autopublish turned on. Because autopublish is still\\n\" + \"** on, your Meteor.publish() calls won't have much effect. All data\\n\" + \"** will still be sent to all clients.\\n\" + \"**\\n\" + \"** Turn off autopublish by removing the autopublish package:\\n\" + \"**\\n\" + \"**   $ meteor remove autopublish\\n\" + \"**\\n\" + \"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\n\" + \"** for each collection that you want clients to see.\\n\");\n                    } // 1509\n                  } // 1510\n                  //\n                  if (name) self.publish_handlers[name] = handler;else {\n                    // 1512\n                    self.universal_publish_handlers.push(handler); // 1515\n                    // Spin up the new publisher on any existing session too. Run each                                            //\n                    // session's subscription in a new Fiber, so that there's no change for                                       //\n                    // self.sessions to change while we're running this loop.                                                     //\n                    _.each(self.sessions, function (session) {\n                      // 1519\n                      if (!session._dontStartNewUniversalSubs) {\n                        // 1520\n                        Fiber(function () {\n                          // 1521\n                          session._startSubscription(handler); // 1522\n                        }).run(); // 1523\n                      } // 1524\n                    }); // 1525\n                  } // 1526\n                } else {\n                    // 1527\n                    _.each(name, function (value, key) {\n                      // 1529\n                      self.publish(key, value, {}); // 1530\n                    }); // 1531\n                  } // 1532\n              }, // 1533\n              //\n              _removeSession: function _removeSession(session) {\n                // 1535\n                var self = this; // 1536\n                if (self.sessions[session.id]) {\n                  // 1537\n                  delete self.sessions[session.id]; // 1538\n                } // 1539\n              }, // 1540\n              //\n              /**                                                                                                                 //\n               * @summary Defines functions that can be invoked over the network by clients.                                      //\n               * @locus Anywhere                                                                                                  //\n               * @param {Object} methods Dictionary whose keys are method names and values are functions.                         //\n               * @memberOf Meteor                                                                                                 //\n               * @importFromPackage meteor                                                                                        //\n               */ //\n              methods: function methods(_methods) {\n                // 1549\n                var self = this; // 1550\n                _.each(_methods, function (func, name) {\n                  // 1551\n                  if (typeof func !== 'function') throw new Error(\"Method '\" + name + \"' must be a function\"); // 1552\n                  if (self.method_handlers[name]) throw new Error(\"A method named '\" + name + \"' is already defined\"); // 1554\n                  self.method_handlers[name] = func; // 1556\n                }); // 1557\n              }, // 1558\n              //\n              call: function call(name /*, arguments */) {\n                // 1560\n                // if it's a function, the last argument is the result callback,                                                  //\n                // not a parameter to the remote method.                                                                          //\n                var args = Array.prototype.slice.call(arguments, 1); // 1563\n                if (args.length && typeof args[args.length - 1] === \"function\") var callback = args.pop(); // 1564\n                return this.apply(name, args, callback); // 1566\n              }, // 1567\n              //\n              // @param options {Optional Object}                                                                                 //\n              // @param callback {Optional Function}                                                                              //\n              apply: function apply(name, args, options, callback) {\n                // 1571\n                var self = this; // 1572\n                //\n                // We were passed 3 arguments. They may be either (name, args, options)                                           //\n                // or (name, args, callback)                                                                                      //\n                if (!callback && typeof options === 'function') {\n                  // 1576\n                  callback = options; // 1577\n                  options = {}; // 1578\n                } // 1579\n                options = options || {}; // 1580\n                //\n                if (callback) // 1582\n                  // It's not really necessary to do this, since we immediately                                                   //\n                  // run the callback in this fiber before returning, but we do it                                                //\n                  // anyway for regularity.                                                                                       //\n                  // XXX improve error message (and how we report it)                                                             //\n                  callback = Meteor.bindEnvironment(callback, \"delivering result of invoking '\" + name + \"'\"); // 1587\n                //\n                // Run the handler                                                                                                //\n                var handler = self.method_handlers[name]; // 1593\n                var exception; // 1594\n                if (!handler) {\n                  // 1595\n                  exception = new Meteor.Error(404, \"Method '\" + name + \"' not found\"); // 1596\n                } else {\n                    // 1597\n                    // If this is a method call from within another method, get the                                                 //\n                    // user state from the outer method, otherwise don't allow                                                      //\n                    // setUserId to be called                                                                                       //\n                    var userId = null; // 1601\n                    var setUserId = function setUserId() {\n                      // 1602\n                      throw new Error(\"Can't call setUserId on a server initiated method call\"); // 1603\n                    }; // 1604\n                    var connection = null; // 1605\n                    var currentInvocation = DDP._CurrentInvocation.get(); // 1606\n                    if (currentInvocation) {\n                      // 1607\n                      userId = currentInvocation.userId; // 1608\n                      setUserId = function setUserId(userId) {\n                        // 1609\n                        currentInvocation.setUserId(userId); // 1610\n                      }; // 1611\n                      connection = currentInvocation.connection; // 1612\n                    } // 1613\n                    //\n                    var invocation = new DDPCommon.MethodInvocation({ // 1615\n                      isSimulation: false, // 1616\n                      userId: userId, // 1617\n                      setUserId: setUserId, // 1618\n                      connection: connection, // 1619\n                      randomSeed: DDPCommon.makeRpcSeed(currentInvocation, name) // 1620\n                    }); // 1615\n                    try {\n                      // 1622\n                      var result = DDP._CurrentInvocation.withValue(invocation, function () {\n                        // 1623\n                        return maybeAuditArgumentChecks(handler, invocation, EJSON.clone(args), \"internal call to '\" + name + \"'\");\n                      }); // 1627\n                      result = EJSON.clone(result); // 1628\n                    } catch (e) {\n                      // 1629\n                      exception = e; // 1630\n                    } // 1631\n                  } // 1632\n                //\n                // Return the result in whichever way the caller asked for it. Note that we                                       //\n                // do NOT block on the write fence in an analogous way to how the client                                          //\n                // blocks on the relevant data being visible, so you are NOT guaranteed that                                      //\n                // cursor observe callbacks have fired when your callback is invoked. (We                                         //\n                // can change this if there's a real use case.)                                                                   //\n                if (callback) {\n                  // 1639\n                  callback(exception, result); // 1640\n                  return undefined; // 1641\n                } // 1642\n                if (exception) throw exception; // 1643\n                return result; // 1645\n              }, // 1646\n              //\n              _urlForSession: function _urlForSession(sessionId) {\n                // 1648\n                var self = this; // 1649\n                var session = self.sessions[sessionId]; // 1650\n                if (session) return session._socketUrl;else return null; // 1651\n              } // 1655\n            }); // 1392\n            //\n            var calculateVersion = function calculateVersion(clientSupportedVersions, serverSupportedVersions) {\n              // 1658\n              var correctVersion = _.find(clientSupportedVersions, function (version) {\n                // 1660\n                return _.contains(serverSupportedVersions, version); // 1661\n              }); // 1662\n              if (!correctVersion) {\n                // 1663\n                correctVersion = serverSupportedVersions[0]; // 1664\n              } // 1665\n              return correctVersion; // 1666\n            }; // 1667\n            //\n            DDPServer._calculateVersion = calculateVersion; // 1669\n            //\n            // \"blind\" exceptions other than those that were deliberately thrown to signal                                        //\n            // errors to the client                                                                                               //\n            var wrapInternalException = function wrapInternalException(exception, context) {\n              // 1674\n              if (!exception || exception instanceof Meteor.Error) return exception; // 1675\n              //\n              // tests can set the 'expected' flag on an exception so it won't go to the                                          //\n              // server log                                                                                                       //\n              if (!exception.expected) {\n                // 1680\n                Meteor._debug(\"Exception \" + context, exception.stack); // 1681\n                if (exception.sanitizedError) {\n                  // 1682\n                  Meteor._debug(\"Sanitized and reported to the client as:\", exception.sanitizedError.message); // 1683\n                  Meteor._debug(); // 1684\n                } // 1685\n              } // 1686\n              //\n              // Did the error contain more details that could have been useful if caught in                                      //\n              // server code (or if thrown from non-client-originated code), but also                                             //\n              // provided a \"sanitized\" version with more context than 500 Internal server                                        //\n              // error? Use that.                                                                                                 //\n              if (exception.sanitizedError) {\n                // 1692\n                if (exception.sanitizedError instanceof Meteor.Error) return exception.sanitizedError; // 1693\n                Meteor._debug(\"Exception \" + context + \" provides a sanitizedError that \" + \"is not a Meteor.Error; ignoring\"); // 1695\n              } // 1697\n              //\n              return new Meteor.Error(500, \"Internal server error\"); // 1699\n            }; // 1700\n            //\n            // Audit argument checks, if the audit-argument-checks package exists (it is a                                        //\n            // weak dependency of this package).                                                                                  //\n            var maybeAuditArgumentChecks = function maybeAuditArgumentChecks(f, context, args, description) {\n              // 1705\n              args = args || []; // 1706\n              if (Package['audit-argument-checks']) {\n                // 1707\n                return Match._failIfArgumentsAreNotAllChecked(f, context, args, description); // 1708\n              } // 1710\n              return f.apply(context, args); // 1711\n            }; // 1712\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }], \"writefence.js\": function writefenceJs(require) {\n\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/ddp-server/writefence.js                                                                                  //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            var path = Npm.require('path'); // 1\n            var Future = Npm.require(path.join('fibers', 'future')); // 2\n            //\n            // A write fence collects a group of writes, and provides a callback                                                  //\n            // when all of the writes are fully committed and propagated (all                                                     //\n            // observers have been notified of the write and acknowledged it.)                                                    //\n            //                                                                                                                    //\n            DDPServer._WriteFence = function () {\n              // 8\n              var self = this; // 9\n              //\n              self.armed = false; // 11\n              self.fired = false; // 12\n              self.retired = false; // 13\n              self.outstanding_writes = 0; // 14\n              self.before_fire_callbacks = []; // 15\n              self.completion_callbacks = []; // 16\n            }; // 17\n            //\n            // The current write fence. When there is a current write fence, code                                                 //\n            // that writes to databases should register their writes with it using                                                //\n            // beginWrite().                                                                                                      //\n            //                                                                                                                    //\n            DDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable(); // 23\n            //\n            _.extend(DDPServer._WriteFence.prototype, { // 25\n              // Start tracking a write, and return an object to represent it. The                                                //\n              // object has a single method, committed(). This method should be                                                   //\n              // called when the write is fully committed and propagated. You can                                                 //\n              // continue to add writes to the WriteFence up until it is triggered                                                //\n              // (calls its callbacks because all writes have committed.)                                                         //\n              beginWrite: function beginWrite() {\n                // 31\n                var self = this; // 32\n                //\n                if (self.retired) return { committed: function committed() {} }; // 34\n                //\n                if (self.fired) throw new Error(\"fence has already activated -- too late to add writes\"); // 37\n                //\n                self.outstanding_writes++; // 40\n                var _committed = false; // 41\n                return { // 42\n                  committed: function committed() {\n                    // 43\n                    if (_committed) throw new Error(\"committed called twice on the same write\"); // 44\n                    _committed = true; // 46\n                    self.outstanding_writes--; // 47\n                    self._maybeFire(); // 48\n                  } // 49\n                }; // 42\n              }, // 51\n              //\n              // Arm the fence. Once the fence is armed, and there are no more                                                    //\n              // uncommitted writes, it will activate.                                                                            //\n              arm: function arm() {\n                // 55\n                var self = this; // 56\n                if (self === DDPServer._CurrentWriteFence.get()) throw Error(\"Can't arm the current fence\"); // 57\n                self.armed = true; // 59\n                self._maybeFire(); // 60\n              }, // 61\n              //\n              // Register a function to be called once before firing the fence.                                                   //\n              // Callback function can add new writes to the fence, in which case                                                 //\n              // it won't fire until those writes are done as well.                                                               //\n              onBeforeFire: function onBeforeFire(func) {\n                // 66\n                var self = this; // 67\n                if (self.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\"); // 68\n                self.before_fire_callbacks.push(func); // 71\n              }, // 72\n              //\n              // Register a function to be called when the fence fires.                                                           //\n              onAllCommitted: function onAllCommitted(func) {\n                // 75\n                var self = this; // 76\n                if (self.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\"); // 77\n                self.completion_callbacks.push(func); // 80\n              }, // 81\n              //\n              // Convenience function. Arms the fence, then blocks until it fires.                                                //\n              armAndWait: function armAndWait() {\n                // 84\n                var self = this; // 85\n                var future = new Future(); // 86\n                self.onAllCommitted(function () {\n                  // 87\n                  future['return'](); // 88\n                }); // 89\n                self.arm(); // 90\n                future.wait(); // 91\n              }, // 92\n              //\n              _maybeFire: function _maybeFire() {\n                // 94\n                var self = this; // 95\n                if (self.fired) throw new Error(\"write fence already activated?\"); // 96\n                if (self.armed && !self.outstanding_writes) {\n                  // 98\n                  var invokeCallback = function invokeCallback(func) {\n                    // 98\n                    try {\n                      // 100\n                      func(self); // 101\n                    } catch (err) {\n                      // 102\n                      Meteor._debug(\"exception in write fence callback:\", err); // 103\n                    } // 104\n                  }; // 105\n                  //\n                  self.outstanding_writes++; // 107\n                  while (self.before_fire_callbacks.length > 0) {\n                    // 108\n                    var callbacks = self.before_fire_callbacks; // 109\n                    self.before_fire_callbacks = []; // 110\n                    _.each(callbacks, invokeCallback); // 111\n                  } // 112\n                  self.outstanding_writes--; // 113\n                  //\n                  if (!self.outstanding_writes) {\n                    // 115\n                    self.fired = true; // 116\n                    var callbacks = self.completion_callbacks; // 117\n                    self.completion_callbacks = []; // 118\n                    _.each(callbacks, invokeCallback); // 119\n                  } // 120\n                } // 121\n              }, // 122\n              //\n              // Deactivate this fence so that adding more writes has no effect.                                                  //\n              // The fence must have already fired.                                                                               //\n              retire: function retire() {\n                // 126\n                var self = this; // 127\n                if (!self.fired) throw new Error(\"Can't retire a fence that hasn't fired.\"); // 128\n                self.retired = true; // 130\n              } // 131\n            }); // 25\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }, \"crossbar.js\": function crossbarJs() {\n\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/ddp-server/crossbar.js                                                                                    //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            // A \"crossbar\" is a class that provides structured notification registration.                                        //\n            // See _match for the definition of how a notification matches a trigger.                                             //\n            // All notifications and triggers must have a string key named 'collection'.                                          //\n            //\n            DDPServer._Crossbar = function (options) {\n              // 5\n              var self = this; // 6\n              options = options || {}; // 7\n              //\n              self.nextId = 1; // 9\n              // map from collection name (string) -> listener id -> object. each object has                                      //\n              // keys 'trigger', 'callback'.  As a hack, the empty string means \"no                                               //\n              // collection\".                                                                                                     //\n              self.listenersByCollection = {}; // 13\n              self.factPackage = options.factPackage || \"livedata\"; // 14\n              self.factName = options.factName || null; // 15\n            }; // 16\n            //\n            _.extend(DDPServer._Crossbar.prototype, { // 18\n              // msg is a trigger or a notification                                                                               //\n              _collectionForMessage: function _collectionForMessage(msg) {\n                // 20\n                var self = this; // 21\n                if (!_.has(msg, 'collection')) {\n                  // 22\n                  return ''; // 23\n                } else if (typeof msg.collection === 'string') {\n                    // 24\n                    if (msg.collection === '') throw Error(\"Message has empty collection!\"); // 25\n                    return msg.collection; // 27\n                  } else {\n                      // 28\n                      throw Error(\"Message has non-string collection!\"); // 29\n                    } // 30\n              }, // 31\n              //\n              // Listen for notification that match 'trigger'. A notification                                                     //\n              // matches if it has the key-value pairs in trigger as a                                                            //\n              // subset. When a notification matches, call 'callback', passing                                                    //\n              // the actual notification.                                                                                         //\n              //                                                                                                                  //\n              // Returns a listen handle, which is an object with a method                                                        //\n              // stop(). Call stop() to stop listening.                                                                           //\n              //                                                                                                                  //\n              // XXX It should be legal to call fire() from inside a listen()                                                     //\n              // callback?                                                                                                        //\n              listen: function listen(trigger, callback) {\n                // 43\n                var self = this; // 44\n                var id = self.nextId++; // 45\n                //\n                var collection = self._collectionForMessage(trigger); // 47\n                var record = { trigger: EJSON.clone(trigger), callback: callback }; // 48\n                if (!_.has(self.listenersByCollection, collection)) {\n                  // 49\n                  self.listenersByCollection[collection] = {}; // 50\n                } // 51\n                self.listenersByCollection[collection][id] = record; // 52\n                //\n                if (self.factName && Package.facts) {\n                  // 54\n                  Package.facts.Facts.incrementServerFact(self.factPackage, self.factName, 1); // 55\n                } // 57\n                //\n                return { // 59\n                  stop: function stop() {\n                    // 60\n                    if (self.factName && Package.facts) {\n                      // 61\n                      Package.facts.Facts.incrementServerFact(self.factPackage, self.factName, -1); // 62\n                    } // 64\n                    delete self.listenersByCollection[collection][id]; // 65\n                    if (_.isEmpty(self.listenersByCollection[collection])) {\n                      // 66\n                      delete self.listenersByCollection[collection]; // 67\n                    } // 68\n                  } // 69\n                }; // 59\n              }, // 71\n              //\n              // Fire the provided 'notification' (an object whose attribute                                                      //\n              // values are all JSON-compatibile) -- inform all matching listeners                                                //\n              // (registered with listen()).                                                                                      //\n              //                                                                                                                  //\n              // If fire() is called inside a write fence, then each of the                                                       //\n              // listener callbacks will be called inside the write fence as well.                                                //\n              //                                                                                                                  //\n              // The listeners may be invoked in parallel, rather than serially.                                                  //\n              fire: function fire(notification) {\n                // 81\n                var self = this; // 82\n                //\n                var collection = self._collectionForMessage(notification); // 84\n                //\n                if (!_.has(self.listenersByCollection, collection)) {\n                  // 86\n                  return; // 87\n                } // 88\n                //\n                var listenersForCollection = self.listenersByCollection[collection]; // 90\n                var callbackIds = []; // 91\n                _.each(listenersForCollection, function (l, id) {\n                  // 92\n                  if (self._matches(notification, l.trigger)) {\n                    // 93\n                    callbackIds.push(id); // 94\n                  } // 95\n                }); // 96\n                //\n                // Listener callbacks can yield, so we need to first find all the ones that                                       //\n                // match in a single iteration over self.listenersByCollection (which can't                                       //\n                // be mutated during this iteration), and then invoke the matching                                                //\n                // callbacks, checking before each call to ensure they haven't stopped.                                           //\n                // Note that we don't have to check that                                                                          //\n                // self.listenersByCollection[collection] still === listenersForCollection,                                       //\n                // because the only way that stops being true is if listenersForCollection                                        //\n                // first gets reduced down to the empty object (and then never gets                                               //\n                // increased again).                                                                                              //\n                _.each(callbackIds, function (id) {\n                  // 107\n                  if (_.has(listenersForCollection, id)) {\n                    // 108\n                    listenersForCollection[id].callback(notification); // 109\n                  } // 110\n                }); // 111\n              }, // 112\n              //\n              // A notification matches a trigger if all keys that exist in both are equal.                                       //\n              //                                                                                                                  //\n              // Examples:                                                                                                        //\n              //  N:{collection: \"C\"} matches T:{collection: \"C\"}                                                                 //\n              //    (a non-targeted write to a collection matches a                                                               //\n              //     non-targeted query)                                                                                          //\n              //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\"}                                                        //\n              //    (a targeted write to a collection matches a non-targeted query)                                               //\n              //  N:{collection: \"C\"} matches T:{collection: \"C\", id: \"X\"}                                                        //\n              //    (a non-targeted write to a collection matches a                                                               //\n              //     targeted query)                                                                                              //\n              //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\", id: \"X\"}                                               //\n              //    (a targeted write to a collection matches a targeted query targeted                                           //\n              //     at the same document)                                                                                        //\n              //  N:{collection: \"C\", id: \"X\"} does not match T:{collection: \"C\", id: \"Y\"}                                        //\n              //    (a targeted write to a collection does not match a targeted query                                             //\n              //     targeted at a different document)                                                                            //\n              _matches: function _matches(notification, trigger) {\n                // 131\n                // Most notifications that use the crossbar have a string `collection` and                                        //\n                // maybe an `id` that is a string or ObjectID. We're already dividing up                                          //\n                // triggers by collection, but let's fast-track \"nope, different ID\" (and                                         //\n                // avoid the overly generic EJSON.equals). This makes a noticeable                                                //\n                // performance difference; see https://github.com/meteor/meteor/pull/3697                                         //\n                if (typeof notification.id === 'string' && typeof trigger.id === 'string' && notification.id !== trigger.id) {\n                  // 137\n                  return false; // 140\n                } // 141\n                if (notification.id instanceof MongoID.ObjectID && trigger.id instanceof MongoID.ObjectID && !notification.id.equals(trigger.id)) {\n                  return false; // 145\n                } // 146\n                //\n                return _.all(trigger, function (triggerValue, key) {\n                  // 148\n                  return !_.has(notification, key) || EJSON.equals(triggerValue, notification[key]); // 149\n                }); // 151\n              } // 152\n            }); // 18\n            //\n            // The \"invalidation crossbar\" is a specific instance used by the DDP server to                                       //\n            // implement write fence notifications. Listener callbacks on this crossbar                                           //\n            // should call beginWrite on the current write fence before they return, if they                                      //\n            // want to delay the write fence from firing (ie, the DDP method-data-updated                                         //\n            // message from being sent).                                                                                          //\n            DDPServer._InvalidationCrossbar = new DDPServer._Crossbar({ // 160\n              factName: \"invalidation-crossbar-listeners\" // 161\n            }); // 160\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }, \"server_convenience.js\": function server_convenienceJs() {\n\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/ddp-server/server_convenience.js                                                                          //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            if (process.env.DDP_DEFAULT_CONNECTION_URL) {\n              // 1\n              __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL = process.env.DDP_DEFAULT_CONNECTION_URL; // 2\n            } // 4\n            //\n            Meteor.server = new Server(); // 6\n            //\n            Meteor.refresh = function (notification) {\n              // 8\n              DDPServer._InvalidationCrossbar.fire(notification); // 9\n            }; // 10\n            //\n            // Proxy the public methods of Meteor.server so they can                                                              //\n            // be called directly on Meteor.                                                                                      //\n            _.each(['publish', 'methods', 'call', 'apply', 'onConnection'], function (name) {\n              // 14\n              Meteor[name] = _.bind(Meteor.server[name], Meteor.server); // 16\n            }); // 17\n            //\n            // Meteor.server used to be called Meteor.default_server. Provide                                                     //\n            // backcompat as a courtesy even though it was never documented.                                                      //\n            // XXX COMPAT WITH 0.6.4                                                                                              //\n            Meteor.default_server = Meteor.server; // 22\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          } } } } }, { \"extensions\": [\".js\", \".json\"] });\n  require(\"./node_modules/meteor/ddp-server/stream_server.js\");\n  require(\"./node_modules/meteor/ddp-server/livedata_server.js\");\n  require(\"./node_modules/meteor/ddp-server/writefence.js\");\n  require(\"./node_modules/meteor/ddp-server/crossbar.js\");\n  require(\"./node_modules/meteor/ddp-server/server_convenience.js\");\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package['ddp-server'] = {}, {\n    DDPServer: DDPServer\n  });\n})();\n\n//# sourceMappingURL=ddp-server.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/ddp-server.js"],"names":[],"mappings":"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","file":"/bundle/programs/server/packages/ddp-server.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar Random = Package.random.Random;\nvar EJSON = Package.ejson.EJSON;\nvar _ = Package.underscore._;\nvar Retry = Package.retry.Retry;\nvar MongoID = Package['mongo-id'].MongoID;\nvar DiffSequence = Package['diff-sequence'].DiffSequence;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar DDPCommon = Package['ddp-common'].DDPCommon;\nvar DDP = Package['ddp-client'].DDP;\nvar WebApp = Package.webapp.WebApp;\nvar main = Package.webapp.main;\nvar WebAppInternals = Package.webapp.WebAppInternals;\nvar RoutePolicy = Package.routepolicy.RoutePolicy;\nvar Hook = Package['callback-hook'].Hook;\nvar LocalCollection = Package.minimongo.LocalCollection;\nvar Minimongo = Package.minimongo.Minimongo;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Buffer = Package.modules.Buffer;\nvar process = Package.modules.process;\nvar Symbol = Package['ecmascript-runtime'].Symbol;\nvar Map = Package['ecmascript-runtime'].Map;\nvar Set = Package['ecmascript-runtime'].Set;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar StreamServer, DDPServer, Server;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"ddp-server\":{\"stream_server.js\":function(require){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/ddp-server/stream_server.js                                                                               //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nvar url = Npm.require('url');                                                                                         // 1\n                                                                                                                      //\n// By default, we use the permessage-deflate extension with default                                                   //\n// configuration. If $SERVER_WEBSOCKET_COMPRESSION is set, then it must be valid                                      //\n// JSON. If it represents a falsey value, then we do not use permessage-deflate                                       //\n// at all; otherwise, the JSON value is used as an argument to deflate's                                              //\n// configure method; see                                                                                              //\n// https://github.com/faye/permessage-deflate-node/blob/master/README.md                                              //\n//                                                                                                                    //\n// (We do this in an _.once instead of at startup, because we don't want to                                           //\n// crash the tool during isopacket load if your JSON doesn't parse. This is only                                      //\n// a problem because the tool has to load the DDP server code just in order to                                        //\n// be a DDP client; see https://github.com/meteor/meteor/issues/3452 .)                                               //\nvar websocketExtensions = _.once(function () {                                                                        // 14\n  var extensions = [];                                                                                                // 15\n                                                                                                                      //\n  var websocketCompressionConfig = process.env.SERVER_WEBSOCKET_COMPRESSION ? JSON.parse(process.env.SERVER_WEBSOCKET_COMPRESSION) : {};\n  if (websocketCompressionConfig) {                                                                                   // 19\n    extensions.push(Npm.require('permessage-deflate').configure(websocketCompressionConfig));                         // 20\n  }                                                                                                                   // 23\n                                                                                                                      //\n  return extensions;                                                                                                  // 25\n});                                                                                                                   // 26\n                                                                                                                      //\nvar pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || \"\";                                                // 28\n                                                                                                                      //\nStreamServer = function StreamServer() {                                                                              // 30\n  var self = this;                                                                                                    // 31\n  self.registration_callbacks = [];                                                                                   // 32\n  self.open_sockets = [];                                                                                             // 33\n                                                                                                                      //\n  // Because we are installing directly onto WebApp.httpServer instead of using                                       //\n  // WebApp.app, we have to process the path prefix ourselves.                                                        //\n  self.prefix = pathPrefix + '/sockjs';                                                                               // 37\n  RoutePolicy.declare(self.prefix + '/', 'network');                                                                  // 38\n                                                                                                                      //\n  // set up sockjs                                                                                                    //\n  var sockjs = Npm.require('sockjs');                                                                                 // 41\n  var serverOptions = {                                                                                               // 42\n    prefix: self.prefix,                                                                                              // 43\n    log: function log() {},                                                                                           // 44\n    // this is the default, but we code it explicitly because we depend                                               //\n    // on it in stream_client:HEARTBEAT_TIMEOUT                                                                       //\n    heartbeat_delay: 45000,                                                                                           // 47\n    // The default disconnect_delay is 5 seconds, but if the server ends up CPU                                       //\n    // bound for that much time, SockJS might not notice that the user has                                            //\n    // reconnected because the timer (of disconnect_delay ms) can fire before                                         //\n    // SockJS processes the new connection. Eventually we'll fix this by not                                          //\n    // combining CPU-heavy processing with SockJS termination (eg a proxy which                                       //\n    // converts to Unix sockets) but for now, raise the delay.                                                        //\n    disconnect_delay: 60 * 1000,                                                                                      // 54\n    // Set the USE_JSESSIONID environment variable to enable setting the                                              //\n    // JSESSIONID cookie. This is useful for setting up proxies with                                                  //\n    // session affinity.                                                                                              //\n    jsessionid: !!process.env.USE_JSESSIONID                                                                          // 58\n  };                                                                                                                  // 42\n                                                                                                                      //\n  // If you know your server environment (eg, proxies) will prevent websockets                                        //\n  // from ever working, set $DISABLE_WEBSOCKETS and SockJS clients (ie,                                               //\n  // browsers) will not waste time attempting to use them.                                                            //\n  // (Your server will still have a /websocket endpoint.)                                                             //\n  if (process.env.DISABLE_WEBSOCKETS) {                                                                               // 65\n    serverOptions.websocket = false;                                                                                  // 66\n  } else {                                                                                                            // 67\n    serverOptions.faye_server_options = {                                                                             // 68\n      extensions: websocketExtensions()                                                                               // 69\n    };                                                                                                                // 68\n  }                                                                                                                   // 71\n                                                                                                                      //\n  self.server = sockjs.createServer(serverOptions);                                                                   // 73\n                                                                                                                      //\n  // Install the sockjs handlers, but we want to keep around our own particular                                       //\n  // request handler that adjusts idle timeouts while we have an outstanding                                          //\n  // request.  This compensates for the fact that sockjs removes all listeners                                        //\n  // for \"request\" to add its own.                                                                                    //\n  WebApp.httpServer.removeListener('request', WebApp._timeoutAdjustmentRequestCallback);                              // 79\n  self.server.installHandlers(WebApp.httpServer);                                                                     // 81\n  WebApp.httpServer.addListener('request', WebApp._timeoutAdjustmentRequestCallback);                                 // 82\n                                                                                                                      //\n  // Support the /websocket endpoint                                                                                  //\n  self._redirectWebsocketEndpoint();                                                                                  // 86\n                                                                                                                      //\n  self.server.on('connection', function (socket) {                                                                    // 88\n    socket.send = function (data) {                                                                                   // 89\n      socket.write(data);                                                                                             // 90\n    };                                                                                                                // 91\n    socket.on('close', function () {                                                                                  // 92\n      self.open_sockets = _.without(self.open_sockets, socket);                                                       // 93\n    });                                                                                                               // 94\n    self.open_sockets.push(socket);                                                                                   // 95\n                                                                                                                      //\n    // XXX COMPAT WITH 0.6.6. Send the old style welcome message, which                                               //\n    // will force old clients to reload. Remove this once we're not                                                   //\n    // concerned about people upgrading from a pre-0.7.0 release. Also,                                               //\n    // remove the clause in the client that ignores the welcome message                                               //\n    // (livedata_connection.js)                                                                                       //\n    socket.send(JSON.stringify({ server_id: \"0\" }));                                                                  // 102\n                                                                                                                      //\n    // call all our callbacks when we get a new socket. they will do the                                              //\n    // work of setting up handlers and such for specific messages.                                                    //\n    _.each(self.registration_callbacks, function (callback) {                                                         // 106\n      callback(socket);                                                                                               // 107\n    });                                                                                                               // 108\n  });                                                                                                                 // 109\n};                                                                                                                    // 111\n                                                                                                                      //\n_.extend(StreamServer.prototype, {                                                                                    // 113\n  // call my callback when a new socket connects.                                                                     //\n  // also call it for all current connections.                                                                        //\n  register: function register(callback) {                                                                             // 116\n    var self = this;                                                                                                  // 117\n    self.registration_callbacks.push(callback);                                                                       // 118\n    _.each(self.all_sockets(), function (socket) {                                                                    // 119\n      callback(socket);                                                                                               // 120\n    });                                                                                                               // 121\n  },                                                                                                                  // 122\n                                                                                                                      //\n  // get a list of all sockets                                                                                        //\n  all_sockets: function all_sockets() {                                                                               // 125\n    var self = this;                                                                                                  // 126\n    return _.values(self.open_sockets);                                                                               // 127\n  },                                                                                                                  // 128\n                                                                                                                      //\n  // Redirect /websocket to /sockjs/websocket in order to not expose                                                  //\n  // sockjs to clients that want to use raw websockets                                                                //\n  _redirectWebsocketEndpoint: function _redirectWebsocketEndpoint() {                                                 // 132\n    var self = this;                                                                                                  // 133\n    // Unfortunately we can't use a connect middleware here since                                                     //\n    // sockjs installs itself prior to all existing listeners                                                         //\n    // (meaning prior to any connect middlewares) so we need to take                                                  //\n    // an approach similar to overshadowListeners in                                                                  //\n    // https://github.com/sockjs/sockjs-node/blob/cf820c55af6a9953e16558555a31decea554f70e/src/utils.coffee           //\n    _.each(['request', 'upgrade'], function (event) {                                                                 // 139\n      var httpServer = WebApp.httpServer;                                                                             // 140\n      var oldHttpServerListeners = httpServer.listeners(event).slice(0);                                              // 141\n      httpServer.removeAllListeners(event);                                                                           // 142\n                                                                                                                      //\n      // request and upgrade have different arguments passed but                                                      //\n      // we only care about the first one which is always request                                                     //\n      var newListener = function newListener(request /*, moreArguments */) {                                          // 146\n        // Store arguments for use within the closure below                                                           //\n        var args = arguments;                                                                                         // 148\n                                                                                                                      //\n        // Rewrite /websocket and /websocket/ urls to /sockjs/websocket while                                         //\n        // preserving query string.                                                                                   //\n        var parsedUrl = url.parse(request.url);                                                                       // 152\n        if (parsedUrl.pathname === pathPrefix + '/websocket' || parsedUrl.pathname === pathPrefix + '/websocket/') {  // 153\n          parsedUrl.pathname = self.prefix + '/websocket';                                                            // 155\n          request.url = url.format(parsedUrl);                                                                        // 156\n        }                                                                                                             // 157\n        _.each(oldHttpServerListeners, function (oldListener) {                                                       // 158\n          oldListener.apply(httpServer, args);                                                                        // 159\n        });                                                                                                           // 160\n      };                                                                                                              // 161\n      httpServer.addListener(event, newListener);                                                                     // 162\n    });                                                                                                               // 163\n  }                                                                                                                   // 164\n});                                                                                                                   // 113\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"livedata_server.js\":[\"babel-runtime/helpers/typeof\",function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/ddp-server/livedata_server.js                                                                             //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nvar _typeof;module.import(\"babel-runtime/helpers/typeof\",{\"default\":function(v){_typeof=v}});                         //\nDDPServer = {};                                                                                                       // 1\n                                                                                                                      //\nvar Fiber = Npm.require('fibers');                                                                                    // 3\n                                                                                                                      //\n// This file contains classes:                                                                                        //\n// * Session - The server's connection to a single DDP client                                                         //\n// * Subscription - A single subscription for a single client                                                         //\n// * Server - An entire server that may talk to > 1 client. A DDP endpoint.                                           //\n//                                                                                                                    //\n// Session and Subscription are file scope. For now, until we freeze                                                  //\n// the interface, Server is package scope (in the future it should be                                                 //\n// exported.)                                                                                                         //\n                                                                                                                      //\n// Represents a single document in a SessionCollectionView                                                            //\nvar SessionDocumentView = function SessionDocumentView() {                                                            // 15\n  var self = this;                                                                                                    // 16\n  self.existsIn = {}; // set of subscriptionHandle                                                                    // 17\n  self.dataByKey = {}; // key-> [ {subscriptionHandle, value} by precedence]                                          // 18\n};                                                                                                                    // 19\n                                                                                                                      //\nDDPServer._SessionDocumentView = SessionDocumentView;                                                                 // 21\n                                                                                                                      //\n_.extend(SessionDocumentView.prototype, {                                                                             // 24\n                                                                                                                      //\n  getFields: function getFields() {                                                                                   // 26\n    var self = this;                                                                                                  // 27\n    var ret = {};                                                                                                     // 28\n    _.each(self.dataByKey, function (precedenceList, key) {                                                           // 29\n      ret[key] = precedenceList[0].value;                                                                             // 30\n    });                                                                                                               // 31\n    return ret;                                                                                                       // 32\n  },                                                                                                                  // 33\n                                                                                                                      //\n  clearField: function clearField(subscriptionHandle, key, changeCollector) {                                         // 35\n    var self = this;                                                                                                  // 36\n    // Publish API ignores _id if present in fields                                                                   //\n    if (key === \"_id\") return;                                                                                        // 38\n    var precedenceList = self.dataByKey[key];                                                                         // 40\n                                                                                                                      //\n    // It's okay to clear fields that didn't exist. No need to throw                                                  //\n    // an error.                                                                                                      //\n    if (!precedenceList) return;                                                                                      // 44\n                                                                                                                      //\n    var removedValue = undefined;                                                                                     // 47\n    for (var i = 0; i < precedenceList.length; i++) {                                                                 // 48\n      var precedence = precedenceList[i];                                                                             // 49\n      if (precedence.subscriptionHandle === subscriptionHandle) {                                                     // 50\n        // The view's value can only change if this subscription is the one that                                      //\n        // used to have precedence.                                                                                   //\n        if (i === 0) removedValue = precedence.value;                                                                 // 53\n        precedenceList.splice(i, 1);                                                                                  // 55\n        break;                                                                                                        // 56\n      }                                                                                                               // 57\n    }                                                                                                                 // 58\n    if (_.isEmpty(precedenceList)) {                                                                                  // 59\n      delete self.dataByKey[key];                                                                                     // 60\n      changeCollector[key] = undefined;                                                                               // 61\n    } else if (removedValue !== undefined && !EJSON.equals(removedValue, precedenceList[0].value)) {                  // 62\n      changeCollector[key] = precedenceList[0].value;                                                                 // 64\n    }                                                                                                                 // 65\n  },                                                                                                                  // 66\n                                                                                                                      //\n  changeField: function changeField(subscriptionHandle, key, value, changeCollector, isAdd) {                         // 68\n    var self = this;                                                                                                  // 70\n    // Publish API ignores _id if present in fields                                                                   //\n    if (key === \"_id\") return;                                                                                        // 72\n                                                                                                                      //\n    // Don't share state with the data passed in by the user.                                                         //\n    value = EJSON.clone(value);                                                                                       // 76\n                                                                                                                      //\n    if (!_.has(self.dataByKey, key)) {                                                                                // 78\n      self.dataByKey[key] = [{ subscriptionHandle: subscriptionHandle,                                                // 79\n        value: value }];                                                                                              // 80\n      changeCollector[key] = value;                                                                                   // 81\n      return;                                                                                                         // 82\n    }                                                                                                                 // 83\n    var precedenceList = self.dataByKey[key];                                                                         // 84\n    var elt;                                                                                                          // 85\n    if (!isAdd) {                                                                                                     // 86\n      elt = _.find(precedenceList, function (precedence) {                                                            // 87\n        return precedence.subscriptionHandle === subscriptionHandle;                                                  // 88\n      });                                                                                                             // 89\n    }                                                                                                                 // 90\n                                                                                                                      //\n    if (elt) {                                                                                                        // 92\n      if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {                                             // 93\n        // this subscription is changing the value of this field.                                                     //\n        changeCollector[key] = value;                                                                                 // 95\n      }                                                                                                               // 96\n      elt.value = value;                                                                                              // 97\n    } else {                                                                                                          // 98\n      // this subscription is newly caring about this field                                                           //\n      precedenceList.push({ subscriptionHandle: subscriptionHandle, value: value });                                  // 100\n    }                                                                                                                 // 101\n  }                                                                                                                   // 103\n});                                                                                                                   // 24\n                                                                                                                      //\n/**                                                                                                                   //\n * Represents a client's view of a single collection                                                                  //\n * @param {String} collectionName Name of the collection it represents                                                //\n * @param {Object.<String, Function>} sessionCallbacks The callbacks for added, changed, removed                      //\n * @class SessionCollectionView                                                                                       //\n */                                                                                                                   //\nvar SessionCollectionView = function SessionCollectionView(collectionName, sessionCallbacks) {                        // 112\n  var self = this;                                                                                                    // 113\n  self.collectionName = collectionName;                                                                               // 114\n  self.documents = {};                                                                                                // 115\n  self.callbacks = sessionCallbacks;                                                                                  // 116\n};                                                                                                                    // 117\n                                                                                                                      //\nDDPServer._SessionCollectionView = SessionCollectionView;                                                             // 119\n                                                                                                                      //\n_.extend(SessionCollectionView.prototype, {                                                                           // 122\n                                                                                                                      //\n  isEmpty: function isEmpty() {                                                                                       // 124\n    var self = this;                                                                                                  // 125\n    return _.isEmpty(self.documents);                                                                                 // 126\n  },                                                                                                                  // 127\n                                                                                                                      //\n  diff: function diff(previous) {                                                                                     // 129\n    var self = this;                                                                                                  // 130\n    DiffSequence.diffObjects(previous.documents, self.documents, {                                                    // 131\n      both: _.bind(self.diffDocument, self),                                                                          // 132\n                                                                                                                      //\n      rightOnly: function rightOnly(id, nowDV) {                                                                      // 134\n        self.callbacks.added(self.collectionName, id, nowDV.getFields());                                             // 135\n      },                                                                                                              // 136\n                                                                                                                      //\n      leftOnly: function leftOnly(id, prevDV) {                                                                       // 138\n        self.callbacks.removed(self.collectionName, id);                                                              // 139\n      }                                                                                                               // 140\n    });                                                                                                               // 131\n  },                                                                                                                  // 142\n                                                                                                                      //\n  diffDocument: function diffDocument(id, prevDV, nowDV) {                                                            // 144\n    var self = this;                                                                                                  // 145\n    var fields = {};                                                                                                  // 146\n    DiffSequence.diffObjects(prevDV.getFields(), nowDV.getFields(), {                                                 // 147\n      both: function both(key, prev, now) {                                                                           // 148\n        if (!EJSON.equals(prev, now)) fields[key] = now;                                                              // 149\n      },                                                                                                              // 151\n      rightOnly: function rightOnly(key, now) {                                                                       // 152\n        fields[key] = now;                                                                                            // 153\n      },                                                                                                              // 154\n      leftOnly: function leftOnly(key, prev) {                                                                        // 155\n        fields[key] = undefined;                                                                                      // 156\n      }                                                                                                               // 157\n    });                                                                                                               // 147\n    self.callbacks.changed(self.collectionName, id, fields);                                                          // 159\n  },                                                                                                                  // 160\n                                                                                                                      //\n  added: function added(subscriptionHandle, id, fields) {                                                             // 162\n    var self = this;                                                                                                  // 163\n    var docView = self.documents[id];                                                                                 // 164\n    var added = false;                                                                                                // 165\n    if (!docView) {                                                                                                   // 166\n      added = true;                                                                                                   // 167\n      docView = new SessionDocumentView();                                                                            // 168\n      self.documents[id] = docView;                                                                                   // 169\n    }                                                                                                                 // 170\n    docView.existsIn[subscriptionHandle] = true;                                                                      // 171\n    var changeCollector = {};                                                                                         // 172\n    _.each(fields, function (value, key) {                                                                            // 173\n      docView.changeField(subscriptionHandle, key, value, changeCollector, true);                                     // 174\n    });                                                                                                               // 176\n    if (added) self.callbacks.added(self.collectionName, id, changeCollector);else self.callbacks.changed(self.collectionName, id, changeCollector);\n  },                                                                                                                  // 181\n                                                                                                                      //\n  changed: function changed(subscriptionHandle, id, _changed) {                                                       // 183\n    var self = this;                                                                                                  // 184\n    var changedResult = {};                                                                                           // 185\n    var docView = self.documents[id];                                                                                 // 186\n    if (!docView) throw new Error(\"Could not find element with id \" + id + \" to change\");                             // 187\n    _.each(_changed, function (value, key) {                                                                          // 189\n      if (value === undefined) docView.clearField(subscriptionHandle, key, changedResult);else docView.changeField(subscriptionHandle, key, value, changedResult);\n    });                                                                                                               // 194\n    self.callbacks.changed(self.collectionName, id, changedResult);                                                   // 195\n  },                                                                                                                  // 196\n                                                                                                                      //\n  removed: function removed(subscriptionHandle, id) {                                                                 // 198\n    var self = this;                                                                                                  // 199\n    var docView = self.documents[id];                                                                                 // 200\n    if (!docView) {                                                                                                   // 201\n      var err = new Error(\"Removed nonexistent document \" + id);                                                      // 202\n      throw err;                                                                                                      // 203\n    }                                                                                                                 // 204\n    delete docView.existsIn[subscriptionHandle];                                                                      // 205\n    if (_.isEmpty(docView.existsIn)) {                                                                                // 206\n      // it is gone from everyone                                                                                     //\n      self.callbacks.removed(self.collectionName, id);                                                                // 208\n      delete self.documents[id];                                                                                      // 209\n    } else {                                                                                                          // 210\n      var changed = {};                                                                                               // 211\n      // remove this subscription from every precedence list                                                          //\n      // and record the changes                                                                                       //\n      _.each(docView.dataByKey, function (precedenceList, key) {                                                      // 214\n        docView.clearField(subscriptionHandle, key, changed);                                                         // 215\n      });                                                                                                             // 216\n                                                                                                                      //\n      self.callbacks.changed(self.collectionName, id, changed);                                                       // 218\n    }                                                                                                                 // 219\n  }                                                                                                                   // 220\n});                                                                                                                   // 122\n                                                                                                                      //\n/******************************************************************************/                                      //\n/* Session                                                                    */                                      //\n/******************************************************************************/                                      //\n                                                                                                                      //\nvar Session = function Session(server, version, socket, options) {                                                    // 227\n  var self = this;                                                                                                    // 228\n  self.id = Random.id();                                                                                              // 229\n                                                                                                                      //\n  self.server = server;                                                                                               // 231\n  self.version = version;                                                                                             // 232\n                                                                                                                      //\n  self.initialized = false;                                                                                           // 234\n  self.socket = socket;                                                                                               // 235\n                                                                                                                      //\n  // set to null when the session is destroyed. multiple places below                                                 //\n  // use this to determine if the session is alive or not.                                                            //\n  self.inQueue = new Meteor._DoubleEndedQueue();                                                                      // 239\n                                                                                                                      //\n  self.blocked = false;                                                                                               // 241\n  self.workerRunning = false;                                                                                         // 242\n                                                                                                                      //\n  // Sub objects for active subscriptions                                                                             //\n  self._namedSubs = {};                                                                                               // 245\n  self._universalSubs = [];                                                                                           // 246\n                                                                                                                      //\n  self.userId = null;                                                                                                 // 248\n                                                                                                                      //\n  self.collectionViews = {};                                                                                          // 250\n                                                                                                                      //\n  // Set this to false to not send messages when collectionViews are                                                  //\n  // modified. This is done when rerunning subs in _setUserId and those messages                                      //\n  // are calculated via a diff instead.                                                                               //\n  self._isSending = true;                                                                                             // 255\n                                                                                                                      //\n  // If this is true, don't start a newly-created universal publisher on this                                         //\n  // session. The session will take care of starting it when appropriate.                                             //\n  self._dontStartNewUniversalSubs = false;                                                                            // 259\n                                                                                                                      //\n  // when we are rerunning subscriptions, any ready messages                                                          //\n  // we want to buffer up for when we are done rerunning subscriptions                                                //\n  self._pendingReady = [];                                                                                            // 263\n                                                                                                                      //\n  // List of callbacks to call when this connection is closed.                                                        //\n  self._closeCallbacks = [];                                                                                          // 266\n                                                                                                                      //\n  // XXX HACK: If a sockjs connection, save off the URL. This is                                                      //\n  // temporary and will go away in the near future.                                                                   //\n  self._socketUrl = socket.url;                                                                                       // 271\n                                                                                                                      //\n  // Allow tests to disable responding to pings.                                                                      //\n  self._respondToPings = options.respondToPings;                                                                      // 274\n                                                                                                                      //\n  // This object is the public interface to the session. In the public                                                //\n  // API, it is called the `connection` object.  Internally we call it                                                //\n  // a `connectionHandle` to avoid ambiguity.                                                                         //\n  self.connectionHandle = {                                                                                           // 279\n    id: self.id,                                                                                                      // 280\n    close: function close() {                                                                                         // 281\n      self.close();                                                                                                   // 282\n    },                                                                                                                // 283\n    onClose: function onClose(fn) {                                                                                   // 284\n      var cb = Meteor.bindEnvironment(fn, \"connection onClose callback\");                                             // 285\n      if (self.inQueue) {                                                                                             // 286\n        self._closeCallbacks.push(cb);                                                                                // 287\n      } else {                                                                                                        // 288\n        // if we're already closed, call the callback.                                                                //\n        Meteor.defer(cb);                                                                                             // 290\n      }                                                                                                               // 291\n    },                                                                                                                // 292\n    clientAddress: self._clientAddress(),                                                                             // 293\n    httpHeaders: self.socket.headers                                                                                  // 294\n  };                                                                                                                  // 279\n                                                                                                                      //\n  self.send({ msg: 'connected', session: self.id });                                                                  // 297\n                                                                                                                      //\n  // On initial connect, spin up all the universal publishers.                                                        //\n  Fiber(function () {                                                                                                 // 300\n    self.startUniversalSubs();                                                                                        // 301\n  }).run();                                                                                                           // 302\n                                                                                                                      //\n  if (version !== 'pre1' && options.heartbeatInterval !== 0) {                                                        // 304\n    self.heartbeat = new DDPCommon.Heartbeat({                                                                        // 305\n      heartbeatInterval: options.heartbeatInterval,                                                                   // 306\n      heartbeatTimeout: options.heartbeatTimeout,                                                                     // 307\n      onTimeout: function onTimeout() {                                                                               // 308\n        self.close();                                                                                                 // 309\n      },                                                                                                              // 310\n      sendPing: function sendPing() {                                                                                 // 311\n        self.send({ msg: 'ping' });                                                                                   // 312\n      }                                                                                                               // 313\n    });                                                                                                               // 305\n    self.heartbeat.start();                                                                                           // 315\n  }                                                                                                                   // 316\n                                                                                                                      //\n  Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"sessions\", 1);                                // 318\n};                                                                                                                    // 320\n                                                                                                                      //\n_.extend(Session.prototype, {                                                                                         // 322\n                                                                                                                      //\n  sendReady: function sendReady(subscriptionIds) {                                                                    // 324\n    var self = this;                                                                                                  // 325\n    if (self._isSending) self.send({ msg: \"ready\", subs: subscriptionIds });else {                                    // 326\n      _.each(subscriptionIds, function (subscriptionId) {                                                             // 329\n        self._pendingReady.push(subscriptionId);                                                                      // 330\n      });                                                                                                             // 331\n    }                                                                                                                 // 332\n  },                                                                                                                  // 333\n                                                                                                                      //\n  sendAdded: function sendAdded(collectionName, id, fields) {                                                         // 335\n    var self = this;                                                                                                  // 336\n    if (self._isSending) self.send({ msg: \"added\", collection: collectionName, id: id, fields: fields });             // 337\n  },                                                                                                                  // 339\n                                                                                                                      //\n  sendChanged: function sendChanged(collectionName, id, fields) {                                                     // 341\n    var self = this;                                                                                                  // 342\n    if (_.isEmpty(fields)) return;                                                                                    // 343\n                                                                                                                      //\n    if (self._isSending) {                                                                                            // 346\n      self.send({                                                                                                     // 347\n        msg: \"changed\",                                                                                               // 348\n        collection: collectionName,                                                                                   // 349\n        id: id,                                                                                                       // 350\n        fields: fields                                                                                                // 351\n      });                                                                                                             // 347\n    }                                                                                                                 // 353\n  },                                                                                                                  // 354\n                                                                                                                      //\n  sendRemoved: function sendRemoved(collectionName, id) {                                                             // 356\n    var self = this;                                                                                                  // 357\n    if (self._isSending) self.send({ msg: \"removed\", collection: collectionName, id: id });                           // 358\n  },                                                                                                                  // 360\n                                                                                                                      //\n  getSendCallbacks: function getSendCallbacks() {                                                                     // 362\n    var self = this;                                                                                                  // 363\n    return {                                                                                                          // 364\n      added: _.bind(self.sendAdded, self),                                                                            // 365\n      changed: _.bind(self.sendChanged, self),                                                                        // 366\n      removed: _.bind(self.sendRemoved, self)                                                                         // 367\n    };                                                                                                                // 364\n  },                                                                                                                  // 369\n                                                                                                                      //\n  getCollectionView: function getCollectionView(collectionName) {                                                     // 371\n    var self = this;                                                                                                  // 372\n    if (_.has(self.collectionViews, collectionName)) {                                                                // 373\n      return self.collectionViews[collectionName];                                                                    // 374\n    }                                                                                                                 // 375\n    var ret = new SessionCollectionView(collectionName, self.getSendCallbacks());                                     // 376\n    self.collectionViews[collectionName] = ret;                                                                       // 378\n    return ret;                                                                                                       // 379\n  },                                                                                                                  // 380\n                                                                                                                      //\n  added: function added(subscriptionHandle, collectionName, id, fields) {                                             // 382\n    var self = this;                                                                                                  // 383\n    var view = self.getCollectionView(collectionName);                                                                // 384\n    view.added(subscriptionHandle, id, fields);                                                                       // 385\n  },                                                                                                                  // 386\n                                                                                                                      //\n  removed: function removed(subscriptionHandle, collectionName, id) {                                                 // 388\n    var self = this;                                                                                                  // 389\n    var view = self.getCollectionView(collectionName);                                                                // 390\n    view.removed(subscriptionHandle, id);                                                                             // 391\n    if (view.isEmpty()) {                                                                                             // 392\n      delete self.collectionViews[collectionName];                                                                    // 393\n    }                                                                                                                 // 394\n  },                                                                                                                  // 395\n                                                                                                                      //\n  changed: function changed(subscriptionHandle, collectionName, id, fields) {                                         // 397\n    var self = this;                                                                                                  // 398\n    var view = self.getCollectionView(collectionName);                                                                // 399\n    view.changed(subscriptionHandle, id, fields);                                                                     // 400\n  },                                                                                                                  // 401\n                                                                                                                      //\n  startUniversalSubs: function startUniversalSubs() {                                                                 // 403\n    var self = this;                                                                                                  // 404\n    // Make a shallow copy of the set of universal handlers and start them. If                                        //\n    // additional universal publishers start while we're running them (due to                                         //\n    // yielding), they will run separately as part of Server.publish.                                                 //\n    var handlers = _.clone(self.server.universal_publish_handlers);                                                   // 408\n    _.each(handlers, function (handler) {                                                                             // 409\n      self._startSubscription(handler);                                                                               // 410\n    });                                                                                                               // 411\n  },                                                                                                                  // 412\n                                                                                                                      //\n  // Destroy this session and unregister it at the server.                                                            //\n  close: function close() {                                                                                           // 415\n    var self = this;                                                                                                  // 416\n                                                                                                                      //\n    // Destroy this session, even if it's not registered at the                                                       //\n    // server. Stop all processing and tear everything down. If a socket                                              //\n    // was attached, close it.                                                                                        //\n                                                                                                                      //\n    // Already destroyed.                                                                                             //\n    if (!self.inQueue) return;                                                                                        // 423\n                                                                                                                      //\n    // Drop the merge box data immediately.                                                                           //\n    self.inQueue = null;                                                                                              // 427\n    self.collectionViews = {};                                                                                        // 428\n                                                                                                                      //\n    if (self.heartbeat) {                                                                                             // 430\n      self.heartbeat.stop();                                                                                          // 431\n      self.heartbeat = null;                                                                                          // 432\n    }                                                                                                                 // 433\n                                                                                                                      //\n    if (self.socket) {                                                                                                // 435\n      self.socket.close();                                                                                            // 436\n      self.socket._meteorSession = null;                                                                              // 437\n    }                                                                                                                 // 438\n                                                                                                                      //\n    Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"sessions\", -1);                             // 440\n                                                                                                                      //\n    Meteor.defer(function () {                                                                                        // 443\n      // stop callbacks can yield, so we defer this on close.                                                         //\n      // sub._isDeactivated() detects that we set inQueue to null and                                                 //\n      // treats it as semi-deactivated (it will ignore incoming callbacks, etc).                                      //\n      self._deactivateAllSubscriptions();                                                                             // 447\n                                                                                                                      //\n      // Defer calling the close callbacks, so that the caller closing                                                //\n      // the session isn't waiting for all the callbacks to complete.                                                 //\n      _.each(self._closeCallbacks, function (callback) {                                                              // 451\n        callback();                                                                                                   // 452\n      });                                                                                                             // 453\n    });                                                                                                               // 454\n                                                                                                                      //\n    // Unregister the session.                                                                                        //\n    self.server._removeSession(self);                                                                                 // 457\n  },                                                                                                                  // 458\n                                                                                                                      //\n  // Send a message (doing nothing if no socket is connected right now.)                                              //\n  // It should be a JSON object (it will be stringified.)                                                             //\n  send: function send(msg) {                                                                                          // 462\n    var self = this;                                                                                                  // 463\n    if (self.socket) {                                                                                                // 464\n      if (Meteor._printSentDDP) Meteor._debug(\"Sent DDP\", DDPCommon.stringifyDDP(msg));                               // 465\n      self.socket.send(DDPCommon.stringifyDDP(msg));                                                                  // 467\n    }                                                                                                                 // 468\n  },                                                                                                                  // 469\n                                                                                                                      //\n  // Send a connection error.                                                                                         //\n  sendError: function sendError(reason, offendingMessage) {                                                           // 472\n    var self = this;                                                                                                  // 473\n    var msg = { msg: 'error', reason: reason };                                                                       // 474\n    if (offendingMessage) msg.offendingMessage = offendingMessage;                                                    // 475\n    self.send(msg);                                                                                                   // 477\n  },                                                                                                                  // 478\n                                                                                                                      //\n  // Process 'msg' as an incoming message. (But as a guard against                                                    //\n  // race conditions during reconnection, ignore the message if                                                       //\n  // 'socket' is not the currently connected socket.)                                                                 //\n  //                                                                                                                  //\n  // We run the messages from the client one at a time, in the order                                                  //\n  // given by the client. The message handler is passed an idempotent                                                 //\n  // function 'unblock' which it may call to allow other messages to                                                  //\n  // begin running in parallel in another fiber (for example, a method                                                //\n  // that wants to yield.) Otherwise, it is automatically unblocked                                                   //\n  // when it returns.                                                                                                 //\n  //                                                                                                                  //\n  // Actually, we don't have to 'totally order' the messages in this                                                  //\n  // way, but it's the easiest thing that's correct. (unsub needs to                                                  //\n  // be ordered against sub, methods need to be ordered against each                                                  //\n  // other.)                                                                                                          //\n  processMessage: function processMessage(msg_in) {                                                                   // 495\n    var self = this;                                                                                                  // 496\n    if (!self.inQueue) // we have been destroyed.                                                                     // 497\n      return;                                                                                                         // 498\n                                                                                                                      //\n    // Respond to ping and pong messages immediately without queuing.                                                 //\n    // If the negotiated DDP version is \"pre1\" which didn't support                                                   //\n    // pings, preserve the \"pre1\" behavior of responding with a \"bad                                                  //\n    // request\" for the unknown messages.                                                                             //\n    //                                                                                                                //\n    // Fibers are needed because heartbeat uses Meteor.setTimeout, which                                              //\n    // needs a Fiber. We could actually use regular setTimeout and avoid                                              //\n    // these new fibers, but it is easier to just make everything use                                                 //\n    // Meteor.setTimeout and not think too hard.                                                                      //\n    //                                                                                                                //\n    // Any message counts as receiving a pong, as it demonstrates that                                                //\n    // the client is still alive.                                                                                     //\n    if (self.heartbeat) {                                                                                             // 512\n      Fiber(function () {                                                                                             // 513\n        self.heartbeat.messageReceived();                                                                             // 514\n      }).run();                                                                                                       // 515\n    }                                                                                                                 // 516\n                                                                                                                      //\n    if (self.version !== 'pre1' && msg_in.msg === 'ping') {                                                           // 518\n      if (self._respondToPings) self.send({ msg: \"pong\", id: msg_in.id });                                            // 519\n      return;                                                                                                         // 521\n    }                                                                                                                 // 522\n    if (self.version !== 'pre1' && msg_in.msg === 'pong') {                                                           // 523\n      // Since everything is a pong, nothing to do                                                                    //\n      return;                                                                                                         // 525\n    }                                                                                                                 // 526\n                                                                                                                      //\n    self.inQueue.push(msg_in);                                                                                        // 528\n    if (self.workerRunning) return;                                                                                   // 529\n    self.workerRunning = true;                                                                                        // 531\n                                                                                                                      //\n    var processNext = function processNext() {                                                                        // 533\n      var msg = self.inQueue && self.inQueue.shift();                                                                 // 534\n      if (!msg) {                                                                                                     // 535\n        self.workerRunning = false;                                                                                   // 536\n        return;                                                                                                       // 537\n      }                                                                                                               // 538\n                                                                                                                      //\n      Fiber(function () {                                                                                             // 540\n        var blocked = true;                                                                                           // 541\n                                                                                                                      //\n        var unblock = function unblock() {                                                                            // 543\n          if (!blocked) return; // idempotent                                                                         // 544\n          blocked = false;                                                                                            // 546\n          processNext();                                                                                              // 547\n        };                                                                                                            // 548\n                                                                                                                      //\n        if (_.has(self.protocol_handlers, msg.msg)) self.protocol_handlers[msg.msg].call(self, msg, unblock);else self.sendError('Bad request', msg);\n        unblock(); // in case the handler didn't already do it                                                        // 554\n      }).run();                                                                                                       // 555\n    };                                                                                                                // 556\n                                                                                                                      //\n    processNext();                                                                                                    // 558\n  },                                                                                                                  // 559\n                                                                                                                      //\n  protocol_handlers: {                                                                                                // 561\n    sub: function sub(msg) {                                                                                          // 562\n      var self = this;                                                                                                // 563\n                                                                                                                      //\n      // reject malformed messages                                                                                    //\n      if (typeof msg.id !== \"string\" || typeof msg.name !== \"string\" || 'params' in msg && !(msg.params instanceof Array)) {\n        self.sendError(\"Malformed subscription\", msg);                                                                // 569\n        return;                                                                                                       // 570\n      }                                                                                                               // 571\n                                                                                                                      //\n      if (!self.server.publish_handlers[msg.name]) {                                                                  // 573\n        self.send({                                                                                                   // 574\n          msg: 'nosub', id: msg.id,                                                                                   // 575\n          error: new Meteor.Error(404, \"Subscription '\" + msg.name + \"' not found\") });                               // 576\n        return;                                                                                                       // 577\n      }                                                                                                               // 578\n                                                                                                                      //\n      if (_.has(self._namedSubs, msg.id))                                                                             // 580\n        // subs are idempotent, or rather, they are ignored if a sub                                                  //\n        // with that id already exists. this is important during                                                      //\n        // reconnect.                                                                                                 //\n        return;                                                                                                       // 584\n                                                                                                                      //\n      // XXX It'd be much better if we had generic hooks where any package can                                        //\n      // hook into subscription handling, but in the mean while we special case                                       //\n      // ddp-rate-limiter package. This is also done for weak requirements to                                         //\n      // add the ddp-rate-limiter package in case we don't have Accounts. A                                           //\n      // user trying to use the ddp-rate-limiter must explicitly require it.                                          //\n      if (Package['ddp-rate-limiter']) {                                                                              // 591\n        var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;                                              // 592\n        var rateLimiterInput = {                                                                                      // 593\n          userId: self.userId,                                                                                        // 594\n          clientAddress: self.connectionHandle.clientAddress,                                                         // 595\n          type: \"subscription\",                                                                                       // 596\n          name: msg.name,                                                                                             // 597\n          connectionId: self.id                                                                                       // 598\n        };                                                                                                            // 593\n                                                                                                                      //\n        DDPRateLimiter._increment(rateLimiterInput);                                                                  // 601\n        var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);                                                // 602\n        if (!rateLimitResult.allowed) {                                                                               // 603\n          self.send({                                                                                                 // 604\n            msg: 'nosub', id: msg.id,                                                                                 // 605\n            error: new Meteor.Error('too-many-requests', DDPRateLimiter.getErrorMessage(rateLimitResult), { timeToReset: rateLimitResult.timeToReset })\n          });                                                                                                         // 604\n          return;                                                                                                     // 611\n        }                                                                                                             // 612\n      }                                                                                                               // 613\n                                                                                                                      //\n      var handler = self.server.publish_handlers[msg.name];                                                           // 615\n                                                                                                                      //\n      self._startSubscription(handler, msg.id, msg.params, msg.name);                                                 // 617\n    },                                                                                                                // 619\n                                                                                                                      //\n    unsub: function unsub(msg) {                                                                                      // 621\n      var self = this;                                                                                                // 622\n                                                                                                                      //\n      self._stopSubscription(msg.id);                                                                                 // 624\n    },                                                                                                                // 625\n                                                                                                                      //\n    method: function method(msg, unblock) {                                                                           // 627\n      var self = this;                                                                                                // 628\n                                                                                                                      //\n      // reject malformed messages                                                                                    //\n      // For now, we silently ignore unknown attributes,                                                              //\n      // for forwards compatibility.                                                                                  //\n      if (typeof msg.id !== \"string\" || typeof msg.method !== \"string\" || 'params' in msg && !(msg.params instanceof Array) || 'randomSeed' in msg && typeof msg.randomSeed !== \"string\") {\n        self.sendError(\"Malformed method invocation\", msg);                                                           // 637\n        return;                                                                                                       // 638\n      }                                                                                                               // 639\n                                                                                                                      //\n      var randomSeed = msg.randomSeed || null;                                                                        // 641\n                                                                                                                      //\n      // set up to mark the method as satisfied once all observers                                                    //\n      // (and subscriptions) have reacted to any writes that were                                                     //\n      // done.                                                                                                        //\n      var fence = new DDPServer._WriteFence();                                                                        // 646\n      fence.onAllCommitted(function () {                                                                              // 647\n        // Retire the fence so that future writes are allowed.                                                        //\n        // This means that callbacks like timers are free to use                                                      //\n        // the fence, and if they fire before it's armed (for                                                         //\n        // example, because the method waits for them) their                                                          //\n        // writes will be included in the fence.                                                                      //\n        fence.retire();                                                                                               // 653\n        self.send({                                                                                                   // 654\n          msg: 'updated', methods: [msg.id] });                                                                       // 655\n      });                                                                                                             // 656\n                                                                                                                      //\n      // find the handler                                                                                             //\n      var handler = self.server.method_handlers[msg.method];                                                          // 659\n      if (!handler) {                                                                                                 // 660\n        self.send({                                                                                                   // 661\n          msg: 'result', id: msg.id,                                                                                  // 662\n          error: new Meteor.Error(404, \"Method '\" + msg.method + \"' not found\") });                                   // 663\n        fence.arm();                                                                                                  // 664\n        return;                                                                                                       // 665\n      }                                                                                                               // 666\n                                                                                                                      //\n      var setUserId = function setUserId(userId) {                                                                    // 668\n        self._setUserId(userId);                                                                                      // 669\n      };                                                                                                              // 670\n                                                                                                                      //\n      var invocation = new DDPCommon.MethodInvocation({                                                               // 672\n        isSimulation: false,                                                                                          // 673\n        userId: self.userId,                                                                                          // 674\n        setUserId: setUserId,                                                                                         // 675\n        unblock: unblock,                                                                                             // 676\n        connection: self.connectionHandle,                                                                            // 677\n        randomSeed: randomSeed                                                                                        // 678\n      });                                                                                                             // 672\n                                                                                                                      //\n      var promise = new Promise(function (resolve, reject) {                                                          // 681\n        // XXX It'd be better if we could hook into method handlers better but                                        //\n        // for now, we need to check if the ddp-rate-limiter exists since we                                          //\n        // have a weak requirement for the ddp-rate-limiter package to be added                                       //\n        // to our application.                                                                                        //\n        if (Package['ddp-rate-limiter']) {                                                                            // 686\n          var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;                                            // 687\n          var rateLimiterInput = {                                                                                    // 688\n            userId: self.userId,                                                                                      // 689\n            clientAddress: self.connectionHandle.clientAddress,                                                       // 690\n            type: \"method\",                                                                                           // 691\n            name: msg.method,                                                                                         // 692\n            connectionId: self.id                                                                                     // 693\n          };                                                                                                          // 688\n          DDPRateLimiter._increment(rateLimiterInput);                                                                // 695\n          var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);                                              // 696\n          if (!rateLimitResult.allowed) {                                                                             // 697\n            reject(new Meteor.Error(\"too-many-requests\", DDPRateLimiter.getErrorMessage(rateLimitResult), { timeToReset: rateLimitResult.timeToReset }));\n            return;                                                                                                   // 703\n          }                                                                                                           // 704\n        }                                                                                                             // 705\n                                                                                                                      //\n        resolve(DDPServer._CurrentWriteFence.withValue(fence, function () {                                           // 707\n          return DDP._CurrentInvocation.withValue(invocation, function () {                                           // 709\n            return maybeAuditArgumentChecks(handler, invocation, msg.params, \"call to '\" + msg.method + \"'\");         // 711\n          });                                                                                                         // 711\n        }));                                                                                                          // 709\n      });                                                                                                             // 717\n                                                                                                                      //\n      function finish() {                                                                                             // 719\n        fence.arm();                                                                                                  // 720\n        unblock();                                                                                                    // 721\n      }                                                                                                               // 722\n                                                                                                                      //\n      var payload = {                                                                                                 // 724\n        msg: \"result\",                                                                                                // 725\n        id: msg.id                                                                                                    // 726\n      };                                                                                                              // 724\n                                                                                                                      //\n      promise.then(function (result) {                                                                                // 729\n        finish();                                                                                                     // 730\n        if (result !== undefined) {                                                                                   // 731\n          payload.result = result;                                                                                    // 732\n        }                                                                                                             // 733\n        self.send(payload);                                                                                           // 734\n      }, function (exception) {                                                                                       // 735\n        finish();                                                                                                     // 736\n        payload.error = wrapInternalException(exception, \"while invoking method '\" + msg.method + \"'\");               // 737\n        self.send(payload);                                                                                           // 741\n      });                                                                                                             // 742\n    }                                                                                                                 // 743\n  },                                                                                                                  // 561\n                                                                                                                      //\n  _eachSub: function _eachSub(f) {                                                                                    // 746\n    var self = this;                                                                                                  // 747\n    _.each(self._namedSubs, f);                                                                                       // 748\n    _.each(self._universalSubs, f);                                                                                   // 749\n  },                                                                                                                  // 750\n                                                                                                                      //\n  _diffCollectionViews: function _diffCollectionViews(beforeCVs) {                                                    // 752\n    var self = this;                                                                                                  // 753\n    DiffSequence.diffObjects(beforeCVs, self.collectionViews, {                                                       // 754\n      both: function both(collectionName, leftValue, rightValue) {                                                    // 755\n        rightValue.diff(leftValue);                                                                                   // 756\n      },                                                                                                              // 757\n      rightOnly: function rightOnly(collectionName, rightValue) {                                                     // 758\n        _.each(rightValue.documents, function (docView, id) {                                                         // 759\n          self.sendAdded(collectionName, id, docView.getFields());                                                    // 760\n        });                                                                                                           // 761\n      },                                                                                                              // 762\n      leftOnly: function leftOnly(collectionName, leftValue) {                                                        // 763\n        _.each(leftValue.documents, function (doc, id) {                                                              // 764\n          self.sendRemoved(collectionName, id);                                                                       // 765\n        });                                                                                                           // 766\n      }                                                                                                               // 767\n    });                                                                                                               // 754\n  },                                                                                                                  // 769\n                                                                                                                      //\n  // Sets the current user id in all appropriate contexts and reruns                                                  //\n  // all subscriptions                                                                                                //\n  _setUserId: function _setUserId(userId) {                                                                           // 773\n    var self = this;                                                                                                  // 774\n                                                                                                                      //\n    if (userId !== null && typeof userId !== \"string\") throw new Error(\"setUserId must be called on string or null, not \" + (typeof userId === \"undefined\" ? \"undefined\" : _typeof(userId)));\n                                                                                                                      //\n    // Prevent newly-created universal subscriptions from being added to our                                          //\n    // session; they will be found below when we call startUniversalSubs.                                             //\n    //                                                                                                                //\n    // (We don't have to worry about named subscriptions, because we only add                                         //\n    // them when we process a 'sub' message. We are currently processing a                                            //\n    // 'method' message, and the method did not unblock, because it is illegal                                        //\n    // to call setUserId after unblock. Thus we cannot be concurrently adding a                                       //\n    // new named subscription.)                                                                                       //\n    self._dontStartNewUniversalSubs = true;                                                                           // 788\n                                                                                                                      //\n    // Prevent current subs from updating our collectionViews and call their                                          //\n    // stop callbacks. This may yield.                                                                                //\n    self._eachSub(function (sub) {                                                                                    // 792\n      sub._deactivate();                                                                                              // 793\n    });                                                                                                               // 794\n                                                                                                                      //\n    // All subs should now be deactivated. Stop sending messages to the client,                                       //\n    // save the state of the published collections, reset to an empty view, and                                       //\n    // update the userId.                                                                                             //\n    self._isSending = false;                                                                                          // 799\n    var beforeCVs = self.collectionViews;                                                                             // 800\n    self.collectionViews = {};                                                                                        // 801\n    self.userId = userId;                                                                                             // 802\n                                                                                                                      //\n    // Save the old named subs, and reset to having no subscriptions.                                                 //\n    var oldNamedSubs = self._namedSubs;                                                                               // 805\n    self._namedSubs = {};                                                                                             // 806\n    self._universalSubs = [];                                                                                         // 807\n                                                                                                                      //\n    _.each(oldNamedSubs, function (sub, subscriptionId) {                                                             // 809\n      self._namedSubs[subscriptionId] = sub._recreate();                                                              // 810\n      // nb: if the handler throws or calls this.error(), it will in fact                                             //\n      // immediately send its 'nosub'. This is OK, though.                                                            //\n      self._namedSubs[subscriptionId]._runHandler();                                                                  // 813\n    });                                                                                                               // 814\n                                                                                                                      //\n    // Allow newly-created universal subs to be started on our connection in                                          //\n    // parallel with the ones we're spinning up here, and spin up universal                                           //\n    // subs.                                                                                                          //\n    self._dontStartNewUniversalSubs = false;                                                                          // 819\n    self.startUniversalSubs();                                                                                        // 820\n                                                                                                                      //\n    // Start sending messages again, beginning with the diff from the previous                                        //\n    // state of the world to the current state. No yields are allowed during                                          //\n    // this diff, so that other changes cannot interleave.                                                            //\n    Meteor._noYieldsAllowed(function () {                                                                             // 825\n      self._isSending = true;                                                                                         // 826\n      self._diffCollectionViews(beforeCVs);                                                                           // 827\n      if (!_.isEmpty(self._pendingReady)) {                                                                           // 828\n        self.sendReady(self._pendingReady);                                                                           // 829\n        self._pendingReady = [];                                                                                      // 830\n      }                                                                                                               // 831\n    });                                                                                                               // 832\n  },                                                                                                                  // 833\n                                                                                                                      //\n  _startSubscription: function _startSubscription(handler, subId, params, name) {                                     // 835\n    var self = this;                                                                                                  // 836\n                                                                                                                      //\n    var sub = new Subscription(self, handler, subId, params, name);                                                   // 838\n    if (subId) self._namedSubs[subId] = sub;else self._universalSubs.push(sub);                                       // 840\n                                                                                                                      //\n    sub._runHandler();                                                                                                // 845\n  },                                                                                                                  // 846\n                                                                                                                      //\n  // tear down specified subscription                                                                                 //\n  _stopSubscription: function _stopSubscription(subId, error) {                                                       // 849\n    var self = this;                                                                                                  // 850\n                                                                                                                      //\n    var subName = null;                                                                                               // 852\n                                                                                                                      //\n    if (subId && self._namedSubs[subId]) {                                                                            // 854\n      subName = self._namedSubs[subId]._name;                                                                         // 855\n      self._namedSubs[subId]._removeAllDocuments();                                                                   // 856\n      self._namedSubs[subId]._deactivate();                                                                           // 857\n      delete self._namedSubs[subId];                                                                                  // 858\n    }                                                                                                                 // 859\n                                                                                                                      //\n    var response = { msg: 'nosub', id: subId };                                                                       // 861\n                                                                                                                      //\n    if (error) {                                                                                                      // 863\n      response.error = wrapInternalException(error, subName ? \"from sub \" + subName + \" id \" + subId : \"from sub id \" + subId);\n    }                                                                                                                 // 868\n                                                                                                                      //\n    self.send(response);                                                                                              // 870\n  },                                                                                                                  // 871\n                                                                                                                      //\n  // tear down all subscriptions. Note that this does NOT send removed or nosub                                       //\n  // messages, since we assume the client is gone.                                                                    //\n  _deactivateAllSubscriptions: function _deactivateAllSubscriptions() {                                               // 875\n    var self = this;                                                                                                  // 876\n                                                                                                                      //\n    _.each(self._namedSubs, function (sub, id) {                                                                      // 878\n      sub._deactivate();                                                                                              // 879\n    });                                                                                                               // 880\n    self._namedSubs = {};                                                                                             // 881\n                                                                                                                      //\n    _.each(self._universalSubs, function (sub) {                                                                      // 883\n      sub._deactivate();                                                                                              // 884\n    });                                                                                                               // 885\n    self._universalSubs = [];                                                                                         // 886\n  },                                                                                                                  // 887\n                                                                                                                      //\n  // Determine the remote client's IP address, based on the                                                           //\n  // HTTP_FORWARDED_COUNT environment variable representing how many                                                  //\n  // proxies the server is behind.                                                                                    //\n  _clientAddress: function _clientAddress() {                                                                         // 892\n    var self = this;                                                                                                  // 893\n                                                                                                                      //\n    // For the reported client address for a connection to be correct,                                                //\n    // the developer must set the HTTP_FORWARDED_COUNT environment                                                    //\n    // variable to an integer representing the number of hops they                                                    //\n    // expect in the `x-forwarded-for` header. E.g., set to \"1\" if the                                                //\n    // server is behind one proxy.                                                                                    //\n    //                                                                                                                //\n    // This could be computed once at startup instead of every time.                                                  //\n    var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0;                                      // 902\n                                                                                                                      //\n    if (httpForwardedCount === 0) return self.socket.remoteAddress;                                                   // 904\n                                                                                                                      //\n    var forwardedFor = self.socket.headers[\"x-forwarded-for\"];                                                        // 907\n    if (!_.isString(forwardedFor)) return null;                                                                       // 908\n    forwardedFor = forwardedFor.trim().split(/\\s*,\\s*/);                                                              // 910\n                                                                                                                      //\n    // Typically the first value in the `x-forwarded-for` header is                                                   //\n    // the original IP address of the client connecting to the first                                                  //\n    // proxy.  However, the end user can easily spoof the header, in                                                  //\n    // which case the first value(s) will be the fake IP address from                                                 //\n    // the user pretending to be a proxy reporting the original IP                                                    //\n    // address value.  By counting HTTP_FORWARDED_COUNT back from the                                                 //\n    // end of the list, we ensure that we get the IP address being                                                    //\n    // reported by *our* first proxy.                                                                                 //\n                                                                                                                      //\n    if (httpForwardedCount < 0 || httpForwardedCount > forwardedFor.length) return null;                              // 921\n                                                                                                                      //\n    return forwardedFor[forwardedFor.length - httpForwardedCount];                                                    // 924\n  }                                                                                                                   // 925\n});                                                                                                                   // 322\n                                                                                                                      //\n/******************************************************************************/                                      //\n/* Subscription                                                               */                                      //\n/******************************************************************************/                                      //\n                                                                                                                      //\n// ctor for a sub handle: the input to each publish function                                                          //\n                                                                                                                      //\n// Instance name is this because it's usually referred to as this inside a                                            //\n// publish                                                                                                            //\n/**                                                                                                                   //\n * @summary The server's side of a subscription                                                                       //\n * @class Subscription                                                                                                //\n * @instanceName this                                                                                                 //\n */                                                                                                                   //\nvar Subscription = function Subscription(session, handler, subscriptionId, params, name) {                            // 941\n  var self = this;                                                                                                    // 943\n  self._session = session; // type is Session                                                                         // 944\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.\n   * @locus Server                                                                                                    //\n   * @name  connection                                                                                                //\n   * @memberOf Subscription                                                                                           //\n   * @instance                                                                                                        //\n   */                                                                                                                 //\n  self.connection = session.connectionHandle; // public API object                                                    // 953\n                                                                                                                      //\n  self._handler = handler;                                                                                            // 955\n                                                                                                                      //\n  // my subscription ID (generated by client, undefined for universal subs).                                          //\n  self._subscriptionId = subscriptionId;                                                                              // 958\n  // undefined for universal subs                                                                                     //\n  self._name = name;                                                                                                  // 960\n                                                                                                                      //\n  self._params = params || [];                                                                                        // 962\n                                                                                                                      //\n  // Only named subscriptions have IDs, but we need some sort of string                                               //\n  // internally to keep track of all subscriptions inside                                                             //\n  // SessionDocumentViews. We use this subscriptionHandle for that.                                                   //\n  if (self._subscriptionId) {                                                                                         // 967\n    self._subscriptionHandle = 'N' + self._subscriptionId;                                                            // 968\n  } else {                                                                                                            // 969\n    self._subscriptionHandle = 'U' + Random.id();                                                                     // 970\n  }                                                                                                                   // 971\n                                                                                                                      //\n  // has _deactivate been called?                                                                                     //\n  self._deactivated = false;                                                                                          // 974\n                                                                                                                      //\n  // stop callbacks to g/c this sub.  called w/ zero arguments.                                                       //\n  self._stopCallbacks = [];                                                                                           // 977\n                                                                                                                      //\n  // the set of (collection, documentid) that this subscription has                                                   //\n  // an opinion about                                                                                                 //\n  self._documents = {};                                                                                               // 981\n                                                                                                                      //\n  // remember if we are ready.                                                                                        //\n  self._ready = false;                                                                                                // 984\n                                                                                                                      //\n  // Part of the public API: the user of this sub.                                                                    //\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.    //\n   * @locus Server                                                                                                    //\n   * @memberOf Subscription                                                                                           //\n   * @name  userId                                                                                                    //\n   * @instance                                                                                                        //\n   */                                                                                                                 //\n  self.userId = session.userId;                                                                                       // 995\n                                                                                                                      //\n  // For now, the id filter is going to default to                                                                    //\n  // the to/from DDP methods on MongoID, to                                                                           //\n  // specifically deal with mongo/minimongo ObjectIds.                                                                //\n                                                                                                                      //\n  // Later, you will be able to make this be \"raw\"                                                                    //\n  // if you want to publish a collection that you know                                                                //\n  // just has strings for keys and no funny business, to                                                              //\n  // a ddp consumer that isn't minimongo                                                                              //\n                                                                                                                      //\n  self._idFilter = {                                                                                                  // 1006\n    idStringify: MongoID.idStringify,                                                                                 // 1007\n    idParse: MongoID.idParse                                                                                          // 1008\n  };                                                                                                                  // 1006\n                                                                                                                      //\n  Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"subscriptions\", 1);                           // 1011\n};                                                                                                                    // 1013\n                                                                                                                      //\n_.extend(Subscription.prototype, {                                                                                    // 1015\n  _runHandler: function _runHandler() {                                                                               // 1016\n    // XXX should we unblock() here? Either before running the publish                                                //\n    // function, or before running _publishCursor.                                                                    //\n    //                                                                                                                //\n    // Right now, each publish function blocks all future publishes and                                               //\n    // methods waiting on data from Mongo (or whatever else the function                                              //\n    // blocks on). This probably slows page load in common cases.                                                     //\n                                                                                                                      //\n    var self = this;                                                                                                  // 1024\n    try {                                                                                                             // 1025\n      var res = maybeAuditArgumentChecks(self._handler, self, EJSON.clone(self._params),                              // 1026\n      // It's OK that this would look weird for universal subscriptions,                                              //\n      // because they have no arguments so there can never be an                                                      //\n      // audit-argument-checks failure.                                                                               //\n      \"publisher '\" + self._name + \"'\");                                                                              // 1031\n    } catch (e) {                                                                                                     // 1032\n      self.error(e);                                                                                                  // 1033\n      return;                                                                                                         // 1034\n    }                                                                                                                 // 1035\n                                                                                                                      //\n    // Did the handler call this.error or this.stop?                                                                  //\n    if (self._isDeactivated()) return;                                                                                // 1038\n                                                                                                                      //\n    self._publishHandlerResult(res);                                                                                  // 1041\n  },                                                                                                                  // 1042\n                                                                                                                      //\n  _publishHandlerResult: function _publishHandlerResult(res) {                                                        // 1044\n    // SPECIAL CASE: Instead of writing their own callbacks that invoke                                               //\n    // this.added/changed/ready/etc, the user can just return a collection                                            //\n    // cursor or array of cursors from the publish function; we call their                                            //\n    // _publishCursor method which starts observing the cursor and publishes the                                      //\n    // results. Note that _publishCursor does NOT call ready().                                                       //\n    //                                                                                                                //\n    // XXX This uses an undocumented interface which only the Mongo cursor                                            //\n    // interface publishes. Should we make this interface public and encourage                                        //\n    // users to implement it themselves? Arguably, it's unnecessary; users can                                        //\n    // already write their own functions like                                                                         //\n    //   var publishMyReactiveThingy = function (name, handler) {                                                     //\n    //     Meteor.publish(name, function () {                                                                         //\n    //       var reactiveThingy = handler();                                                                          //\n    //       reactiveThingy.publishMe();                                                                              //\n    //     });                                                                                                        //\n    //   };                                                                                                           //\n                                                                                                                      //\n    var self = this;                                                                                                  // 1062\n    var isCursor = function isCursor(c) {                                                                             // 1063\n      return c && c._publishCursor;                                                                                   // 1064\n    };                                                                                                                // 1065\n    if (isCursor(res)) {                                                                                              // 1066\n      try {                                                                                                           // 1067\n        res._publishCursor(self);                                                                                     // 1068\n      } catch (e) {                                                                                                   // 1069\n        self.error(e);                                                                                                // 1070\n        return;                                                                                                       // 1071\n      }                                                                                                               // 1072\n      // _publishCursor only returns after the initial added callbacks have run.                                      //\n      // mark subscription as ready.                                                                                  //\n      self.ready();                                                                                                   // 1075\n    } else if (_.isArray(res)) {                                                                                      // 1076\n      // check all the elements are cursors                                                                           //\n      if (!_.all(res, isCursor)) {                                                                                    // 1078\n        self.error(new Error(\"Publish function returned an array of non-Cursors\"));                                   // 1079\n        return;                                                                                                       // 1080\n      }                                                                                                               // 1081\n      // find duplicate collection names                                                                              //\n      // XXX we should support overlapping cursors, but that would require the                                        //\n      // merge box to allow overlap within a subscription                                                             //\n      var collectionNames = {};                                                                                       // 1085\n      for (var i = 0; i < res.length; ++i) {                                                                          // 1086\n        var collectionName = res[i]._getCollectionName();                                                             // 1087\n        if (_.has(collectionNames, collectionName)) {                                                                 // 1088\n          self.error(new Error(\"Publish function returned multiple cursors for collection \" + collectionName));       // 1089\n          return;                                                                                                     // 1092\n        }                                                                                                             // 1093\n        collectionNames[collectionName] = true;                                                                       // 1094\n      };                                                                                                              // 1095\n                                                                                                                      //\n      try {                                                                                                           // 1097\n        _.each(res, function (cur) {                                                                                  // 1098\n          cur._publishCursor(self);                                                                                   // 1099\n        });                                                                                                           // 1100\n      } catch (e) {                                                                                                   // 1101\n        self.error(e);                                                                                                // 1102\n        return;                                                                                                       // 1103\n      }                                                                                                               // 1104\n      self.ready();                                                                                                   // 1105\n    } else if (res) {                                                                                                 // 1106\n      // truthy values other than cursors or arrays are probably a                                                    //\n      // user mistake (possible returning a Mongo document via, say,                                                  //\n      // `coll.findOne()`).                                                                                           //\n      self.error(new Error(\"Publish function can only return a Cursor or \" + \"an array of Cursors\"));                 // 1110\n    }                                                                                                                 // 1112\n  },                                                                                                                  // 1113\n                                                                                                                      //\n  // This calls all stop callbacks and prevents the handler from updating any                                         //\n  // SessionCollectionViews further. It's used when the user unsubscribes or                                          //\n  // disconnects, as well as during setUserId re-runs. It does *NOT* send                                             //\n  // removed messages for the published objects; if that is necessary, call                                           //\n  // _removeAllDocuments first.                                                                                       //\n  _deactivate: function _deactivate() {                                                                               // 1120\n    var self = this;                                                                                                  // 1121\n    if (self._deactivated) return;                                                                                    // 1122\n    self._deactivated = true;                                                                                         // 1124\n    self._callStopCallbacks();                                                                                        // 1125\n    Package.facts && Package.facts.Facts.incrementServerFact(\"livedata\", \"subscriptions\", -1);                        // 1126\n  },                                                                                                                  // 1128\n                                                                                                                      //\n  _callStopCallbacks: function _callStopCallbacks() {                                                                 // 1130\n    var self = this;                                                                                                  // 1131\n    // tell listeners, so they can clean up                                                                           //\n    var callbacks = self._stopCallbacks;                                                                              // 1133\n    self._stopCallbacks = [];                                                                                         // 1134\n    _.each(callbacks, function (callback) {                                                                           // 1135\n      callback();                                                                                                     // 1136\n    });                                                                                                               // 1137\n  },                                                                                                                  // 1138\n                                                                                                                      //\n  // Send remove messages for every document.                                                                         //\n  _removeAllDocuments: function _removeAllDocuments() {                                                               // 1141\n    var self = this;                                                                                                  // 1142\n    Meteor._noYieldsAllowed(function () {                                                                             // 1143\n      _.each(self._documents, function (collectionDocs, collectionName) {                                             // 1144\n        // Iterate over _.keys instead of the dictionary itself, since we'll be                                       //\n        // mutating it.                                                                                               //\n        _.each(_.keys(collectionDocs), function (strId) {                                                             // 1147\n          self.removed(collectionName, self._idFilter.idParse(strId));                                                // 1148\n        });                                                                                                           // 1149\n      });                                                                                                             // 1150\n    });                                                                                                               // 1151\n  },                                                                                                                  // 1152\n                                                                                                                      //\n  // Returns a new Subscription for the same session with the same                                                    //\n  // initial creation parameters. This isn't a clone: it doesn't have                                                 //\n  // the same _documents cache, stopped state or callbacks; may have a                                                //\n  // different _subscriptionHandle, and gets its userId from the                                                      //\n  // session, not from this object.                                                                                   //\n  _recreate: function _recreate() {                                                                                   // 1159\n    var self = this;                                                                                                  // 1160\n    return new Subscription(self._session, self._handler, self._subscriptionId, self._params, self._name);            // 1161\n  },                                                                                                                  // 1164\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).\n   * @locus Server                                                                                                    //\n   * @param {Error} error The error to pass to the client.                                                            //\n   * @instance                                                                                                        //\n   * @memberOf Subscription                                                                                           //\n   */                                                                                                                 //\n  error: function error(_error) {                                                                                     // 1173\n    var self = this;                                                                                                  // 1174\n    if (self._isDeactivated()) return;                                                                                // 1175\n    self._session._stopSubscription(self._subscriptionId, _error);                                                    // 1177\n  },                                                                                                                  // 1178\n                                                                                                                      //\n  // Note that while our DDP client will notice that you've called stop() on the                                      //\n  // server (and clean up its _subscriptions table) we don't actually provide a                                       //\n  // mechanism for an app to notice this (the subscribe onError callback only                                         //\n  // triggers if there is an error).                                                                                  //\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.\n   * @locus Server                                                                                                    //\n   * @instance                                                                                                        //\n   * @memberOf Subscription                                                                                           //\n   */                                                                                                                 //\n  stop: function stop() {                                                                                             // 1191\n    var self = this;                                                                                                  // 1192\n    if (self._isDeactivated()) return;                                                                                // 1193\n    self._session._stopSubscription(self._subscriptionId);                                                            // 1195\n  },                                                                                                                  // 1196\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.\n   * @locus Server                                                                                                    //\n   * @memberOf Subscription                                                                                           //\n   * @instance                                                                                                        //\n   * @param {Function} func The callback function                                                                     //\n   */                                                                                                                 //\n  onStop: function onStop(callback) {                                                                                 // 1205\n    var self = this;                                                                                                  // 1206\n    if (self._isDeactivated()) callback();else self._stopCallbacks.push(callback);                                    // 1207\n  },                                                                                                                  // 1211\n                                                                                                                      //\n  // This returns true if the sub has been deactivated, *OR* if the session was                                       //\n  // destroyed but the deferred call to _deactivateAllSubscriptions hasn't                                            //\n  // happened yet.                                                                                                    //\n  _isDeactivated: function _isDeactivated() {                                                                         // 1216\n    var self = this;                                                                                                  // 1217\n    return self._deactivated || self._session.inQueue === null;                                                       // 1218\n  },                                                                                                                  // 1219\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.\n   * @locus Server                                                                                                    //\n   * @memberOf Subscription                                                                                           //\n   * @instance                                                                                                        //\n   * @param {String} collection The name of the collection that contains the new document.                            //\n   * @param {String} id The new document's ID.                                                                        //\n   * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.                       //\n   */                                                                                                                 //\n  added: function added(collectionName, id, fields) {                                                                 // 1230\n    var self = this;                                                                                                  // 1231\n    if (self._isDeactivated()) return;                                                                                // 1232\n    id = self._idFilter.idStringify(id);                                                                              // 1234\n    Meteor._ensure(self._documents, collectionName)[id] = true;                                                       // 1235\n    self._session.added(self._subscriptionHandle, collectionName, id, fields);                                        // 1236\n  },                                                                                                                  // 1237\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.\n   * @locus Server                                                                                                    //\n   * @memberOf Subscription                                                                                           //\n   * @instance                                                                                                        //\n   * @param {String} collection The name of the collection that contains the changed document.                        //\n   * @param {String} id The changed document's ID.                                                                    //\n   * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.\n   */                                                                                                                 //\n  changed: function changed(collectionName, id, fields) {                                                             // 1248\n    var self = this;                                                                                                  // 1249\n    if (self._isDeactivated()) return;                                                                                // 1250\n    id = self._idFilter.idStringify(id);                                                                              // 1252\n    self._session.changed(self._subscriptionHandle, collectionName, id, fields);                                      // 1253\n  },                                                                                                                  // 1254\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.\n   * @locus Server                                                                                                    //\n   * @memberOf Subscription                                                                                           //\n   * @instance                                                                                                        //\n   * @param {String} collection The name of the collection that the document has been removed from.                   //\n   * @param {String} id The ID of the document that has been removed.                                                 //\n   */                                                                                                                 //\n  removed: function removed(collectionName, id) {                                                                     // 1264\n    var self = this;                                                                                                  // 1265\n    if (self._isDeactivated()) return;                                                                                // 1266\n    id = self._idFilter.idStringify(id);                                                                              // 1268\n    // We don't bother to delete sets of things in a collection if the                                                //\n    // collection is empty.  It could break _removeAllDocuments.                                                      //\n    delete self._documents[collectionName][id];                                                                       // 1271\n    self._session.removed(self._subscriptionHandle, collectionName, id);                                              // 1272\n  },                                                                                                                  // 1273\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.\n   * @locus Server                                                                                                    //\n   * @memberOf Subscription                                                                                           //\n   * @instance                                                                                                        //\n   */                                                                                                                 //\n  ready: function ready() {                                                                                           // 1281\n    var self = this;                                                                                                  // 1282\n    if (self._isDeactivated()) return;                                                                                // 1283\n    if (!self._subscriptionId) return; // unnecessary but ignored for universal sub                                   // 1285\n    if (!self._ready) {                                                                                               // 1287\n      self._session.sendReady([self._subscriptionId]);                                                                // 1288\n      self._ready = true;                                                                                             // 1289\n    }                                                                                                                 // 1290\n  }                                                                                                                   // 1291\n});                                                                                                                   // 1015\n                                                                                                                      //\n/******************************************************************************/                                      //\n/* Server                                                                     */                                      //\n/******************************************************************************/                                      //\n                                                                                                                      //\nServer = function Server(options) {                                                                                   // 1298\n  var self = this;                                                                                                    // 1299\n                                                                                                                      //\n  // The default heartbeat interval is 30 seconds on the server and 35                                                //\n  // seconds on the client.  Since the client doesn't need to send a                                                  //\n  // ping as long as it is receiving pings, this means that pings                                                     //\n  // normally go from the server to the client.                                                                       //\n  //                                                                                                                  //\n  // Note: Troposphere depends on the ability to mutate                                                               //\n  // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.                                           //\n  self.options = _.defaults(options || {}, {                                                                          // 1308\n    heartbeatInterval: 15000,                                                                                         // 1309\n    heartbeatTimeout: 15000,                                                                                          // 1310\n    // For testing, allow responding to pings to be disabled.                                                         //\n    respondToPings: true                                                                                              // 1312\n  });                                                                                                                 // 1308\n                                                                                                                      //\n  // Map of callbacks to call when a new connection comes in to the                                                   //\n  // server and completes DDP version negotiation. Use an object instead                                              //\n  // of an array so we can safely remove one from the list while                                                      //\n  // iterating over it.                                                                                               //\n  self.onConnectionHook = new Hook({                                                                                  // 1319\n    debugPrintExceptions: \"onConnection callback\"                                                                     // 1320\n  });                                                                                                                 // 1319\n                                                                                                                      //\n  self.publish_handlers = {};                                                                                         // 1323\n  self.universal_publish_handlers = [];                                                                               // 1324\n                                                                                                                      //\n  self.method_handlers = {};                                                                                          // 1326\n                                                                                                                      //\n  self.sessions = {}; // map from id to session                                                                       // 1328\n                                                                                                                      //\n  self.stream_server = new StreamServer();                                                                            // 1330\n                                                                                                                      //\n  self.stream_server.register(function (socket) {                                                                     // 1332\n    // socket implements the SockJSConnection interface                                                               //\n    socket._meteorSession = null;                                                                                     // 1334\n                                                                                                                      //\n    var sendError = function sendError(reason, offendingMessage) {                                                    // 1336\n      var msg = { msg: 'error', reason: reason };                                                                     // 1337\n      if (offendingMessage) msg.offendingMessage = offendingMessage;                                                  // 1338\n      socket.send(DDPCommon.stringifyDDP(msg));                                                                       // 1340\n    };                                                                                                                // 1341\n                                                                                                                      //\n    socket.on('data', function (raw_msg) {                                                                            // 1343\n      if (Meteor._printReceivedDDP) {                                                                                 // 1344\n        Meteor._debug(\"Received DDP\", raw_msg);                                                                       // 1345\n      }                                                                                                               // 1346\n      try {                                                                                                           // 1347\n        try {                                                                                                         // 1348\n          var msg = DDPCommon.parseDDP(raw_msg);                                                                      // 1349\n        } catch (err) {                                                                                               // 1350\n          sendError('Parse error');                                                                                   // 1351\n          return;                                                                                                     // 1352\n        }                                                                                                             // 1353\n        if (msg === null || !msg.msg) {                                                                               // 1354\n          sendError('Bad request', msg);                                                                              // 1355\n          return;                                                                                                     // 1356\n        }                                                                                                             // 1357\n                                                                                                                      //\n        if (msg.msg === 'connect') {                                                                                  // 1359\n          if (socket._meteorSession) {                                                                                // 1360\n            sendError(\"Already connected\", msg);                                                                      // 1361\n            return;                                                                                                   // 1362\n          }                                                                                                           // 1363\n          Fiber(function () {                                                                                         // 1364\n            self._handleConnect(socket, msg);                                                                         // 1365\n          }).run();                                                                                                   // 1366\n          return;                                                                                                     // 1367\n        }                                                                                                             // 1368\n                                                                                                                      //\n        if (!socket._meteorSession) {                                                                                 // 1370\n          sendError('Must connect first', msg);                                                                       // 1371\n          return;                                                                                                     // 1372\n        }                                                                                                             // 1373\n        socket._meteorSession.processMessage(msg);                                                                    // 1374\n      } catch (e) {                                                                                                   // 1375\n        // XXX print stack nicely                                                                                     //\n        Meteor._debug(\"Internal exception while processing message\", msg, e.message, e.stack);                        // 1377\n      }                                                                                                               // 1379\n    });                                                                                                               // 1380\n                                                                                                                      //\n    socket.on('close', function () {                                                                                  // 1382\n      if (socket._meteorSession) {                                                                                    // 1383\n        Fiber(function () {                                                                                           // 1384\n          socket._meteorSession.close();                                                                              // 1385\n        }).run();                                                                                                     // 1386\n      }                                                                                                               // 1387\n    });                                                                                                               // 1388\n  });                                                                                                                 // 1389\n};                                                                                                                    // 1390\n                                                                                                                      //\n_.extend(Server.prototype, {                                                                                          // 1392\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Register a callback to be called when a new DDP connection is made to the server.                       //\n   * @locus Server                                                                                                    //\n   * @param {function} callback The function to call when a new DDP connection is established.                        //\n   * @memberOf Meteor                                                                                                 //\n   * @importFromPackage meteor                                                                                        //\n   */                                                                                                                 //\n  onConnection: function onConnection(fn) {                                                                           // 1401\n    var self = this;                                                                                                  // 1402\n    return self.onConnectionHook.register(fn);                                                                        // 1403\n  },                                                                                                                  // 1404\n                                                                                                                      //\n  _handleConnect: function _handleConnect(socket, msg) {                                                              // 1406\n    var self = this;                                                                                                  // 1407\n                                                                                                                      //\n    // The connect message must specify a version and an array of supported                                           //\n    // versions, and it must claim to support what it is proposing.                                                   //\n    if (!(typeof msg.version === 'string' && _.isArray(msg.support) && _.all(msg.support, _.isString) && _.contains(msg.support, msg.version))) {\n      socket.send(DDPCommon.stringifyDDP({ msg: 'failed',                                                             // 1415\n        version: DDPCommon.SUPPORTED_DDP_VERSIONS[0] }));                                                             // 1416\n      socket.close();                                                                                                 // 1417\n      return;                                                                                                         // 1418\n    }                                                                                                                 // 1419\n                                                                                                                      //\n    // In the future, handle session resumption: something like:                                                      //\n    //  socket._meteorSession = self.sessions[msg.session]                                                            //\n    var version = calculateVersion(msg.support, DDPCommon.SUPPORTED_DDP_VERSIONS);                                    // 1423\n                                                                                                                      //\n    if (msg.version !== version) {                                                                                    // 1425\n      // The best version to use (according to the client's stated preferences)                                       //\n      // is not the one the client is trying to use. Inform them about the best                                       //\n      // version to use.                                                                                              //\n      socket.send(DDPCommon.stringifyDDP({ msg: 'failed', version: version }));                                       // 1429\n      socket.close();                                                                                                 // 1430\n      return;                                                                                                         // 1431\n    }                                                                                                                 // 1432\n                                                                                                                      //\n    // Yay, version matches! Create a new session.                                                                    //\n    // Note: Troposphere depends on the ability to mutate                                                             //\n    // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.                                         //\n    socket._meteorSession = new Session(self, version, socket, self.options);                                         // 1437\n    self.sessions[socket._meteorSession.id] = socket._meteorSession;                                                  // 1438\n    self.onConnectionHook.each(function (callback) {                                                                  // 1439\n      if (socket._meteorSession) callback(socket._meteorSession.connectionHandle);                                    // 1440\n      return true;                                                                                                    // 1442\n    });                                                                                                               // 1443\n  },                                                                                                                  // 1444\n  /**                                                                                                                 //\n   * Register a publish handler function.                                                                             //\n   *                                                                                                                  //\n   * @param name {String} identifier for query                                                                        //\n   * @param handler {Function} publish handler                                                                        //\n   * @param options {Object}                                                                                          //\n   *                                                                                                                  //\n   * Server will call handler function on each new subscription,                                                      //\n   * either when receiving DDP sub message for a named subscription, or on                                            //\n   * DDP connect for a universal subscription.                                                                        //\n   *                                                                                                                  //\n   * If name is null, this will be a subscription that is                                                             //\n   * automatically established and permanently on for all connected                                                   //\n   * client, instead of a subscription that can be turned on and off                                                  //\n   * with subscribe().                                                                                                //\n   *                                                                                                                  //\n   * options to contain:                                                                                              //\n   *  - (mostly internal) is_auto: true if generated automatically                                                    //\n   *    from an autopublish hook. this is for cosmetic purposes only                                                  //\n   *    (it lets us determine whether to print a warning suggesting                                                   //\n   *    that you turn off autopublish.)                                                                               //\n   */                                                                                                                 //\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Publish a record set.                                                                                   //\n   * @memberOf Meteor                                                                                                 //\n   * @importFromPackage meteor                                                                                        //\n   * @locus Server                                                                                                    //\n   * @param {String|Object} name If String, name of the record set.  If Object, publications Dictionary of publish functions by name.  If `null`, the set has no name, and the record set is automatically sent to all connected clients.\n   * @param {Function} func Function called on the server each time a client subscribes.  Inside the function, `this` is the publish handler object, described below.  If the client passed arguments to `subscribe`, the function is called with the same arguments.\n   */                                                                                                                 //\n  publish: function publish(name, handler, options) {                                                                 // 1476\n    var self = this;                                                                                                  // 1477\n                                                                                                                      //\n    if (!_.isObject(name)) {                                                                                          // 1479\n      options = options || {};                                                                                        // 1480\n                                                                                                                      //\n      if (name && name in self.publish_handlers) {                                                                    // 1482\n        Meteor._debug(\"Ignoring duplicate publish named '\" + name + \"'\");                                             // 1483\n        return;                                                                                                       // 1484\n      }                                                                                                               // 1485\n                                                                                                                      //\n      if (Package.autopublish && !options.is_auto) {                                                                  // 1487\n        // They have autopublish on, yet they're trying to manually                                                   //\n        // picking stuff to publish. They probably should turn off                                                    //\n        // autopublish. (This check isn't perfect -- if you create a                                                  //\n        // publish before you turn on autopublish, it won't catch                                                     //\n        // it. But this will definitely handle the simple case where                                                  //\n        // you've added the autopublish package to your app, and are                                                  //\n        // calling publish from your app code.)                                                                       //\n        if (!self.warned_about_autopublish) {                                                                         // 1495\n          self.warned_about_autopublish = true;                                                                       // 1496\n          Meteor._debug(\"** You've set up some data subscriptions with Meteor.publish(), but\\n\" + \"** you still have autopublish turned on. Because autopublish is still\\n\" + \"** on, your Meteor.publish() calls won't have much effect. All data\\n\" + \"** will still be sent to all clients.\\n\" + \"**\\n\" + \"** Turn off autopublish by removing the autopublish package:\\n\" + \"**\\n\" + \"**   $ meteor remove autopublish\\n\" + \"**\\n\" + \"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\n\" + \"** for each collection that you want clients to see.\\n\");\n        }                                                                                                             // 1509\n      }                                                                                                               // 1510\n                                                                                                                      //\n      if (name) self.publish_handlers[name] = handler;else {                                                          // 1512\n        self.universal_publish_handlers.push(handler);                                                                // 1515\n        // Spin up the new publisher on any existing session too. Run each                                            //\n        // session's subscription in a new Fiber, so that there's no change for                                       //\n        // self.sessions to change while we're running this loop.                                                     //\n        _.each(self.sessions, function (session) {                                                                    // 1519\n          if (!session._dontStartNewUniversalSubs) {                                                                  // 1520\n            Fiber(function () {                                                                                       // 1521\n              session._startSubscription(handler);                                                                    // 1522\n            }).run();                                                                                                 // 1523\n          }                                                                                                           // 1524\n        });                                                                                                           // 1525\n      }                                                                                                               // 1526\n    } else {                                                                                                          // 1527\n      _.each(name, function (value, key) {                                                                            // 1529\n        self.publish(key, value, {});                                                                                 // 1530\n      });                                                                                                             // 1531\n    }                                                                                                                 // 1532\n  },                                                                                                                  // 1533\n                                                                                                                      //\n  _removeSession: function _removeSession(session) {                                                                  // 1535\n    var self = this;                                                                                                  // 1536\n    if (self.sessions[session.id]) {                                                                                  // 1537\n      delete self.sessions[session.id];                                                                               // 1538\n    }                                                                                                                 // 1539\n  },                                                                                                                  // 1540\n                                                                                                                      //\n  /**                                                                                                                 //\n   * @summary Defines functions that can be invoked over the network by clients.                                      //\n   * @locus Anywhere                                                                                                  //\n   * @param {Object} methods Dictionary whose keys are method names and values are functions.                         //\n   * @memberOf Meteor                                                                                                 //\n   * @importFromPackage meteor                                                                                        //\n   */                                                                                                                 //\n  methods: function methods(_methods) {                                                                               // 1549\n    var self = this;                                                                                                  // 1550\n    _.each(_methods, function (func, name) {                                                                          // 1551\n      if (typeof func !== 'function') throw new Error(\"Method '\" + name + \"' must be a function\");                    // 1552\n      if (self.method_handlers[name]) throw new Error(\"A method named '\" + name + \"' is already defined\");            // 1554\n      self.method_handlers[name] = func;                                                                              // 1556\n    });                                                                                                               // 1557\n  },                                                                                                                  // 1558\n                                                                                                                      //\n  call: function call(name /*, arguments */) {                                                                        // 1560\n    // if it's a function, the last argument is the result callback,                                                  //\n    // not a parameter to the remote method.                                                                          //\n    var args = Array.prototype.slice.call(arguments, 1);                                                              // 1563\n    if (args.length && typeof args[args.length - 1] === \"function\") var callback = args.pop();                        // 1564\n    return this.apply(name, args, callback);                                                                          // 1566\n  },                                                                                                                  // 1567\n                                                                                                                      //\n  // @param options {Optional Object}                                                                                 //\n  // @param callback {Optional Function}                                                                              //\n  apply: function apply(name, args, options, callback) {                                                              // 1571\n    var self = this;                                                                                                  // 1572\n                                                                                                                      //\n    // We were passed 3 arguments. They may be either (name, args, options)                                           //\n    // or (name, args, callback)                                                                                      //\n    if (!callback && typeof options === 'function') {                                                                 // 1576\n      callback = options;                                                                                             // 1577\n      options = {};                                                                                                   // 1578\n    }                                                                                                                 // 1579\n    options = options || {};                                                                                          // 1580\n                                                                                                                      //\n    if (callback)                                                                                                     // 1582\n      // It's not really necessary to do this, since we immediately                                                   //\n      // run the callback in this fiber before returning, but we do it                                                //\n      // anyway for regularity.                                                                                       //\n      // XXX improve error message (and how we report it)                                                             //\n      callback = Meteor.bindEnvironment(callback, \"delivering result of invoking '\" + name + \"'\");                    // 1587\n                                                                                                                      //\n    // Run the handler                                                                                                //\n    var handler = self.method_handlers[name];                                                                         // 1593\n    var exception;                                                                                                    // 1594\n    if (!handler) {                                                                                                   // 1595\n      exception = new Meteor.Error(404, \"Method '\" + name + \"' not found\");                                           // 1596\n    } else {                                                                                                          // 1597\n      // If this is a method call from within another method, get the                                                 //\n      // user state from the outer method, otherwise don't allow                                                      //\n      // setUserId to be called                                                                                       //\n      var userId = null;                                                                                              // 1601\n      var setUserId = function setUserId() {                                                                          // 1602\n        throw new Error(\"Can't call setUserId on a server initiated method call\");                                    // 1603\n      };                                                                                                              // 1604\n      var connection = null;                                                                                          // 1605\n      var currentInvocation = DDP._CurrentInvocation.get();                                                           // 1606\n      if (currentInvocation) {                                                                                        // 1607\n        userId = currentInvocation.userId;                                                                            // 1608\n        setUserId = function setUserId(userId) {                                                                      // 1609\n          currentInvocation.setUserId(userId);                                                                        // 1610\n        };                                                                                                            // 1611\n        connection = currentInvocation.connection;                                                                    // 1612\n      }                                                                                                               // 1613\n                                                                                                                      //\n      var invocation = new DDPCommon.MethodInvocation({                                                               // 1615\n        isSimulation: false,                                                                                          // 1616\n        userId: userId,                                                                                               // 1617\n        setUserId: setUserId,                                                                                         // 1618\n        connection: connection,                                                                                       // 1619\n        randomSeed: DDPCommon.makeRpcSeed(currentInvocation, name)                                                    // 1620\n      });                                                                                                             // 1615\n      try {                                                                                                           // 1622\n        var result = DDP._CurrentInvocation.withValue(invocation, function () {                                       // 1623\n          return maybeAuditArgumentChecks(handler, invocation, EJSON.clone(args), \"internal call to '\" + name + \"'\");\n        });                                                                                                           // 1627\n        result = EJSON.clone(result);                                                                                 // 1628\n      } catch (e) {                                                                                                   // 1629\n        exception = e;                                                                                                // 1630\n      }                                                                                                               // 1631\n    }                                                                                                                 // 1632\n                                                                                                                      //\n    // Return the result in whichever way the caller asked for it. Note that we                                       //\n    // do NOT block on the write fence in an analogous way to how the client                                          //\n    // blocks on the relevant data being visible, so you are NOT guaranteed that                                      //\n    // cursor observe callbacks have fired when your callback is invoked. (We                                         //\n    // can change this if there's a real use case.)                                                                   //\n    if (callback) {                                                                                                   // 1639\n      callback(exception, result);                                                                                    // 1640\n      return undefined;                                                                                               // 1641\n    }                                                                                                                 // 1642\n    if (exception) throw exception;                                                                                   // 1643\n    return result;                                                                                                    // 1645\n  },                                                                                                                  // 1646\n                                                                                                                      //\n  _urlForSession: function _urlForSession(sessionId) {                                                                // 1648\n    var self = this;                                                                                                  // 1649\n    var session = self.sessions[sessionId];                                                                           // 1650\n    if (session) return session._socketUrl;else return null;                                                          // 1651\n  }                                                                                                                   // 1655\n});                                                                                                                   // 1392\n                                                                                                                      //\nvar calculateVersion = function calculateVersion(clientSupportedVersions, serverSupportedVersions) {                  // 1658\n  var correctVersion = _.find(clientSupportedVersions, function (version) {                                           // 1660\n    return _.contains(serverSupportedVersions, version);                                                              // 1661\n  });                                                                                                                 // 1662\n  if (!correctVersion) {                                                                                              // 1663\n    correctVersion = serverSupportedVersions[0];                                                                      // 1664\n  }                                                                                                                   // 1665\n  return correctVersion;                                                                                              // 1666\n};                                                                                                                    // 1667\n                                                                                                                      //\nDDPServer._calculateVersion = calculateVersion;                                                                       // 1669\n                                                                                                                      //\n// \"blind\" exceptions other than those that were deliberately thrown to signal                                        //\n// errors to the client                                                                                               //\nvar wrapInternalException = function wrapInternalException(exception, context) {                                      // 1674\n  if (!exception || exception instanceof Meteor.Error) return exception;                                              // 1675\n                                                                                                                      //\n  // tests can set the 'expected' flag on an exception so it won't go to the                                          //\n  // server log                                                                                                       //\n  if (!exception.expected) {                                                                                          // 1680\n    Meteor._debug(\"Exception \" + context, exception.stack);                                                           // 1681\n    if (exception.sanitizedError) {                                                                                   // 1682\n      Meteor._debug(\"Sanitized and reported to the client as:\", exception.sanitizedError.message);                    // 1683\n      Meteor._debug();                                                                                                // 1684\n    }                                                                                                                 // 1685\n  }                                                                                                                   // 1686\n                                                                                                                      //\n  // Did the error contain more details that could have been useful if caught in                                      //\n  // server code (or if thrown from non-client-originated code), but also                                             //\n  // provided a \"sanitized\" version with more context than 500 Internal server                                        //\n  // error? Use that.                                                                                                 //\n  if (exception.sanitizedError) {                                                                                     // 1692\n    if (exception.sanitizedError instanceof Meteor.Error) return exception.sanitizedError;                            // 1693\n    Meteor._debug(\"Exception \" + context + \" provides a sanitizedError that \" + \"is not a Meteor.Error; ignoring\");   // 1695\n  }                                                                                                                   // 1697\n                                                                                                                      //\n  return new Meteor.Error(500, \"Internal server error\");                                                              // 1699\n};                                                                                                                    // 1700\n                                                                                                                      //\n// Audit argument checks, if the audit-argument-checks package exists (it is a                                        //\n// weak dependency of this package).                                                                                  //\nvar maybeAuditArgumentChecks = function maybeAuditArgumentChecks(f, context, args, description) {                     // 1705\n  args = args || [];                                                                                                  // 1706\n  if (Package['audit-argument-checks']) {                                                                             // 1707\n    return Match._failIfArgumentsAreNotAllChecked(f, context, args, description);                                     // 1708\n  }                                                                                                                   // 1710\n  return f.apply(context, args);                                                                                      // 1711\n};                                                                                                                    // 1712\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"writefence.js\":function(require){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/ddp-server/writefence.js                                                                                  //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nvar path = Npm.require('path');                                                                                       // 1\nvar Future = Npm.require(path.join('fibers', 'future'));                                                              // 2\n                                                                                                                      //\n// A write fence collects a group of writes, and provides a callback                                                  //\n// when all of the writes are fully committed and propagated (all                                                     //\n// observers have been notified of the write and acknowledged it.)                                                    //\n//                                                                                                                    //\nDDPServer._WriteFence = function () {                                                                                 // 8\n  var self = this;                                                                                                    // 9\n                                                                                                                      //\n  self.armed = false;                                                                                                 // 11\n  self.fired = false;                                                                                                 // 12\n  self.retired = false;                                                                                               // 13\n  self.outstanding_writes = 0;                                                                                        // 14\n  self.before_fire_callbacks = [];                                                                                    // 15\n  self.completion_callbacks = [];                                                                                     // 16\n};                                                                                                                    // 17\n                                                                                                                      //\n// The current write fence. When there is a current write fence, code                                                 //\n// that writes to databases should register their writes with it using                                                //\n// beginWrite().                                                                                                      //\n//                                                                                                                    //\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable();                                                      // 23\n                                                                                                                      //\n_.extend(DDPServer._WriteFence.prototype, {                                                                           // 25\n  // Start tracking a write, and return an object to represent it. The                                                //\n  // object has a single method, committed(). This method should be                                                   //\n  // called when the write is fully committed and propagated. You can                                                 //\n  // continue to add writes to the WriteFence up until it is triggered                                                //\n  // (calls its callbacks because all writes have committed.)                                                         //\n  beginWrite: function beginWrite() {                                                                                 // 31\n    var self = this;                                                                                                  // 32\n                                                                                                                      //\n    if (self.retired) return { committed: function committed() {} };                                                  // 34\n                                                                                                                      //\n    if (self.fired) throw new Error(\"fence has already activated -- too late to add writes\");                         // 37\n                                                                                                                      //\n    self.outstanding_writes++;                                                                                        // 40\n    var _committed = false;                                                                                           // 41\n    return {                                                                                                          // 42\n      committed: function committed() {                                                                               // 43\n        if (_committed) throw new Error(\"committed called twice on the same write\");                                  // 44\n        _committed = true;                                                                                            // 46\n        self.outstanding_writes--;                                                                                    // 47\n        self._maybeFire();                                                                                            // 48\n      }                                                                                                               // 49\n    };                                                                                                                // 42\n  },                                                                                                                  // 51\n                                                                                                                      //\n  // Arm the fence. Once the fence is armed, and there are no more                                                    //\n  // uncommitted writes, it will activate.                                                                            //\n  arm: function arm() {                                                                                               // 55\n    var self = this;                                                                                                  // 56\n    if (self === DDPServer._CurrentWriteFence.get()) throw Error(\"Can't arm the current fence\");                      // 57\n    self.armed = true;                                                                                                // 59\n    self._maybeFire();                                                                                                // 60\n  },                                                                                                                  // 61\n                                                                                                                      //\n  // Register a function to be called once before firing the fence.                                                   //\n  // Callback function can add new writes to the fence, in which case                                                 //\n  // it won't fire until those writes are done as well.                                                               //\n  onBeforeFire: function onBeforeFire(func) {                                                                         // 66\n    var self = this;                                                                                                  // 67\n    if (self.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\");                // 68\n    self.before_fire_callbacks.push(func);                                                                            // 71\n  },                                                                                                                  // 72\n                                                                                                                      //\n  // Register a function to be called when the fence fires.                                                           //\n  onAllCommitted: function onAllCommitted(func) {                                                                     // 75\n    var self = this;                                                                                                  // 76\n    if (self.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\");                // 77\n    self.completion_callbacks.push(func);                                                                             // 80\n  },                                                                                                                  // 81\n                                                                                                                      //\n  // Convenience function. Arms the fence, then blocks until it fires.                                                //\n  armAndWait: function armAndWait() {                                                                                 // 84\n    var self = this;                                                                                                  // 85\n    var future = new Future();                                                                                        // 86\n    self.onAllCommitted(function () {                                                                                 // 87\n      future['return']();                                                                                             // 88\n    });                                                                                                               // 89\n    self.arm();                                                                                                       // 90\n    future.wait();                                                                                                    // 91\n  },                                                                                                                  // 92\n                                                                                                                      //\n  _maybeFire: function _maybeFire() {                                                                                 // 94\n    var self = this;                                                                                                  // 95\n    if (self.fired) throw new Error(\"write fence already activated?\");                                                // 96\n    if (self.armed && !self.outstanding_writes) {                                                                     // 98\n      var invokeCallback = function invokeCallback(func) {                                                            // 98\n        try {                                                                                                         // 100\n          func(self);                                                                                                 // 101\n        } catch (err) {                                                                                               // 102\n          Meteor._debug(\"exception in write fence callback:\", err);                                                   // 103\n        }                                                                                                             // 104\n      };                                                                                                              // 105\n                                                                                                                      //\n      self.outstanding_writes++;                                                                                      // 107\n      while (self.before_fire_callbacks.length > 0) {                                                                 // 108\n        var callbacks = self.before_fire_callbacks;                                                                   // 109\n        self.before_fire_callbacks = [];                                                                              // 110\n        _.each(callbacks, invokeCallback);                                                                            // 111\n      }                                                                                                               // 112\n      self.outstanding_writes--;                                                                                      // 113\n                                                                                                                      //\n      if (!self.outstanding_writes) {                                                                                 // 115\n        self.fired = true;                                                                                            // 116\n        var callbacks = self.completion_callbacks;                                                                    // 117\n        self.completion_callbacks = [];                                                                               // 118\n        _.each(callbacks, invokeCallback);                                                                            // 119\n      }                                                                                                               // 120\n    }                                                                                                                 // 121\n  },                                                                                                                  // 122\n                                                                                                                      //\n  // Deactivate this fence so that adding more writes has no effect.                                                  //\n  // The fence must have already fired.                                                                               //\n  retire: function retire() {                                                                                         // 126\n    var self = this;                                                                                                  // 127\n    if (!self.fired) throw new Error(\"Can't retire a fence that hasn't fired.\");                                      // 128\n    self.retired = true;                                                                                              // 130\n  }                                                                                                                   // 131\n});                                                                                                                   // 25\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"crossbar.js\":function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/ddp-server/crossbar.js                                                                                    //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n// A \"crossbar\" is a class that provides structured notification registration.                                        //\n// See _match for the definition of how a notification matches a trigger.                                             //\n// All notifications and triggers must have a string key named 'collection'.                                          //\n                                                                                                                      //\nDDPServer._Crossbar = function (options) {                                                                            // 5\n  var self = this;                                                                                                    // 6\n  options = options || {};                                                                                            // 7\n                                                                                                                      //\n  self.nextId = 1;                                                                                                    // 9\n  // map from collection name (string) -> listener id -> object. each object has                                      //\n  // keys 'trigger', 'callback'.  As a hack, the empty string means \"no                                               //\n  // collection\".                                                                                                     //\n  self.listenersByCollection = {};                                                                                    // 13\n  self.factPackage = options.factPackage || \"livedata\";                                                               // 14\n  self.factName = options.factName || null;                                                                           // 15\n};                                                                                                                    // 16\n                                                                                                                      //\n_.extend(DDPServer._Crossbar.prototype, {                                                                             // 18\n  // msg is a trigger or a notification                                                                               //\n  _collectionForMessage: function _collectionForMessage(msg) {                                                        // 20\n    var self = this;                                                                                                  // 21\n    if (!_.has(msg, 'collection')) {                                                                                  // 22\n      return '';                                                                                                      // 23\n    } else if (typeof msg.collection === 'string') {                                                                  // 24\n      if (msg.collection === '') throw Error(\"Message has empty collection!\");                                        // 25\n      return msg.collection;                                                                                          // 27\n    } else {                                                                                                          // 28\n      throw Error(\"Message has non-string collection!\");                                                              // 29\n    }                                                                                                                 // 30\n  },                                                                                                                  // 31\n                                                                                                                      //\n  // Listen for notification that match 'trigger'. A notification                                                     //\n  // matches if it has the key-value pairs in trigger as a                                                            //\n  // subset. When a notification matches, call 'callback', passing                                                    //\n  // the actual notification.                                                                                         //\n  //                                                                                                                  //\n  // Returns a listen handle, which is an object with a method                                                        //\n  // stop(). Call stop() to stop listening.                                                                           //\n  //                                                                                                                  //\n  // XXX It should be legal to call fire() from inside a listen()                                                     //\n  // callback?                                                                                                        //\n  listen: function listen(trigger, callback) {                                                                        // 43\n    var self = this;                                                                                                  // 44\n    var id = self.nextId++;                                                                                           // 45\n                                                                                                                      //\n    var collection = self._collectionForMessage(trigger);                                                             // 47\n    var record = { trigger: EJSON.clone(trigger), callback: callback };                                               // 48\n    if (!_.has(self.listenersByCollection, collection)) {                                                             // 49\n      self.listenersByCollection[collection] = {};                                                                    // 50\n    }                                                                                                                 // 51\n    self.listenersByCollection[collection][id] = record;                                                              // 52\n                                                                                                                      //\n    if (self.factName && Package.facts) {                                                                             // 54\n      Package.facts.Facts.incrementServerFact(self.factPackage, self.factName, 1);                                    // 55\n    }                                                                                                                 // 57\n                                                                                                                      //\n    return {                                                                                                          // 59\n      stop: function stop() {                                                                                         // 60\n        if (self.factName && Package.facts) {                                                                         // 61\n          Package.facts.Facts.incrementServerFact(self.factPackage, self.factName, -1);                               // 62\n        }                                                                                                             // 64\n        delete self.listenersByCollection[collection][id];                                                            // 65\n        if (_.isEmpty(self.listenersByCollection[collection])) {                                                      // 66\n          delete self.listenersByCollection[collection];                                                              // 67\n        }                                                                                                             // 68\n      }                                                                                                               // 69\n    };                                                                                                                // 59\n  },                                                                                                                  // 71\n                                                                                                                      //\n  // Fire the provided 'notification' (an object whose attribute                                                      //\n  // values are all JSON-compatibile) -- inform all matching listeners                                                //\n  // (registered with listen()).                                                                                      //\n  //                                                                                                                  //\n  // If fire() is called inside a write fence, then each of the                                                       //\n  // listener callbacks will be called inside the write fence as well.                                                //\n  //                                                                                                                  //\n  // The listeners may be invoked in parallel, rather than serially.                                                  //\n  fire: function fire(notification) {                                                                                 // 81\n    var self = this;                                                                                                  // 82\n                                                                                                                      //\n    var collection = self._collectionForMessage(notification);                                                        // 84\n                                                                                                                      //\n    if (!_.has(self.listenersByCollection, collection)) {                                                             // 86\n      return;                                                                                                         // 87\n    }                                                                                                                 // 88\n                                                                                                                      //\n    var listenersForCollection = self.listenersByCollection[collection];                                              // 90\n    var callbackIds = [];                                                                                             // 91\n    _.each(listenersForCollection, function (l, id) {                                                                 // 92\n      if (self._matches(notification, l.trigger)) {                                                                   // 93\n        callbackIds.push(id);                                                                                         // 94\n      }                                                                                                               // 95\n    });                                                                                                               // 96\n                                                                                                                      //\n    // Listener callbacks can yield, so we need to first find all the ones that                                       //\n    // match in a single iteration over self.listenersByCollection (which can't                                       //\n    // be mutated during this iteration), and then invoke the matching                                                //\n    // callbacks, checking before each call to ensure they haven't stopped.                                           //\n    // Note that we don't have to check that                                                                          //\n    // self.listenersByCollection[collection] still === listenersForCollection,                                       //\n    // because the only way that stops being true is if listenersForCollection                                        //\n    // first gets reduced down to the empty object (and then never gets                                               //\n    // increased again).                                                                                              //\n    _.each(callbackIds, function (id) {                                                                               // 107\n      if (_.has(listenersForCollection, id)) {                                                                        // 108\n        listenersForCollection[id].callback(notification);                                                            // 109\n      }                                                                                                               // 110\n    });                                                                                                               // 111\n  },                                                                                                                  // 112\n                                                                                                                      //\n  // A notification matches a trigger if all keys that exist in both are equal.                                       //\n  //                                                                                                                  //\n  // Examples:                                                                                                        //\n  //  N:{collection: \"C\"} matches T:{collection: \"C\"}                                                                 //\n  //    (a non-targeted write to a collection matches a                                                               //\n  //     non-targeted query)                                                                                          //\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\"}                                                        //\n  //    (a targeted write to a collection matches a non-targeted query)                                               //\n  //  N:{collection: \"C\"} matches T:{collection: \"C\", id: \"X\"}                                                        //\n  //    (a non-targeted write to a collection matches a                                                               //\n  //     targeted query)                                                                                              //\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\", id: \"X\"}                                               //\n  //    (a targeted write to a collection matches a targeted query targeted                                           //\n  //     at the same document)                                                                                        //\n  //  N:{collection: \"C\", id: \"X\"} does not match T:{collection: \"C\", id: \"Y\"}                                        //\n  //    (a targeted write to a collection does not match a targeted query                                             //\n  //     targeted at a different document)                                                                            //\n  _matches: function _matches(notification, trigger) {                                                                // 131\n    // Most notifications that use the crossbar have a string `collection` and                                        //\n    // maybe an `id` that is a string or ObjectID. We're already dividing up                                          //\n    // triggers by collection, but let's fast-track \"nope, different ID\" (and                                         //\n    // avoid the overly generic EJSON.equals). This makes a noticeable                                                //\n    // performance difference; see https://github.com/meteor/meteor/pull/3697                                         //\n    if (typeof notification.id === 'string' && typeof trigger.id === 'string' && notification.id !== trigger.id) {    // 137\n      return false;                                                                                                   // 140\n    }                                                                                                                 // 141\n    if (notification.id instanceof MongoID.ObjectID && trigger.id instanceof MongoID.ObjectID && !notification.id.equals(trigger.id)) {\n      return false;                                                                                                   // 145\n    }                                                                                                                 // 146\n                                                                                                                      //\n    return _.all(trigger, function (triggerValue, key) {                                                              // 148\n      return !_.has(notification, key) || EJSON.equals(triggerValue, notification[key]);                              // 149\n    });                                                                                                               // 151\n  }                                                                                                                   // 152\n});                                                                                                                   // 18\n                                                                                                                      //\n// The \"invalidation crossbar\" is a specific instance used by the DDP server to                                       //\n// implement write fence notifications. Listener callbacks on this crossbar                                           //\n// should call beginWrite on the current write fence before they return, if they                                      //\n// want to delay the write fence from firing (ie, the DDP method-data-updated                                         //\n// message from being sent).                                                                                          //\nDDPServer._InvalidationCrossbar = new DDPServer._Crossbar({                                                           // 160\n  factName: \"invalidation-crossbar-listeners\"                                                                         // 161\n});                                                                                                                   // 160\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"server_convenience.js\":function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/ddp-server/server_convenience.js                                                                          //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nif (process.env.DDP_DEFAULT_CONNECTION_URL) {                                                                         // 1\n  __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL = process.env.DDP_DEFAULT_CONNECTION_URL;                      // 2\n}                                                                                                                     // 4\n                                                                                                                      //\nMeteor.server = new Server();                                                                                         // 6\n                                                                                                                      //\nMeteor.refresh = function (notification) {                                                                            // 8\n  DDPServer._InvalidationCrossbar.fire(notification);                                                                 // 9\n};                                                                                                                    // 10\n                                                                                                                      //\n// Proxy the public methods of Meteor.server so they can                                                              //\n// be called directly on Meteor.                                                                                      //\n_.each(['publish', 'methods', 'call', 'apply', 'onConnection'], function (name) {                                     // 14\n  Meteor[name] = _.bind(Meteor.server[name], Meteor.server);                                                          // 16\n});                                                                                                                   // 17\n                                                                                                                      //\n// Meteor.server used to be called Meteor.default_server. Provide                                                     //\n// backcompat as a courtesy even though it was never documented.                                                      //\n// XXX COMPAT WITH 0.6.4                                                                                              //\nMeteor.default_server = Meteor.server;                                                                                // 22\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\"extensions\":[\".js\",\".json\"]});\nrequire(\"./node_modules/meteor/ddp-server/stream_server.js\");\nrequire(\"./node_modules/meteor/ddp-server/livedata_server.js\");\nrequire(\"./node_modules/meteor/ddp-server/writefence.js\");\nrequire(\"./node_modules/meteor/ddp-server/crossbar.js\");\nrequire(\"./node_modules/meteor/ddp-server/server_convenience.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['ddp-server'] = {}, {\n  DDPServer: DDPServer\n});\n\n})();\n\n//# sourceMappingURL=ddp-server.js.map\n"]},"hash":"3c95478003b7940050dd1c8a1f9d4dd24b8971cb"}

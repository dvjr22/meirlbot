{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/geojson-utils.js","filenameRelative":"/bundle/programs/server/packages/geojson-utils.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/geojson-utils.js.map","sourceFileName":"/bundle/programs/server/packages/geojson-utils.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"geojson-utils"},"ignored":false,"code":"(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var meteorInstall = Package.modules.meteorInstall;\n  var Buffer = Package.modules.Buffer;\n  var process = Package.modules.process;\n\n  /* Package-scope variables */\n  var GeoJSON;\n\n  var require = meteorInstall({ \"node_modules\": { \"meteor\": { \"geojson-utils\": { \"main.js\": [\"./geojson-utils.js\", function (require, exports) {\n\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                         //\n            // packages/geojson-utils/main.js                                                                          //\n            //                                                                                                         //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            exports.GeoJSON = require(\"./geojson-utils.js\");\n\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }], \"geojson-utils.js\": function geojsonUtilsJs(require, exports, module) {\n\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                         //\n            // packages/geojson-utils/geojson-utils.js                                                                 //\n            //                                                                                                         //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            (function () {\n              var gju = {};\n\n              // Export the geojson object for **CommonJS**\n              if (typeof module !== 'undefined' && module.exports) {\n                module.exports = gju;\n              }\n\n              // adapted from http://www.kevlindev.com/gui/math/intersection/Intersection.js\n              gju.lineStringsIntersect = function (l1, l2) {\n                var intersects = [];\n                for (var i = 0; i <= l1.coordinates.length - 2; ++i) {\n                  for (var j = 0; j <= l2.coordinates.length - 2; ++j) {\n                    var a1 = {\n                      x: l1.coordinates[i][1],\n                      y: l1.coordinates[i][0]\n                    },\n                        a2 = {\n                      x: l1.coordinates[i + 1][1],\n                      y: l1.coordinates[i + 1][0]\n                    },\n                        b1 = {\n                      x: l2.coordinates[j][1],\n                      y: l2.coordinates[j][0]\n                    },\n                        b2 = {\n                      x: l2.coordinates[j + 1][1],\n                      y: l2.coordinates[j + 1][0]\n                    },\n                        ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),\n                        ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),\n                        u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n                    if (u_b != 0) {\n                      var ua = ua_t / u_b,\n                          ub = ub_t / u_b;\n                      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n                        intersects.push({\n                          'type': 'Point',\n                          'coordinates': [a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)]\n                        });\n                      }\n                    }\n                  }\n                }\n                if (intersects.length == 0) intersects = false;\n                return intersects;\n              };\n\n              // Bounding Box\n\n              function boundingBoxAroundPolyCoords(coords) {\n                var xAll = [],\n                    yAll = [];\n\n                for (var i = 0; i < coords[0].length; i++) {\n                  xAll.push(coords[0][i][1]);\n                  yAll.push(coords[0][i][0]);\n                }\n\n                xAll = xAll.sort(function (a, b) {\n                  return a - b;\n                });\n                yAll = yAll.sort(function (a, b) {\n                  return a - b;\n                });\n\n                return [[xAll[0], yAll[0]], [xAll[xAll.length - 1], yAll[yAll.length - 1]]];\n              }\n\n              gju.pointInBoundingBox = function (point, bounds) {\n                return !(point.coordinates[1] < bounds[0][0] || point.coordinates[1] > bounds[1][0] || point.coordinates[0] < bounds[0][1] || point.coordinates[0] > bounds[1][1]);\n              };\n\n              // Point in Polygon\n              // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html#Listing the Vertices\n\n              function pnpoly(x, y, coords) {\n                var vert = [[0, 0]];\n\n                for (var i = 0; i < coords.length; i++) {\n                  for (var j = 0; j < coords[i].length; j++) {\n                    vert.push(coords[i][j]);\n                  }\n                  vert.push([0, 0]);\n                }\n\n                var inside = false;\n                for (var i = 0, j = vert.length - 1; i < vert.length; j = i++) {\n                  if (vert[i][0] > y != vert[j][0] > y && x < (vert[j][1] - vert[i][1]) * (y - vert[i][0]) / (vert[j][0] - vert[i][0]) + vert[i][1]) inside = !inside;\n                }\n\n                return inside;\n              }\n\n              gju.pointInPolygon = function (p, poly) {\n                var coords = poly.type == \"Polygon\" ? [poly.coordinates] : poly.coordinates;\n\n                var insideBox = false;\n                for (var i = 0; i < coords.length; i++) {\n                  if (gju.pointInBoundingBox(p, boundingBoxAroundPolyCoords(coords[i]))) insideBox = true;\n                }\n                if (!insideBox) return false;\n\n                var insidePoly = false;\n                for (var i = 0; i < coords.length; i++) {\n                  if (pnpoly(p.coordinates[1], p.coordinates[0], coords[i])) insidePoly = true;\n                }\n\n                return insidePoly;\n              };\n\n              gju.numberToRadius = function (number) {\n                return number * Math.PI / 180;\n              };\n\n              gju.numberToDegree = function (number) {\n                return number * 180 / Math.PI;\n              };\n\n              // written with help from @tautologe\n              gju.drawCircle = function (radiusInMeters, centerPoint, steps) {\n                var center = [centerPoint.coordinates[1], centerPoint.coordinates[0]],\n                    dist = radiusInMeters / 1000 / 6371,\n\n                // convert meters to radiant\n                radCenter = [gju.numberToRadius(center[0]), gju.numberToRadius(center[1])],\n                    steps = steps || 15,\n\n                // 15 sided circle\n                poly = [[center[0], center[1]]];\n                for (var i = 0; i < steps; i++) {\n                  var brng = 2 * Math.PI * i / steps;\n                  var lat = Math.asin(Math.sin(radCenter[0]) * Math.cos(dist) + Math.cos(radCenter[0]) * Math.sin(dist) * Math.cos(brng));\n                  var lng = radCenter[1] + Math.atan2(Math.sin(brng) * Math.sin(dist) * Math.cos(radCenter[0]), Math.cos(dist) - Math.sin(radCenter[0]) * Math.sin(lat));\n                  poly[i] = [];\n                  poly[i][1] = gju.numberToDegree(lat);\n                  poly[i][0] = gju.numberToDegree(lng);\n                }\n                return {\n                  \"type\": \"Polygon\",\n                  \"coordinates\": [poly]\n                };\n              };\n\n              // assumes rectangle starts at lower left point\n              gju.rectangleCentroid = function (rectangle) {\n                var bbox = rectangle.coordinates[0];\n                var xmin = bbox[0][0],\n                    ymin = bbox[0][1],\n                    xmax = bbox[2][0],\n                    ymax = bbox[2][1];\n                var xwidth = xmax - xmin;\n                var ywidth = ymax - ymin;\n                return {\n                  'type': 'Point',\n                  'coordinates': [xmin + xwidth / 2, ymin + ywidth / 2]\n                };\n              };\n\n              // from http://www.movable-type.co.uk/scripts/latlong.html\n              gju.pointDistance = function (pt1, pt2) {\n                var lon1 = pt1.coordinates[0],\n                    lat1 = pt1.coordinates[1],\n                    lon2 = pt2.coordinates[0],\n                    lat2 = pt2.coordinates[1],\n                    dLat = gju.numberToRadius(lat2 - lat1),\n                    dLon = gju.numberToRadius(lon2 - lon1),\n                    a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(gju.numberToRadius(lat1)) * Math.cos(gju.numberToRadius(lat2)) * Math.pow(Math.sin(dLon / 2), 2),\n                    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n                // Earth radius is 6371 km\n                return 6371 * c * 1000; // returns meters\n              },\n\n              // checks if geometry lies entirely within a circle\n              // works with Point, LineString, Polygon\n              gju.geometryWithinRadius = function (geometry, center, radius) {\n                if (geometry.type == 'Point') {\n                  return gju.pointDistance(geometry, center) <= radius;\n                } else if (geometry.type == 'LineString' || geometry.type == 'Polygon') {\n                  var point = {};\n                  var coordinates;\n                  if (geometry.type == 'Polygon') {\n                    // it's enough to check the exterior ring of the Polygon\n                    coordinates = geometry.coordinates[0];\n                  } else {\n                    coordinates = geometry.coordinates;\n                  }\n                  for (var i in coordinates) {\n                    point.coordinates = coordinates[i];\n                    if (gju.pointDistance(point, center) > radius) {\n                      return false;\n                    }\n                  }\n                }\n                return true;\n              };\n\n              // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt\n              gju.area = function (polygon) {\n                var area = 0;\n                // TODO: polygon holes at coordinates[1]\n                var points = polygon.coordinates[0];\n                var j = points.length - 1;\n                var p1, p2;\n\n                for (var i = 0; i < points.length; j = i++) {\n                  var p1 = {\n                    x: points[i][1],\n                    y: points[i][0]\n                  };\n                  var p2 = {\n                    x: points[j][1],\n                    y: points[j][0]\n                  };\n                  area += p1.x * p2.y;\n                  area -= p1.y * p2.x;\n                }\n\n                area /= 2;\n                return area;\n              },\n\n              // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt\n              gju.centroid = function (polygon) {\n                var f,\n                    x = 0,\n                    y = 0;\n                // TODO: polygon holes at coordinates[1]\n                var points = polygon.coordinates[0];\n                var j = points.length - 1;\n                var p1, p2;\n\n                for (var i = 0; i < points.length; j = i++) {\n                  var p1 = {\n                    x: points[i][1],\n                    y: points[i][0]\n                  };\n                  var p2 = {\n                    x: points[j][1],\n                    y: points[j][0]\n                  };\n                  f = p1.x * p2.y - p2.x * p1.y;\n                  x += (p1.x + p2.x) * f;\n                  y += (p1.y + p2.y) * f;\n                }\n\n                f = gju.area(polygon) * 6;\n                return {\n                  'type': 'Point',\n                  'coordinates': [y / f, x / f]\n                };\n              }, gju.simplify = function (source, kink) {\n                /* source[] array of geojson points */\n                /* kink\tin metres, kinks above this depth kept  */\n                /* kink depth is the height of the triangle abc where a-b and b-c are two consecutive line segments */\n                kink = kink || 20;\n                source = source.map(function (o) {\n                  return {\n                    lng: o.coordinates[0],\n                    lat: o.coordinates[1]\n                  };\n                });\n\n                var n_source, n_stack, n_dest, start, end, i, sig;\n                var dev_sqr, max_dev_sqr, band_sqr;\n                var x12, y12, d12, x13, y13, d13, x23, y23, d23;\n                var F = Math.PI / 180.0 * 0.5;\n                var index = new Array(); /* aray of indexes of source points to include in the reduced line */\n                var sig_start = new Array(); /* indices of start & end of working section */\n                var sig_end = new Array();\n\n                /* check for simple cases */\n\n                if (source.length < 3) return source; /* one or two points */\n\n                /* more complex case. initialize stack */\n\n                n_source = source.length;\n                band_sqr = kink * 360.0 / (2.0 * Math.PI * 6378137.0); /* Now in degrees */\n                band_sqr *= band_sqr;\n                n_dest = 0;\n                sig_start[0] = 0;\n                sig_end[0] = n_source - 1;\n                n_stack = 1;\n\n                /* while the stack is not empty  ... */\n                while (n_stack > 0) {\n\n                  /* ... pop the top-most entries off the stacks */\n\n                  start = sig_start[n_stack - 1];\n                  end = sig_end[n_stack - 1];\n                  n_stack--;\n\n                  if (end - start > 1) {\n                    /* any intermediate points ? */\n\n                    /* ... yes, so find most deviant intermediate point to\n                    either side of line joining start & end points */\n\n                    x12 = source[end].lng() - source[start].lng();\n                    y12 = source[end].lat() - source[start].lat();\n                    if (Math.abs(x12) > 180.0) x12 = 360.0 - Math.abs(x12);\n                    x12 *= Math.cos(F * (source[end].lat() + source[start].lat())); /* use avg lat to reduce lng */\n                    d12 = x12 * x12 + y12 * y12;\n\n                    for (i = start + 1, sig = start, max_dev_sqr = -1.0; i < end; i++) {\n\n                      x13 = source[i].lng() - source[start].lng();\n                      y13 = source[i].lat() - source[start].lat();\n                      if (Math.abs(x13) > 180.0) x13 = 360.0 - Math.abs(x13);\n                      x13 *= Math.cos(F * (source[i].lat() + source[start].lat()));\n                      d13 = x13 * x13 + y13 * y13;\n\n                      x23 = source[i].lng() - source[end].lng();\n                      y23 = source[i].lat() - source[end].lat();\n                      if (Math.abs(x23) > 180.0) x23 = 360.0 - Math.abs(x23);\n                      x23 *= Math.cos(F * (source[i].lat() + source[end].lat()));\n                      d23 = x23 * x23 + y23 * y23;\n\n                      if (d13 >= d12 + d23) dev_sqr = d23;else if (d23 >= d12 + d13) dev_sqr = d13;else dev_sqr = (x13 * y12 - y13 * x12) * (x13 * y12 - y13 * x12) / d12; // solve triangle\n                      if (dev_sqr > max_dev_sqr) {\n                        sig = i;\n                        max_dev_sqr = dev_sqr;\n                      }\n                    }\n\n                    if (max_dev_sqr < band_sqr) {\n                      /* is there a sig. intermediate point ? */\n                      /* ... no, so transfer current start point */\n                      index[n_dest] = start;\n                      n_dest++;\n                    } else {\n                      /* ... yes, so push two sub-sections on stack for further processing */\n                      n_stack++;\n                      sig_start[n_stack - 1] = sig;\n                      sig_end[n_stack - 1] = end;\n                      n_stack++;\n                      sig_start[n_stack - 1] = start;\n                      sig_end[n_stack - 1] = sig;\n                    }\n                  } else {\n                    /* ... no intermediate points, so transfer current start point */\n                    index[n_dest] = start;\n                    n_dest++;\n                  }\n                }\n\n                /* transfer last point */\n                index[n_dest] = n_source - 1;\n                n_dest++;\n\n                /* make return array */\n                var r = new Array();\n                for (var i = 0; i < n_dest; i++) {\n                  r.push(source[index[i]]);\n                }return r.map(function (o) {\n                  return {\n                    type: \"Point\",\n                    coordinates: [o.lng, o.lat]\n                  };\n                });\n              };\n\n              // http://www.movable-type.co.uk/scripts/latlong.html#destPoint\n              gju.destinationPoint = function (pt, brng, dist) {\n                dist = dist / 6371; // convert dist to angular distance in radians\n                brng = gju.numberToRadius(brng);\n\n                var lat1 = gju.numberToRadius(pt.coordinates[0]);\n                var lon1 = gju.numberToRadius(pt.coordinates[1]);\n\n                var lat2 = Math.asin(Math.sin(lat1) * Math.cos(dist) + Math.cos(lat1) * Math.sin(dist) * Math.cos(brng));\n                var lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(dist) * Math.cos(lat1), Math.cos(dist) - Math.sin(lat1) * Math.sin(lat2));\n                lon2 = (lon2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // normalise to -180..+180ยบ\n\n                return {\n                  'type': 'Point',\n                  'coordinates': [gju.numberToDegree(lat2), gju.numberToDegree(lon2)]\n                };\n              };\n            })();\n\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          } } } } }, { \"extensions\": [\".js\", \".json\"] });\n  var exports = require(\"./node_modules/meteor/geojson-utils/main.js\");\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package['geojson-utils'] = exports, {\n    GeoJSON: GeoJSON\n  });\n})();\n\n//# sourceMappingURL=geojson-utils.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/geojson-utils.js"],"names":[],"mappings":"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","file":"/bundle/programs/server/packages/geojson-utils.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Buffer = Package.modules.Buffer;\nvar process = Package.modules.process;\n\n/* Package-scope variables */\nvar GeoJSON;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"geojson-utils\":{\"main.js\":[\"./geojson-utils.js\",function(require,exports){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/geojson-utils/main.js                                                                          //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\nexports.GeoJSON = require(\"./geojson-utils.js\");\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"geojson-utils.js\":function(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/geojson-utils/geojson-utils.js                                                                 //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\n(function () {\n  var gju = {};\n\n  // Export the geojson object for **CommonJS**\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = gju;\n  }\n\n  // adapted from http://www.kevlindev.com/gui/math/intersection/Intersection.js\n  gju.lineStringsIntersect = function (l1, l2) {\n    var intersects = [];\n    for (var i = 0; i <= l1.coordinates.length - 2; ++i) {\n      for (var j = 0; j <= l2.coordinates.length - 2; ++j) {\n        var a1 = {\n          x: l1.coordinates[i][1],\n          y: l1.coordinates[i][0]\n        },\n          a2 = {\n            x: l1.coordinates[i + 1][1],\n            y: l1.coordinates[i + 1][0]\n          },\n          b1 = {\n            x: l2.coordinates[j][1],\n            y: l2.coordinates[j][0]\n          },\n          b2 = {\n            x: l2.coordinates[j + 1][1],\n            y: l2.coordinates[j + 1][0]\n          },\n          ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),\n          ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),\n          u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n        if (u_b != 0) {\n          var ua = ua_t / u_b,\n            ub = ub_t / u_b;\n          if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n            intersects.push({\n              'type': 'Point',\n              'coordinates': [a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)]\n            });\n          }\n        }\n      }\n    }\n    if (intersects.length == 0) intersects = false;\n    return intersects;\n  }\n\n  // Bounding Box\n\n  function boundingBoxAroundPolyCoords (coords) {\n    var xAll = [], yAll = []\n\n    for (var i = 0; i < coords[0].length; i++) {\n      xAll.push(coords[0][i][1])\n      yAll.push(coords[0][i][0])\n    }\n\n    xAll = xAll.sort(function (a,b) { return a - b })\n    yAll = yAll.sort(function (a,b) { return a - b })\n\n    return [ [xAll[0], yAll[0]], [xAll[xAll.length - 1], yAll[yAll.length - 1]] ]\n  }\n\n  gju.pointInBoundingBox = function (point, bounds) {\n    return !(point.coordinates[1] < bounds[0][0] || point.coordinates[1] > bounds[1][0] || point.coordinates[0] < bounds[0][1] || point.coordinates[0] > bounds[1][1]) \n  }\n\n  // Point in Polygon\n  // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html#Listing the Vertices\n\n  function pnpoly (x,y,coords) {\n    var vert = [ [0,0] ]\n\n    for (var i = 0; i < coords.length; i++) {\n      for (var j = 0; j < coords[i].length; j++) {\n        vert.push(coords[i][j])\n      }\n      vert.push([0,0])\n    }\n\n    var inside = false\n    for (var i = 0, j = vert.length - 1; i < vert.length; j = i++) {\n      if (((vert[i][0] > y) != (vert[j][0] > y)) && (x < (vert[j][1] - vert[i][1]) * (y - vert[i][0]) / (vert[j][0] - vert[i][0]) + vert[i][1])) inside = !inside\n    }\n\n    return inside\n  }\n\n  gju.pointInPolygon = function (p, poly) {\n    var coords = (poly.type == \"Polygon\") ? [ poly.coordinates ] : poly.coordinates\n\n    var insideBox = false\n    for (var i = 0; i < coords.length; i++) {\n      if (gju.pointInBoundingBox(p, boundingBoxAroundPolyCoords(coords[i]))) insideBox = true\n    }\n    if (!insideBox) return false\n\n    var insidePoly = false\n    for (var i = 0; i < coords.length; i++) {\n      if (pnpoly(p.coordinates[1], p.coordinates[0], coords[i])) insidePoly = true\n    }\n\n    return insidePoly\n  }\n\n  gju.numberToRadius = function (number) {\n    return number * Math.PI / 180;\n  }\n\n  gju.numberToDegree = function (number) {\n    return number * 180 / Math.PI;\n  }\n\n  // written with help from @tautologe\n  gju.drawCircle = function (radiusInMeters, centerPoint, steps) {\n    var center = [centerPoint.coordinates[1], centerPoint.coordinates[0]],\n      dist = (radiusInMeters / 1000) / 6371,\n      // convert meters to radiant\n      radCenter = [gju.numberToRadius(center[0]), gju.numberToRadius(center[1])],\n      steps = steps || 15,\n      // 15 sided circle\n      poly = [[center[0], center[1]]];\n    for (var i = 0; i < steps; i++) {\n      var brng = 2 * Math.PI * i / steps;\n      var lat = Math.asin(Math.sin(radCenter[0]) * Math.cos(dist)\n              + Math.cos(radCenter[0]) * Math.sin(dist) * Math.cos(brng));\n      var lng = radCenter[1] + Math.atan2(Math.sin(brng) * Math.sin(dist) * Math.cos(radCenter[0]),\n                                          Math.cos(dist) - Math.sin(radCenter[0]) * Math.sin(lat));\n      poly[i] = [];\n      poly[i][1] = gju.numberToDegree(lat);\n      poly[i][0] = gju.numberToDegree(lng);\n    }\n    return {\n      \"type\": \"Polygon\",\n      \"coordinates\": [poly]\n    };\n  }\n\n  // assumes rectangle starts at lower left point\n  gju.rectangleCentroid = function (rectangle) {\n    var bbox = rectangle.coordinates[0];\n    var xmin = bbox[0][0],\n      ymin = bbox[0][1],\n      xmax = bbox[2][0],\n      ymax = bbox[2][1];\n    var xwidth = xmax - xmin;\n    var ywidth = ymax - ymin;\n    return {\n      'type': 'Point',\n      'coordinates': [xmin + xwidth / 2, ymin + ywidth / 2]\n    };\n  }\n\n  // from http://www.movable-type.co.uk/scripts/latlong.html\n  gju.pointDistance = function (pt1, pt2) {\n    var lon1 = pt1.coordinates[0],\n      lat1 = pt1.coordinates[1],\n      lon2 = pt2.coordinates[0],\n      lat2 = pt2.coordinates[1],\n      dLat = gju.numberToRadius(lat2 - lat1),\n      dLon = gju.numberToRadius(lon2 - lon1),\n      a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(gju.numberToRadius(lat1))\n        * Math.cos(gju.numberToRadius(lat2)) * Math.pow(Math.sin(dLon / 2), 2),\n      c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    // Earth radius is 6371 km\n    return (6371 * c) * 1000; // returns meters\n  },\n\n  // checks if geometry lies entirely within a circle\n  // works with Point, LineString, Polygon\n  gju.geometryWithinRadius = function (geometry, center, radius) {\n    if (geometry.type == 'Point') {\n      return gju.pointDistance(geometry, center) <= radius;\n    } else if (geometry.type == 'LineString' || geometry.type == 'Polygon') {\n      var point = {};\n      var coordinates;\n      if (geometry.type == 'Polygon') {\n        // it's enough to check the exterior ring of the Polygon\n        coordinates = geometry.coordinates[0];\n      } else {\n        coordinates = geometry.coordinates;\n      }\n      for (var i in coordinates) {\n        point.coordinates = coordinates[i];\n        if (gju.pointDistance(point, center) > radius) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt\n  gju.area = function (polygon) {\n    var area = 0;\n    // TODO: polygon holes at coordinates[1]\n    var points = polygon.coordinates[0];\n    var j = points.length - 1;\n    var p1, p2;\n\n    for (var i = 0; i < points.length; j = i++) {\n      var p1 = {\n        x: points[i][1],\n        y: points[i][0]\n      };\n      var p2 = {\n        x: points[j][1],\n        y: points[j][0]\n      };\n      area += p1.x * p2.y;\n      area -= p1.y * p2.x;\n    }\n\n    area /= 2;\n    return area;\n  },\n\n  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt\n  gju.centroid = function (polygon) {\n    var f, x = 0,\n      y = 0;\n    // TODO: polygon holes at coordinates[1]\n    var points = polygon.coordinates[0];\n    var j = points.length - 1;\n    var p1, p2;\n\n    for (var i = 0; i < points.length; j = i++) {\n      var p1 = {\n        x: points[i][1],\n        y: points[i][0]\n      };\n      var p2 = {\n        x: points[j][1],\n        y: points[j][0]\n      };\n      f = p1.x * p2.y - p2.x * p1.y;\n      x += (p1.x + p2.x) * f;\n      y += (p1.y + p2.y) * f;\n    }\n\n    f = gju.area(polygon) * 6;\n    return {\n      'type': 'Point',\n      'coordinates': [y / f, x / f]\n    };\n  },\n\n  gju.simplify = function (source, kink) { /* source[] array of geojson points */\n    /* kink\tin metres, kinks above this depth kept  */\n    /* kink depth is the height of the triangle abc where a-b and b-c are two consecutive line segments */\n    kink = kink || 20;\n    source = source.map(function (o) {\n      return {\n        lng: o.coordinates[0],\n        lat: o.coordinates[1]\n      }\n    });\n\n    var n_source, n_stack, n_dest, start, end, i, sig;\n    var dev_sqr, max_dev_sqr, band_sqr;\n    var x12, y12, d12, x13, y13, d13, x23, y23, d23;\n    var F = (Math.PI / 180.0) * 0.5;\n    var index = new Array(); /* aray of indexes of source points to include in the reduced line */\n    var sig_start = new Array(); /* indices of start & end of working section */\n    var sig_end = new Array();\n\n    /* check for simple cases */\n\n    if (source.length < 3) return (source); /* one or two points */\n\n    /* more complex case. initialize stack */\n\n    n_source = source.length;\n    band_sqr = kink * 360.0 / (2.0 * Math.PI * 6378137.0); /* Now in degrees */\n    band_sqr *= band_sqr;\n    n_dest = 0;\n    sig_start[0] = 0;\n    sig_end[0] = n_source - 1;\n    n_stack = 1;\n\n    /* while the stack is not empty  ... */\n    while (n_stack > 0) {\n\n      /* ... pop the top-most entries off the stacks */\n\n      start = sig_start[n_stack - 1];\n      end = sig_end[n_stack - 1];\n      n_stack--;\n\n      if ((end - start) > 1) { /* any intermediate points ? */\n\n        /* ... yes, so find most deviant intermediate point to\n        either side of line joining start & end points */\n\n        x12 = (source[end].lng() - source[start].lng());\n        y12 = (source[end].lat() - source[start].lat());\n        if (Math.abs(x12) > 180.0) x12 = 360.0 - Math.abs(x12);\n        x12 *= Math.cos(F * (source[end].lat() + source[start].lat())); /* use avg lat to reduce lng */\n        d12 = (x12 * x12) + (y12 * y12);\n\n        for (i = start + 1, sig = start, max_dev_sqr = -1.0; i < end; i++) {\n\n          x13 = source[i].lng() - source[start].lng();\n          y13 = source[i].lat() - source[start].lat();\n          if (Math.abs(x13) > 180.0) x13 = 360.0 - Math.abs(x13);\n          x13 *= Math.cos(F * (source[i].lat() + source[start].lat()));\n          d13 = (x13 * x13) + (y13 * y13);\n\n          x23 = source[i].lng() - source[end].lng();\n          y23 = source[i].lat() - source[end].lat();\n          if (Math.abs(x23) > 180.0) x23 = 360.0 - Math.abs(x23);\n          x23 *= Math.cos(F * (source[i].lat() + source[end].lat()));\n          d23 = (x23 * x23) + (y23 * y23);\n\n          if (d13 >= (d12 + d23)) dev_sqr = d23;\n          else if (d23 >= (d12 + d13)) dev_sqr = d13;\n          else dev_sqr = (x13 * y12 - y13 * x12) * (x13 * y12 - y13 * x12) / d12; // solve triangle\n          if (dev_sqr > max_dev_sqr) {\n            sig = i;\n            max_dev_sqr = dev_sqr;\n          }\n        }\n\n        if (max_dev_sqr < band_sqr) { /* is there a sig. intermediate point ? */\n          /* ... no, so transfer current start point */\n          index[n_dest] = start;\n          n_dest++;\n        } else { /* ... yes, so push two sub-sections on stack for further processing */\n          n_stack++;\n          sig_start[n_stack - 1] = sig;\n          sig_end[n_stack - 1] = end;\n          n_stack++;\n          sig_start[n_stack - 1] = start;\n          sig_end[n_stack - 1] = sig;\n        }\n      } else { /* ... no intermediate points, so transfer current start point */\n        index[n_dest] = start;\n        n_dest++;\n      }\n    }\n\n    /* transfer last point */\n    index[n_dest] = n_source - 1;\n    n_dest++;\n\n    /* make return array */\n    var r = new Array();\n    for (var i = 0; i < n_dest; i++)\n      r.push(source[index[i]]);\n\n    return r.map(function (o) {\n      return {\n        type: \"Point\",\n        coordinates: [o.lng, o.lat]\n      }\n    });\n  }\n\n  // http://www.movable-type.co.uk/scripts/latlong.html#destPoint\n  gju.destinationPoint = function (pt, brng, dist) {\n    dist = dist/6371;  // convert dist to angular distance in radians\n    brng = gju.numberToRadius(brng);\n\n    var lat1 = gju.numberToRadius(pt.coordinates[0]);\n    var lon1 = gju.numberToRadius(pt.coordinates[1]);\n\n    var lat2 = Math.asin( Math.sin(lat1)*Math.cos(dist) +\n                          Math.cos(lat1)*Math.sin(dist)*Math.cos(brng) );\n    var lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(dist)*Math.cos(lat1),\n                                 Math.cos(dist)-Math.sin(lat1)*Math.sin(lat2));\n    lon2 = (lon2+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180ยบ\n\n    return {\n      'type': 'Point',\n      'coordinates': [gju.numberToDegree(lat2), gju.numberToDegree(lon2)]\n    };\n  };\n\n})();\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\"extensions\":[\".js\",\".json\"]});\nvar exports = require(\"./node_modules/meteor/geojson-utils/main.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['geojson-utils'] = exports, {\n  GeoJSON: GeoJSON\n});\n\n})();\n\n//# sourceMappingURL=geojson-utils.js.map\n"]},"hash":"3d51cc09773954e31dd0a1966423ac0f7a1d3fb5"}

{"metadata":{"usedHelpers":["typeof"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/modules-runtime.js","filenameRelative":"/bundle/programs/server/packages/modules-runtime.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/modules-runtime.js.map","sourceFileName":"/bundle/programs/server/packages/modules-runtime.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"modules-runtime"},"ignored":false,"code":"var _typeof;module.import(\"babel-runtime/helpers/typeof\",{\"default\":function(v){_typeof=v}});\n(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n\n  /* Package-scope variables */\n  var makeInstaller, meteorInstall;\n\n  /////////////////////////////////////////////////////////////////////////////\n  //                                                                         //\n  // packages/modules-runtime/.npm/package/node_modules/install/install.js   //\n  // This file is in bare mode and is not in its own closure.                //\n  //                                                                         //\n  /////////////////////////////////////////////////////////////////////////////\n  //\n  makeInstaller = function makeInstaller(options) {\n    options = options || {};\n\n    // These file extensions will be appended to required module identifiers\n    // if they do not exactly match an installed module.\n    var defaultExtensions = options.extensions || [\".js\", \".json\"];\n\n    // If defined, the options.onInstall function will be called any time\n    // new modules are installed.\n    var onInstall = options.onInstall;\n\n    // If defined, the options.override function will be called before\n    // looking up any top-level package identifiers in node_modules\n    // directories. It can either return a string to provide an alternate\n    // package identifier, or a non-string value to prevent the lookup from\n    // proceeding.\n    var override = options.override;\n\n    // If defined, the options.fallback function will be called when no\n    // installed module is found for a required module identifier. Often\n    // options.fallback will be implemented in terms of the native Node\n    // require function, which has the ability to load binary modules.\n    var fallback = options.fallback;\n\n    // Nothing special about MISSING.hasOwnProperty, except that it's fewer\n    // characters than Object.prototype.hasOwnProperty after minification.\n    var hasOwn = {}.hasOwnProperty;\n\n    // The file object representing the root directory of the installed\n    // module tree.\n    var root = new File(\"/\", new File(\"/..\"));\n    var rootRequire = makeRequire(root);\n\n    // Merges the given tree of directories and module factory functions\n    // into the tree of installed modules and returns a require function\n    // that behaves as if called from a module in the root directory.\n    function install(tree, options) {\n      if (isObject(tree)) {\n        fileMergeContents(root, tree, options);\n        if (isFunction(onInstall)) {\n          onInstall(rootRequire);\n        }\n      }\n      return rootRequire;\n    }\n\n    // This constructor will be used to instantiate the module objects\n    // passed to module factory functions (i.e. the third argument after\n    // require and exports), and is exposed as install.Module in case the\n    // caller of makeInstaller wishes to modify Module.prototype.\n    function Module(id) {\n      this.id = id;\n      this.children = [];\n    }\n\n    Module.prototype.resolve = function (id) {\n      return this.require.resolve(id);\n    };\n\n    install.Module = Module;\n\n    function getOwn(obj, key) {\n      return hasOwn.call(obj, key) && obj[key];\n    }\n\n    function isObject(value) {\n      return value && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\";\n    }\n\n    function isFunction(value) {\n      return typeof value === \"function\";\n    }\n\n    function isString(value) {\n      return typeof value === \"string\";\n    }\n\n    function makeRequire(file) {\n      function require(id) {\n        var result = fileResolve(file, id);\n        if (result) {\n          return fileEvaluate(result, file.m);\n        }\n\n        var error = new Error(\"Cannot find module '\" + id + \"'\");\n\n        if (isFunction(fallback)) {\n          return fallback(id, // The missing module identifier.\n          file.m.id, // The path of the requiring file.\n          error // The error we would have thrown.\n          );\n        }\n\n        throw error;\n      }\n\n      require.resolve = function (id) {\n        var f = fileResolve(file, id);\n        if (f) return f.m.id;\n        var error = new Error(\"Cannot find module '\" + id + \"'\");\n        if (fallback && isFunction(fallback.resolve)) {\n          return fallback.resolve(id, file.m.id, error);\n        }\n        throw error;\n      };\n\n      return require;\n    }\n\n    // File objects represent either directories or modules that have been\n    // installed. When a `File` respresents a directory, its `.c` (contents)\n    // property is an object containing the names of the files (or\n    // directories) that it contains. When a `File` represents a module, its\n    // `.c` property is a function that can be invoked with the appropriate\n    // `(require, exports, module)` arguments to evaluate the module. If the\n    // `.c` property is a string, that string will be resolved as a module\n    // identifier, and the exports of the resulting module will provide the\n    // exports of the original file. The `.p` (parent) property of a File is\n    // either a directory `File` or `null`. Note that a child may claim\n    // another `File` as its parent even if the parent does not have an\n    // entry for that child in its `.c` object.  This is important for\n    // implementing anonymous files, and preventing child modules from using\n    // `../relative/identifier` syntax to examine unrelated modules.\n    function File(name, parent) {\n      var file = this;\n\n      // Link to the parent file.\n      file.p = parent = parent || null;\n\n      // The module object for this File, which will eventually boast an\n      // .exports property when/if the file is evaluated.\n      file.m = new Module(name);\n    }\n\n    function fileEvaluate(file, parentModule) {\n      var contents = file && file.c;\n      var module = file.m;\n\n      if (!hasOwn.call(module, \"exports\")) {\n        if (parentModule) {\n          module.parent = parentModule;\n          var children = parentModule.children;\n          if (Array.isArray(children)) {\n            children.push(module);\n          }\n        }\n\n        // If a Module.prototype.useNode method is defined, give it a chance\n        // to define module.exports based on module.id using Node.\n        if (!isFunction(module.useNode) || !module.useNode()) {\n          contents(module.require = module.require || makeRequire(file), module.exports = {}, module, file.m.id, file.p.m.id);\n        }\n\n        module.loaded = true;\n      }\n\n      if (isFunction(module.runModuleSetters)) {\n        module.runModuleSetters();\n      }\n\n      return module.exports;\n    }\n\n    function fileIsDirectory(file) {\n      return file && isObject(file.c);\n    }\n\n    function fileMergeContents(file, contents, options) {\n      // If contents is an array of strings and functions, return the last\n      // function with a `.d` property containing all the strings.\n      if (Array.isArray(contents)) {\n        var deps = [];\n\n        contents.forEach(function (item) {\n          if (isString(item)) {\n            deps.push(item);\n          } else if (isFunction(item)) {\n            contents = item;\n          }\n        });\n\n        if (isFunction(contents)) {\n          contents.d = deps;\n        } else {\n          // If the array did not contain a function, merge nothing.\n          contents = null;\n        }\n      } else if (isFunction(contents)) {\n        // If contents is already a function, make sure it has `.d`.\n        contents.d = contents.d || [];\n      } else if (!isString(contents) && !isObject(contents)) {\n        // If contents is neither an array nor a function nor a string nor\n        // an object, just give up and merge nothing.\n        contents = null;\n      }\n\n      if (contents) {\n        file.c = file.c || (isObject(contents) ? {} : contents);\n        if (isObject(contents) && fileIsDirectory(file)) {\n          Object.keys(contents).forEach(function (key) {\n            if (key === \"..\") {\n              child = file.p;\n            } else {\n              var child = getOwn(file.c, key);\n              if (!child) {\n                child = file.c[key] = new File(file.m.id.replace(/\\/*$/, \"/\") + key, file);\n\n                child.o = options;\n              }\n            }\n\n            fileMergeContents(child, contents[key], options);\n          });\n        }\n      }\n    }\n\n    function fileGetExtensions(file) {\n      return file.o && file.o.extensions || defaultExtensions;\n    }\n\n    function fileAppendIdPart(file, part, extensions) {\n      // Always append relative to a directory.\n      while (file && !fileIsDirectory(file)) {\n        file = file.p;\n      }\n\n      if (!file || !part || part === \".\") {\n        return file;\n      }\n\n      if (part === \"..\") {\n        return file.p;\n      }\n\n      var exactChild = getOwn(file.c, part);\n\n      // Only consider multiple file extensions if this part is the last\n      // part of a module identifier and not equal to `.` or `..`, and there\n      // was no exact match or the exact match was a directory.\n      if (extensions && (!exactChild || fileIsDirectory(exactChild))) {\n        for (var e = 0; e < extensions.length; ++e) {\n          var child = getOwn(file.c, part + extensions[e]);\n          if (child) {\n            return child;\n          }\n        }\n      }\n\n      return exactChild;\n    }\n\n    function fileAppendId(file, id, extensions) {\n      var parts = id.split(\"/\");\n\n      // Use `Array.prototype.every` to terminate iteration early if\n      // `fileAppendIdPart` returns a falsy value.\n      parts.every(function (part, i) {\n        return file = i < parts.length - 1 ? fileAppendIdPart(file, part) : fileAppendIdPart(file, part, extensions);\n      });\n\n      return file;\n    }\n\n    function fileResolve(file, id, seenDirFiles) {\n      var extensions = fileGetExtensions(file);\n\n      file =\n      // Absolute module identifiers (i.e. those that begin with a `/`\n      // character) are interpreted relative to the root directory, which\n      // is a slight deviation from Node, which has access to the entire\n      // file system.\n      id.charAt(0) === \"/\" ? fileAppendId(root, id, extensions) :\n      // Relative module identifiers are interpreted relative to the\n      // current file, naturally.\n      id.charAt(0) === \".\" ? fileAppendId(file, id, extensions) :\n      // Top-level module identifiers are interpreted as referring to\n      // packages in `node_modules` directories.\n      nodeModulesLookup(file, id, extensions);\n\n      // If the identifier resolves to a directory, we use the same logic as\n      // Node to find an `index.js` or `package.json` file to evaluate.\n      while (fileIsDirectory(file)) {\n        seenDirFiles = seenDirFiles || [];\n\n        // If the \"main\" field of a `package.json` file resolves to a\n        // directory we've already considered, then we should not attempt to\n        // read the same `package.json` file again. Using an array as a set\n        // is acceptable here because the number of directories to consider\n        // is rarely greater than 1 or 2. Also, using indexOf allows us to\n        // store File objects instead of strings.\n        if (seenDirFiles.indexOf(file) < 0) {\n          seenDirFiles.push(file);\n\n          var pkgJsonFile = fileAppendIdPart(file, \"package.json\");\n          var main = pkgJsonFile && fileEvaluate(pkgJsonFile).main;\n          if (isString(main)) {\n            // The \"main\" field of package.json does not have to begin with\n            // ./ to be considered relative, so first we try simply\n            // appending it to the directory path before falling back to a\n            // full fileResolve, which might return a package from a\n            // node_modules directory.\n            file = fileAppendId(file, main, extensions) || fileResolve(file, main, seenDirFiles);\n\n            if (file) {\n              // The fileAppendId call above may have returned a directory,\n              // so continue the loop to make sure we resolve it to a\n              // non-directory file.\n              continue;\n            }\n          }\n        }\n\n        // If we didn't find a `package.json` file, or it didn't have a\n        // resolvable `.main` property, the only possibility left to\n        // consider is that this directory contains an `index.js` module.\n        // This assignment almost always terminates the while loop, because\n        // there's very little chance `fileIsDirectory(file)` will be true\n        // for the result of `fileAppendIdPart(file, \"index.js\")`. However,\n        // in principle it is remotely possible that a file called\n        // `index.js` could be a directory instead of a file.\n        file = fileAppendIdPart(file, \"index.js\");\n      }\n\n      if (file && isString(file.c)) {\n        file = fileResolve(file, file.c, seenDirFiles);\n      }\n\n      return file;\n    };\n\n    function nodeModulesLookup(file, id, extensions) {\n      if (isFunction(override)) {\n        id = override(id, file.m.id);\n      }\n\n      if (isString(id)) {\n        for (var resolved; file && !resolved; file = file.p) {\n          resolved = fileIsDirectory(file) && fileAppendId(file, \"node_modules/\" + id, extensions);\n        }\n\n        return resolved;\n      }\n    }\n\n    return install;\n  };\n\n  if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === \"object\") {\n    exports.makeInstaller = makeInstaller;\n  }\n\n  /////////////////////////////////////////////////////////////////////////////\n\n  (function () {\n\n    /////////////////////////////////////////////////////////////////////////////\n    //                                                                         //\n    // packages/modules-runtime/modules-runtime.js                             //\n    //                                                                         //\n    /////////////////////////////////////////////////////////////////////////////\n    //\n    var options = {};\n    var hasOwn = options.hasOwnProperty;\n\n    // RegExp matching strings that don't start with a `.` or a `/`.\n    var topLevelIdPattern = /^[^./]/;\n\n    // This function will be called whenever a module identifier that hasn't\n    // been installed is required. For backwards compatibility, and so that we\n    // can require binary dependencies on the server, we implement the\n    // fallback in terms of Npm.require.\n    options.fallback = function (id, parentId, error) {\n      // For simplicity, we honor only top-level module identifiers here.\n      // We could try to honor relative and absolute module identifiers by\n      // somehow combining `id` with `dir`, but we'd have to be really careful\n      // that the resulting modules were located in a known directory (not\n      // some arbitrary location on the file system), and we only really need\n      // the fallback for dependencies installed in node_modules directories.\n      if (topLevelIdPattern.test(id)) {\n        if ((typeof Npm === \"undefined\" ? \"undefined\" : _typeof(Npm)) === \"object\" && typeof Npm.require === \"function\") {\n          return Npm.require(id);\n        }\n      }\n\n      throw error;\n    };\n\n    options.fallback.resolve = function (id, parentId, error) {\n      if (Meteor.isServer && topLevelIdPattern.test(id)) {\n        // Allow any top-level identifier to resolve to itself on the server,\n        // so that options.fallback can have a chance to handle it.\n        return id;\n      }\n\n      throw error;\n    };\n\n    meteorInstall = makeInstaller(options);\n    var Mp = meteorInstall.Module.prototype;\n\n    if (Meteor.isServer) {\n      Mp.useNode = function () {\n        if (typeof npmRequire !== \"function\") {\n          // Can't use Node if npmRequire is not defined.\n          return false;\n        }\n\n        var parts = this.id.split(\"/\");\n        var start = 0;\n        if (parts[start] === \"\") ++start;\n        if (parts[start] === \"node_modules\" && parts[start + 1] === \"meteor\") {\n          start += 2;\n        }\n\n        if (parts.indexOf(\"node_modules\", start) < 0) {\n          // Don't try to use Node for modules that aren't in node_modules\n          // directories.\n          return false;\n        }\n\n        try {\n          npmRequire.resolve(this.id);\n        } catch (e) {\n          return false;\n        }\n\n        this.exports = npmRequire(this.id);\n\n        return true;\n      };\n    }\n\n    /////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package['modules-runtime'] = {}, {\n    meteorInstall: meteorInstall\n  });\n})();\n\n//# sourceMappingURL=modules-runtime.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/modules-runtime.js"],"names":[],"mappings":"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","file":"/bundle/programs/server/packages/modules-runtime.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\n\n/* Package-scope variables */\nvar makeInstaller, meteorInstall;\n\n/////////////////////////////////////////////////////////////////////////////\n//                                                                         //\n// packages/modules-runtime/.npm/package/node_modules/install/install.js   //\n// This file is in bare mode and is not in its own closure.                //\n//                                                                         //\n/////////////////////////////////////////////////////////////////////////////\n                                                                           //\nmakeInstaller = function (options) {\n  options = options || {};\n\n  // These file extensions will be appended to required module identifiers\n  // if they do not exactly match an installed module.\n  var defaultExtensions = options.extensions || [\".js\", \".json\"];\n\n  // If defined, the options.onInstall function will be called any time\n  // new modules are installed.\n  var onInstall = options.onInstall;\n\n  // If defined, the options.override function will be called before\n  // looking up any top-level package identifiers in node_modules\n  // directories. It can either return a string to provide an alternate\n  // package identifier, or a non-string value to prevent the lookup from\n  // proceeding.\n  var override = options.override;\n\n  // If defined, the options.fallback function will be called when no\n  // installed module is found for a required module identifier. Often\n  // options.fallback will be implemented in terms of the native Node\n  // require function, which has the ability to load binary modules.\n  var fallback = options.fallback;\n\n  // Nothing special about MISSING.hasOwnProperty, except that it's fewer\n  // characters than Object.prototype.hasOwnProperty after minification.\n  var hasOwn = {}.hasOwnProperty;\n\n  // The file object representing the root directory of the installed\n  // module tree.\n  var root = new File(\"/\", new File(\"/..\"));\n  var rootRequire = makeRequire(root);\n\n  // Merges the given tree of directories and module factory functions\n  // into the tree of installed modules and returns a require function\n  // that behaves as if called from a module in the root directory.\n  function install(tree, options) {\n    if (isObject(tree)) {\n      fileMergeContents(root, tree, options);\n      if (isFunction(onInstall)) {\n        onInstall(rootRequire);\n      }\n    }\n    return rootRequire;\n  }\n\n  // This constructor will be used to instantiate the module objects\n  // passed to module factory functions (i.e. the third argument after\n  // require and exports), and is exposed as install.Module in case the\n  // caller of makeInstaller wishes to modify Module.prototype.\n  function Module(id) {\n    this.id = id;\n    this.children = [];\n  }\n\n  Module.prototype.resolve = function (id) {\n    return this.require.resolve(id);\n  };\n\n  install.Module = Module;\n\n  function getOwn(obj, key) {\n    return hasOwn.call(obj, key) && obj[key];\n  }\n\n  function isObject(value) {\n    return value && typeof value === \"object\";\n  }\n\n  function isFunction(value) {\n    return typeof value === \"function\";\n  }\n\n  function isString(value) {\n    return typeof value === \"string\";\n  }\n\n  function makeRequire(file) {\n    function require(id) {\n      var result = fileResolve(file, id);\n      if (result) {\n        return fileEvaluate(result, file.m);\n      }\n\n      var error = new Error(\"Cannot find module '\" + id + \"'\");\n\n      if (isFunction(fallback)) {\n        return fallback(\n          id, // The missing module identifier.\n          file.m.id, // The path of the requiring file.\n          error // The error we would have thrown.\n        );\n      }\n\n      throw error;\n    }\n\n    require.resolve = function (id) {\n      var f = fileResolve(file, id);\n      if (f) return f.m.id;\n      var error = new Error(\"Cannot find module '\" + id + \"'\");\n      if (fallback && isFunction(fallback.resolve)) {\n        return fallback.resolve(id, file.m.id, error);\n      }\n      throw error;\n    };\n\n    return require;\n  }\n\n  // File objects represent either directories or modules that have been\n  // installed. When a `File` respresents a directory, its `.c` (contents)\n  // property is an object containing the names of the files (or\n  // directories) that it contains. When a `File` represents a module, its\n  // `.c` property is a function that can be invoked with the appropriate\n  // `(require, exports, module)` arguments to evaluate the module. If the\n  // `.c` property is a string, that string will be resolved as a module\n  // identifier, and the exports of the resulting module will provide the\n  // exports of the original file. The `.p` (parent) property of a File is\n  // either a directory `File` or `null`. Note that a child may claim\n  // another `File` as its parent even if the parent does not have an\n  // entry for that child in its `.c` object.  This is important for\n  // implementing anonymous files, and preventing child modules from using\n  // `../relative/identifier` syntax to examine unrelated modules.\n  function File(name, parent) {\n    var file = this;\n\n    // Link to the parent file.\n    file.p = parent = parent || null;\n\n    // The module object for this File, which will eventually boast an\n    // .exports property when/if the file is evaluated.\n    file.m = new Module(name);\n  }\n\n  function fileEvaluate(file, parentModule) {\n    var contents = file && file.c;\n    var module = file.m;\n\n    if (! hasOwn.call(module, \"exports\")) {\n      if (parentModule) {\n        module.parent = parentModule;\n        var children = parentModule.children;\n        if (Array.isArray(children)) {\n          children.push(module);\n        }\n      }\n\n      // If a Module.prototype.useNode method is defined, give it a chance\n      // to define module.exports based on module.id using Node.\n      if (! isFunction(module.useNode) ||\n          ! module.useNode()) {\n        contents(\n          module.require = module.require || makeRequire(file),\n          module.exports = {},\n          module,\n          file.m.id,\n          file.p.m.id\n        );\n      }\n\n      module.loaded = true;\n    }\n\n    if (isFunction(module.runModuleSetters)) {\n      module.runModuleSetters();\n    }\n\n    return module.exports;\n  }\n\n  function fileIsDirectory(file) {\n    return file && isObject(file.c);\n  }\n\n  function fileMergeContents(file, contents, options) {\n    // If contents is an array of strings and functions, return the last\n    // function with a `.d` property containing all the strings.\n    if (Array.isArray(contents)) {\n      var deps = [];\n\n      contents.forEach(function (item) {\n        if (isString(item)) {\n          deps.push(item);\n        } else if (isFunction(item)) {\n          contents = item;\n        }\n      });\n\n      if (isFunction(contents)) {\n        contents.d = deps;\n      } else {\n        // If the array did not contain a function, merge nothing.\n        contents = null;\n      }\n\n    } else if (isFunction(contents)) {\n      // If contents is already a function, make sure it has `.d`.\n      contents.d = contents.d || [];\n\n    } else if (! isString(contents) &&\n               ! isObject(contents)) {\n      // If contents is neither an array nor a function nor a string nor\n      // an object, just give up and merge nothing.\n      contents = null;\n    }\n\n    if (contents) {\n      file.c = file.c || (isObject(contents) ? {} : contents);\n      if (isObject(contents) && fileIsDirectory(file)) {\n        Object.keys(contents).forEach(function (key) {\n          if (key === \"..\") {\n            child = file.p;\n\n          } else {\n            var child = getOwn(file.c, key);\n            if (! child) {\n              child = file.c[key] = new File(\n                file.m.id.replace(/\\/*$/, \"/\") + key,\n                file\n              );\n\n              child.o = options;\n            }\n          }\n\n          fileMergeContents(child, contents[key], options);\n        });\n      }\n    }\n  }\n\n  function fileGetExtensions(file) {\n    return file.o && file.o.extensions || defaultExtensions;\n  }\n\n  function fileAppendIdPart(file, part, extensions) {\n    // Always append relative to a directory.\n    while (file && ! fileIsDirectory(file)) {\n      file = file.p;\n    }\n\n    if (! file || ! part || part === \".\") {\n      return file;\n    }\n\n    if (part === \"..\") {\n      return file.p;\n    }\n\n    var exactChild = getOwn(file.c, part);\n\n    // Only consider multiple file extensions if this part is the last\n    // part of a module identifier and not equal to `.` or `..`, and there\n    // was no exact match or the exact match was a directory.\n    if (extensions && (! exactChild || fileIsDirectory(exactChild))) {\n      for (var e = 0; e < extensions.length; ++e) {\n        var child = getOwn(file.c, part + extensions[e]);\n        if (child) {\n          return child;\n        }\n      }\n    }\n\n    return exactChild;\n  }\n\n  function fileAppendId(file, id, extensions) {\n    var parts = id.split(\"/\");\n\n    // Use `Array.prototype.every` to terminate iteration early if\n    // `fileAppendIdPart` returns a falsy value.\n    parts.every(function (part, i) {\n      return file = i < parts.length - 1\n        ? fileAppendIdPart(file, part)\n        : fileAppendIdPart(file, part, extensions);\n    });\n\n    return file;\n  }\n\n  function fileResolve(file, id, seenDirFiles) {\n    var extensions = fileGetExtensions(file);\n\n    file =\n      // Absolute module identifiers (i.e. those that begin with a `/`\n      // character) are interpreted relative to the root directory, which\n      // is a slight deviation from Node, which has access to the entire\n      // file system.\n      id.charAt(0) === \"/\" ? fileAppendId(root, id, extensions) :\n      // Relative module identifiers are interpreted relative to the\n      // current file, naturally.\n      id.charAt(0) === \".\" ? fileAppendId(file, id, extensions) :\n      // Top-level module identifiers are interpreted as referring to\n      // packages in `node_modules` directories.\n      nodeModulesLookup(file, id, extensions);\n\n    // If the identifier resolves to a directory, we use the same logic as\n    // Node to find an `index.js` or `package.json` file to evaluate.\n    while (fileIsDirectory(file)) {\n      seenDirFiles = seenDirFiles || [];\n\n      // If the \"main\" field of a `package.json` file resolves to a\n      // directory we've already considered, then we should not attempt to\n      // read the same `package.json` file again. Using an array as a set\n      // is acceptable here because the number of directories to consider\n      // is rarely greater than 1 or 2. Also, using indexOf allows us to\n      // store File objects instead of strings.\n      if (seenDirFiles.indexOf(file) < 0) {\n        seenDirFiles.push(file);\n\n        var pkgJsonFile = fileAppendIdPart(file, \"package.json\");\n        var main = pkgJsonFile && fileEvaluate(pkgJsonFile).main;\n        if (isString(main)) {\n          // The \"main\" field of package.json does not have to begin with\n          // ./ to be considered relative, so first we try simply\n          // appending it to the directory path before falling back to a\n          // full fileResolve, which might return a package from a\n          // node_modules directory.\n          file = fileAppendId(file, main, extensions) ||\n            fileResolve(file, main, seenDirFiles);\n\n          if (file) {\n            // The fileAppendId call above may have returned a directory,\n            // so continue the loop to make sure we resolve it to a\n            // non-directory file.\n            continue;\n          }\n        }\n      }\n\n      // If we didn't find a `package.json` file, or it didn't have a\n      // resolvable `.main` property, the only possibility left to\n      // consider is that this directory contains an `index.js` module.\n      // This assignment almost always terminates the while loop, because\n      // there's very little chance `fileIsDirectory(file)` will be true\n      // for the result of `fileAppendIdPart(file, \"index.js\")`. However,\n      // in principle it is remotely possible that a file called\n      // `index.js` could be a directory instead of a file.\n      file = fileAppendIdPart(file, \"index.js\");\n    }\n\n    if (file && isString(file.c)) {\n      file = fileResolve(file, file.c, seenDirFiles);\n    }\n\n    return file;\n  };\n\n  function nodeModulesLookup(file, id, extensions) {\n    if (isFunction(override)) {\n      id = override(id, file.m.id);\n    }\n\n    if (isString(id)) {\n      for (var resolved; file && ! resolved; file = file.p) {\n        resolved = fileIsDirectory(file) &&\n          fileAppendId(file, \"node_modules/\" + id, extensions);\n      }\n\n      return resolved;\n    }\n  }\n\n  return install;\n};\n\nif (typeof exports === \"object\") {\n  exports.makeInstaller = makeInstaller;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////\n//                                                                         //\n// packages/modules-runtime/modules-runtime.js                             //\n//                                                                         //\n/////////////////////////////////////////////////////////////////////////////\n                                                                           //\nvar options = {};\nvar hasOwn = options.hasOwnProperty;\n\n// RegExp matching strings that don't start with a `.` or a `/`.\nvar topLevelIdPattern = /^[^./]/;\n\n// This function will be called whenever a module identifier that hasn't\n// been installed is required. For backwards compatibility, and so that we\n// can require binary dependencies on the server, we implement the\n// fallback in terms of Npm.require.\noptions.fallback = function (id, parentId, error) {\n  // For simplicity, we honor only top-level module identifiers here.\n  // We could try to honor relative and absolute module identifiers by\n  // somehow combining `id` with `dir`, but we'd have to be really careful\n  // that the resulting modules were located in a known directory (not\n  // some arbitrary location on the file system), and we only really need\n  // the fallback for dependencies installed in node_modules directories.\n  if (topLevelIdPattern.test(id)) {\n    if (typeof Npm === \"object\" &&\n        typeof Npm.require === \"function\") {\n      return Npm.require(id);\n    }\n  }\n\n  throw error;\n};\n\noptions.fallback.resolve = function (id, parentId, error) {\n  if (Meteor.isServer &&\n      topLevelIdPattern.test(id)) {\n    // Allow any top-level identifier to resolve to itself on the server,\n    // so that options.fallback can have a chance to handle it.\n    return id;\n  }\n\n  throw error;\n};\n\nmeteorInstall = makeInstaller(options);\nvar Mp = meteorInstall.Module.prototype;\n\nif (Meteor.isServer) {\n  Mp.useNode = function () {\n    if (typeof npmRequire !== \"function\") {\n      // Can't use Node if npmRequire is not defined.\n      return false;\n    }\n\n    var parts = this.id.split(\"/\");\n    var start = 0;\n    if (parts[start] === \"\") ++start;\n    if (parts[start] === \"node_modules\" &&\n        parts[start + 1] === \"meteor\") {\n      start += 2;\n    }\n\n    if (parts.indexOf(\"node_modules\", start) < 0) {\n      // Don't try to use Node for modules that aren't in node_modules\n      // directories.\n      return false;\n    }\n\n    try {\n      npmRequire.resolve(this.id);\n    } catch (e) {\n      return false;\n    }\n\n    this.exports = npmRequire(this.id);\n\n    return true;\n  };\n}\n\n/////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['modules-runtime'] = {}, {\n  meteorInstall: meteorInstall\n});\n\n})();\n\n//# sourceMappingURL=modules-runtime.js.map\n"]},"hash":"3036e93944d665a1c7f5a861c2f934cdb6c6bf06"}

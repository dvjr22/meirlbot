{"metadata":{"usedHelpers":["typeof"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/bundle/programs/server/packages/spacebars.js","filenameRelative":"/bundle/programs/server/packages/spacebars.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/bundle/programs/server/packages/spacebars.js.map","sourceFileName":"/bundle/programs/server/packages/spacebars.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"spacebars"},"ignored":false,"code":"var _typeof;module.import('babel-runtime/helpers/typeof',{\"default\":function(v){_typeof=v}});\n(function () {\n\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var ObserveSequence = Package['observe-sequence'].ObserveSequence;\n  var _ = Package.underscore._;\n  var Tracker = Package.tracker.Tracker;\n  var Deps = Package.tracker.Deps;\n  var HTML = Package.htmljs.HTML;\n  var Blaze = Package.blaze.Blaze;\n  var UI = Package.blaze.UI;\n  var Handlebars = Package.blaze.Handlebars;\n\n  /* Package-scope variables */\n  var Spacebars;\n\n  (function () {\n\n    ///////////////////////////////////////////////////////////////////////////////////\n    //                                                                               //\n    // packages/spacebars/spacebars-runtime.js                                       //\n    //                                                                               //\n    ///////////////////////////////////////////////////////////////////////////////////\n    //\n    Spacebars = {};\n\n    var tripleEquals = function tripleEquals(a, b) {\n      return a === b;\n    };\n\n    Spacebars.include = function (templateOrFunction, contentFunc, elseFunc) {\n      if (!templateOrFunction) return null;\n\n      if (typeof templateOrFunction !== 'function') {\n        var template = templateOrFunction;\n        if (!Blaze.isTemplate(template)) throw new Error(\"Expected template or null, found: \" + template);\n        var view = templateOrFunction.constructView(contentFunc, elseFunc);\n        view.__startsNewLexicalScope = true;\n        return view;\n      }\n\n      var templateVar = Blaze.ReactiveVar(null, tripleEquals);\n      var view = Blaze.View('Spacebars.include', function () {\n        var template = templateVar.get();\n        if (template === null) return null;\n\n        if (!Blaze.isTemplate(template)) throw new Error(\"Expected template or null, found: \" + template);\n\n        return template.constructView(contentFunc, elseFunc);\n      });\n      view.__templateVar = templateVar;\n      view.onViewCreated(function () {\n        this.autorun(function () {\n          templateVar.set(templateOrFunction());\n        });\n      });\n      view.__startsNewLexicalScope = true;\n\n      return view;\n    };\n\n    // Executes `{{foo bar baz}}` when called on `(foo, bar, baz)`.\n    // If `bar` and `baz` are functions, they are called before\n    // `foo` is called on them.\n    //\n    // This is the shared part of Spacebars.mustache and\n    // Spacebars.attrMustache, which differ in how they post-process the\n    // result.\n    Spacebars.mustacheImpl = function (value /*, args*/) {\n      var args = arguments;\n      // if we have any arguments (pos or kw), add an options argument\n      // if there isn't one.\n      if (args.length > 1) {\n        var kw = args[args.length - 1];\n        if (!(kw instanceof Spacebars.kw)) {\n          kw = Spacebars.kw();\n          // clone arguments into an actual array, then push\n          // the empty kw object.\n          args = Array.prototype.slice.call(arguments);\n          args.push(kw);\n        } else {\n          // For each keyword arg, call it if it's a function\n          var newHash = {};\n          for (var k in kw.hash) {\n            var v = kw.hash[k];\n            newHash[k] = typeof v === 'function' ? v() : v;\n          }\n          args[args.length - 1] = Spacebars.kw(newHash);\n        }\n      }\n\n      return Spacebars.call.apply(null, args);\n    };\n\n    Spacebars.mustache = function (value /*, args*/) {\n      var result = Spacebars.mustacheImpl.apply(null, arguments);\n\n      if (result instanceof Spacebars.SafeString) return HTML.Raw(result.toString());else\n        // map `null`, `undefined`, and `false` to null, which is important\n        // so that attributes with nully values are considered absent.\n        // stringify anything else (e.g. strings, booleans, numbers including 0).\n        return result == null || result === false ? null : String(result);\n    };\n\n    Spacebars.attrMustache = function (value /*, args*/) {\n      var result = Spacebars.mustacheImpl.apply(null, arguments);\n\n      if (result == null || result === '') {\n        return null;\n      } else if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') {\n        return result;\n      } else if (typeof result === 'string' && HTML.isValidAttributeName(result)) {\n        var obj = {};\n        obj[result] = '';\n        return obj;\n      } else {\n        throw new Error(\"Expected valid attribute name, '', null, or object\");\n      }\n    };\n\n    Spacebars.dataMustache = function (value /*, args*/) {\n      var result = Spacebars.mustacheImpl.apply(null, arguments);\n\n      return result;\n    };\n\n    // Idempotently wrap in `HTML.Raw`.\n    //\n    // Called on the return value from `Spacebars.mustache` in case the\n    // template uses triple-stache (`{{{foo bar baz}}}`).\n    Spacebars.makeRaw = function (value) {\n      if (value == null) // null or undefined\n        return null;else if (value instanceof HTML.Raw) return value;else return HTML.Raw(value);\n    };\n\n    // If `value` is a function, evaluate its `args` (by calling them, if they\n    // are functions), and then call it on them. Otherwise, return `value`.\n    //\n    // If `value` is not a function and is not null, then this method will assert\n    // that there are no args. We check for null before asserting because a user\n    // may write a template like {{user.fullNameWithPrefix 'Mr.'}}, where the\n    // function will be null until data is ready.\n    Spacebars.call = function (value /*, args*/) {\n      if (typeof value === 'function') {\n        // Evaluate arguments by calling them if they are functions.\n        var newArgs = [];\n        for (var i = 1; i < arguments.length; i++) {\n          var arg = arguments[i];\n          newArgs[i - 1] = typeof arg === 'function' ? arg() : arg;\n        }\n\n        return value.apply(null, newArgs);\n      } else {\n        if (value != null && arguments.length > 1) {\n          throw new Error(\"Can't call non-function: \" + value);\n        }\n        return value;\n      }\n    };\n\n    // Call this as `Spacebars.kw({ ... })`.  The return value\n    // is `instanceof Spacebars.kw`.\n    Spacebars.kw = function (hash) {\n      if (!(this instanceof Spacebars.kw))\n        // called without new; call with new\n        return new Spacebars.kw(hash);\n\n      this.hash = hash || {};\n    };\n\n    // Call this as `Spacebars.SafeString(\"some HTML\")`.  The return value\n    // is `instanceof Spacebars.SafeString` (and `instanceof Handlebars.SafeString).\n    Spacebars.SafeString = function (html) {\n      if (!(this instanceof Spacebars.SafeString))\n        // called without new; call with new\n        return new Spacebars.SafeString(html);\n\n      return new Handlebars.SafeString(html);\n    };\n    Spacebars.SafeString.prototype = Handlebars.SafeString.prototype;\n\n    // `Spacebars.dot(foo, \"bar\", \"baz\")` performs a special kind\n    // of `foo.bar.baz` that allows safe indexing of `null` and\n    // indexing of functions (which calls the function).  If the\n    // result is a function, it is always a bound function (e.g.\n    // a wrapped version of `baz` that always uses `foo.bar` as\n    // `this`).\n    //\n    // In `Spacebars.dot(foo, \"bar\")`, `foo` is assumed to be either\n    // a non-function value or a \"fully-bound\" function wrapping a value,\n    // where fully-bound means it takes no arguments and ignores `this`.\n    //\n    // `Spacebars.dot(foo, \"bar\")` performs the following steps:\n    //\n    // * If `foo` is falsy, return `foo`.\n    //\n    // * If `foo` is a function, call it (set `foo` to `foo()`).\n    //\n    // * If `foo` is falsy now, return `foo`.\n    //\n    // * Return `foo.bar`, binding it to `foo` if it's a function.\n    Spacebars.dot = function (value, id1 /*, id2, ...*/) {\n      if (arguments.length > 2) {\n        // Note: doing this recursively is probably less efficient than\n        // doing it in an iterative loop.\n        var argsForRecurse = [];\n        argsForRecurse.push(Spacebars.dot(value, id1));\n        argsForRecurse.push.apply(argsForRecurse, Array.prototype.slice.call(arguments, 2));\n        return Spacebars.dot.apply(null, argsForRecurse);\n      }\n\n      if (typeof value === 'function') value = value();\n\n      if (!value) return value; // falsy, don't index, pass through\n\n      var result = value[id1];\n      if (typeof result !== 'function') return result;\n      // `value[id1]` (or `value()[id1]`) is a function.\n      // Bind it so that when called, `value` will be placed in `this`.\n      return function () /*arguments*/{\n        return result.apply(value, arguments);\n      };\n    };\n\n    // Spacebars.With implements the conditional logic of rendering\n    // the `{{else}}` block if the argument is falsy.  It combines\n    // a Blaze.If with a Blaze.With (the latter only in the truthy\n    // case, since the else block is evaluated without entering\n    // a new data context).\n    Spacebars.With = function (argFunc, contentFunc, elseFunc) {\n      var argVar = new Blaze.ReactiveVar();\n      var view = Blaze.View('Spacebars_with', function () {\n        return Blaze.If(function () {\n          return argVar.get();\n        }, function () {\n          return Blaze.With(function () {\n            return argVar.get();\n          }, contentFunc);\n        }, elseFunc);\n      });\n      view.onViewCreated(function () {\n        this.autorun(function () {\n          argVar.set(argFunc());\n\n          // This is a hack so that autoruns inside the body\n          // of the #with get stopped sooner.  It reaches inside\n          // our ReactiveVar to access its dep.\n\n          Tracker.onInvalidate(function () {\n            argVar.dep.changed();\n          });\n\n          // Take the case of `{{#with A}}{{B}}{{/with}}`.  The goal\n          // is to not re-render `B` if `A` changes to become falsy\n          // and `B` is simultaneously invalidated.\n          //\n          // A series of autoruns are involved:\n          //\n          // 1. This autorun (argument to Spacebars.With)\n          // 2. Argument to Blaze.If\n          // 3. Blaze.If view re-render\n          // 4. Argument to Blaze.With\n          // 5. The template tag `{{B}}`\n          //\n          // When (3) is invalidated, it immediately stops (4) and (5)\n          // because of a Tracker.onInvalidate built into materializeView.\n          // (When a View's render method is invalidated, it immediately\n          // tears down all the subviews, via a Tracker.onInvalidate much\n          // like this one.\n          //\n          // Suppose `A` changes to become falsy, and `B` changes at the\n          // same time (i.e. without an intervening flush).\n          // Without the code above, this happens:\n          //\n          // - (1) and (5) are invalidated.\n          // - (1) runs, invalidating (2) and (4).\n          // - (5) runs.\n          // - (2) runs, invalidating (3), stopping (4) and (5).\n          //\n          // With the code above:\n          //\n          // - (1) and (5) are invalidated, invalidating (2) and (4).\n          // - (1) runs.\n          // - (2) runs, invalidating (3), stopping (4) and (5).\n          //\n          // If the re-run of (5) is originally enqueued before (1), all\n          // bets are off, but typically that doesn't seem to be the\n          // case.  Anyway, doing this is always better than not doing it,\n          // because it might save a bunch of DOM from being updated\n          // needlessly.\n        });\n      });\n\n      return view;\n    };\n\n    // XXX COMPAT WITH 0.9.0\n    Spacebars.TemplateWith = Blaze._TemplateWith;\n\n    ///////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n\n  /* Exports */\n  if (typeof Package === 'undefined') Package = {};\n  (function (pkg, symbols) {\n    for (var s in symbols) {\n      s in pkg || (pkg[s] = symbols[s]);\n    }\n  })(Package.spacebars = {}, {\n    Spacebars: Spacebars\n  });\n})();\n\n//# sourceMappingURL=spacebars.js.map","ast":null,"map":{"version":3,"sources":["/bundle/programs/server/packages/spacebars.js"],"names":[],"mappings":"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","file":"/bundle/programs/server/packages/spacebars.js.map","sourcesContent":["(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar ObserveSequence = Package['observe-sequence'].ObserveSequence;\nvar _ = Package.underscore._;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar HTML = Package.htmljs.HTML;\nvar Blaze = Package.blaze.Blaze;\nvar UI = Package.blaze.UI;\nvar Handlebars = Package.blaze.Handlebars;\n\n/* Package-scope variables */\nvar Spacebars;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////\n//                                                                               //\n// packages/spacebars/spacebars-runtime.js                                       //\n//                                                                               //\n///////////////////////////////////////////////////////////////////////////////////\n                                                                                 //\nSpacebars = {};\n\nvar tripleEquals = function (a, b) { return a === b; };\n\nSpacebars.include = function (templateOrFunction, contentFunc, elseFunc) {\n  if (! templateOrFunction)\n    return null;\n\n  if (typeof templateOrFunction !== 'function') {\n    var template = templateOrFunction;\n    if (! Blaze.isTemplate(template))\n      throw new Error(\"Expected template or null, found: \" + template);\n    var view = templateOrFunction.constructView(contentFunc, elseFunc);\n    view.__startsNewLexicalScope = true;\n    return view;\n  }\n\n  var templateVar = Blaze.ReactiveVar(null, tripleEquals);\n  var view = Blaze.View('Spacebars.include', function () {\n    var template = templateVar.get();\n    if (template === null)\n      return null;\n\n    if (! Blaze.isTemplate(template))\n      throw new Error(\"Expected template or null, found: \" + template);\n\n    return template.constructView(contentFunc, elseFunc);\n  });\n  view.__templateVar = templateVar;\n  view.onViewCreated(function () {\n    this.autorun(function () {\n      templateVar.set(templateOrFunction());\n    });\n  });\n  view.__startsNewLexicalScope = true;\n\n  return view;\n};\n\n// Executes `{{foo bar baz}}` when called on `(foo, bar, baz)`.\n// If `bar` and `baz` are functions, they are called before\n// `foo` is called on them.\n//\n// This is the shared part of Spacebars.mustache and\n// Spacebars.attrMustache, which differ in how they post-process the\n// result.\nSpacebars.mustacheImpl = function (value/*, args*/) {\n  var args = arguments;\n  // if we have any arguments (pos or kw), add an options argument\n  // if there isn't one.\n  if (args.length > 1) {\n    var kw = args[args.length - 1];\n    if (! (kw instanceof Spacebars.kw)) {\n      kw = Spacebars.kw();\n      // clone arguments into an actual array, then push\n      // the empty kw object.\n      args = Array.prototype.slice.call(arguments);\n      args.push(kw);\n    } else {\n      // For each keyword arg, call it if it's a function\n      var newHash = {};\n      for (var k in kw.hash) {\n        var v = kw.hash[k];\n        newHash[k] = (typeof v === 'function' ? v() : v);\n      }\n      args[args.length - 1] = Spacebars.kw(newHash);\n    }\n  }\n\n  return Spacebars.call.apply(null, args);\n};\n\nSpacebars.mustache = function (value/*, args*/) {\n  var result = Spacebars.mustacheImpl.apply(null, arguments);\n\n  if (result instanceof Spacebars.SafeString)\n    return HTML.Raw(result.toString());\n  else\n    // map `null`, `undefined`, and `false` to null, which is important\n    // so that attributes with nully values are considered absent.\n    // stringify anything else (e.g. strings, booleans, numbers including 0).\n    return (result == null || result === false) ? null : String(result);\n};\n\nSpacebars.attrMustache = function (value/*, args*/) {\n  var result = Spacebars.mustacheImpl.apply(null, arguments);\n\n  if (result == null || result === '') {\n    return null;\n  } else if (typeof result === 'object') {\n    return result;\n  } else if (typeof result === 'string' && HTML.isValidAttributeName(result)) {\n    var obj = {};\n    obj[result] = '';\n    return obj;\n  } else {\n    throw new Error(\"Expected valid attribute name, '', null, or object\");\n  }\n};\n\nSpacebars.dataMustache = function (value/*, args*/) {\n  var result = Spacebars.mustacheImpl.apply(null, arguments);\n\n  return result;\n};\n\n// Idempotently wrap in `HTML.Raw`.\n//\n// Called on the return value from `Spacebars.mustache` in case the\n// template uses triple-stache (`{{{foo bar baz}}}`).\nSpacebars.makeRaw = function (value) {\n  if (value == null) // null or undefined\n    return null;\n  else if (value instanceof HTML.Raw)\n    return value;\n  else\n    return HTML.Raw(value);\n};\n\n// If `value` is a function, evaluate its `args` (by calling them, if they\n// are functions), and then call it on them. Otherwise, return `value`.\n//\n// If `value` is not a function and is not null, then this method will assert\n// that there are no args. We check for null before asserting because a user\n// may write a template like {{user.fullNameWithPrefix 'Mr.'}}, where the\n// function will be null until data is ready.\nSpacebars.call = function (value/*, args*/) {\n  if (typeof value === 'function') {\n    // Evaluate arguments by calling them if they are functions.\n    var newArgs = [];\n    for (var i = 1; i < arguments.length; i++) {\n      var arg = arguments[i];\n      newArgs[i-1] = (typeof arg === 'function' ? arg() : arg);\n    }\n\n    return value.apply(null, newArgs);\n  } else {\n    if (value != null && arguments.length > 1) {\n      throw new Error(\"Can't call non-function: \" + value);\n    }\n    return value;\n  }\n};\n\n// Call this as `Spacebars.kw({ ... })`.  The return value\n// is `instanceof Spacebars.kw`.\nSpacebars.kw = function (hash) {\n  if (! (this instanceof Spacebars.kw))\n    // called without new; call with new\n    return new Spacebars.kw(hash);\n\n  this.hash = hash || {};\n};\n\n// Call this as `Spacebars.SafeString(\"some HTML\")`.  The return value\n// is `instanceof Spacebars.SafeString` (and `instanceof Handlebars.SafeString).\nSpacebars.SafeString = function (html) {\n  if (! (this instanceof Spacebars.SafeString))\n    // called without new; call with new\n    return new Spacebars.SafeString(html);\n\n  return new Handlebars.SafeString(html);\n};\nSpacebars.SafeString.prototype = Handlebars.SafeString.prototype;\n\n// `Spacebars.dot(foo, \"bar\", \"baz\")` performs a special kind\n// of `foo.bar.baz` that allows safe indexing of `null` and\n// indexing of functions (which calls the function).  If the\n// result is a function, it is always a bound function (e.g.\n// a wrapped version of `baz` that always uses `foo.bar` as\n// `this`).\n//\n// In `Spacebars.dot(foo, \"bar\")`, `foo` is assumed to be either\n// a non-function value or a \"fully-bound\" function wrapping a value,\n// where fully-bound means it takes no arguments and ignores `this`.\n//\n// `Spacebars.dot(foo, \"bar\")` performs the following steps:\n//\n// * If `foo` is falsy, return `foo`.\n//\n// * If `foo` is a function, call it (set `foo` to `foo()`).\n//\n// * If `foo` is falsy now, return `foo`.\n//\n// * Return `foo.bar`, binding it to `foo` if it's a function.\nSpacebars.dot = function (value, id1/*, id2, ...*/) {\n  if (arguments.length > 2) {\n    // Note: doing this recursively is probably less efficient than\n    // doing it in an iterative loop.\n    var argsForRecurse = [];\n    argsForRecurse.push(Spacebars.dot(value, id1));\n    argsForRecurse.push.apply(argsForRecurse,\n                              Array.prototype.slice.call(arguments, 2));\n    return Spacebars.dot.apply(null, argsForRecurse);\n  }\n\n  if (typeof value === 'function')\n    value = value();\n\n  if (! value)\n    return value; // falsy, don't index, pass through\n\n  var result = value[id1];\n  if (typeof result !== 'function')\n    return result;\n  // `value[id1]` (or `value()[id1]`) is a function.\n  // Bind it so that when called, `value` will be placed in `this`.\n  return function (/*arguments*/) {\n    return result.apply(value, arguments);\n  };\n};\n\n// Spacebars.With implements the conditional logic of rendering\n// the `{{else}}` block if the argument is falsy.  It combines\n// a Blaze.If with a Blaze.With (the latter only in the truthy\n// case, since the else block is evaluated without entering\n// a new data context).\nSpacebars.With = function (argFunc, contentFunc, elseFunc) {\n  var argVar = new Blaze.ReactiveVar;\n  var view = Blaze.View('Spacebars_with', function () {\n    return Blaze.If(function () { return argVar.get(); },\n                    function () { return Blaze.With(function () {\n                      return argVar.get(); }, contentFunc); },\n                    elseFunc);\n  });\n  view.onViewCreated(function () {\n    this.autorun(function () {\n      argVar.set(argFunc());\n\n      // This is a hack so that autoruns inside the body\n      // of the #with get stopped sooner.  It reaches inside\n      // our ReactiveVar to access its dep.\n\n      Tracker.onInvalidate(function () {\n        argVar.dep.changed();\n      });\n\n      // Take the case of `{{#with A}}{{B}}{{/with}}`.  The goal\n      // is to not re-render `B` if `A` changes to become falsy\n      // and `B` is simultaneously invalidated.\n      //\n      // A series of autoruns are involved:\n      //\n      // 1. This autorun (argument to Spacebars.With)\n      // 2. Argument to Blaze.If\n      // 3. Blaze.If view re-render\n      // 4. Argument to Blaze.With\n      // 5. The template tag `{{B}}`\n      //\n      // When (3) is invalidated, it immediately stops (4) and (5)\n      // because of a Tracker.onInvalidate built into materializeView.\n      // (When a View's render method is invalidated, it immediately\n      // tears down all the subviews, via a Tracker.onInvalidate much\n      // like this one.\n      //\n      // Suppose `A` changes to become falsy, and `B` changes at the\n      // same time (i.e. without an intervening flush).\n      // Without the code above, this happens:\n      //\n      // - (1) and (5) are invalidated.\n      // - (1) runs, invalidating (2) and (4).\n      // - (5) runs.\n      // - (2) runs, invalidating (3), stopping (4) and (5).\n      //\n      // With the code above:\n      //\n      // - (1) and (5) are invalidated, invalidating (2) and (4).\n      // - (1) runs.\n      // - (2) runs, invalidating (3), stopping (4) and (5).\n      //\n      // If the re-run of (5) is originally enqueued before (1), all\n      // bets are off, but typically that doesn't seem to be the\n      // case.  Anyway, doing this is always better than not doing it,\n      // because it might save a bunch of DOM from being updated\n      // needlessly.\n    });\n  });\n\n  return view;\n};\n\n// XXX COMPAT WITH 0.9.0\nSpacebars.TemplateWith = Blaze._TemplateWith;\n\n///////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package.spacebars = {}, {\n  Spacebars: Spacebars\n});\n\n})();\n\n//# sourceMappingURL=spacebars.js.map\n"]},"hash":"cad7adbc045593a0b4ec56b9e61caab77816f6e2"}
